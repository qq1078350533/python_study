{"title": "uni-app微信小程序开发之引入腾讯视频小程序播放插件 ", "author": "Rolan", "pub_time": "2019-12-17 00:01", "content": "目录导航：登录微信小程序管理后台添加腾讯视频播放插件： 在uni-app中引入插件代码：指定整个小程序可使用：指定到对应的分包中使用：在pages.json全局配置文件中对要使用插件的页面配置如下条件编译代码：　　 在.vue页面中使用腾讯视频播放组件：关于如何获取腾讯视频vid问题： 参考资料：腾讯视频小程序播放插件开发文档：decloud uni-app相关配置：微信小程序特有配置: 文章正文：回到顶部登录微信小程序管理后台添加腾讯视频播放插件：　　正式开始使用腾讯视频小程序插件之前需先在微信公众平台 -> 第三方设置 -> 插件管理处添加插件，如下图所示：回到顶部 在uni-app中引入插件代码：　　注意在使用uni-app开发微信小程序时与直接会用微信网页开发工具开发微信小程序是有很大的差别的，因为uni-app可开发多平台的原因，因此不同平台的开发相应的配置需要放到指定的位置才能够生效。而uni-app引入腾讯视频小程序有两种方式一种是整个小程序可使用（小程序中所有的分包可以使用），第二种是指定对应的分包可使用。指定整个小程序可使用：使用插件之前需要在manifest.json中的mp-weixin内声明使用的插件，具体配置参照所用插件的开发文档：1234567891011\"mp-weixin\": {        /* 小程序相关配置 */        \"usingComponents\": true,//是否启用自定义组件模式        \"appid\": \"小程序AppID\",        \"plugins\": {            \"tencentvideo\": {                \"version\": \"1.3.6\",                \"provider\": \"腾讯视频小程序AppID\"            }        }    }指定到对应的分包中使用：如果插件只在（同一个插件不能被多个分包同时引用）一个分包用到，可以单独配置到分包中，这样插件不会随主包加载，可以在pages.json的subPackages中声明插件：1234567891011121314151617{  \"subpackages\": [    {      \"root\": \"package1\",//分包名称      \"pages\": [        \"pages/cat\",        \"pages/dog\"      ],      \"plugins\": {        \"tencentvideo\": {          \"version\": \"1.3.6\",          \"provider\": \"腾讯视频小程序AppID\"        }      }    }  ]}　　回到顶部在pages.json全局配置文件中对要使用插件的页面配置如下条件编译代码：　　12345\"usingComponents\": {    // #ifdef  MP-WEIXIN       \"txv-video\": \"plugin://tencentvideo/video\"    // #endif},回到顶部 在.vue页面中使用腾讯视频播放组件：123456789101112131415<view>           <!--vid中的腾讯视频id最好为动态的数据，方便管理-->          <txv-video :vid=\"VideoId\" playerid=\"txv1\"></txv-video></view>  <script>export default {    data() {        return {            VideoId:'c3029q7tdnp'        };    }}</script>　　　回到顶部关于如何获取腾讯视频vid问题：打开网页腾讯视频=>随便找到一个视频点击鼠标右键=>赋值链接地址（仅供参考）如下图所示：  最后取视频连接地址.html前面的那一小串英文数字编号即可，下图所示：回到顶部 参考资料：腾讯视频小程序播放插件开发文档：https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wxa75efa648b60994b&token=&lang=zh_CNdecloud uni-app相关配置：https://uniapp.dcloud.io/component/mp-weixin-plugin微信小程序特有配置:https://uniapp.dcloud.io/collocation/manifest?id=mp-weixin"}
{"title": "小程序 找不到可构建的npm包-解决方法 ", "author": "Rolan", "pub_time": "2019-12-23 00:52", "content": "问题复现：在项目根目录执行npm init -y # 初始化npm最近在学习7yue老师的koa课，使用到npm包，出现这个问题，目录结构如下工具 -> 构建 npm -> '没有找到可以构建的 NPM 包'查看文档查阅npm 支持| 微信开放文档)有如下说明此处并没有强制要求 node_modules 必须在小程序根目录下（即 project.config.js 中的 miniprogramRoot 字段），也可以存在于小程序根目录下的各个子目录中。但是不允许 node_modules 在小程序根目录外。所以： npm包应放在小程序根目录下 ，而我搞混了小程序目录和项目根目录小程序根目录(为 /project.config.json 中 miniprogramRoot字段指定)项目根目录(为 / )是两个不同位置原来是我的node-models放错了地方，正确位置应该是**miniprogram**文件夹下问题解决cd miniprogramnpm init -ynpm install lin-ui --production工具 -> 构建 npm目录如下，出现了miniprogram_npm"}
{"title": "基于微信小程序picker组件开发的时间自定义功能 ", "author": "Rolan", "pub_time": "2019-12-23 00:33", "content": "背景需求：最近接了一个需求，需要做一个类似电影院的选座功能，不同的是需要自己选择日期，预定时间段，然后根据日期+时间段查询座位信息，结合图片说下需求。a、日期组件可选2天内（当天+第二天）。进入页面默认展示当天日期，预定开始时间为当前时间，预定结束时间为开始时间之后30分钟。b、日期确定后才能选择预定开始时间，开始时间以及结束时间我这边是固定的时间点（08:30-22:30）。开始时间分钟段以5分钟为倍数设置往后推算展示，其余时段不显示。如果当前时间为22:00，则不展示当天时间，自动切换到第二天。c、选择预定结束时间。结束时间已开始时间为标记，半小时为倍数生成规则，其余时段不显示。两个时间段确定以后算出预定时长（小时为单位），并调后端接口查询座位信息。"}
{"title": "【微信小程序】知乎视频查看 ", "author": "Rolan", "pub_time": "2019-12-24 00:04", "content": "第一版做了知乎视频保存视频到本地相册的功能。进一步我们可以做一个增强功能，支持视频查看。用户在登录状态下载过的知乎视频，可以在我的浏览或者查看历史记录在线查看视频这个功能的核心其实是用户身份标识的获取，因为我们只要拿到了用户标识，相应用户下载过的视频就可以和用户标识绑定，存储到数据库中。当用户下次再进入app，只要通过用户标识就可以去数据库中拿用户之前下载过的视频就可以了。表结构如下：CREATE TABLE `wx_user_zhihu_answer` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\r\n  `is_delete` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '软删除标识',\r\n  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\r\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\r\n  `openId_md5` varchar(128) NOT NULL DEFAULT '' COMMENT 'openId md5加密',\r\n  `answer_url` varchar(128) NOT NULL DEFAULT '' COMMENT '知乎回答url',\r\n  PRIMARY KEY (`id`),\r\n  KEY `idx_is_delete` (`is_delete`),\r\n  KEY `idx_openId_md5` (`openId_md5`),\r\n  KEY `idx_answer_url` (`answer_url`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户及知乎回答信息';获取用户标识我们借鉴微信的例程来设计用户登录逻辑首先按钮上设置open-type=\"getUserInfo\",可以让用户自主选择是否授权小程序。<button class=\"login-btn\" wx:if=\"{{!hasUserInfo}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n  点击登录\r\n</button>当用户点击并确认授权，会执行回调的getUserInfo方法getUserInfo: function(e) {\r\n  app.globalData.userInfo = e.detail.userInfo;\r\n  this.setData({\r\n    userInfo: e.detail.userInfo,\r\n    hasUserInfo: true\r\n  });\r\n\r\n  // 登录\r\n  wx.login({\r\n    success: res => {\r\n      const { code } = res;\r\n      app.globalData.loginInfo.jsCode = code;\r\n      this.fetchUserIdInfo();\r\n      // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n    }\r\n  });\r\n  // 获取用户信息\r\n  wx.getSetting({\r\n    success: res => {\r\n      if (res.authSetting[\"scope.userInfo\"]) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n        wx.getUserInfo({\r\n          success: res => {\r\n            const { encryptedData, iv } = res;\r\n            // 可以将 res 发送给后台解码出 unionId\r\n            app.globalData.loginInfo.encryptedData = encryptedData;\r\n            app.globalData.loginInfo.iv = iv;\r\n            this.fetchUserIdInfo();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  });\r\n},\r\nfetchUserIdInfo() {\r\n  const { jsCode, encryptedData, iv } = app.globalData.loginInfo;\r\n  if (!(jsCode && encryptedData && iv)) {\r\n    return;\r\n  }\r\n  wx.request({\r\n    url: userInfoFetchUrl,\r\n    method: \"POST\",\r\n    data: {\r\n      jsCode,\r\n      encryptedData,\r\n      iv\r\n    },\r\n    header: {\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n    },\r\n    success: res => {\r\n      res = res.data;\r\n      if (res.code === 1) {\r\n        app.globalData.userIdInfo = res.data;\r\n      }\r\n    }\r\n  });\r\n},getUserInfo可以获取用户的信息，调用wx.login能够拿到code,调用wx.getUserInfo能够拿到encryptedData和iv。拿到code、encryptedData、iv我们就可以调用微信接口以及解码逻辑拿到用户的openId和unionId,我们这部分都放在了后端接口(userInfoFetchUrl)处理，这里我们使用openId标识用户身份，该接口返回的是openId用m5加密后的id。由于所以身份标识相关的操作都在服务器进行且返回的是md5加密后的值，所以极大提高了用户信息的安全性。后端解析用户标识的逻辑如下exports.infoFetch = async params => {\r\n  const { jsCode, encryptedData, iv } = params;\r\n  const sessionRes = await axios.get(\r\n    `${jscode2sessionUrl}?appid=${appId}&secret=${appSecret}&js_code=${jsCode}&grant_type=authorization_code`\r\n  );\r\n  const sessionResData = sessionRes.data;\r\n  const sessionKey = sessionResData.session_key;\r\n  const openId = sessionResData.openid;\r\n  const pc = new WXBizDataCrypt(appId, sessionKey);\r\n  const userInfo = pc.decryptData(encryptedData, iv);\r\n  const unionId = userInfo.unionId;\r\n  if (unionId && openId) {\r\n    return {\r\n      openIdMD5: md5(openId),\r\n      unionIdMD5: md5(unionId)\r\n    };\r\n  } else if (openId) {\r\n    return {\r\n      openIdMD5: md5(openId)\r\n    };\r\n  }\r\n  return {};\r\n};拿到用户标识后工作基本就完成了。我们还需要做一些优化，在app.js的onLaunch回调和登录页onLoad回调中获取用户信息，使得用户再次打开app在有效登录时间内依然可以直接使用用户标识。"}
{"title": "使用阿里云函数计算构建小程序 ", "author": "Rolan", "pub_time": "2019-12-23 00:43", "content": "在用户使用HyperMotion产品过程中，用户可以通过扫描产品中二维码方式，自助进行Licnese申请。用户提交申请后，请求将发送到钉钉流程中。完成审批后，后台服务将自动根据用户的特征码、申请的数量、可使用的时间将生成好的正式Licnese发送到客户的邮箱中。在原有设计中，使用了Python Flask提供WEB界面，后台使用Celery异步的将用户请求发送至钉钉中，之后采用轮询方式监控审批工单状态，当工单完成审批后，将生成好的License发送至客户提供的邮箱中。实现的效果：这种方式虽然可以满足需求，但是在使用过程中也发现有如下痛点：1、由于对于可用性要求比较高，所以将整套应用以容器化方式部署在云主机上，程序高可用性依赖于底层的平台，基于成本考虑并没有在多可用区进行部署。2、当业务变化时，需要专人将容器从本地容器库上传后进行更新，更新速度慢，敏捷性低。3、需要专人对操作系统层进行维护，并且由于该云主机还运行了其他程序，所以管控上也存在安全风险。基于以上出现的问题，决定对原有二维码程序进行重构，并重新部署在阿里云函数计算服务上。1、第一阶段的改造主要是将二维码扫描程序移植到函数计算服务中。2、第二阶段的改造主要是将发送二维码程序改造为函数计算服务，使用钉钉流程接口中的Callback方法调用该接口，在审批结束后触发发送License流程。2、函数计算服务——无服务，零运维最早接触Serverless的雏形是在2011年开发Cloud Foundry项目时，当时留下一个非常深的印象就是把写好的应用直接上传就完成了部署、扩展等。但是当时Cloud Foundry有一个非常大的局限性，受限于几种开发语言和框架。记得当时的Cloud Foundry只支持Node.js、Python、Java、PHP、Ruby on Rails等，脱离了这个范围则就无法支持，所以当时我其实对这种形态的应用场景存在很大的疑问。这种困惑直到2013年Docker的出现而逐步解开，Docker的出现让开发语言、框架不再是问题，巧妙的解决了Cloud Foundry上述局限性。但是Docker毕竟只是一种工具形态，还不能称得上是平台，紧接着k8s的出现弥补了这一空白，使得Docker从游击队变成了正规军。在这个发展过程中我们不难看出，软件领域发展出现了重大变革，从服务器为王逐渐演进到应用为王的阶段。如果说虚拟化改变了整个物理机的格局，那么无服务化的出现则改变了整个软件开发行业。由于网上各种文档太多了，这里就不对Serverless基本概念进行介绍了，借用一张图说明下。另外还有一点，我们从这里面看到IT行业里的某些岗位，注定要消失的，比如传统运维。3、应用架构整个架构上，分为两个函数计算服务完成：二维码前端：主要用于显示页面，并承担HTTP请求转发代理的角色，将请求转发至二维码后端，发给钉钉，采用HTTP触发器，允许公网访问。二维码后端：用于将用户请求发送给钉钉，该部分服务仍然采用HTTP触发器，不同于前端，该服务是不允许公网直接访问的，但是需要配置NAT网关，通过网关访问钉钉，实现固定IP访问钉钉的效果。从逻辑上讲，整个应用并不复杂，但是在实际使用时遇到最大的问题来自钉钉白名单。由于函数服务对外连接的IP并不固定，所以无法在钉钉中添加，那么就要求函数服务对外连接的IP地址一定要固定。社区中提供的方法主要分为：ECI（运行Nginx充当Proxy），优势是便宜，劣势是高可用性需要自己维护NAT网关，优势是高可用性，劣势是比ECI贵4、构建过程由于篇幅原因，这里只介绍关键步骤。4.1 构建模板为了后续管理和扩展方便，选用了阿里云函数计算中使用flask-web模板进行构建，同时可以将前端静态文件模板存放于项目下（出于统一管理的需要，也可以存放于阿里云的OSS中，作为静态网站发布）。前端我们使用flask-web作为模板创建函数，后端我们直接采用最简单的HTTP函数。函数入口配置，及触发器配置：服务配置，包含公网访问权限，专有网络配置，日志配置，权限配置。前端服务需要公网访问权限，不需要专有网络配置，需要的权限为：AliyunLogFullAccess。后端服务不需要公网访问权限，但是需要配置好的NAT映射的专有网络，由于函数服务在北京2区中在cn-beijing-c和cn-beijing-f，所以在新建交换机时需要使用这两个区。还需要选择安全组，由于出方向并没有明确禁止，所以不需要特别的安全组规则设定。需要的权限为：AliyunLogFullAccess/AliyunECSNetworkInterfaceManagementAccess。配置好后，通过导出功能，分别下载前端和后端代码和配置，在本地进行开发调试。4.2 前端开发我们的前端采用Vue.js进行开发，在main.py同级新建templates目录。Vue编译好的静态文件可以放入该目录中，后续Flask会加载该文件作为入口文件。├── templates\r\n│   ├── index.html\r\n│   ├── static\r\n├── main.py\r\n# main.py sample\r\nfrom flask import render_template\r\n\r\nLICENSE_URL = \"https://[x](https://.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license)x[x](https://xxxxxx.cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license).cn-beijing-internal.fc.aliyuncs.com/2016-08-15/proxy/QR_code/apply_license/license\"\r\n\r\n@app.route('/qr_code', methods=['GET'])\r\ndef index():\r\n      return render_template('index.html')\r\n\r\n      @app.route('/qr_code/license', methods=['POST'])\r\n      def create():\r\n            payload = request.json\r\n                resp = requests.post(LICENSE_URL,\r\n                                                 json=payload,\r\n                                                                              headers=DEFAULT_HEADERS)\r\n                return make_response(resp.text, resp.status_code)\r\n4.3 后端开发后端的开发较为简单，实现一个函数支持POST请求，将转发的结果发送至钉钉即可。4.4 本地调试阿里云在本地开发时提供了fun应用部署和开发工具，详细使用方法见： https://help.aliyun.com/document_detail/64204.html 。安装funnpm config set registry [https://registry.npm.taobao.org](https://registry.npm.taobao.org/) --global\r\nnpm config set disturl [https://npm.taobao.org/dist](https://npm.taobao.org/dist) --global\r\n\r\nnpm install @alicloud/fun -g\r\n配置funfun config\r\n\r\n(venv) [root@ray-dev test_func]# fun config\r\n? Aliyun Account ID xxxxxxxx\r\n? Aliyun Access Key ID ***********r5Qd\r\n? Aliyun Access Key Secret ***********kCCi\r\n? Default region name cn-beijing\r\n? The timeout in seconds for each SDK client invoking 10\r\n? The maximum number of retries for each SDK client 3\r\n? Allow to anonymously report usage statistics to improve the tool over time? Yes\r\nHttp Trigger本地运行fun local start\r\n部署fun deploy\r\n4.5 配置域名解析部署完成后有一点需要特别注意，必须要绑定域名，并且设定必要的路由。如果在没有绑定域名的情况下，服务端会为 response header中强制添加 content-disposition: attachment字段，此字段会使得返回结果在浏览器中以附件的方式打开。（ https://www.alibabacloud.com/help/zh/doc-detail/56103.htm ）"}
{"title": "【微信小程序】写一个能自定义尺寸、样式的switch ", "author": "Rolan", "pub_time": "2019-12-24 00:51", "content": "小程序原生的switch不能灵活的修改宽高、样式，很不方便，我这边参考 WeUI 的开关，写了一个可以自定义尺寸样式的switch组件。直接上代码： https://gitee.com/piscdong/we...效果如下图，可以自定义宽高，可以做成方角的代码分析这个switch主要的难点就是点击后背景颜色变换的动画，这里用到了css的transition、transform两个属性来实现动画，以及::before和::after两个伪元素。wxml基本结构为：<view class=\"switch\">\r\n    <view></view>\r\n</view>父级view是整个switch容器，会用到::before做背景色切换动画，::after做禁用时的灰色遮罩。内部的一个view是来回切换的白点。未选中时默认class是switch，选中时增加一个class：switch_checked。选中状态到未选中状态背景有一个从中间变大到全部的白色动画，所以需要给父级view设置一个颜色作为背景色。.switch {\r\n    ...\r\n    background: #00c000;\r\n    position: relative;\r\n}未选中时::before覆盖整个容器，选中时::before设置 transform: scale(0); ，这样选中时白色区域就会缩放到最小，再加上transition的实现动画效果。.switch::before {\r\n    display: block;\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    border-radius: 9999rpx;\r\n    background: #fff;\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked::before {\r\n    transform: scale(0);\r\n}来回移动的白点，未选中时通过 left: 0; 定位到左侧，选中时将left设置为100%定位到右侧，但是这样白点会完全移出容器范围，所以还需要加上 transform: translateX(-100%); 将白点向左再一定自身宽度的100%，同样加上transition的实现动画效果。.switch view {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 60rpx;\r\n    height: 60rpx;\r\n    border-radius: 50%;\r\n    background: #fff;\r\n    box-shadow: 0 2rpx 6rpx rgba(0, 0, 0, 0.4);\r\n    transition: all 0.35s cubic-bezier(0.45, 1, 0.4, 1);\r\n}\r\n\r\n.switch_checked view {\r\n    left: 100%;\r\n    transform: translateX(-100%);\r\n}关于“::”最后搭车说一下“:”和“::”，“:”是伪类，“::”是伪元素。按照我的理解：伪类不会在dom中增加节点，只不过是css选择器的一种特殊效果；伪元素会增加节点，flex布局中会影响到其他元素。为了保证兼容性，css3是允许伪元素使用单个冒号。"}
{"title": "小程序的getElementsById，就像一把梭 ", "author": "Rolan", "pub_time": "2019-12-24 00:52", "content": "使用selectComponent可以抓取自定义组件实例对象，但在层层嵌套结构的业务场景中，id的设置繁复，js/wxml开发界面频繁的切换，查找、维护、调整的开发工作很是让人抓狂啊好想封装一个getElementsById方法给小程序，像在web开发中那样能够方便的获取页面元素。在父子子子子级间轻松调用，好想念jquery开发的一把梭时代！实现如下需求：任何绑定id的自定义组件都能够方便抓取实例对象(任何嵌套层级均可调用)通过数据配置思路实现不难，我们可以将所有自定义组件在create生命周期方法时将\tthis 挂载到一个全局变量中，\tdetached 生命周期时销毁该实例(不然爆内存)实现准备一个全局变量app._elements = {}\r\n复制代码挂载/销毁方法一个全局的挂载、销毁方法，方便将实例对象注册、注销在app._elements上app.mount = function(id, context){\r\n    app._elements[id] = context\r\n}\r\n\r\napp.unmount = function(id){\r\n    app._elements[id] = null\r\n}\r\n复制代码getElementsById定义全局\tgetElementsById 在Page中能够方便调用app.getElementsById = function(id){\r\n    let res = app._elements[id]\r\n    if (!res) {  // 兼容selectComponent\r\n        return wx.selectComponent('#'+id) || wx.selectComponent('.'+id)\r\n    }\r\n    return res\r\n}\r\n复制代码自定义组件ui-component组件const app = getApp()\r\nComponent({\r\n  options: {\r\n    multipleSlots: true, // 在组件定义时的选项中启用多slot支持\r\n    addGlobalClass: true\r\n  },\r\n  properties: {\r\n    dataSource: {\r\n      type: Object,\r\n    },\r\n  },\r\n  data: {},\r\n  behaviors: [],\r\n  lifetimes: {\r\n    created: function() {\r\n    },\r\n    attached: function() {\r\n        this.id = this.data.dataSource.$$id  // 专用$$id来指定唯一名称\r\n    },\r\n    ready: function() {\r\n        app.mount(this.id, this)\r\n    },\r\n    detached: function(){\r\n        app.unmount(this.id)\r\n    }\r\n  },\r\n  methods: {\r\n      active(clsName){\r\n          /* do something */\r\n      }\r\n  })\r\n复制代码应用下面开始在Page中使用\tgetElementsById 来抓取自定义组件实例wxml<ui-component dataSource=\"{{config}}\" />\r\n复制代码jsPage({\r\n    data: {\r\n        config:  {\r\n            $$id: 'component-id',\r\n            title: 'some text'\r\n        }\r\n    },\r\n    \r\n    onReady(){\r\n        // 我们应该在onReady中来调用，onLoad时，页面组件结构并没有渲染完成  \r\n        const $ele = app.getElementsById('component-id')\r\n        $ele.active('.active') \r\n    }\r\n})\r\n复制代码至此，基本思路已经实现，现在即兼容了selectComponent方法，又简化了写模板id的麻烦。不知道大家有没有了解小程序组件是可以递归嵌套自己的(模板不能递归嵌套)。因此聪明的你应该可以想到通过数据嵌套去实现组件嵌套，进而实现结构嵌套，这样我们就能够实现很复杂的页面结构，当然小程序目前建议是结构应该在30层左右，然并卵，反正它能够正常显示，哈哈"}
{"title": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 ... ", "author": "Rolan", "pub_time": "2019-12-5 00:31", "content": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 在做小程序的时候，要实现下面的搜索历史界面下面的搜索很明显的想到是用flex布局，然后把justify-content设置为justify-content: flex-start; 代码如下：<view class=\"flex\"><button class=\"item\">1</button><button class=\"item\">2</button><button class=\"item\">3</button><button class=\"item\">4</button><button class=\"item\">5</button><button class=\"item\">6</button><button class=\"item\">7</button></view>.flex{  display: flex;  flex-wrap: wrap;   justify-content: flex-start;}.flex .item{  width: 216rpx;  background-color: red;  margin-bottom: 34rpx;}可效果却不尽人意，发现justify-content不起作用，无论怎么设置都是space-around的效果。 经过排查，发现原因是小程序button中的默认样式中的margin-left: auto;margin-right: auto;所引起的。flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。参考自探秘 flex 上下文中神奇的自动 margin原因找到了，具体修改就容易多了，我们可以覆盖button的margin-left和margin-right的默认值，或者在button外面包裹一层view。在遇到这个问题之前，我也没想到过flex和margin之间还能这么用，涨姿势了"}
{"title": "解决小程序渲染复杂长列表，内存不足问题 ", "author": "Rolan", "pub_time": "2019-12-9 00:12", "content": "问题回顾：我们有一个列表展示页，是无限瀑布流式的，展示的元素我们封装成了单个组件，暂且叫它Item组件。这个瀑布流包含若干个Item组件，并且这个Item组件也比较复杂，包含各种展示样式（根据不同类型，大概有9种吧，反正渲染节点很多），在进行滑动的过程中，item大概加载30-40个以后，就会造成小程序内存不足而退出，蓝瘦香菇......【干货在最后，小程序代码片段奉上】\r\n\r\n解决思路：\r\n将超出屏幕一定部分的列表内的组件进行不渲染的处理（也就是用wx:if卸载掉组件），当到达渲染临界点时再开始渲染；保证每次少量的数据展示。\r\n\r\n我们的项目中是保持15条Item，我们是每次分页请求5条，按照前5条，中间5条和后5条来划分，如果不在这个范围，则用一个等高度的骨架代替，并且卸载这些组件\r\n\r\n初期实现方式（后面有更优化的方式）\r\n使用曝光监听，当一个Item曝光时，记录Item高度，并放到数组里面，作为骨架的填充高度，如果已经记录了高度，则不再重复记录；曝光时向外传递一个当前渲染范围的中心值（比如当前Item所属页码，或者当前Item索引），以此进行处理；\r\n\r\n这里有一点要注意，如果你的列表item组件比较复杂，需要在ready的时候将记录的高度设置为item最小高度，不然组件重新装载时会有一定的渲染时间，在临界点会造成跳屏【此处已经通过骨架组件解决，可以忽略，只是作为踩坑记录】\r\n\r\n此时优化点\r\n\r\n为避免频繁setData和渲染，做了防抖函数，时间是600ms\r\n\r\n此时缺点\r\n\r\n滑动特别快时，会出现白屏，是因为曝光监听是在组件里面，而超快速滚动时，组件没有装载进来，也无法进行曝光监听，所以无法触发，这里考虑用骨架组件进行二次监听曝光\r\n\r\n优化迭代\r\n\r\n将骨架组件作为外壳套在Item外面（用slot），并对骨架进行监听曝光，可以解决上面缺点\r\n给骨架组件做一个常规骨架屏样式，而不是纯白色，看起来更优雅\r\n\r\n继续发现问题\r\n经过一系列的实践，上面的方案有些问题，其中最麻烦的就是，需要对外传递一个当前index，然后控制前后数据展示；这里对于每个用到skeleton组件的页面来说，都要重复的写一个方法来承接这个index，然后渲染页面对应的数据。\r\n优化\r\n依然是监听skeleton曝光，这里监听的方案变为出现在屏幕上下n屏的内容块进行展示，此范围外的内容块就卸载掉。\r\n如图所示\r\n\r\n核心代码\r\n     // 修改了监听是否显示内容的方法，改为前后showNum屏高度渲染\r\n     // 监听进入屏幕的范围relativeToViewport({top: xxx, bottom: xxx})\r\n      let info = SystemInfo.getInfo() //获取系统信息\r\n      let { windowHeight = 667 } = info.source.system\r\n      let showNum = 2 //超过屏幕的数量，目前这个设置是上下2屏\r\n      let listItemContainer = this.createIntersectionObserver()\r\n      listItemContainer.relativeToViewport({ top: showNum * windowHeight, bottom: showNum * windowHeight })\r\n        .observe(`#list-item-${this.data.skeletonId}`, (res) => {\r\n        \t// 此处来控制slot展示，详见代码片段\r\n        })\r\n       \r\n复制代码干货\r\n话不多说，干货放后面，点击获取代码片段\r\n最后，还是尽量减少节点数，优化代码"}
{"title": "微信小程序setData复杂数组的更新、删除、添加、拼接 ", "author": "Rolan", "pub_time": "2019-12-9 00:20", "content": "众所周知，微信小程序里所有对数据的修改只有在setData里修改才会在页面上渲染。在此分享小程序里复杂数组的更新、删除、添加、拼接 初始数据数组嵌套对象data: {\r\n    cartList = [{ id: 1, goods: {id: 1, name: 'wechat'}, checked: true }, { id: 2, goods: {}, checked: false }, { id: 3, goods: {}, checked: true }]\r\n }, 索引部分删除1 let index = 2;\r\n2 let cartList = this.data.cartList\r\n3 cartList.splice(index, 1)\r\n4 this.setData({\r\n5         cartList: cartList\r\n6       }) 内部部分修改只修改数据内某项里的某属性。但此方法对于有引用到被修改的数据的wxs不会刷新页面显示，尚未清楚是bug还是小程序本身就不支持。let index = 2\r\nlet updateTodo = `cartList[${index}].checked`\r\nthis.setData({\r\n          [updateTodo]:  true\r\n        })用一个变量接收要修改的数组，修改好后再整体setData赋值，如果原数据很大的话可能会影响性能。1 let index = 2\r\n2 let cartList = this.data.cartList;\r\n3 cartList[index].checked = res.data.checked\r\n4 this.setData({\r\n5           cartList: cartList\r\n6         }) 添加、拼接push和concat 1 // push改变原数组\r\n 2 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n 3 let cartList = this.data.cartList;\r\n 4 cartList.push(...newList);\r\n 5 this.setData({\r\n 6           cartList: cartList\r\n 7         })\r\n 8 \r\n 9 // concat返回添加后的副本，并不会修改原有数组\r\n10 let newList=  [{ id: 4, goods: {}, checked: true }, { id: 5, goods: {}, checked: false }}]\r\n11 let cartList = this.data.cartList;\r\n12 this.setData({\r\n13           cartList: cartList.concat(newList)\r\n14         })"}
{"title": "解决微信小程序安卓机器上 backgroundAudioManager 的一个坑 ", "author": "Rolan", "pub_time": "2019-12-9 10:32", "content": "一句话来说，问题的根源就在于安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate背景在做的小程序中要做的一个功能是 AB 定次重复：重复播放音频中 A 秒到 B 秒的声音 N 次。根据我的需求，理想中流程是通过 backgroundAudioManager 的绑定事件完成功能（这里先不讨论 B == backgroundAudioManager.duration 的情况）。设定backgroundAudioManager的title和srcbackgroundAudioManager.seek(A)backgroundAudioManager.onSeeking()backgroundAudioManager.onSeeked()\t4.a backgroundAudioManager.play();backgroundAudioManager.onTimeUpdate\t5.a 如果 backgroundAudioManager.currentTime >= B, backgroundAudioManager.pause()\t5.a.1 如果没达到重复次数，回到步骤2\t5.b 如果 backgroundAudioManager.currentTime < B，回到步骤5问题在几次摸索后 iOS 上可以完美完成，但是安卓上会跳次数，比如希望一共播放3次，在播放完第一次之后会直接跳过第二次进行第三次的播放，最后一共只播放了两次。解决我在网上搜的时候发现有人写到了\tbackgroundAudioManager中的一些坑 ，其中提到暂停状态下跳转到指定位置，在 onSeeked() 回调中，Android 的 currentTime 是跳转前的时间，而 iOS 是跳转后的时间。一开始我以为完全是这个原因，seek 后第一次 onTimeUpdate 时 currentTime >= B导致直接跳次数，所以我就加上一个 boolean 变量，在 onSeeked 中将它赋值为 true，用它判断是否刚执行 seek，如果否再进行 currentTime 的判断。但是改来改去问题还是存在。在加了一堆 console.log，反复和 iOS的结果比较后为发现了问题的根本所在。安卓机器上 backgroundAudioManager.pause() 后还会触发一两次 onTimeUpdate找到了问题解决起来就比较简单啦，在 onTimeUpdate 中先判断 backgroundAudioManager.paused 是否为 true，只有在 backgroundAudioManager.paused == false 时才进行步骤5的流程。结论backgroundAudioManager 和 innerAudioContext 写起来，测试起来都好痛苦。同样的代码 innerAudioContext 在 2.6.1 可以在开发工具中完成我要的效果，但是后面的版本就不行了。而且 iOS，Android 还有开发者工具上的行为都不一样，每次改一点就要用两个手机扫码预览还是挺不方便的。希望官方可以优化一下。这篇文章我原本发在微信小程序交流专区https://developers.weixin.qq.com/community/develop/article/doc/00086c3f998a603d51899109151013"}
{"title": "微信小程序|CSS的内边距和圆框 ", "author": "Rolan", "pub_time": "2019-12-9 00:02", "content": "本文首发于微信公众号： \"算法与编程之美\"，欢迎关注，及时了解更多此系列文章。问题描述在制作小程序的时候会经常用到浮动来设计各种组件的排版，微信小程序对排版的要求很高。 光有浮动是远远不够的，如果一个板块内的组件过多就会变得混乱。 所以就需要用设置内边框来调整位置。 微信小程序中会有很多的头像设置，所以就会用到圆框。 那么如何来设置css盒子的内边框和头像的圆框呢？解决方案跟网页一样小程序也是用很多标签来定义的。 需要用css盒子来设置解决问题，并调用来实现问题。（1）内边距我们需要用到margin这个标签代表内边距，用rpx来设置距离单位。 在.wxss中设置，然后在wxml中调用就可以了。margin-left： 离左边的距离margin-right： 离右边的距离margin-top： 离上边的距离margin-bottom： 离下边的距离margin-top: 100rpx;margin-left: 10rpx（2）框 用border来定义框线的宽度，用width和heigth来设置框的长宽。solid来定义颜色。 跟内边距一样在.wxss中设置，然后在wxml中调用。.view4{margin-top: 0rpx;margin-left: 0rpx;width: 800rpx;height: 115rpx;border: 5rpx solid whitesmoke}（3）圆框border-radius： rpx定义圆框。.view3{margin-top: 350rpx;margin-left: -190rpx;height: 60rpx;width: 220rpx;float: left;background-color: rgb(131, 178, 240);border-radius: r5px}（4）圆框头像跟上面的圆框一样也是用border-radius来定义，但不同的是后面的设置： %。 就是一个圆的弧度不同，rpx是将框的四角成为圆弧而%是成为一个圆。.view1{float: left;margin-left: 290rpx;margin-top: 120rpx;border-radius: 50%}结语对标签的正确使用和调用， 最麻烦的是对标签后面的单位设置，必须充满耐心，你需要不断地调才能调到你需要的位置，才能使界面美观。END实习编辑 | 王文星责 编 | 江汪霖where2go 团队微信号： 算法与编程之美"}
{"title": "小程序开发中的一些实践和踩坑 ", "author": "Rolan", "pub_time": "2019-12-10 00:23", "content": "在公司小程序也开发了一段时间了，中间遇到过很多问题，特此记录几个比较典型的问题和解决方案。01—textarea 的高层级问题此问题提供源码demo，可导入微信开发者工具查看。复制到电脑上打开：https://github.com/dunizb/CodeTest/tree/master/Wechat/textarea-test 症状（表现）textarea 是小程序的原生组件，它的一个表现就是优先级很高，这导致了一些困扰，比如我们有一个表单页面，最下面就是一个textarea和一个保存按钮，这会导致textarea的文字会浮现在按钮上。如下图：它最大的问题是会导致保存按钮可能点击无效或者会弹出键盘，并且开发者工具模拟器和真机表现不一样，这真是个坑！诊断（实验）模拟器中，针对 position:fixed 定位的按钮，我们加一个 z-index:10 即可， z-index 等于多少合适不清楚，试了等于1是不行的，10就可以，其余的值没试过。.submit-cls {  position: fixed;  left: 30px;  right: 30px;  bottom: 300px;  text-align: center;  background-color: green;  color: #fff;  z-index: 10;}模拟器中的表现：然儿，真机上（Android）依然无效！如下图：于是我想到了 cover-view 标签，cover-view 是微信提供的一个原生组件，它是覆盖在原生组件之上的文本视图，可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher之上，只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。用 cover-view 标签包裹 button 如何呢？郁闷的事情发生了，真机上按钮不见了！。。。这方法貌似不行。。<cover-view>  <button class=\"submit-cls\" id='button' bindtap=\"onClick\"> Button z-index: 10 </button></cover-view>那我直接用 cover-view 标签作为按钮呢？<cover-view class=\"cover-view-clas\" id='cover-view' bindtap=\"onClick\"> cover-view z-index: 10 </cover-view>.cover-view-clas {  position: fixed;  height: 40px;  line-height: 40px;  left: 30px;  right: 30px;  bottom: 250px;  text-align: center;  background-color: orangered;  color: #fff;}结果在模拟器里不行但是真机上表现很好。于是我也加了一个 z-index: 10 ，这样模拟器和真机表现就一致。药方（总结）综上所述，要解决这个问题似乎只有一个办法，那就是用 cover-view + z-index:10 ，然儿这样会导致一个的副作用，没法使用微信的开放能力比如 open-type。02—setData优化我们知道，与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。然而当 setData 传递大量的新数据、频繁的执行 setData 操作、过多的页面节点数时会影响渲染性能。区分数据类别意思是， setData 只用来通知页面更新，只有需要通知页面更新的时候，页面引用了某个 data 字段时才使用，其它字段数据我们有时候可能只是为了让 js 方便使用。比如如下数据data: {    form: {        name: 'xxxx',        ... ...    },    index: 0}假如 页面上根本没用到 index 来展示，只是我们的逻辑变量，那么我们在赋值的时候就直接 this.data.index = xxx 即可，不要用 setData 去赋值了。合理利用局部更新setData 是支持使用 数据路径 的方式对对象的局部字段进行更新，我们可能会遇到这样的场景：list 列表是从后台获取的数据，并展示在页面上，当 list 列表的第一项数据的 src 字段需要更新时，一般情况下我们会从后台获取新的 list 列表，执行 setData 更新整个 list 列表。// 后台获取列表数据const list = requestSync(); // 更新整个列表this.setData({ list });实际上，只有个别字段需要更新时，我们可以这么写来避免整个 list 列表更新:// 后台获取列表数据const list = requestSync(); // 局部更新列表this.setData({   'list[0].src': list[0].src});善用自定义组件小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似：在页面引用自定义组件后，当初始化页面时，Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用，这是组件化带来的好处。基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。03—大表单交互的一点实践经验在项目中，有一个预约模块，字段忒多，保险业务嘛，需要用户填写各种数据的，为了用户体验拆成了多个步骤，如图一开始，业务上要求切换tab的时候数据要缓存，跟Vue的 keep-alive 一样，但是小程序没有这样的机制，所以利用小程序的 hidden 属性，也就是 Vue 中的 v-show，组件始终会被渲染，只是简单的控制显示与隐藏。关于wx:if 和 hidden。这样的导致页面节点太多，在低性能手机上会出现卡死的现象，直接无法渲染或者渲染太慢。后来改为 wx:if 来切换<view wx:if=\"{{current === 0}}\">......</view><view wx:if=\"{{current === 1}}\">......</view><view wx:if=\"{{current === 2}}\">......</view>... ...这样一来一次渲染节点太多的问题解决了，但是怎么实现tab切换的时候输入的内容杯缓存呢？其实我们的笨办法就是切换的时候把前一个表单内容保存到 localStorage 或 gloabData 中，切换回去的时候再取出来填充，这中间会有一个明显的渲染过程，肉眼可见，没办法，目前只能牺牲一点点体验了。对于这种大型表单，数据处理和逻辑交互的时候要非常注意，很容易出现性能问题。这次就说这么多吧，文章如有什么错误，或有什么想法，请留言，不吝赐教！"}
{"title": "微信小程序之下载(下载文件tempFilePath后缀unknown) ", "author": "Rolan", "pub_time": "2019-9-18 00:36", "content": "1.下载文件使用downloadFile下载API/* 直接这样写的话，会出现下载文件后缀名为unknown的情况 */\r\nwx.downloadFile({\r\n  url: '',\r\n  success (res) {\r\n    console.log(res.filePath);\r\n  }\r\n})改进后的下载保存/* 使用时间戳为下载后的文件的名字 */\r\nlet fileName = new Date().valueOf();\r\nwx.downloadFile({\r\n  /* url 为要下载的文件链接 */\r\n  url: '',\r\n  /* filePath指定文件下载后存储的路径，wx.env.USER_DATA_PATH */\r\n  filePath: wx.env.USER_DATA_PATH + '/' + fileName + '.mp4', \r\n  success: res => {\r\n    let filePath = res.filePath;\r\n    wx.saveVideoToPhotosAlbum({\r\n      filePath,\r\n      success: file => {\r\n        wx.hideLoading();\r\n        /* 删除缓存 */\r\n        let fileMgr = wx.getFileSystemManager();\r\n        fileMgr.unlink({\r\n           filePath: wx.env.USER_DATA_PATH + '/' + fileName + '.mp4',\r\n           success: function (r) {\r\n\r\n           },\r\n        })\r\n     },\r\n     fail: err => {\r\n        wx.hideLoading();\r\n        /* 拒绝授权时显示 */\r\n        if (err.errMsg === 'saveVideoToPhotosAlbum:fail auth deny') {\r\n          wx.showModal({\r\n            title: '提示',\r\n            content: '需要您授权保存相册',\r\n            showCancel: false,\r\n            success: data => {\r\n              /* 打开权限设置 */\r\n              wx.openSetting({\r\n                success: setting => {\r\n                  if (setting.authSetting['scope.writePhotosAlbum']) {\r\n                    wx.showModal({\r\n                      title: '提示',\r\n                      content: '获取权限成功,再次点击下载即可保存',\r\n                      showCancel: false,\r\n                    })\r\n                  } else {\r\n                    wx.showModal({\r\n                      title: '提示',\r\n                      content: '获取权限失败，将无法保存到相册哦',\r\n                      showCancel: false,\r\n                    })\r\n                  }\r\n                },\r\n              })\r\n            }\r\n          })\r\n        }\r\n      },\r\n  },\r\n  fail: err => {\r\n    wx.hideLoading();\r\n    if (err.errMsg == 'downloadFile:fail createDownloadTask:fail url not in domain list') {\r\n        wx.showToast({\r\n          title: '服务器错误，请联系相关管理员',\r\n          icon: 'none'\r\n        })\r\n     }\r\n  },\r\n  complete: () => {\r\n    wx.hideLoading();\r\n  }\r\n})2.下载图片下载图片的步骤和上面是一样的，就是在保存的时候，api使用的不一样 wx.saveImageToPhotosAlbum({\r\n    filePath: '',\r\n    success: () => {}\r\n})"}
{"title": "小程序Ticker倒计时最佳实践 ", "author": "Rolan", "pub_time": "2019-9-20 00:22", "content": "Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址\r\n一. 什么是ticker？\r\ntick本来的意思是钟表的滴答声。Ticker类为游戏开发提供了一个主要的定时类。它主要的目的就是把stage渲染的工作集中起来，也就是说定时调用stage.update()这个方法。Ticker设置的频率也就是游戏的帧数了。\r\n我们把Ticker应用到小程序开发中，频率设置为1s。\r\nTicker的使用如下，初始化Ticker对象，添加侦听tick事件，启动ticker。\r\nconst ticker = new Ticker()\r\n// 参数为Object类型，必须有tick方法\r\nticker.addTick({\r\n    tick: (delta) => {\r\n    \t...\r\n    }\r\n})\r\nticker.start()\r\n复制代码这里不细说Ticker的实现，详情请看Ticker.js源码。\r\n二. 小程序倒计时的烦恼\r\n假如我们都在页面onShow设置setTimeout。\r\n1、onHide取消clearTimeout。假如首页有个倒计时在倒数100S，进入二级页面后，触发onHide，取消clearTimeout。过了10S返回首页，又重新启动setTimeout，那么应该是从100S还是90S开始倒数呢？\r\n那肯定是90S开始呀，可是setTimeout都停了，怎么记录到过去了10S呢？\r\n2、onUnload 取消clearTimeout。onHide之后，其实倒计时还在后台执行，setData也在重新渲染。如果有多级页面，无疑是非常浪费性能。\r\n三. Ticker实现countdown解决方案\r\n在Page的生命周期函数中，添加tick处理。\r\nimport ticker from './utils/ticker'\r\n\r\nPage({\r\n\tcountdown: 100,\r\n\t// 添加当前页面对象到ticker队列\r\n\tonLoad () {\r\n\t\tticker.addTick(this)\r\n\t},\r\n\t// 恢复当前页面对象tick\r\n\tonShow () {\r\n\t\tticker.resume(this)\r\n\t},\r\n\t// 暂停当前页面对象tick\r\n\tonHide () {\r\n\t\tticker.pause(this)\r\n\t},\r\n\t// 移除当前页面对象tick从ticker队列\r\n\tonUnload () {\r\n\t\tticker.removeTick(this)\r\n\t},\r\n\t// 需要计时的页面添加tick方法\r\n\ttick (delta) {\r\n\t\tcountdown -= delta\r\n\t\tthis.setData({\r\n\t\t\tcountdown\r\n\t\t})\r\n\t}\r\n})\r\n复制代码统一处理Page的tick\r\n每个需要用ticker的页面，都需要在各自的生命周期函数里面添加对应的操作。重复的工作交给代码，来重写Page构造函数。interceptor.js\r\n// 生命周期函数集合\r\nconst Interceptor = {\r\n    onLoad: [], onShow: [], onHide: [], onUnload: []\r\n}\r\n\r\n/**\r\n * 组合函数，依次执行\r\n * @param  {...Function} args 被组合的函数\r\n */\r\nfunction compose(interceptorList, sourceMethod){\r\n    return function () {\r\n        [...interceptorList, sourceMethod].forEach( fn => {\r\n            typeof fn === 'function' && fn.call(this, arguments)\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * 小程序Page方法的替代实现\r\n */\r\nconst wxPage = Page\r\n\r\n/**\r\n * 重写Page构造函数\r\n * @param pageObject - 传入的页面对象\r\n */\r\nPage = function (pageObject) {\r\n    Object.keys(Interceptor).forEach((keyName) => {\r\n        const sourceMethod = pageObject[keyName]\r\n        pageObject[keyName] = compose(Interceptor[keyName], sourceMethod)\r\n    })\r\n    return wxPage(pageObject)\r\n}\r\n\r\n/**\r\n * 增加对Page生命周期方法的拦截器\r\n * @param methodName\r\n * @param handler\r\n */\r\nexport function addInterceptor (methodName, handler) {\r\n    Interceptor[methodName] && Interceptor[methodName].push(handler)\r\n}\r\n复制代码小程序入口文件app.js，给页面生命周期函数全局注入ticker对应的方法。\r\nimport * as Interceptor from './utils/interceptor'\r\nimport ticker from './utils/ticker'\r\n\r\nInterceptor.addInterceptor('onLoad', function () {\r\n    ticker.addTick(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onShow', function () {\r\n    ticker.resume(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onHide', function () {\r\n    ticker.pause(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onUnload', function () {\r\n    ticker.removeTick(this)\r\n})\r\n\r\nApp({\r\n    onLaunch () {\r\n        \r\n    }\r\n})\r\n复制代码页面只需要添加tick方法，利用delta计算倒数时间，无需操作ticker逻辑。page.js：\r\nimport formatTime from '../../utils/formatTime'\r\nPage({\r\n    countdown: 1000,\r\n    data: {\r\n        countdownStr: ''\r\n    },\r\n    tick (delta) {\r\n        console.log('index tick')\r\n        let countdownStr = formatTime(this.countdown -= delta)\r\n        this.setData({\r\n            countdownStr\r\n        })\r\n    }\r\n});\r\n复制代码done\r\n\r\nGithub: github.com/songdy/todo…"}
{"title": "两天撸两个天气小程序 ", "author": "Rolan", "pub_time": "2019-9-20 00:25", "content": "经过最近两年多的发展，小程序的地位也逐渐越来越高了，各个平台前赴后继做了自家的小程序平台，随着市场的需求越来愈多，我们开发各平台的小程序的激情也随（被）之（逼）高（无）涨（奈）。选择uniapp来开发。uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。即使不跨端，uni-app同时也是更好的小程序开发框架。来自官方。喜欢taro， wepy，mpvue的朋友也莫喷我，大家各有所好，大家开心就好。【智行天气】小程序效果图1、获取位置信息在定位功能中，本程序用到腾讯地图的api 以及 腾讯天气的api接口，需要到官网中注册开发者账号，通过注册后得到的appKey来请求我们需要的数据，详细注册步骤请自行度娘由于需要用到定位功能，uniapp的getLocation方法获取到的是当前位置的坐标，然后对应腾讯地图具体城市uni.getLocation({\r\n    // #ifdef MP-WEIXIN\r\n    type: 'wgs84',\r\n    // #endif\r\n    async success (res) {\r\n        const {latitude, longitude} = res\r\n        const result = await that.ajax({url: 'https://apis.map.qq.com/ws/geocoder/v1', data: {\r\n            location: `${latitude},${longitude}`,\r\n            key: ''\r\n        }})\r\n        let {province, city, district} = result.result.address_component\r\n        that.getData(province, city, district)\r\n    },\r\n    fail(){\r\n        uni.showModal({\r\n          content: '检测到您没打开定位权限，是否去设置打开？',\r\n          confirmText: \"确认\",\r\n          cancelText: \"取消\",\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              // #ifdef MP-WEIXIN\r\n              wx.openSetting({\r\n                success: (res) => {\r\n                    that.getIn()\r\n                }\r\n              })\r\n              // #endif\r\n              // #ifdef MP-ALIPAY\r\n              my.openSetting({\r\n                 success: (res) => {\r\n                    that.getIn()\r\n                 }\r\n              })\r\n              // #endif\r\n            }\r\n          }\r\n        });\r\n    }\r\n})2、查询天气得到城市名后，再用城市名查询天气的接口，得到未来几天的天气预报。天气接口使用腾讯天气接口api。在小程序中使用前，要在小程序设置界面，开发设置中添加request合法域名。methods: {\r\n    async getData(province, city, district){\r\n        const that = this\r\n        const data = await that.ajax({url: 'https://wis.qq.com/weather/common', data: {\r\n            source: 'xw',\r\n            weather_type: 'observe|alarm|air|forecast_1h|forecast_24h|index|limit|tips|rise',\r\n            province: province,\r\n            city: city,\r\n            county: district\r\n        }})\r\n        that.region = [province, city, district]\r\n        if(data.status != 200){\r\n            uni.showToast({\r\n                title: result.message,\r\n                icon: 'none'\r\n            });\r\n            return false;\r\n        }\r\n        if(!data.data.air.aqi_name){\r\n            uni.showToast({\r\n                title: '暂无该地区的天气信息',\r\n                icon: 'none'\r\n            });\r\n            return false;\r\n        }\r\n        that.data = data.data\r\n    }\r\n}3、小程序界面由于没有什么审美，缺乏想象力，参考腾讯天气的界面来做的。功能十分简单，查看当前地区的天气和切换其他地区的天气，查看最近24小时的天气情况以及最近6天的天气情况，展示今天的农历时间。4、插件使用想快速完成小程序的搭建，里面的折线图采用的 uchart.js ,因为可以兼容支付宝小程序和微信小程序，农历查询也是采用的插件 calendar.js折线图在支付宝小程序中会有模糊的问题，需要做兼容处理<template>\r\n<!-- #ifdef MP-ALIPAY -->\r\n<canvas canvas-id=\"canvas\" id=\"canvas\" width=\"750\" height=\"240\" style=\"width:750rpx;height:240rpx;\" class=\"canvas\">\r\n</canvas>\r\n<!-- #endif -->\r\n<!-- #ifdef MP-WEIXIN -->\r\n<canvas canvas-id=\"canvas\" id=\"canvas\" class=\"canvas\">\r\n</canvas>\r\n<!-- #endif -->\r\n</template>\r\n\r\n<script>\r\nvar wxCharts = require('../../utils/chart.js');\r\nlineChart = new wxCharts({\r\n    $this: this,\r\n    canvasId: 'canvas',\r\n    type: 'line',\r\n    categories: ['', '', '', '', '' ,''],\r\n    colors: ['#ffad35', '#4fc3f7'],\r\n    background: '#fff',\r\n    animation: true,\r\n    series: [{\r\n        name: '',\r\n        data: that.max,\r\n        format: function (val, name) {\r\n            return val + '°';\r\n        }\r\n    }, {\r\n        name: '',\r\n        data: that.min,\r\n        format: function (val, name) {\r\n            return val + '°';\r\n        }\r\n    }],\r\n    xAxis: {\r\n        disableGrid: true,\r\n        disabled: true,\r\n        axisLine: false\r\n    },\r\n    yAxis: {\r\n        max: Math.max.apply(Math, that.max) * 1 + 0.1,\r\n        disabled: true,\r\n        disableGrid: true,\r\n    },\r\n    legend:{ \r\n        show: false \r\n    },\r\n    // #ifdef MP-ALIPAY\r\n    pixelRatio: that.pixelRatio, // 解决支付宝模糊问题\r\n    // #endif\r\n    width: that.cWidth,\r\n    height: that.cHeight\r\n});\r\n</script>微信小程序有城市选择组件，支付宝的没有可以直接使用的城市组件，uniapp官方介绍:支持安装 mpvue 组件，但npm方式不支持小程序自定义组件（如 wxml格式的vant-weapp）,找到一款支付宝可以使用的城市插件： mpvue-citypicker ,城市选择组件<template>\r\n    <view class=\"txt-location\" @tap=\"showCityPicker\">\r\n        <view class=\"icon\"></view>\r\n        <block v-if=\"region.length\">{{region[0]}}{{region[1]}}{{region[2]}}</block>\r\n        <block v-else>选择城市</block>\r\n        <!-- #ifdef MP-WEIXIN -->\r\n        <picker class=\"city\" mode=\"region\" @change=\"handleChange\" :value=\"region\">\r\n            <view class=\"picker\">\r\n                当前选择：{{region[0]}}，{{region[1]}}，{{region[2]}}\r\n            </view>\r\n         </picker>\r\n        <!-- #endif -->\r\n    </view>\r\n    <mpvue-city-picker ref=\"mpvueCityPicker\" :pickerValueDefault=\"pickerValueDefault\" @onConfirm=\"onConfirm\"></mpvue-city-picker>\r\n</template>\r\n\r\n<script>\r\nimport mpvueCityPicker from 'mpvue-citypicker';\r\nexport default {\r\n  data() {\r\n    return {\r\n      region: [],\r\n      pickerValueDefault: [0, 0, 1]\r\n    };\r\n  },\r\n  components: {\r\n    mpvueCityPicker\r\n  },\r\n  methods: {\r\n    showCityPicker() {\r\n        // #ifdef MP-ALIPAY\r\n        this.$refs.mpvueCityPicker.show()\r\n        // #endif\r\n    },\r\n    onConfirm(e) {\r\n        if(e.label){\r\n            this.region = e.label.split('-')\r\n            this.getData(this.region[0], this.region[1], this.region[2])\r\n        }\r\n    },\r\n    handleChange(e) {\r\n        this.region = e.detail.value\r\n        this.getData(this.region[0], this.region[1], this.region[2])\r\n    }\r\n  }\r\n};\r\n</script>总结界面很快就搭建完成，提供了较为完整的组件以及各种API2天气接口查询的腾讯天气的，需要做过滤处理才能使用，某些地区查询天气没有返回需要友情提示处理第一次做支付宝小程序遇到的坑不少，例如图表模糊，城市选择组件需要自己做，消息提示框uni.showToast使用时需要兼容，支付宝不能使用duration字段，获取位置uni.getLocation使用时也需要兼容，支付宝不能使用type字段等。程序的提交审核比较快，我的大概是用了一天的时间就申请好了。但是支付宝审核比较慢后续将代码放到 https://github.com/galan99"}
{"title": "如何实现微信小程序图像剪切？代码拿去用，不谢！ ", "author": "Rolan", "pub_time": "2019-11-4 00:41", "content": "前情回顾\r\n我在早先发布的文章《如何实现微信小程序换头像？三步帮你搞定！》中，提到实现微信小程序换头像需要三步：\r\n\r\n获取用户头像\r\n图片模板\r\n图片合成\r\n\r\n前文已经就获取用户头像和图片模板两个步骤进行了讲解，本文就来详细说说如何合成图片。\r\n图片合成的过程中非常重要的一块功能对图片进行剪切。该功能点很固定，大都是对图片进行拖拽、缩放后，在一定区域内剪切出一个固定长宽的图片。这类功能在app端和H5中都有很多成熟的插件供使用，接下来就来看看我在海豚趣图小程序中的头像剪切插件是如何实现的，欢迎大家提意见。\r\n为了更好地理解接下来的代码，建议大家先扫描体验一下图片裁剪效果。\r\n\r\n实现效果\r\n界面实现\r\n在H5中要实现图片的拖拽和缩放需要一大坨代码，具体实现网上有很多。小程序实现就简单的多了，通过 <movable-area> 和 <movable-view> 就可以实现上述功能\r\n<view class=\"clip-view\">\r\n  <!--\r\n    clipHeight、clipWidth 分别为剪切框的高和宽\r\n    imgHeight、imgWidth 分别对应图片的初始高和宽\r\n    imgUrl 为剪切图片的url地址\r\n  -->\r\n  <movable-area class=\"moveare\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \">\r\n    <movable-view scale=\"true\" scale-min=\"{{1}}\" damping=\"1000\" style=\"height: {{imgHeight}}px; width: {{imgWidth}}px; \" direction=\"all\" x=\"{{x}}\" y=\"{{y}}\" bindchange=\"_onChange\" bindscale=\"_onScale\">\r\n      <image class=\"clip-img\" src=\"{{imgUrl}}\" />\r\n    </movable-view>\r\n  </movable-area>\r\n  <!--剪切框 装饰用-->\r\n  <view class=\"clip-box\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \">\r\n    <!--剪切框四个角-->\r\n    <view class=\"clip-border clip-border-lt\"></view>\r\n    <view class=\"clip-border clip-border-rt\"></view>\r\n    <view class=\"clip-border clip-border-lb\"></view>\r\n    <view class=\"clip-border clip-border-rb\"></view>\r\n  </view>\r\n  <!--剪切图片用的canvas-->\r\n  <canvas class=\"clip-canvas\" id=\"img_clip_canvas\" canvas-id=\"img_clip_canvas\" style=\"height: {{clipHeight}}rpx; width: {{clipWidth}}rpx; \"></canvas>\r\n</view>\r\n复制代码组件属性\r\n组件的入参只需要原始图片的地址和图片剪切框的宽高\r\n/**\r\n * 组件的属性列表\r\n */\r\nproperties: {\r\n  // 原始图片路径（要剪切的图片）\r\n  imgUrl: {\r\n    type: String,\r\n    value: ''\r\n  },\r\n  // 剪切的宽度 (rpx)\r\n  clipWidth: {\r\n    type: Number,\r\n    value: 500\r\n  },\r\n  // 截切的高度 (rpx)\r\n  clipHeight: {\r\n    type: Number,\r\n    value: 500\r\n  }\r\n}\r\n复制代码组件data\r\n组件的data就会多一些记录图片拖拽缩放的数据，需要注意的是，图片初始位置和图片拖拽位置没有使用同一变量存储，是为了防止在拖拽过程中产生抖动。\r\n/**\r\n * 组件的初始数据\r\n */\r\ndata: {\r\n  baseScale: 1,\r\n  imgPath: '',\r\n  imgWidth: 0, // 图片宽\r\n  imgHeight: 0, // 图片高\r\n  x: 0, // 图片初始时x轴位置\r\n  y: 0, // 图片初始时y轴位置，之所以不和top共用一个变量，是因为如果频繁改变y值，图片会闪烁，x同理\r\n  left: 0, // 图片拖拽后的x轴位置\r\n  top: 0, // 图片拖拽后的y轴位置\r\n  scale: 1 // 拖拽后的缩放比例\r\n}\r\n复制代码组件初始化\r\n组件的初始化方法用于把图片缩放到合适的大小，并使剪切框位于图片中央\r\n/**\r\n * 初始化方法\r\n * 获取图片宽高后，把图片缩放至剪切框大小，\r\n * 并使剪切框位于图片中央\r\n **/\r\n_init() {\r\n  if (!this.data.imgUrl) return\r\n  // 获取屏幕宽度\r\n  let {\r\n    screenWidth\r\n  } = wx.getSystemInfoSync()\r\n  // 计算屏幕rpx\r\n  const rpx = screenWidth / 750\r\n  // 获取图片宽高，然后缩放至剪切框大小\r\n  wx.getImageInfo({\r\n    src: this.data.imgUrl,\r\n    success: ({\r\n      width,\r\n      height,\r\n      path\r\n    }) => {\r\n      const cw = this.data.clipWidth * rpx\r\n      const ch = this.data.clipHeight * rpx\r\n      let scale = Math.max(cw / width, ch / height)\r\n      const imgWidth = width * scale\r\n      const imgHeight = height * scale\r\n      this.setData({\r\n        imgPath: path,\r\n        imgWidth,\r\n        imgHeight,\r\n        baseScale: scale,\r\n        x: (cw - imgWidth) / 2,\r\n        y: (ch - imgHeight) / 2\r\n      })\r\n    }\r\n  })\r\n}\r\n复制代码图片拖拽缩放处理\r\n完成初始化后就可以监听用户的拖拽和缩放操作了，主要是记录拖拽的位置和缩放的比例，具体到代码实现就是监听<movable-view> 的拖拽(bindchange)和缩放(bindscale)事件\r\n  // 拖拽事件响应函数\r\n  _onChange: function(e) {\r\n    this.setData({\r\n      x: e.detail.x,\r\n      y: e.detail.y\r\n    })\r\n  }\r\n\r\n  // 缩放事件响应函数\r\n  _onScale: function(e) {\r\n    this.setData({\r\n      x: e.detail.x,\r\n      y: e.detail.y,\r\n      scale: e.detail.scale\r\n    })\r\n  }\r\n复制代码图片剪切实现\r\n拖拽缩放完成后就是剪切了,剪切是利用了<canvas>重新绘制图片的剪切区域，保存到微信临时目录里，并返回保存路径。需要注意的是拖拽和缩放后记录的图片剪切位置并不是原图的位置，利用canvas 的drawImage 进行绘制的时候需要转换成原图位置，或者先把canvas的坐标系进行缩放。注意：在自定义组件下调用 wx.createCanvasContext(string canvasId, Object this)方法时，第二个参数this不能省略，否则canvas绘制无响应\r\n/**\r\n  * 图片剪切入口方法\r\n  */\r\nclip() {\r\n  const scale = this.data._scale * this.data._baseScale\r\n  const canvasId = 'img_clip_canvas'\r\n  imageClip(canvasId, this.data.imgPath, {\r\n    x: this.data._left * -1,\r\n    y: this.data._top * -1,\r\n    scale,\r\n    width: this.data.clipWidth,\r\n    height: this.data.clipHeight\r\n  }, this)\r\n}\r\n\r\n/**\r\n * 图片剪切\r\n *\r\n * @param canvas canvas组件id，用于绘制剪切图片\r\n * @param img 要剪切的图片\r\n * @param option 剪切的位置宽高等信息\r\n * @param option.left 剪切图片左边距\r\n * @param option.top 剪切图片上边距\r\n * @param option.width 剪切图片宽度\r\n * @param option.height 剪切图片高度\r\n * @param context 组件实例对象\r\n * \r\n * @return new Promise(resolve=>ctx)\r\n */\r\nimageClip(canvas, img, option, context) {\r\n  return new Promise((resolve, reject) => {\r\n    option = Object.assign({\r\n      left: 0,\r\n      top: 0,\r\n      scale: 1,\r\n      width: 0,\r\n      height: 0\r\n    }, option)\r\n    let x = option.left / option.scale\r\n    let y = option.top / option.scale\r\n    let clipW = option.width / option.scale\r\n    let clipH = option.height / option.scale\r\n    const ctx = wx.createCanvasContext(canvas, context)\r\n    ctx.drawImage(img,\r\n      x,\r\n      y,\r\n      clipW,\r\n      clipH,\r\n      0,\r\n      0,\r\n      option.width,\r\n      option.height)\r\n\r\n    ctx.draw(false, (e) => {\r\n      console.log(e)\r\n      resolve()\r\n    })\r\n\r\n  })\r\n},\r\n\r\n/**\r\n * canvas 保存为临时文件\r\n */\r\nfunction saveCanvasToTemp(canvas, option) {\r\n  return new Promise((resolve, reject)=>{\r\n    wx.canvasToTempFilePath({\r\n      ...option,\r\n      canvasId: canvas,\r\n      success:resolve,\r\n      fail:reject\r\n    }, this)\r\n  })\r\n}\r\n复制代码写在最后\r\n这就是小程序版图片剪切的主要代码实现，里面还有一些小点儿需要注意\r\n\r\n<movable-view> 的damping的值要设置大写，否则可能会出现拖出界外的情况\r\n在自定义组件下调用 wx.createCanvasContext(string canvasId, Object this)方法时，第二个参数this不能省略，否则canvas绘制无响应\r\n切图时要记住转换成实际图片的大小"}
{"title": "一个简单日历的实现（以小程序为例） ", "author": "Rolan", "pub_time": "2019-11-5 00:32", "content": "最近做的小程序，有个页面要求展示日历。于是，结合网络上的一些文章，做了一个简单版，即拿即用。\r\n效果图：\r\n\r\njs代码：\r\n逻辑都写在注释中，这里就不啰嗦了。\r\n        const dat = new Date(); // 今天的标准时间\r\n        const timeY = dat.getFullYear() // 本年度\r\n        const timeM = dat.getMonth()// 本月，注意值是0-11\r\n        const timeD = dat.getDate() // 日期\r\n        // 获取本月长度\r\n        const start = new Date(timeY, timeM, 1) // 本月第一天的中国标准时间，\r\n        console.log(start);//Fri Nov 01 2019 00:00:00 GMT+0800\r\n        const end = new Date(timeY, timeM+1, 0) // 本月最后一天的中国标准时间\r\n        console.log(end);\r\n        const thisMLastD = end.getDate() // 本月最后一天的日期，也是本月的长度\r\n        // 获取下个月的第一天\r\n        const nextFirst = new Date(timeY, timeM+1, 1); // 下个月第一天的标准时间\r\n        const nextFirstW = nextFirst.getDay(); // 下个月第一天的星期数，周天是0，其他跟星期几一致\r\n        console.log(nextFirstW);\r\n\r\n        const lastMLast = new Date(timeY, timeM, 0) // 上个月最后一天的中国标准时间\r\n        const lastMLastW = lastMLast.getDay(); // 上个月最后一天的星期数,+1就是上个月要展示的天数\r\n        const lastMLength = lastMLast.getDate(); // 上个月最后一天的日期数\r\n        console.log(lastMLength)\r\n        console.log(lastMLastW)\r\n        // 上月要展示的数组\r\n        let lastMonthDate = []\r\n        // 由于星期日排第一位，上个月要展示的日期数量应该是上个月最后一天星期数+1，比如最后一天是周四，那就展示5天\r\n        for (var i = 0; i< lastMLastW+1; i++ ) {\r\n            let index = lastMLength - lastMLastW + i // 上个月总长度减去上月最后一天的星期数等于上月应该展示的第一天的日期数\r\n            let item = {num:index}\r\n            console.log(item)\r\n            lastMonthDate.push(item);\r\n        }\r\n        console.log(lastMonthDate)\r\n\r\n        // 本月要展示的数组\r\n        let thisMonthDate = []\r\n        for (var i = 0; i< thisMLastD + 1; i++ ) {\r\n            let item = {num:i}\r\n            console.log(item)\r\n            thisMonthDate.push(item);\r\n        }\r\n        console.log(thisMonthDate)\r\n\r\n        // 下月要展示的数组\r\n        let nextMonthDate = []\r\n        if (nextFirstW !== 0) { // 为0说明是周天，也就没必要展示下月了\r\n            for (let i = 0; i < 7 - 2; i++) {\r\n            let item = {num:i+1}\r\n                nextMonthDate.push(item)\r\n            }\r\n        }\r\n        console.log(nextMonthDate)\r\n        \r\n        //页面中做三个循环，依次循环lastMonthDate、thisMonthDate和nextMonthDate。\r\n        // 为啥要搞成数组，不根据月份长度直接循环？\r\n        // 方便做UI，毕竟一般日历肯定都是某些日期会有状态的，比如5号是生日，要加个背景色啥的，可以把状态值也添加进数组\r\n\r\n复制代码html代码(以小程序为例)\r\n分为四个部分：星期（你做成数组循环也可以，这里直接写死）；上月日期，本月完整日期；下月日期。完整点的话，你可以自己做个判断，看上月和下月是否需要展示，比如上个月的最后一天刚好星期六，本月第一天正好星期天，那上月就没有展示必要了。\r\n        <view>\r\n        <ul>\r\n          <li>日</li>\r\n          <li>一</li>\r\n          <li>二</li>\r\n          <li>三</li>\r\n          <li>四</li>\r\n          <li>五</li>\r\n          <li>六</li>\r\n        </ul>\r\n        <ul>\r\n            /*li标签里不加view也行，看自己需要*/\r\n            <li wx:for=\"{{lastMonthDate}}\">\r\n              <view class=\"calendar-view\">{{item.num}}</view>\r\n            </li>\r\n            <li wx:for=\"{{thisMonthDate}}\">\r\n              <view class=\"calendar-view\">{{item.num}}</view>\r\n            </li>\r\n            <li wx:for=\"{{nextMonthDate}}\">\r\n              <view class=\"calendar-view\">{{item.num}}</view>\r\n            </li>\r\n        </ul>\r\n    </view>\r\n复制代码css代码：\r\n样式也很简单，浮动布局可以让li标签每铺满一行后自动换行。\r\n        ul {\r\n            width: 500px;\r\n        }\r\n        li {\r\n            list-style-type: none;\r\n            float: left;\r\n            width: 13.6%;\r\n            height: 20px;\r\n        }\r\n复制代码回头有空会传到GitHub～欢迎关注\r\ngithub.com/suosuojiang…"}
{"title": "当小程序的flex布局遇到button时，justify-content不起作用的原因及解决方案 ... ", "author": "Rolan", "pub_time": "2019-11-12 11:23", "content": "在做小程序的时候，要实现下面的搜索历史界面下面的搜索很明显的想到是用flex布局，然后把justify-content设置为justify-content: flex-start; 代码如下：<!--wxml--><view class=\"flex\"><button class=\"item\">1</button><button class=\"item\">2</button><button class=\"item\">3</button><button class=\"item\">4</button><button class=\"item\">5</button><button class=\"item\">6</button><button class=\"item\">7</button></view><!--wxss-->.flex{  display: flex;  flex-wrap: wrap;   justify-content: flex-start;}.flex .item{  width: 216rpx;  background-color: red;  margin-bottom: 34rpx;}可效果却不尽人意，发现justify-content不起作用，无论怎么设置都是space-around的效果。 经过排查，发现原因是小程序button中的默认样式中的margin-left: auto;margin-right: auto;所引起的。flex 格式化上下文中，在通过 justify-content 和 align-self 进行对齐之前，任何正处于空闲的空间都会分配到该方向的自动 margin 中去。参考自探秘 flex 上下文中神奇的自动 margin原因找到了，具体修改就容易多了，我们可以覆盖button的margin-left和margin-right的默认值，或者在button外面包裹一层view。在遇到这个问题之前，我也没想到过flex和margin之间还能这么用，涨姿势了。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序实现A-Z导航的Slidebar ", "author": "Rolan", "pub_time": "2019-11-12 00:41", "content": "微信小程序实现A-Z导航的Slidebar效果代码slidebar.wxml<view id=\"s-bar\" class=\"slidebar\" bindtouchstart=\"_onTouchStart\" bindtouchmove=\"_onTouchMove\" bindtouchend=\"_onTouchEnd\">  <view wx:for=\"{{data}}\" class=\"slide-item\" id=\"item-{{index}}\" wx:key=\"{{index}}\">    <text class=\"t {{item.selected ? 'slide-item-selected' : ''}}\">{{item.key}}</text>  </view></view><view class=\"dialog\" hidden=\"{{currentKey == '' || closeKeyDialog}}\" animation=\"{{animationData}}\" bindtransitionend=\"_onAnimationend\">  {{currentKey}}</view>slidebar.wxss  /* components/slidebar/slidebar.wxss */.slidebar{  position: absolute;  right: 0rpx;  height: 98vh;  width: 60rpx;  border-radius: 30rpx;}.slide-item{  display: flex;  justify-content: center;  justify-items: center;  height: 3.9vh;  width: 60rpx;  font-size: 24rpx;  color: #222222;  text-align: center;  line-height: 3.9vh;  font-weight: 400;}.slide-item .t{  width: 40rpx;  height: 40rpx;  display: inline-block;}.slide-item-selected{  font-weight: 500;  color: #ffffff;  background: #07C160;  border-radius: 50%;}.dialog{  position: absolute;  top: 50%;  margin-top: -180rpx;  left: 50%;  margin-left: -125rpx;  width: 250rpx;  height: 250rpx;  text-align: center;  font-size: 72rpx;  line-height: 250rpx;  color: #ffffff;  background: grey;  border-radius: 15%;}slidebar.js  // components/slidebar/slidebar.jsComponent({  /**   * 组件的属性列表   */  properties: {    data: {      type: Array,      value: [        { key: \"A\" },        { key: \"B\" },        { key: \"C\" },        { key: \"D\" },        { key: \"E\" },        { key: \"F\" },        { key: \"G\" },        { key: \"H\" },        { key: \"I\" },        { key: \"J\" },        { key: \"L\" },        { key: \"M\" },        { key: \"N\" },        { key: \"O\" },        { key: \"P\" },        { key: \"Q\" },        { key: \"R\" },        { key: \"S\" },        { key: \"T\" },        { key: \"U\" },        { key: \"V\" },        { key: \"W\" },        { key: \"X\" },        { key: \"Y\" },        { key: \"Z\" }      ]    }  },  /**   * 组件的初始数据   */  data: {    selectedIndex: -1,    currentKey: \"\",    closeKeyDialog: false,    animationData: {},  },  lifetimes: {    attached: function () {      // 在组件实例进入页面节点树时执行      this.isTouch = false;    },    ready: function(){      this.data.data.forEach((d,i)=>{        this._wxQueryElementInfo(\"#item-\" + i).then(res => {          d.top = res[0].top;          d.left = res[0].left;          d.height = res[0].height;          d.width = res[0].width;        });      });      this.animation = wx.createAnimation({        duration: 1000,        timingFunction: 'ease',      });    },    detached: function () {      // 在组件实例被从页面节点树移除时执行    },  },  /**   * 组件的方法列表   */  methods: {    _onTouchStart: function(e){      this.isTouch = true;      this.setData({        closeKeyDialog: false,        animationData: this.animation.opacity(1).step().export()      });      this._markSlideItemSeleted(e.touches[0].clientY);    },    _onTouchMove: function(e){      this._markSlideItemSeleted(e.touches[0].clientY);    },    _onTouchEnd: function(e){      this.isTouch = false;      this.setData({        animationData: this.animation.opacity(0).step().export()      })    },    /**     * 通过selector查询元素信息     */    _wxQueryElementInfo: function(selector){      return new Promise((resolve, reject)=>{        var query = wx.createSelectorQuery().in(this);        query.select(selector).boundingClientRect();        query.selectViewport().scrollOffset();        query.exec(function (res) {          resolve(res);        });      });    },    /**     * 根据y的位置标记SlideItem的selected状态     */    _markSlideItemSeleted: function(y){      for(var i=0; i<this.data.data.length; i++){        var d = this.data.data[i];        if (y >= d.top && y <= d.top + d.height) {          if(this.data.selectedIndex == i){            return;          }          this._setSlideItemSelectStatus(d,i);          console.log(\"当前选中=>\" + d.key);          this.triggerEvent(\"selected\",d);          return;        }      }    },    _setSlideItemSelectStatus(d,i){      d.selected = true;      if (this.data.selectedIndex != -1) {        this.data.data[this.data.selectedIndex].selected = false;      }      this.setData({        data: this.data.data,        currentKey: d.key,        selectedIndex: i      });    },    _onAnimationend: function(e){      if (this.isTouch){        return;      }      console.log(\"动画结束\")      this.setData({        closeKeyDialog: true      });    },    /**     * 通过key更新slidebar选择的item     */    updateItemSelectedByKey: function(key){      this.data.data.forEach((d,i)=>{        if(d.key == key){          this._setSlideItemSelectStatus(d,i);          return;        }      });    },    /**     * 通过index更新slidebar选择的item     */    updateItemSelectedByIndex: function(index){      if(index > 0 && index < this.data.data.length){        this._setSlideItemSelectStatus(this.data.data[index], index);      }    }  }})"}
{"title": "小程序-腾讯地图SDK-获取当前地址 ", "author": "Rolan", "pub_time": "2019-12-3 00:41", "content": "如何获取用户当前地址，这个就要先用到小程序的定位功能:定位官方文档第一步获取当前定位在js当中写运行项目之后会有个这样的弹窗：这是因为开发者需要说明获取用户地理位置的用途。 解决方法： 在app.json中增加permission属性。这样就可以获取到用户的地理坐标了。第二步讲当前定位转换程地址信息这个功能需要用到腾讯地图SDK：官方文档 官方文档上使用SDK的步骤写的挺详细的，还带上了各种链接：第4步的安全域名设置在你自己的小程序管理后台里设置 以上4步都完成后，将下载好的SDK文件放到项目里。 在页面js里引入SDK：我们需要用到的是SKD里面的reverseGeocoder()方法，所以我们在获取到用户当前坐标后调用这个方法：这样就将地址坐标转换成了地址，在页面上简单展示出来：完整代码 最后贴上我的js完整代码，写的有点小啰嗦了，如果有什么不太懂的地方欢迎加我qq一起讨论下：546529770，谢谢~~js/**引入SDK核心类 */var qqSDK = require('../../apis/qqmap-wx-jssdk.min.js')Page({  /**   * 页面的初始数据   */  data: {    latitude: '',    longitude: '',    positionData: ''  },  /**   * 生命周期函数--监听页面加载   */  onLoad: function(options) {    var _this = this    /**实例化SDK核心类 */    var qqMap = new qqSDK({      key: '3B4BZ-QHNK3-HLX34-YKUQA-YDHCV-CHFFB' //必填    });    /**获取当前坐标 */    wx.getLocation({      success: function(res) {        var latitude = res.latitude        var longitude = res.longitude        qqMap.reverseGeocoder({          success: function(res) {            var address = res.result.address;            _this.setData({              latitude: latitude,              longitude: longitude,              positionData: address            });          }        })      }    })  }})"}
{"title": "小程序云开发模糊查询，实现数据库多字段的模糊搜索 ", "author": "Rolan", "pub_time": "2019-12-3 00:53", "content": "最近做小程序云开发时，用到了一个数据库的模糊搜索功能，并且是要求多字段的模糊搜索。网上也有一大堆资源，但是都是单个字段的搜索。如下图上图只可以实现time字段的模糊搜索。但是我们如果相对数据表里的多个字段做模糊查询呢？该怎么办呢。多字段模糊搜索一，如我们的数据表里有以下数据，我们想同时模糊查询name和address字段如我们搜索“周杰”可以看到我们查询到下面两条数据。二，如我们搜索“编程”，可以搜索到下面数据可以看到我们搜索到的两条数据，一个是name字段为 编程小石头， 一个是address字段里包含“编程“ 字样。下面把代码贴给大家    let key = \"编程小石头\";    console.log(\"查询的内容\", key)    const db = wx.cloud.database();    const _ = db.command    db.collection('qcl').where(_.or([{        name: db.RegExp({          regexp: '.*' + key,          options: 'i',        })      },      {        address: db.RegExp({          regexp: '.*' + key,          options: 'i',        })      }    ])).get({      success: res => {        console.log(res)      },      fail: err => {        console.log(err)      }    })key就是我们要搜索的关键字。主要是用到了数据库查询的where,or,get方法。 代码都给大家贴出来来，如果对云开发和云数据库还不是很了解的同学可以去翻看下我以前写的文章。"}
{"title": "小程序包大小优化(uni-app) ", "author": "Rolan", "pub_time": "2019-11-28 00:24", "content": "在开发微信小程序的过程中，随着业务逻辑日渐庞大之后，突显了一些问题。首先我们发现在 dev mode 时，本地包大小已经达到了 4m+，这种情况下，已经无法在 dev mode 使用真机调试了。其次此时，小程序 build 后也有 1.8M 左右。而且后续还有相当多的业务需求需要开发，包大小肯定会更大。这时候就想要优化小程序包大小。下面分享一下我的定位过程和解决思路。尽管我们使用 uni-app 开发，但思路是通用的，希望能给大家一些帮助吧。如何减小包大小代码分析首先分析包大在哪儿了。打开本地代码目录查看文件大小。可以发现 common/vendor.js 和 page,components 中 js 占了大部分。在 build 编译模式下，代码压缩已经启用了，需要思考别的优化方式。这时候可以使用\twebpack-bundle-analyzer 插件\t。它可以帮助分析 vendor.js 中都有哪些 js 模块，哪些模块比较大，以便我们进一步优化代码通过这个插件，发现了下面两个问题。问题一: uni-app 自定义组件模式编译 tree shaking 无效如果不是使用 uni-app 开发可以跳过这一段通过代码分析发现有些模块应该被 tree shaking 但却被打包进来了。基本确定是 tree shaking 没有生效。同样是 webpack4 + babel7。在不使用 uni-app，直接使用 vue-cli create 项目的前提下，tree shaking 是没有问题的。而使用 uni-app 去新建项目，tree shaking 却无效。排查 babel 配置时发现是由于 uni-app 在创建项目的时候，设置了 modules: 'commonjs'导致。修改后，demo 的 tree shaking ok。但是回到项目里一编译，又出错了。继续定位发现是\tuni-app 自定义组件模式编译问题 。目前uni-app\t已经修复 了我提的bug，虽然还未正式发布。当然你不使用 uni-app 自定义组件模式编译也可以解决，uni-app 还支持\ttemplate模板模式 ，但是会有一些开发差异和性能差距，有兴趣可以看下\t这篇文章问题二：部分库不支持 tree shaking有些库(比如 lodash)本身并没有使用 import/export，所以 webpack 并不能对它们 tree shaking。这些库我们可以分情况优化。首先可以找下网上是否有库对应的 esm 版本可以替代，如 lodash-es。其次可以从代码分析中看出，如果库的每个模块都在不同文件中，入口文件只是一个统一入口，那么我们就可以通过修改写法按需加载，如import add from \"lodash/add\";\r\nimport Button from 'ant-design-vue/lib/button';\r\n复制代码我们也可以使用\tbabel-plugin-import 插件针对那些库统一实现按需加载，它的本质是在编译时统一按配置修改加载路径，不需要自己手动去修改代码。最后如果都不行，那要么接受，要么自己重写为社区做贡献~规范模块开发为了免除无法 tree shaking 的烦恼，我们在开发 npm 模块的时候也需要遵循一定的规范，从而减少模块打包后的大小。同时支持 commonjs 和 es module我们的模块需要同时支持 commonjs 和 es module。这样才能既满足 commonjs 开发的用户，又支持 tree shaking。如何实现呢？如果你的代码是 typescript,以@sentry/browser 为例，可以在编译时编译 cjs 和 esm 两种规范代码，如下// package.json\r\n\"build\": \"run-s build:dist build:esm build:bundle\",\r\n\"build:bundle\": \"rollup --config\",\r\n\"build:dist\": \"tsc -p tsconfig.build.json\",\r\n\"build:esm\": \"tsc -p tsconfig.esm.json\",\r\n复制代码然后在 package.json 中指定两个入口以及无副作用标识\"main\": \"dist/index.js\",\r\n  \"module\": \"esm/index.js\",\r\n  \"sideEffects\": false,\r\n复制代码这样当 webpack 解析模块(\t解析规则 )，就会按需优先解析 esm 目录。并且当识别到无副作用时进行 tree shaking。如果你的代码本身就是 es6，你也可以这样\"module\": \"src/index.js\",\r\n复制代码第三方自定义组件如果使用了第三方\t微信自定义组件 ，由于引用是在 json 文件，所以 webpack 在编译时并不能通过 entry 分析到相关文件，因此不会对其进行编译、压缩等。这时候就需要我们自己处理。而且由于 webpack 不处理，tree shaking 自然也无法支持，因此建议\t尽量避免 这种方式引用组件。分包小程序分包 也是一种常规的优化方案。通过分析后，可以将一些较大的页面划分为子包。如果有单页依赖第三方自定义组件，而且第三方组件还挺大，也可以考虑将该页面划分为子包。也因此\t尽量避免将第三方自定义组件放在 globalStyle ，不然没法将它放到子包去。大图不要打包小程序中的大图，尽量避免打包进来，应该放到 CDN 通过 url 加载。我们的做法是在开发时加载本地图片，在 CI/CD 环节自动化发布图片，并改写地址。如何解决真机调试问题首先还是查看编译后的文件，发现\tcommon/vendor.js 巨大，足有 1.5M。其次\tpages 和\tcomponents 也有 1.4M，而这其中占了 js 的大小又占了绝大部分。为什么 js 文件这么大呢？主要是因为在 dev mode 默认并没有压缩，当然也没有 tree shaking。我的选择是\t修改编译配置，在 dev mode 压缩 js 代码 。本地代码减少到了 2M。预览大小则是减少到了 1.4M。参考配置如下：// vue.config.js\r\n    configureWebpack: () => {\r\n        if (isDev && isMp) {\r\n            return {\r\n                optimization: {\r\n                    minimize: true,\r\n                },\r\n            }\r\n        }\r\n    }\r\n复制代码这看上去并不是个好方案，但确实简单有效。也考虑过分包，但分包并不能解决 common/vendor.js 巨大的问题，预览时包还是很大。如果有其它好的办法也欢迎留言~"}
{"title": "记《高校考勤系统》小程序（2） ", "author": "Rolan", "pub_time": "2019-11-29 00:12", "content": "这是其他几篇的地址：记《高校考勤系统》小程序（1）前面讲了用户注册和首页天气功能，下面讲讲课程表页的实现.五.课程表页这里参考了简书上面 轩辕夜空 位作者的案例,以及其参考 极乐叔 的课程表的思路.同样制作课程表需要用到云开发来存储数据，以及结合云函数对数据的修改，后面会讲到为什么要用到云函数.先来看看完成后的效果图1.先搭建整体结构头部和左侧因为样式是一样的，可以将数据写入data中，再通过for循环渲染出来，这里就直接展示了.（偷个懒:blush::blush:）<!-- 星期 -->\r\n<view class=\"top\">  \r\n    <view class=\"top-text\">\r\n        <text>节\\日</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>一</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>二</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>三</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>四</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>五</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>六</text>\r\n    </view>\r\n    <view class=\"top-text\">\r\n        <text>日</text>\r\n    </view>\r\n</view>\r\n<!-- 课程 -->\r\n<view class=\"cont\">\r\n    <view class=\"cont-left\">\r\n        <view class=\"left\"> 1 </view>\r\n        <view class=\"left\"> 2 </view>\r\n        <view class=\"left\"> 3 </view>\r\n        <view class=\"left\"> 4 </view>\r\n        <view class=\"left\"> 5 </view>\r\n        <view class=\"left\"> 6 </view>\r\n        <view class=\"left\"> 7 </view>\r\n        <view class=\"left\"> 8 </view>\r\n    </view>\r\n    <view class=\"cont-right\">\r\n    </view>\r\n</view>\r\n<view class=\"bottom\">\r\n    ————<text>读万卷书 行万里路</text>————\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n.top {\r\n    padding: 16rpx 0;\r\n    border-top: 1px solid #e9e9e9;\r\n    border-bottom: 1px dashed #d3d3d3;\r\n    display: flex;\r\n    justify-content: flex-start;\r\n}\r\n.top-text {\r\n    width: 12.5%;\r\n    text-align: center;\r\n    font-size: 32rpx;\r\n    font-weight: 600;\r\n    align-items: center;\r\n}\r\n.top .top-text {\r\n    border-left: 1px dashed #d3d3d3;\r\n}\r\n.top .top-text:nth-child(1) {\r\n    font-size: 24rpx;\r\n    border-left: none;\r\n    line-height: 46rpx;\r\n}\r\n.cont {\r\n    display: flex;\r\n    justify-content: start;\r\n}\r\n.cont-left {\r\n    display: inline-block;\r\n}\r\n.left {\r\n    width: 90rpx;\r\n    height: 120rpx;\r\n    justify-content: center;\r\n    display: flex;\r\n    align-items: center;\r\n    border-bottom: 1px dashed #d3d3d3;\r\n    box-sizing: border-box;\r\n    color: #666;\r\n    font-size: 28rpx;\r\n    font-weight: 600;\r\n}\r\n.cont-right {\r\n    width: calc(100% - 90rpx);\r\n}\r\n.bottom {\r\n    width: 100%;\r\n    text-align: center;\r\n    position: absolute;\r\n    bottom: 20rpx;\r\n    font-size: 24rpx;\r\n    color: #ddd;\r\n    display: inline-block;\r\n}\r\n.bottom text {\r\n    margin-left: 20rpx;\r\n    margin-right: 20rpx;\r\n    color: #9b9b9b;\r\n}\r\n复制代码2.结合云开发编写课程表.这里需要考虑到云开发中单次获取数据上限是20条，所以我将课程表数据分为两部分（上午和下午），当然你可以直接使用云函数来提高获取数据的上限，在后面会有介绍，这里就先不做过多的解释了，上代码.单个数据结构{\r\n    //\"_id\": \"296065c95da529b2055b57301b5afa75\",  云开发导入数据会直接生成_id,这里不用自己编写\r\n    \"data_name\": \"Java高级开发技术(JavaEE)\",  //课程名\r\n    \"address\": \"@康庄行知楼301\",              //地点\r\n    \"weekNum\": \"10-15周\",                     //周数\r\n    \"pitchNum\": \"3-4\",                        //节数\r\n    \"teacher\": \"赵老师\",                      //任课老师\r\n    \"_openid\": \"oQnNa5NJfKqSZntKFLGZWnZuXNbo\"  //修改者的openid,本来是想做判断，后面使用了云函数，发现可有可无\r\n}\r\n复制代码下面是从云开发数据库中获取我们编写好的课程表数据,如果对操作不熟悉可以查看 官方文档. 1.打开云开发控制台. 2.创建两个集合对应上午下午课程表. 3.导入我们已经编写好的数据 (一个星期早上和下午的课程分别为14节，所以导入数据时需要注意，如果想要当前课程没有信息，也是需要导入空的字段数据来占一格) . 4.打开权限管理. 5.选中第一个.其中最后两个步骤一定不能忘记！点击查看js代码data: {\r\n    colorArr: [\"rgb(229,188,76, 0.8)\", \"rgb(104,172,246, 0.8)\", \"rgb(183,135,242, 0.8)\", \"rgb(149,226,48, 0.8)\", \"#ff7070\",\r\n        \"#e54d42\", \"#0081ff\", \"#7DC67D\", \"#E17572\", \"#C35CFF\", \"#33BCBA\", \"#FF8533\", \"#6E6E6E\", \"#ebd4ef\",\r\n        \"#428BCA\", \"#39b54a\", \"#FF674F\", \"#e03997\", \"#00CED1\", \"#9F79EE\", \"#FFC125\", \"#32CD32\", \"#00BFFF\", \"#8799a3\",\"#FF69B4\"\r\n    ],\r\n    // 存储随机颜色\r\n    randomColorArr: [],\r\n    randomColorArr2: [],\r\n    i: 25,\r\n    random: '',\r\n    random2: '',\r\n},\r\nonLoad: function(options) {\r\n    this.data.randomColorArr = [] // 重置颜色数组1为空\r\n    this.data.randomColorArr2 = [] // 重置颜色数组2为空\r\n    const db = wx.cloud.database({\r\n        env: '*****'  //你的云开发环境名\r\n    })\r\n\r\n    //获取课程表上午数据\r\n    db.collection('数据集合中你的表名').get().then((res) => {\r\n        this.kechengbiao = res.data\r\n        for (let j = 0; j <= 13; j++) { //for循环判断课名和地名为空则不加颜色\r\n            if (this.kechengbiao[j].data_name == '' && this.kechengbiao[j].address == '') {\r\n                this.random = 'none'\r\n                this.data.randomColorArr.push(this.random)\r\n            } else {\r\n                this.random = this.data.colorArr[Math.floor(Math.random() * this.data.i)] //随机颜色\r\n                this.data.randomColorArr.push(this.random)\r\n            }\r\n        }\r\n        this.setData({\r\n            loding: true,\r\n            kechengbiao: this.kechengbiao,\r\n            randomColorArr: this.data.randomColorArr\r\n        })\r\n    })\r\n    //获取课程表下午\r\n    db.collection('数据集合中你的表名').get().then((res) => {\r\n        this.kechengbiao2 = res.data\r\n        for (let j = 0; j <= 13; j++) { //for循环判断课名和地名为空则不加颜色\r\n            if (this.kechengbiao2[j].data_name == '' && this.kechengbiao2[j].address == '') {\r\n                this.random2 = 'none'\r\n                this.data.randomColorArr2.push(this.random2)\r\n            } else {\r\n                this.random2 = this.data.colorArr[Math.floor(Math.random() * this.data.i)] //随机颜色\r\n                this.data.randomColorArr2.push(this.random2)\r\n            }\r\n        }\r\n        this.setData({\r\n            kechengbiao2: this.kechengbiao2,\r\n            randomColorArr2: this.data.randomColorArr2\r\n        })\r\n    })\r\n},\r\n复制代码<view class=\"cont-right\">\r\n    <view>\r\n        <view class='appointent-date'>  //上午\r\n            <view class=\"appointent-date-div\" bindtap=\"select_date\" wx:for=\"{{kechengbiao}}\" wx:key=\"{{index}}\" data-key='{{index}}' style=\"background-color:{{randomColorArr[index]}}\">\r\n                <view class=\"flex-item\" >\r\n                    <text class='data_name'>{{item.data_name}}</text>\r\n                    <text class='address'>{{item.address}}</text>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class='appointent-date'>  //下午\r\n            <view class=\"appointent-date-div\" bindtap=\"select_date2\" wx:for=\"{{kechengbiao2}}\" wx:key=\"{{index}}\" data-key='{{index}}' style=\"background-color:{{randomColorArr2[index]}}\">\r\n                <view class=\"flex-item\">\r\n                    <text class='data_name'>{{item.data_name}}</text>\r\n                    <text class='address'>{{item.address}}</text>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码点击查看wxss代码.appointent-date {\r\n    display: flex;\r\n    justify-content: space-around;\r\n    flex-wrap: wrap;\r\n}\r\n.appointent-date-div {\r\n    height: 236rpx;\r\n    border-radius: 10rpx;\r\n    margin-bottom: 6rpx;\r\n    color: white;\r\n}\r\n.flex-item {\r\n    display: flex;\r\n    justify-content: flex-start;\r\n    flex-direction: column;\r\n    width: 76rpx;\r\n    height: 212rpx;\r\n    font-size: 24rpx;\r\n    padding: 6rpx;\r\n    border: 1rpx solid transparent;\r\n    text-align: left;\r\n    border-radius: 10rpx;\r\n    cursor: pointer;\r\n    overflow: hidden;\r\n}\r\n.data_name {\r\n    display: inline-block;\r\n}\r\n.address {\r\n    display: inline-block;\r\n}\r\n复制代码3.对课程实现增删改查首先来做最简单的 查 吧，我们需要在for循环中加入 data-='{{index}}' ，如上代码所示:point_up_2:我加了data-key='{{index}}'，其中key可以自定义，目的是为了在点击课程时，可以获取相循环中对应的下标，这样我就可以在数据库中搜索到当前点击的数据并渲染出来.查//点击课程内容弹出详细框\r\nselect_date: function(e) {\r\n  this.id = e.currentTarget.dataset.key //获取当前点击课程的下标\r\n  const db = wx.cloud.database({\r\n    env: '****'\r\n  })\r\n  db.collection('***').get().then(res => {\r\n    console.log(res.data[this.id])   //获取点击时课程表数据\r\n  })\r\n},\r\n复制代码获取到数据后我们可以根据自己的需求渲染在页面上，这里我结合了vant的tab组件，左上角为返回，右上角为删除课程表信息，下面就讲 删 除课程信息.这里的删除不是说真的将数据从我们的数据库中删除，而是将数据赋值为“”也就是空值，这样就做到了删除的功能，在此结合 云函数 来实现，因为云开发中的操作权限无法满足我们对数据操作的要求.删首先我们在云函数中创建一个新的 云函数 ，修改index.js文件这里会有一个问题也就是为什么我们要使用云函数，而不直接用云开发对数据进行处理，是因为云开发中的操作权限只能对自己提交到数据库中的数据进行修改，如果是别人那么就无法修改.正常情况下，管理员肯定不止一位，所以对数据操作不能只限定一个人.//修改课程表\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n    env: '***',//你的开发环境\r\n    traceUser: true\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => { // 云函数入口函数\r\n    try {\r\n        return await db.collection('***').doc(event.id).update({  //需要修改的数据库\r\n            data: {\r\n                data_name: event.data_name,\r\n                address: event.address,\r\n                weekNum: event.weekNum,\r\n                pitchNum: event.pitchNum,\r\n                teacher: event.teacher\r\n          },\r\n        })\r\n    } catch (e) {\r\n        console.error(e)\r\n    }\r\n    return {\r\n        event,\r\n        openid: wxContext.OPENID,\r\n        appid: wxContext.APPID,\r\n        unionid: wxContext.UNIONID,\r\n    }\r\n}\r\n复制代码然后在js文件中编写对应的代码tapDialogButton(e) { //从课表删除课程\r\n    wx.cloud.callFunction({\r\n        name: '***',// 你的云函数名称\r\n        data: {\r\n          id: this._id,  //将数据进行空值赋值\r\n          data_name: \"\",\r\n          address: \"\",\r\n          weekNum: \"\",\r\n          pitchNum: \"\",\r\n          teacher: \"\"\r\n        },\r\n        success: res => {\r\n          // 关闭当前点击课程详情\r\n        }\r\n    })\r\n},\r\n复制代码改，增做完了删其实对改和增的实现应该也变得相对简单，这里也是需要用到云函数，道理和上面讲的一致.在获取当前点击的数据时先将此条数据存储在data中，需要修改时，可以将数据赋值给input的value,在通过云函数来修改数据库中对应的数据.增也是同样的道理.这里就拿改为例.wxml<!-- 编辑页 -->\r\n<view class=\"edit\" hidden=\"{{ editShow }}\">\r\n    <van-nav-bar title=\"编辑课程\" right-text=\"完成\" left-arrow bind:click-left=\"editLeft\" bind:click-right=\"editRight\" />\r\n    <view class=\"label className\">\r\n        <text>课名</text>\r\n        <input  value=\"{{ nowClass.data_name }}\" bindinput=\"bindKeyInput1\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>教室</text>\r\n        <input  value=\"{{ nowClass.address }}\" bindinput=\"bindKeyInput2\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>周数</text>\r\n        <input  value=\"{{ nowClass.weekNum }}\" bindinput=\"bindKeyInput3\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>节数</text>\r\n        <input  value=\"{{ nowClass.pitchNum }}\" bindinput=\"bindKeyInput4\"></input>\r\n    </view>\r\n    <view class=\"label\">\r\n        <text>老师</text>\r\n        <input  value=\"{{ nowClass.teacher }}\" bindinput=\"bindKeyInput5\"></input>\r\n    </view>\r\n</view>\r\n复制代码新建修改课程表数据的云函数//修改课程表\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n    env: '***',//你的开发环境\r\n    traceUser: true\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => { // 云函数入口函数\r\n    try {\r\n        return await db.collection('***').doc(event.id).update({  //你要操作的数据库\r\n            data: {\r\n                data_name: event.data_name,\r\n                address: event.address,\r\n                weekNum: event.weekNum,\r\n                pitchNum: event.pitchNum,\r\n                teacher: event.teacher\r\n            },\r\n        })\r\n    } catch (e) {\r\n        console.error(e)\r\n    }\r\n    return {\r\n        event,\r\n        openid: wxContext.OPENID,\r\n        appid: wxContext.APPID,\r\n        unionid: wxContext.UNIONID,\r\n    }\r\n}\r\n复制代码js//  1.首先获取输入框的值，存在data中\r\nbindKeyInput1(e) { //课名\r\n    this.editClassName = e.detail.value\r\n},\r\nbindKeyInput2(e) { //教室\r\n    this.editAddress = e.detail.value\r\n},\r\nbindKeyInput3(e) { //周数\r\n    this.editWeekNum = e.detail.value\r\n},\r\nbindKeyInput4(e) { //节数\r\n    this.editPitchNum = e.detail.value\r\n},\r\nbindKeyInput5(e) { //老师\r\n    this.editTeacher = e.detail.value\r\n},\r\neditRight() { //  2.编辑完成，点击提交按钮时将输入框的值赋值给对应的字段名\r\n  wx.cloud.callFunction({\r\n    name: '***',// 修改课程表数据的云函数名称\r\n    data: {\r\n      id: this._id,\r\n      data_name: this.editClassName,\r\n      address: this.editAddress,\r\n      weekNum: this.editWeekNum,\r\n      pitchNum: this.editPitchNum,\r\n      teacher: this.editTeacher\r\n    },\r\n    success: res => {\r\n    },\r\n    fail: console.error\r\n  })\r\n\r\n},\r\n复制代码到这里课程表功能就做完了，如果有什么不懂得地方欢迎留言，或者写的不好的地方，请大家指出一起探讨，之后会继续分享后面的内容。大家也可以提前扫码查看小程序，欢迎指出不足，谢谢"}
{"title": "最近很火的 倒放挑战 - ReverseVoice (微信小程序版 前后端源码) Ts Node Taro ... ... ", "author": "Rolan", "pub_time": "2019-11-29 00:21", "content": "项目地址: https://github.com/smackgg/reversevoice整个项目其实很简单，从本人在抖音和 B 站看到火起来到最终小程序上线也就几天的下班时间就搞定了，11月16日上线至今用户量还是蛮多的(主要当时做的快此类 app 比较少)，现在已经出现了大量的更简约更好的倒放挑战 app，本项目开源仅供大家学习~拥抱 TypeScript ~顺便小声吐槽一下 Taro 对 Ts 的支持还是不够啊，希望大家多去给 Taro 提 dts 的 PR ~体验小程序二维码挑战分享海报 (这个海报暂时有问题，修复代码因为资质问题还没有提交审核)功能介绍/实现原理功能及实现原理简述小程序端用户录音并保存本地录音后将录音文件上传至后端进行倒放处理，并返回处理后的音频 url小程序端下载 url 文件，提示用户反转成功，将数据做本地 map用户点击分享，生成分享链接，并将该分享正放、倒放视频均传至后端保存至七牛云同时新建分享 room 保存用户信息，返回 roomId用户分享（海报分享 canvas 动态生成分享码海报）其它用户参加挑战，存储原理同 4，只是增加将挑战者信息了存入 room 的逻辑音频倒放使用 ffmpeg 进行音频倒放，核心代码：// 详见 ./server/src/controllers/file.ts => function reverseVoice\r\nimport ffmpegPath from '@ffmpeg-installer/ffmpeg'\r\nimport ffprobePath from '@ffprobe-installer/ffprobe'\r\nimport ffmpeg from 'fluent-ffmpeg'\r\nffmpeg.setFfprobePath(ffprobePath.path)\r\nffmpeg.setFfmpegPath(ffmpegPath.path)\r\n\r\nffmpeg(filepath)\r\n    .format('mp4')\r\n    // 反转\r\n    .outputOptions([\r\n      '-vf reverse',\r\n      '-af areverse',\r\n      '-preset',\r\n      'superfast',\r\n      '-y',\r\n    ])\r\n    .on('progress', (progress) => {\r\n      // send upload progress\r\n      console.log('upload-file-progress', progress.percent)\r\n    })\r\n    .on('error', (err) => {\r\n      console.log(`Ffmpeg has been killed${err.message}`)\r\n    })\r\n    .toFormat('mp3')\r\n    // 保存\r\n    .save(publicPath + saveFilePath)\r\n    .on('end', () => {\r\n      // 获取音频信息（时长等）\r\n      ffmpeg.ffprobe(publicPath + saveFilePath, (err, metadata) => {\r\n        console.log(metadata.format.duration)\r\n      })\r\n    })小程序录音小程序录音使用官方 api，详细逻辑见 ./wechatapp/pages/index/index.tsx录音海报生成利用 canvas 动态合成分享海报 /wechatapp/pages/sharePoster需要动态请求页面小程序码，涉及微信AccessToken鉴权等，详见 /server/src/controllers/wechat.ts, 下面贴出部分核心代码// 画图\r\nconst draw = async () => {\r\n  // 绘制之前 loading\r\n  Taro.showLoading({\r\n    title: '海报生成中...',\r\n    mask: true,\r\n  })\r\n  // 获取图片信息\r\n  const [productImgInfo, qrcodeImgInfo] = await Promise.all([\r\n    this.getImageInfo(sharePoster), // 获取主图\r\n    this.getQrImgInfo(), // 获取二维码图片\r\n  ])\r\n\r\n  // product image 宽高\r\n  const pW = CANVAS_WIDTH\r\n  const pH = (pW / productImgInfo.width) * productImgInfo.height\r\n\r\n  // canvas 高度\r\n  let canvasHeight = pH\r\n\r\n  const ctx = Taro.createCanvasContext('canvas', null)\r\n\r\n  ctx.fillStyle = '#fff'\r\n  ctx.fillRect(0, 0, CANVAS_WIDTH, canvasHeight)\r\n\r\n  // 绘制背景图片\r\n  ctx.drawImage(sharePoster, 0, 0, pW, pH)\r\n\r\n  // 绘制二维码 （因为有角度，需要旋转画布，再旋转回来）\r\n  ctx.rotate(-Math.PI / 32)\r\n  ctx.translate(-25 * ratio, 10 * ratio)\r\n  ctx.drawImage(qrcodeImgInfo.path, QR_LEFT, QR_TOP, QR_WIDTH, QR_WIDTH)\r\n  ctx.rotate(Math.PI / 32)\r\n  this.setState({\r\n    canvasStyle: {\r\n      ...this.state.canvasStyle,\r\n      height: canvasHeight,\r\n    },\r\n  })\r\n  ctx.stroke()\r\n  setTimeout(() => {\r\n    Taro.hideLoading()\r\n    ctx.draw()\r\n  }, 500)\r\n}微信分享 HOC 函数 ./wechatapp/components/@withShare// 微信小程序每个页面几乎都需要配置分享的参数，并且需要动态更改分享参数\r\n// 所以抽离 HOC 组件，方便页面使用\r\nimport { ComponentClass } from 'react'\r\n\r\nimport Taro from '@tarojs/taro'\r\nimport { connect } from '@tarojs/redux';\r\nimport defaultShareImg from '@/assets/images/share.png'\r\n\r\ntype Options = {\r\n  title?: string\r\n  imageUrl?: string\r\n  path?: string\r\n}\r\n\r\nconst defalutOptions: Options = {\r\n  title: '你能听懂我说啥么？最近很火的反转录音来啦~',\r\n  imageUrl: defaultShareImg,\r\n  path: 'pages/index/index',\r\n}\r\n\r\nfunction withShare() {\r\n  return function demoComponent(Component: ComponentClass) {\r\n    @connect(({ user }) => ({\r\n      userInfo: user.userInfo\r\n    }))\r\n    class WithShare extends Component {\r\n      $shareOptions?: Options\r\n      async componentWillMount() {\r\n        Taro.showShareMenu({\r\n          withShareTicket: true,\r\n        })\r\n\r\n        if (super.componentWillMount) {\r\n          super.componentWillMount()\r\n        }\r\n      }\r\n\r\n      // 点击分享的那一刻会进行调用\r\n      onShareAppMessage() {\r\n        // const sharePath = `${path}&shareFromUser=${userInfo.shareId}`\r\n        let options = defalutOptions\r\n        if (this.$shareOptions) {\r\n          options = {\r\n            ...defalutOptions,\r\n            ...this.$shareOptions,\r\n          }\r\n        }\r\n        return options\r\n      }\r\n\r\n      render() {\r\n        return super.render()\r\n      }\r\n    }\r\n\r\n    return WithShare\r\n  }\r\n}\r\n\r\nexport default withShare使用@withShare()\r\nclass Room extends Component {\r\n  /**\r\n * 指定config的类型声明为: Taro.Config\r\n *\r\n * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型\r\n * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string\r\n * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型\r\n */\r\n  config: Config = {\r\n    navigationBarTitleText: '首页',\r\n  }\r\n\r\n  $shareOptions = {\r\n    title: '倒放挑战！你能听懂我倒立洗头~',\r\n    path: 'pages/index/index',\r\n    imageUrl: '',\r\n  }\r\n\r\n  /**\r\n    ....\r\n  */\r\n}\r\n微信用户登录流程微信官方文档登录流程具体实现可以去看源码项目运行 - 后端准备需要提前安装:Install Node.jsInstall MongoDB开始克隆项目并进入后端目录cd server安装依赖npm install设置 mongoDB# create the db directory\r\nsudo mkdir -p /data/db\r\n# give the db correct read/write permissions\r\nsudo chmod 777 /data/db\r\n\r\n# starting from macOS 10.15 even the admin cannot create directory at root\r\n# so lets create the db diretory under the home directory.\r\nmkdir -p ~/data/db\r\n# user account has automatically read and write permissions for ~/data/db.启动 mongoDB (Start your mongoDB server (you'll probably want another command prompt)mongod\r\n\r\n# on macOS 10.15 or above the db directory is under home directory\r\nmongod --dbpath ~/data/db打包并运行项目npm run build\r\nnpm start项目运行 - 小程序端准备需要提前安装:Install 微信开发者工具开始克隆项目并进入小程序目录cd wechatapp安装依赖npm install新建 .env 文件在 wechatapp/src/utils 目录下克隆 env.example.ts 文件至同目录命名为 .env.ts 文件\r\n此文件两个参数分别代表本地开发和线上部署的请求地址运行项目npm run dev:weapp // development mode\r\n或者 npm run build:weapp // production mode微信开发者工具选择导入项目，并选择 wechatapp/dist 目录\r\n若本地开发，需要在开发者工具中设置开启“不校验合法域名“LicenseMIT"}
{"title": "小程序 - 可搜索的地址选择 ", "author": "Rolan", "pub_time": "2019-11-20 00:41", "content": "最终实现效果：新建index文件夹index.wxml<!--pages/index/index.wxml--><view class='container'>  <view bindtap='onChangeAddress'>    <input value=\"{{address}}\" name=\"address\" placeholder=\"选择地点\">  </view></view>index.js// pages/index/index.jsPage({  data: {    address: ''  },  onChangeAddress() {    var _page = this;    wx.chooseLocation({      success: (res) => {        _page.setData({          address: res.name        });      },      fail: (err) => {        console.log(err);      }    });  }})新建map文件夹map.wxml<!--pages/map/map.wxml--><view class=\"container\">  <map    id=\"myMap\"    style=\"width: 100%; height: 100%;\"    latitude=\"{{latitude}}\"    longitude=\"{{longitude}}\"    markers=\"{{markers}}\"    show-location  ></map></view>map.js// pages/map/map.jsPage({  data: {    latitude: 31.22786,    longitude: 121.46658,    markers: [{      id: 1,      latitude: 31.22786,      longitude: 121.46658,      name: '上海招商局广场'    }]  },  onReady(e) {    this.mapCtx = wx.createMapContext('myMap')  }})"}
{"title": "在腾讯Q3财报中站C位的品牌小程序，BAT态度大不同！ ", "author": "Rolan", "pub_time": "2019-11-22 00:12", "content": "昨天，腾讯2019年Q3财报如“约”而至。其中，小程序数据格外亮眼，不仅日活跃用户超过3亿，商业化也表现强劲，中长尾小程序日均商业交易笔数同比增加超过一倍。值得注意的是，这组数据中，“品牌”二字尤其“夺目”，财报显示：品牌自营类小程序数量同比增长1倍以上；8%的品牌自营类小程序交易额同比增长100倍以上、56%的品牌自营类小程序交易额同比增长50%以上，在头部领跑下，中腰部正在崛起；超过1亿人次访问品牌自营类小程序。这一定程度上说明了越来越多的品牌选择了微信小程序作为重要阵地。因此，要让用户在众多品牌中一眼就能发现自己，品牌曝光是首要环节。对于企业而言，如果没做好品牌曝光，自家品牌就会淹没在“芸芸众生”之中，而这一局面，在搜索场景下尤为突出。比如，用户输入一个关键词，结果“数不胜数”，无论用户看多少眼，也不一定会注意到。于是，BAT三巨头接踵而至地基于自家搜索推出一个能力：品牌主页。直白点说，“品牌主页”就是：在搜索结果页中，将企业各类信息与服务放在一起整体展示，比如企业认证信息、小程序、服务等等，入口更直接。微信“品牌主页”叫作品牌官方区，于去年4月基于搜一搜推出，在公众号后台便可开通；相比之下，支付宝与百度则慢了好几拍，都是最近才推出小程序能力，前者叫品牌直达，后者称百度品牌名片。虽然叫法不同（以下统称时，称为“品牌主页”），但其目的是一致的，都是为了帮助企业更好地建立品牌效应、将服务充分触达用户，从而提升收益。但BAT三平台的属性不同，“品牌主页”的能力开放程度、玩法等也有所差异，并非都能满足所有企业的需求，企业们在选择上也就“不知所云”。对此，晓程序观察（yinghoo-tech）就来一次测评与PK，帮助企业们选择适合自己的“品牌主页”。1流量曝光：微信品牌官方区完胜？既然“品牌主页”是用来帮助企业更好地触达用户，对于企业与品牌而言，最关心的还是流量，比如：用户输入哪些关键词，才能直达“品牌主页”？如果品牌名称输入错误，“品牌主页”能不能显示？“品牌主页”在搜索结果中是怎么排序的？实际上，对于搜索平台来说，这些都是影响流量曝光不可忽略的因素。流量曝光第一环：入口微信：三种样式、三种入口，A级最突出在搜一搜的搜索结果页中，微信品牌官方区的有三种展示样式，如图，依次为A、B、C三种：A级与B级的品牌官方区可以添加公众号、小程序、服务和商品；C级样式仅允许将公众号展示。此外，A级与B级都有品牌详情页，C级样式并没有。在众多搜索结果中，A级样式会有一种“鹤立鸡群”的感觉，更容易建立品牌认知，尤其是小程序、公众号、服务、商品等都是卡片形式，入口更加“抢眼”。不过，A级样式并不是所有品牌都能开通的，三种样式各有不同的门槛。如图，要求中包括公众号与官方区点击量、是否有微信认证与商标认证、公众号注册时间等条件。值得注意的是，开通A级样式还有推广搜一搜的要求，即品牌主在投放广告时或在自有宣传渠道上，要有“微信搜一搜”搜索框露出。线上线下渠道都可以，比如：电梯间广告、户外大屏广告、易拉宝、门店宣传、自有小程序曝光、公众号文章广告、朋友圈广告等等。 支付宝&百度：品牌主页没有特殊展示，入口很“隐蔽”相较于微信官方区，支付宝品牌直达与百度品牌名片的样式则显得尤为“简陋”。展示上，支付宝品牌直达与其他搜索结果并无差别，而百度品牌名片本身即是一个小程序。所以，在入口上，支付宝品牌直达与百度品牌名片都不够突出。对于企业来说，“品牌主页”的作用，就是为了让用户在众多搜索结果中一眼就能看到自家品牌，而“与众不同”的样式，入口也就更“夺目”，这一点，微信官方区是合格的。从品牌曝光来看，支付宝与百度的“品牌主页”在入口上都没有明显优势。如此看来，微信品牌官方区完胜。流量曝光第二环：关键词配置对比完三家“品牌主页”的样式，再来看关键词配置。毕竟，用户输入什么关键词，才能将“品牌主页”搜索出来才是最重要的。微信：级别越高，可配置关键词数量越多刚刚提到，微信品牌官方区有A、B、C三种不同级别。所以，可配置的关键词数量也是不一样的，分别为5个、3个、1个。所以，这对企业来说，可操作空间不大，但仍旧需要将与品牌相关的常见关键词都加上。比如，开通A级官方区的“同程旅游网”，其相关的关键词有同程旅游、同程、同程艺龙等，但晓程序观察（yinghoo-tech）测试后发现，输入“同程艺龙”，并不会出现“同程旅游网”品牌官方区，说明其没有配置关键词“同程艺龙”。同样的问题，也出现在开通B级官方区的“麦当劳”上，搜索英文名称McDonald，就不会出现其品牌官方区。支付宝&百度：“关键词要与品牌名称完全一致”支付宝品牌直达与百度品牌名片的关键词完全不用主动配置，但是，对企业、对用户都极其不友好。因为，只有在用户精确搜索品牌词时，搜索结果中才会出现“品牌主页”。百度品牌名片更甚，据百度官方介绍，用户需要输入“品牌名+品牌名片”（如齐家网品牌名片），或者输入开发者在后台填写的企业全称。对此，晓程序观察也测试了一番，输入“齐家网”后，在搜索结果中，整个第一页都没有看到“齐家网品牌名片”的身影。因此，在“品牌主页”的关键词配置上，微信有一定的运营空间，而百度与支付宝则完全没有。流量曝光第三环：搜索排名对于搜索平台的逻辑来说，决定流量价值的，除了关键词，当然就是搜索结果页排名了。BAT三家“品牌主页”的排名规则，又有什么不一样？微信：“品牌主页”始终占据首位在搜一搜结果页中，微信官方区始终是以首位展示。比如，输入“同程”后，结果页中排在第一位的便是“同程旅游网”品牌官方区，而后才是文章、公众号、小程序、朋友圈等内容。当然前提是，需要针对特定搜索词才能保证官方区首位展示。不同级别的官方区，指定关键词数量也是不一样的。此外，搜索词申请也有一定的要求：须为品牌词汇：针对通用词汇，比如汉堡、保险等，不开放置顶申请；须具有品牌独占性：针对非品牌独占词汇，比如阿拉丁等，不开放置顶申请。支付宝：可通过运营手段来提升搜索排名相比于微信官方区首位展示，支付宝品牌直达的搜索排名则由算法决定。算法维度主要包括：搜索结果中品牌直达的访问和点击用户数、开通品牌直达后搜索带来的增量用户数等，而这些数据都可以利用运营手段来提升。需要注意的是，支付宝品牌直达内包括了小程序、生活号等内容；所以，企业们只需运营品牌直达即可，这样便能同时提升小程序与生活号的排名竞争力。比如，在运营活动中，就可以引导用户“上支付宝搜XXX”，从而改善搜索UV、搜索UV增量数据。百度：广告排在品牌主页前面作为一个搜索引擎平台，百度品牌名片的排名同样根据算法得到，至于逻辑目前还不太清楚。不过，据我们的测试来看，百度品牌名片并不会排在首位，“取而代之”的则是与关键词相关的广告内容。如图，输入“齐家网品牌名片”之后，出现在首位是与齐家网毫无关系的广告内容。综上，微信官方区首位展示，显然是最能帮助企业实现品牌曝光的。而支付宝与百度，还需要开发者在运营规范中自行摸索算法。比如，支付宝品牌直达的搜索UV就是其算法中一个很重要的因素。2在至关重要的拉新与转化上百度输了？对于企业而言，“品牌主页”能带来流量曝光是远远不够的，其更加看重的，仍是拉新与转化。这一点，目前只有微信品牌官方区与支付宝品牌直达能够做到。事实上，BAT三家“品牌主页”看似差别不大，都可以在“品牌主页”内添加小程序等入口，但在拉新与转化上，百度则略逊一筹。原因是微信与支付宝“品牌主页”具备以下两个能力：1.可在品牌主页内直接添加服务与商品在微信与支付宝的“品牌主页”内，开发者能够配置其小程序的服务或商品。品牌在搜索结果页中就能直接触达用户，转化能力更强。用户点击服务或商品后，落地页都是品牌关联的小程序，比如，在NIKE的微信品牌官方区内，点击商品，进入的就是“Nike耐克”小程序的商品详情页。目前，微信品牌官方区最多可在搜索结果页展示4个服务与3个商品；而支付宝品牌直达，仅可添加1-2个小程序服务。2.品牌主页可与功能直达打通在微信与支付宝“品牌主页”中，可与“功能直达”打通，也是其一项重要开放能力。（关于BAT三家功能直达，我们此前已有过测评对比，请点击阅读）在微信搜一搜中，品牌官方区的服务和商品也会出现在相关搜索结果中，拥有更多曝光；同样，用户在支付宝搜索的关键词与某功能关键词匹配时，便会触发功能直达，小程序内的服务便可直接出现在结果页中。相比之下，百度不仅在搜索结果页没有服务入口，在品牌详情页内也不可添加小程序内某个服务，目前只能起到展示作用。综上，无论是“品牌主页”样式，还是流量曝光，微信官方区都要更加完善；而支付宝与百度则处于刚刚起步的阶段，尤其是百度品牌名片，并没有将百度的搜索价值利用至最大化。那么，企业开发者们，BAT三家“品牌名片”，你们会怎么运营？欢迎留言哦~"}
{"title": "微信小程序 模拟打电话 实践 ", "author": "Rolan", "pub_time": "2019-11-20 00:50", "content": "模拟电话模拟打电话功能，拨下指定的号码如10086，等待1.5秒后开始播放本地音频文件并计时。使用小程序官方API createInnerAudioContext()创建 InnerAudioContext对象。小程序官方推荐使用更为强大的音频上下文对象InnerAudioContext，官方已经停止了对组件的维护。上述这个demo效果的具体实现，如下代码：<template><view class=\"task\">  <view class=\"call\">    <!-- 顶部区域 -->    <view class=\"top\" wx:if=\"{{phone.length > 0}}\">      <view class=\"phone\">{{phone}}</view>      <view class=\"tip\" wx:if=\"{{calling}}\">        <view wx:if=\"{{tipShow}}\">正在呼叫...</view>        <view wx:else>{{formatMmSs}}</view>      </view>    </view>    <!-- 中间区域 -->    <view class=\"middle\">      <view class=\"nums\" wx:if=\"{{showNums}}\" @tap=\"numClick\">        <view class=\"row\">          <view class=\"num\" data-num='1'>1</view>          <view class=\"num\" data-num='2'>2</view>          <view class=\"num\" data-num='3'>3</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='4'>4</view>          <view class=\"num\" data-num='5'>5</view>          <view class=\"num\" data-num='6'>6</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='7'>7</view>          <view class=\"num\" data-num='8'>8</view>          <view class=\"num\" data-num='9'>9</view>        </view>        <view class=\"row\">          <view class=\"num\" data-num='*'>*</view>          <view class=\"num\" data-num='0'>0</view>          <view class=\"num\" data-num='#'>#</view>        </view>          </view>      <view class=\"icons\" wx:else>        <view class=\"icon\">          <image src=\"{{img.ringIcon1}}\"></image>          <view>静音</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon2}}\" @tap=\"handle('back')\"></image>          <view>拔号</view>        </view>        <view class=\"icon\">          <image src=\"{{img.ringIcon3}}\"></image>          <view>免提</view>        </view>      </view>    </view>    <!-- 底部区域 -->    <view class=\"bottom\">      <image wx:if=\"{{!calling}}\" class=\"btn\" src=\"{{img.call}}\" @tap=\"handle('call')\"></image>      <image wx:else class=\"btn\" src=\"{{img.cancel}}\" @tap=\"handle('cancel')\"></image>      <image wx:if=\"{{!calling && phone.length>0}}\" class=\"del\" src=\"{{img.delete}}\" @tap=\"handle('delete')\"></image>    </view>  </view></view> </template><script>import wepy from 'wepy'import img from '@/assets'export default class Test extends wepy.page {  config = {    navigationBarTitleText: '模拟电话'  }  data = {    img: img,    phone: '',        // 10086    tipShow: false,   // 显示呼叫中    calling: false,   // 是否拔通电话    showNums: true,   // 显示数字面板    seconds: 0        // 计时  }  computed = {    // 通话计时 格式化    formatMmSs() {      return this.mmss(this.seconds)    }  }  // 格式化时间  mmss(count) {    count = count % 3600  // 不考虑 HH    let mm = Math.floor(count / 60)    let ss = count % 60    if (mm < 10) mm = '0' + mm    if (ss < 10) ss = '0' + ss    return mm + ':' + ss  }  onLoad() {    // 音频上下文    wepy.setInnerAudioOption({      mixWithOther: false,    // 终止其他应用或微信内的音乐      obeyMuteSwitch: false   // 在静音模式下，也能播放声音    })    let ctx = wepy.createInnerAudioContext()    ctx.src = '/assets/media/10086.mp3'    ctx.loop = true    ctx.onPlay(() => {      console.log('开始播放')    })    ctx.onError((res) => {      console.log(res.errMsg)    })    this.ctx = ctx  }  methods = {    // 点击数字    numClick(e) {      console.log(e)      console.log(e.target.dataset.num)      const num = e.target.dataset.num      this.phone = this.phone + num    },    handle(type) {      switch (type) {        case 'call':          // 拔打电话          if (this.phone !== '10086') {            wepy.showToast({ title: '请拔打10086', icon: 'none' })          } else {            this.calling = true            this.tipShow = true            // 延迟1.5秒后开始计时，并播放音频文件            setTimeout(() => {              this.ctx.play()              this.showNums = false              this.timer = setInterval(() => {                this.tipShow = false                this.seconds = this.seconds + 1                this.$apply()              }, 1000)            }, 1500)          }          break        case 'cancel':          // 挂掉电话          clearInterval(this.timer)          this.ctx.seek(0)          this.ctx.stop()          this.phone = ''          this.calling = false          this.showNums = true          this.seconds = 0          break        case 'delete':          // 删除电话号码的最后一位          let phone = this.phone          let arr = phone.split('')          arr.pop()          this.phone = arr.join('')          break        case 'back':          // 返回至数字键盘          this.showNums = true          break        default:          break      }    }  }}</script><style lang='less'>.task {  position: absolute;  top: 0;  bottom: 0;  left: 0;  right: 0;  overflow: hidden;  background: rgba(0, 0, 0, 1);  // 打电话区域  .call {    position: absolute;    top: 0;    right: 0;    bottom: 0;    left: 0;    z-index: 2;    .top {      position: absolute;      top: 48rpx;      left: 0;      right: 0;      color: #FDFDFD;      text-align: center;      .phone {        font-size: 72rpx;        line-height: 100rpx;      }      .tip {        font-size: 36rpx;        line-height: 54rpx;      }    }    .middle {      position: absolute;      top: 232rpx;      left: 0;      right: 0;      // 数字面板      .nums {        .row {          width: 540rpx;          margin: 0 auto;          height: 158rpx;          overflow: hidden;          .num {            float: left;            margin: 0 30rpx;            width: 120rpx;            height: 120rpx;            border-radius: 50%;            background:rgba(229,229,229,1);            text-align: center;            line-height: 120rpx;            font-size: 60rpx;            color: black;          }          .num:active {            background:rgba(229,229,229,0.5);          }        }      }      // 免提等      .icons {        margin: 0 auto;        width: 540rpx;        height: 250rpx;        overflow: hidden;        padding-top: 196rpx;        .icon {          float: left;          width: 120rpx;          margin: 0 30rpx;          &>image {            display: block;            width: 120rpx;            height: 120rpx;            border-radius: 50%;          }          &>image:active {            opacity: 0.7;          }          &>view {            font-size: 32rpx;            color: #FDFDFD;            text-align: center;            line-height: 68rpx;          }        }      }    }    .bottom {      position: absolute;      top: 940rpx;      left: 0;      right: 0;      text-align: center;      .btn {        display: inline-block;        width: 120rpx;        height: 120rpx;        border-radius: 50%;      }      .del {        display: inline-block;        width: 75rpx;        height: 56rpx;        position: absolute;        top: 46rpx;        right: 138rpx;      }      .btn:active {        opacity: 0.7;      }      .del:active {        opacity: 0.7;      }    }  }}</style>"}
{"title": "扫小程序码实现网站登陆,提供源代码 ", "author": "Rolan", "pub_time": "2019-8-19 00:51", "content": "使用扫小程序码登陆网站\r\n网络上关于实现本本功能的文章很多，但是给出案列的几乎没有，今天笔者实现用小程序码实现网站登陆，体验地址如下\r\nidea.techidea8.com/open/login.…\r\n思路\r\n\r\n关键流程\r\n建立场景sceneid和websocket的绑定关系\r\n获得sceneid\r\n场景ID可以前端生成，也可以后端生成，只需要保证sceneid的同一时间唯一性即可。\r\n前端生成可以采用随机数加时间戳的形式,也可以用uuid算法\r\n//时间戳\r\nvar sceneid =\"scend-\" +  new Data().getTime() + Math.ceil(Math.random()*888888+1000000);\r\n复制代码建立websocket\r\nvar ws = new WebSocket(\"ws://192.168.0.106/websocket?clientid=\"+sceneid )\r\nws.onopen=function(env){\r\n\tconsole.log(env)\r\n} \r\nws.onmessage=function(env){\r\n\tvar data = env.data;\r\n\t//这个data 就是后端发来的用户数据\r\n} \r\n\r\n复制代码后端建立websocket\r\n后端采用go语言github.com/gorilla/websocket包建立websocket.因为golang 非常适合高并发场景。\r\nfunc (ctrl *PushCtrl) websocket(w http.ResponseWriter, req *http.Request) {\r\n\r\n\t//fmt.Printf(\"%+v\",request.Header)\r\n\t//todo 检验接入是否合法\r\n\t//checkToken(userId int64,token string)\r\n\tquery := req.URL.Query()\r\n\tclientid := query.Get(\"clientid\")\r\n\r\n\tconn, err := (&websocket.Upgrader{\r\n\t\tCheckOrigin: func(r *http.Request) bool {\r\n\t\t\treturn true\r\n\t\t},\r\n\t}).Upgrade(w, req, nil)\r\n\r\n\tif err != nil {\r\n\t\tlog.Println(err.Error())\r\n\t\treturn\r\n\t}\r\n\r\n\tclientMap.Store(clientid, conn)\r\n\tgo func(clientId string, conn *websocket.Conn) {\r\n\t\t//处理出错信息\r\n\t\tdefer func() {\r\n\t\t\tconn.Close()\r\n\t\t\tclientMap.Delete(clientid)\r\n\t\t}()\r\n\t\tfor {\r\n\t\t\t_, _, err := conn.ReadMessage()\r\n\t\t\tif err != nil {\r\n\t\t\t\tlog.Println(err.Error())\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}(clientid, conn)\r\n}\r\n复制代码我们采用sync.map建立sceneid和websocket的对应关系\r\nclientMap.Save(sceneid,conn)\r\n复制代码对于因为异常断开的con我们需要移除\r\nclientMap.Delete(sceneid)\r\n复制代码获得小程序二维码\r\n获得小程序的accesstoken\r\n小程序access 请求接口如下\r\n``\r\n该接口日使用频率有限制，因此我们需要将这些数据缓存起来,缓存方案很多，有redis,也有内存，我们这里直接用一个变量即可存储\r\naccesstoken :=\"\"\r\nfunc GetAccessToken() string{\r\n\treturn accesstoken \r\n}\r\nfunc RefreshAccessToken()string{\r\n\turl = \"\"\r\n\tresp := httpget(url)\r\n\t//resp 是一个包含accesstoken的json字符串,我们解析这个json即可\r\n\taccesstoken = decodeaccesstokenfromjson(resp)\r\n\treturn accesstoken \r\n}\r\n复制代码我们还需要一个滴答计数器用来刷新accesstoken,accesstoken 的有效期是7200秒，我们4000秒刷新一次accesstoken 即可\r\nfunc refreshAccessToken(){\r\n\tticker := time.NewTicker(time.Second *4000)\r\n\tfor{\r\n\t\tselect {\r\n\t\t\tcase <-ticker.C:\r\n\t\t\t\tRefreshAccessToken()\r\n\t\t}\r\n\t}\r\n}\r\n复制代码在init.go 中的init方法中启动协程\r\ngo refreshAccessToken()\r\n复制代码小程序二维码编程技巧\r\n小程序二维码请求接口如下\r\nhttps://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=ACCESSTOKEN\r\n由于该链接会返回俩种结果\r\n错误返回Json\r\n{\r\n\"errcode\":400001,\r\n\"errmsg\":\"什么什么原因\"\r\n}\r\n复制代码正确返回j图片buffer\r\n这是一个二进制码流，因此我们需要对返回结果进行标准化处理\r\n我们建议一种标准化结果\r\n{\r\ncode:0,\r\ndata:\"\",\r\nmsg:\"结果说明\"\r\n}\r\n复制代码\r\n\r\n\r\n参数\r\n说明\r\n\r\n\r\n\r\n\r\ncode\r\n标识成功或者失败,200为成功,400为失败\r\n\r\n\r\ndata\r\n图片的base64格式编码\r\n\r\n\r\nmsg\r\n结果说明,或者出错提示\r\n\r\n\r\n\r\n代码示例如下\r\nurl := fmt.Sprintf(\"https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=%s\", token)\r\nret, err := util.PostJSON(url, arg)\r\nif err != nil {\r\n\t\tutil.FailMsg(w, err.Error())\r\n\t\treturn\r\n}\r\n\r\njsonstr := string(ret)\r\nif strings.Contains(jsonstr, \"errmsg\") {\r\n\tutil.FailMsg(w, jsonstr)\r\n\treturn\r\n} else {\r\n\tbase64data := base64.StdEncoding.EncodeToString(ret)\r\n\tutil.RespOk(w, \"data:image/png;base64,\"+base64data)\r\n}\r\n复制代码其中util是笔者封装的常用工具包\r\n\r\n前端请求成功后获得data,可以利用$(\"#qrcode\").attr(\"src\",res.data)刷新图片二维码\r\nfunction refreshqrcode(){\r\n    clientId = \"scene-\"+new Date().getTime();\r\n    var api = restgo.buildapi(\"miniapp/getwxacodeunlimit\")\r\n    restgo.post(api,{\"scene\":clientId}).then(res=>{\r\n        if(res.code==200){\r\n            $(\"#qrcode\").attr(\"src\",res.data)\r\n        }else{\r\n            alert(res.msg)    \r\n        }\r\n        intiwebsocket()\r\n    },res=>{\r\n        alert(res.msg)\r\n    })\r\n}\r\n复制代码小程序处理关键点\r\n采用好的框架\r\n我们编程过程才用了uniapp，这个框架不错,完全是vue的语法，\r\n一套代码可以生成H5/小程序/android/ios\r\n我们采用了vue的watch特性,通过监听userid来确定是否发送信息\r\nwatch:{\r\n\t userid:function(a,b){\r\n\t\t\t\r\n\t\t\tif(a==0){\r\n\t\t\t\treturn \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.loaddata()\r\n\t\t\t//如果clientid是空的说明不是扫码进来的\t\r\n\t\t\tif(!this.clientid){\r\n\t\t\t\treturn \r\n\t\t\t}\r\n//如果是扫码进来的,那么我们还需要推送消息到服务器后端\r\nserver.PublishMsg(this.clientid,this.userid,this.role,this.avatarUrl,this.nickName).then(res=>{\r\n\t\t\t\ttip.error(res.msg)\r\n\t\t\t},res=>{\r\n\t\t\t\ttip.error(res.msg)\r\n\t\t\t})\r\n\t\t\t\r\n\t }\r\n  }\r\n复制代码获取sceneid\r\n我们通过onload方法获得sceneid\r\nonLoad(arg) {\r\n\t\tif(!!arg && !!arg.scene){\r\n\t\t\t\t\tthis.clientid = decodeURIComponent(arg.scene)\r\n\t\t}\r\n\t\t\t\t\r\n\t},\r\n复制代码核心代码如下\r\n通过gotUserInfo获得用户头像、昵称等,通过uni.login获得code\r\ngotUserInfo :function(e) {\r\n\t\t\t //获得用户头像、昵称、\r\n\t\t\t  uni.login(\r\n\t\t\t  {\r\n\t\t\t\t  success:(res) =>{\r\n\t\t\t\t\t        //通过wx.login获得code\r\n\t\t\t      \t\t\tuserInfo.code = res.code\r\n                                                //统一传递到后端      \r\n\t\t\t\t\t\tthis.authwithcode(userInfo)\r\n\t\t\t\t  }\r\n\t\t\t  }\r\n\t\t\t  )\r\n\t\t\t}\r\n\t\t  },\r\n\t\tauthwithcode:function(userInfo){\r\n                        //code获得openid在后端做,做了后继续去查User表\r\n\t\t\tserver.AuthWithCode(userInfo).then(res=>{\r\n\t\t\t\t\t//如果这个openid绑定了用户\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\tif(res.data.id>0){\r\n\t\t\t\t\t\t//这里res.data 就是user对象,可以继续操作\r\n\t\t\t\t\t\treturn ;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//如果没有那么注册\r\n\t\t\t\t\tserver.RegisterWithOpenId(res.data.mini_openid,userInfo.avatarUrl,userInfo.nickName)#.then(res=>{\r\n\t\t\t\t\t\t//注册成功则返回\r\n\t\t\t\t\t\t//这里res.data 就是user对象可以继续操作\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t},res=>{\r\n\t\t\t\t\t\ttip.error(res.msg)\r\n\t\t\t\t\t})\r\n\t\t\t\t},res=>{\r\n\t\t\t\t\ttip.error(res.msg||\"\");\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t},\t\r\n复制代码体验地址\r\n本文所有应用体验地址如下\r\n互联网行业解决方案吧https://idea.techidea8.com/open/idea.shtml?id=5\r\n关于代码\r\n代码获得地址\r\n小程序码登陆\r\n代码配置\r\n请认真阅读readme.md"}
{"title": "微信小程序支持 webP 的 WebAssembly 方案 ", "author": "Rolan", "pub_time": "2019-8-20 00:24", "content": "相信不少人听说过 WebAssembly，它是由 Google、Microsoft、Mozilla、Apple 等几家大公司合作发起的一个关于面向 Web 的通用二进制和文本格式的项目。本文我们将跟随作者一步步揭开 WebAssembly 的神秘面纱，并了解 WebAssembly 是如何应用在实际业务中的。引言实践检验真理，让我们一起动手将 WebAssembly 应用在微信小程序场景中，让微信小程序环境支持解码 webP 格式（不了解或没听过 webP 的各位同仁，请先移步到 “探究 WebP 的一些事儿” ）。WebAssembly 工作流程动手之前，让我们先来了解下如何加载和运行 WebAssembly 的代码：C / C++ / Rust / Java 等高级语言开发的代码或功能库 -> Emscripten 编译 -> wasm 文件 -> 结合 WebAssembly JS API -> 浏览器环境中运行，如下图所示：简单来说，编译前端 LLVM / Emscripten 流程可以获得 wasm 文件和胶水 js。然后，通过胶水 js 来加载 wasm 并转为 arrayBuffer 格式。紧接着进行编译和实例化后，即可用 JavaScript 与 WebAssembly 通信。详细过程以及每个过程调用的 API 如下图所示：浏览器环境支持 webP了解完 WebAssembly 的工作流程后，是不是还不清楚要从哪开始搞起？你可以去 github 官网上看一下 libwebp 开源项目 ，Google 已经完全支持把 libwebp 源码编译为 wasm 和 asm.js 两个版本了。针对不支持 WebAssembly 的系统或不兼容 WebAssembly 的浏览器，可以在损失一点性能的情况下降级为使用 asm.js。具体编译步骤如下图所示：待编译完之后，我们便可获得 wasm 文件和胶水 JS。然后，我们可以用“python -m SimpleHTTPServer 8080”启动一个本地服务，在浏览器地址栏输入 http://localhost:8080 后就能看到 webP 解码后的图片。最后，让我们来总结下整个流程。（1）用 LLVM / Emscripten / CMake 工具对 libwebp 解码库进行编译，获得 wasm 文件和胶水 JS。（2）胶水 JS 申请内存，对 wasm 文件进行编译、加载和实例化后，导出 Module 对象。（3）利用 Module 对象上的 WebpToSDL 方法对 webP 进行解码，并转成 Canvas 在浏览器渲染显示出来，呈现最终的图片。微信小程序环境支持 webP微信小程序在 Android / iOS 上用于执行脚本以及渲染组件的环境都不尽相同。在 Android 上，微信小程序逻辑层的 JavaScript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 67 内核来渲染，天然支持 webP 格式；在 iOS 上，微信小程序逻辑层的 JavaScript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染，宿主 Safari 浏览器内核不支持 webP 格式。通过第 3 节内容，我们知道浏览器环境已经能够支持 webP 了，那直接把之前编译好的 wasm 文件和胶水 JS 扔进微信小程序的运行环境，然后跑起来不就搞定了？Too young too simple!浏览器环境支持 webP 的思路是 libwebp 解码 webP -> jpg / png / gif 的 canvas 图片渲染显示，这已经改变了原来 image 组件的结构。而微信小程序提供给开发者的组件不允许去改变它原来的结构，因此换种思路是 libwebp 解码 webP -> jpg / png / gif 的 rgb data -> jpg / png / gif base64 -> 回传给 JS 并赋值给 image src 进行渲染显示。下面我罗列下从 libwebp 编译 wasm 文件和胶水 JS 开始，直到在微信小程序环境跑通为止，整个过程中遇到的一些坑点和优化点：（1）编译 CMakeLists.txt 时需加上“-O3”选项，大大提升编译速度。（2）编译 CMakeLists.txt 时需加上“-s USE_PTHREADS=0”选项，因为 iOS Safari 浏览器不兼容 ShareArrayBuffer 共享缓冲区。（3）编译 CMakeLists.txt 时需加上“-s ALLOW_MEMORY_GROWTH=1”选项，目的是为了解决解码超大分辨率的 webP 图片时出现的 OOM 问题。（4）由于微信小程序环境的兼容性问题，去除胶水 JS 代码中 libwebp 编译时加上的 SDL 相关代码，能节省 100KB 左右的空间。（5）去除胶水 JS 中 ENVIRONMENT_IS_NODE / ENVIRONMENT_IS_SHELL 相关的代码，因为微信小程序环境并未使用到。（6）由于 iOS Safari 浏览器的兼容性问题，将胶水 JS 中流式编译和实例化的方法去掉，替换成非流式编译和实例化的方法。（7）由于 WebAssembly 还没有和 <script type='module'> 或 ES6 的 import 语句集成，因此将 wasm 文件先转成 base64 字符串。等胶水 JS 运行加载逻辑时，再将 base64 转成 ArrayBuffer 并编译和实例化后导出 Module 对象，节省从服务器下载 wasm 文件的时间。（8）编译 CMakeLists.txt 时需加上“-s USE_LIBPNG=1”选项编译 libpng.a 库，然后将 webP 解码获得的 rgb 数据，通过 png 解码库转成 png 内存数据，紧接着转成 base64 回传给 JS，最后赋值给 image src 进行渲染显示。难点是 rgb 转成 png 内存数据这一步出了点问题，但是 wasm 无法调试代码，只能通过搭建 libpng 的 VS 工程进行断点调试，最终定位到是 rgb 转 png data 时传入的 data_size 为 0 导致。（9）胶水 JS 里的 new WebAssembly.Memory 代码在微信小程序环境运行时，会报“refused to create a webassembly object without ‘unsafe-eval’”的错误，必须在 page-frame.html 里的 CSP 设置里加上 unsafe-eval 才能解决。踩了这么多坑之后，终于能在微信小程序环境里支持 webP 了。实测 WebAssembly 在解码不同格式不同分辨率的 webP 时，性能都完胜 JavaScript。写在最后虽然 WebAssembly 的解码性能比 JavaScript 快不少，但遇到超大分辨率（如 1920 x 1080 等）的 webP 时，却远远落后于客户端的解码性能。综合对比各种方案的性能和兼容性之后，我们还是采用了基于 iOS 客户端自定义协议 webphttps 的方案，大致步骤如下：（1）首先，微信小程序基础库判断开发者在 image 组件使用的是 webP 格式时，则在 image src 里加上 webp 头部如 webphttps://example.png。（2）然后，客户端通过 NSURLProtocol 协议挟持 webphttps 的请求，并下载相应的 webP 数据进行解码。（3）最后，再把解码后的 image 数据回吐给浏览器进行渲染显示。到最后，我们完成了微信小程序环境支持 webP 的方案落地。"}
{"title": "微信小程序云端解决方案教程二：WebSocket长连接应用场景 ", "author": "天下雪", "pub_time": "2016-10-15 16:58", "content": "部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 启动 WebSocket 服务6. 启动微信小程序为什么要用 WebSocket通信协议设计服务器逻辑微信端实现没事打开小程序，和附近的人剪刀石头布，想来就来，想走就走。谁能成为武林高手？！微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。腾讯云拿到了小程序内测资格，研究了一番之后，发现微信支持 WebSocket 还是很值得玩味的。这个特性意味着我们可以做一些实时同步或者协作的小程序。这篇文章分享一个简单的剪刀石头布的小游戏的制作，希望能对想要在小程序中使用 WebSocket 的开发者有帮助。整个游戏非常简单，连接到服务器后自动匹配在线玩家（没有则分配一个机器人），然后两人进行剪刀石头布的对抗游戏。当对方进行拳头选择的时候，头像会旋转，这个过程使用 WebSocket 会变得简单快速。部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构小程序的架构非常简单，这里有两条网络同步，一条是 HTTPS 通路，用于常规请求。对于 WebSocket 请求，会先走 HTTPS 后再切换协议到 WebSocket 的 TCP 连接，从而实现全双工通信。1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署剪刀石头布的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像部署完成之后，云主机上就有运行 WebSocket 服务的基本环境、代码和配置了。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 启动 WebSocket 服务在镜像的 nginx 配置中（/etc/nginx/conf.d），已经把 /applet/websocket 的请求转发到 http://127.0.0.1:9595 处理。我们需要把 Node 实现的 WebSocket 服务在这个端口里运行起来。进入镜像中源码位置：cd /data/release/qcloud-applet-websocket使用 pm2 启动服务：pm2 start process.json6. 启动微信小程序在微信开发者工具中修改小程序源码中的 config.js 配置，把通讯域名修改成上面申请的域名。完成后点击调试即可连接到 WebSocket 服务进行游戏。配置完成后，运行小程序就可以看到成功搭建的提示！为什么要用 WebSocket使用传统的 HTTP 轮询或者长连接的方式也可以实现类似服务器推送的效果，但是这类方式都存在资源消耗过大或推送延迟等问题。而 WebSocket 直接使用 TCP 连接保持全双工的传输，可以有效地减少连接的建立，实现真正的服务器通信，对于有低延迟有要求的应用是一个很好的选择。目前浏览器对 WebSocket 的支持程度已经很好，加上微信小程序的平台支持，这种可以极大提高客户端体验的通信方式将会变得更加主流。Server 端需要实现 WebSocket 协议，才能支持微信小程序的 WebSocket 请求。鉴于 SocketIO 被广泛使用，剪刀石头布的小程序，我们选用了比较著名的 SocketIO 作为服务端的实现。Socket IO 的使用比较简单，仅需几行代码就可启动服务。export class Server {    init(path: string) {        /** Port that server listen on */        this.port = process.env.PORT;        /** HTTP Server instance for both express and socket io */        this.http = http.createServer();        /** Socket io instance */        this.io = SocketIO(this.http, { path });        /** Handle incomming connection */        this.io.on(\"connection\", socket => {            // handle connection        });    }    start() {        this.http.listen(this.port);        console.log(`---- server started. listen : ${this.port} ----`);    }}const server = new Server();server.init(\"/applet/ws/socket.io\");server.start();但是，SocketIO 和一些其它的服务器端实现，都有其配套的客户端来完成上层协议的编码解码。但是由于微信的限制（不能使用 window 等对象）， SocketIO 的客户端代码在微信小程序平台上是无法运行的。经过对 SocketIO 通信进行抓包以及研究其客户端源码，笔者封装了一个大约 100 行适用于微信小程序平台的 WxSocketIO 类，可以帮助开发者快速使用 SocketIO 来进行 WebSocket 通信。const socket = new WxSocketIO();socket.on('hi', packet => console.log('server say hi: ' + packet.message));socket.emit('hello', { from: 'techird' });如果想要使用微信原生的 API，那么在服务器端也可以直接使用 ws 来实现 W3C 标准的接口。不过 SocketIO 支持多进程的特性，对于后续做横向扩张是很有帮助的。腾讯云在后面也会有计划推出支持大规模业务需求的 WebSocket 连接服务，减小业务的部署成本。通信协议设计实现一个多客户端交互的服务，是需要把中间涉及到所有的消息类型都设计清楚的，就像是类似剪刀石头布这样一个小程序，都有下面这些消息类型。消息方向说明helloc => s客户端连上后发送 hello 信息，告知服务器自己身份以及位置。his => c服务器响应客户端打招呼，并且反馈附近有多少人joinc => s客户端请求加入一个房间进行游戏leavec => s客户端请求退出房间starts => c房间里面全部人都 ready 后，会发送游戏开始的信号，并且告知客户端游戏时间。choicec => s客户端选择出剪刀、石头还是布facec => s客户端更新自己的表情movements => c有用户更新选择或者更新表情会通知其它用户results => c超过选择时间后，游戏结束，广播游戏结果具体每个消息的参数可以参考源码里的 server/protocol.brief.md服务器逻辑服务器的逻辑很简单：收到用户请求加入房间（join），就寻找还没满的房间找到房间，则加入没找到房间，创建新房间有用户加入的房间检查是否已满，如果已满，则：给房间里每个用户发送开始游戏的信号（start）启动计时器，计时器结束后进行游戏结算游戏结算两两之间 PK，赢方分数加一，输方减一，最终得每个玩家基本得分 x对于每个玩家，如果分数 x 大于 0，则视为胜利，连胜次数加一，否则连胜次数归零本局得分为分数 x 乘以连胜次数发送本局游戏结果给房间里的每位玩家微信端实现微信小程序直接使用上面的协议，针对不同的场景进行渲染。整体的状态机如下。状态机整理清楚后，就是根据状态机来控制什么时候发送消息，接到消息后如何处理的问题了。具体实现请参照 app/pages/game/game.js 里的源码。"}
{"title": "微信小程序云端解决方案教程四：视频应用场景 ", "author": "天下雪", "pub_time": "2016-10-15 17:12", "content": "部署和运行整体架构1. 准备域名和证书2. Nginx 和 Node 代码部署3. 配置 HTTPS4. 域名解析5. 开通 点播服务6. 准备 云数据库MySQL7. 启动新片预告示例 Node 服务8. 启动新片预告 Demo主要功能实现获取视频列表、展示评论、提交评论播放视频新片预告是结合腾讯云点播 VOD和云数据库 MySQL制作的一个微信小程序示例。在代码结构上包含如下两部分：app: 新片预告应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的Node服务端代码，作为服务器和app通信，提供 CGI 接口示例用于拉取云数据库上的视频列表、评论列表，将评论数据提交到云数据库新片预告主要功能如下：支持分页滚动加载视频列表点击海报跳转至详情页播放视频对视频进行评论展示视频的评论列表部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个 SSL 证书。腾讯云提供域名注册和证书申请服务，还没有域名或者证书的可以去使用域名注册好之后，可以登录微信公众平台配置通信域名了。注意：需要将 www.qcloud.la 设置为上面申请的域名2. Nginx 和 Node 代码部署小程序服务要运行，需要进行以下几步：部署 Nginx，Nginx 的安装和部署请大家自行搜索（注意需要把 SSL 模块也编译进去）配置 Nginx 反向代理到 http://127.0.0.1:9994Node 运行环境，可以安装 Node V6.6.0部署 server 目录的代码到服务器上，如 /data/release/qcloud-applet-video使用 npm install 安装依赖模块使用 npm install pm2 -g 安装 pm2上述环境配置比较麻烦，新片预告的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，推荐大家直接使用。镜像部署完成之后，云主机上就有运行 WebSocket 服务的基本环境、代码和配置了。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx\r\n4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通 点播服务新片预告示例的播放资源是存储在 腾讯云点播 上的mp4文件，要使用 点播 服务，需要登录 点播 管理控制台，然后在其中完成以下操作：上传视频资源，点播几乎支持所有主流的视频格式上传转码成功后获取mp4或m3u8源地址目前微信小程序video组件经测试支持mp4和m3u8格式，其中 m3u8 格式只能在手机上使用，开发者可以使用腾讯云点播控制台将视频源转码成 mp4 或 m3u8 格式，并且腾讯云点播会对播放的资源进行CDN加速。6. 准备 云数据库MySQL示例中拉取的视频和评论列表都是存储在 云数据库 上，要使用 云数据库 服务需要完成以下操作购买，注意购买的云数据库需要与云服务器同在一个地域分区初始化流程，本示例选用的是utf8编码点击云数据库 控制台操作栏的登录按钮，登录到phpMyAdmin创建数据库并在当前数据库中导入本示例中的SQL文件注意：导入SQL文件中包含了 点播 上传的视频列表，开发者可以基于云数据库自行开发维护一个视频发布管理系统，因为此内容跟本示例暂不相关，所以不再详述。7. 启动新片预告示例 Node 服务在镜像中，新片预告示例的 Node 服务代码已部署在目录/data/release/qcloud-applet-video下：进入该目录：cd /data/release/qcloud-applet-video\r\n在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 MySQL 配置：module.exports = {\r\n    // Node 监听的端口号\r\n    port: '9994',\r\n    ROUTE_BASE_PATH: '/applet',\r\n\r\n    host: '填写开通 MySQL 时分配的内网IP',\r\n    user: '填写MySQL用户名',\r\n    password: '填写MySQL密码',\r\n    database: '填写上一步中创建的MySQL数据名',\r\n};\r\n示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json\r\n8. 启动新片预告 Demo在微信开发者工具将新片预告应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开新片预告Demo开始体验。主要功能实现获取视频列表、展示评论、提交评论通过node的mysql模块连接mysql，进行查询，插入操作以下是查询评论列表的示例代码const mysql = require('mysql');\r\nconst config = require('../../../config');\r\n\r\nlet vid = this.req.query.vid;\r\nif (!vid) {\r\n    this.res.json({ code: -1, msg: 'failed', data: {} });\r\n    return;\r\n}\r\n\r\n//CDB Mysql配置\r\nlet connection = mysql.createConnection({\r\n    host: config.host,\r\n    password: config.password,\r\n    user: config.user,\r\n    database: config.database\r\n});\r\n\r\n//开启数据库连接\r\nconnection.connect((err) => {\r\n    if (err) {\r\n        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n    }\r\n});\r\n\r\n//查询列表\r\nconnection.query('SELECT * from comment where vid = ? order by id desc', [vid], (err, result) => {\r\n    if (err) {\r\n        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n        return;\r\n    }\r\n\r\n    this.res.json({\r\n        code: 0,\r\n        msg: 'ok',\r\n        data: result,\r\n    });\r\n});\r\n\r\n//查询完后关闭连接\r\nconnection.end();\r\n播放视频<video src=\"{{videoUrl}}\" binderror=\"videoErrorCallback\"></video>\r\n属性名类型说明srcString要播放视频的资源地址binderrorEventHandle当发生错误时触发error事件，event.detail = {errMsg: 'something wrong'}播放视频使用的是video标签，目前官方文档上只给出了两个参数说明，笔者测试了src支持加载mp4和m3u8格式视频，video标签的控制条暂时没办法自定义样式以及隐藏"}
{"title": "微信小程序云端解决方案教程三：会话管理场景 ", "author": "天下雪", "pub_time": "2016-10-15 17:07", "content": "部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 配置云存储 Redis6. 配置云数据库 MongoDB7. 启动一笔到底示例 Node 服务实现会话层实现源代码微信小程序示例 - 一笔到底微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。微信的定位并不是 HTML5，这里很多人都有误解。在一些实现上，并不能想当然地用 HTML5 的思路来思考。比如，微信的请求接口 wx.request并不支持 cookie 传递，所以会话层不能使用传统的 Session 方式。这篇文章分享一个简单的画图应用，使用自己新鲜出炉的小程序会话管理能力来判断并当前用户的身份。小程序非常简单，使用 Canvas 绘图后，把序列化的 actions 提交给服务器保存。下次加载的时候，再列出用户曾经绘制过的图。部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署一笔到底的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 配置云存储 Redis会话管理依赖 Redis 进行作为缓存管理，开发者可以选择自行搭建 Redis 服务或者直接购买云存储 Redis 服务。6. 配置云数据库 MongoDB一笔到底小程序使用 MongoDB 来存储用户绘制的图像路径，要运行小程序开发者需要自行搭建 MongoDB 服务或者直接购买云数据库 MongoDB。7. 启动一笔到底示例 Node 服务在镜像的 nginx 配置中（/etc/nginx/conf.d），已经把/applet/session的请求转发到 http://127.0.0.1:5757处理。我们需要把 Node 服务运行起来。Node 代码部署在目录/data/release/qcloud-applet-session下。进入该目录：cd /data/release/qcloud-applet-session在该目录下有个名为config.js的配置文件（如下所示），根据注释将appId、appSecret、redisConfig、mongoConfig修改成自己的配置。module.exports = {    port: '5757',    ROUTE_BASE_PATH: '/applet',    // 微信小程序 App ID    appId: '',    // 微信小程序 App Secret    appSecret: '',    // Redis 配置    // @see https://www.npmjs.com/package/redis#options-object-properties    redisConfig: {        host: '',        port: '',        password: '',    },    // MongoDB 配置    // @see https://www.qcloud.com/doc/product/240/3979    mongoConfig: {        username: '',        password: '',        host: '',        port: '',        query: '?authMechanism=MONGODB-CR&authSource=admin',        database: 'qcloud-applet-session',    },};一笔到底示例使用 pm2 管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json实现会话层实现会话层实现包含两个部分：服务器端：https://github.com/CFETeam/weapp-session客户端：https://github.com/CFETeam/weapp-session-client我们的 Demo 直接使用这两个仓库，可以快速地拥有会话层的能力。会话层的实现和传统 Cookie 的实现方式类似，都是在 Header 上使用特殊的字段跟踪。一个请求的完整流程如下：客户端（微信小程序）发起请求 requestweapp-session-client 包装 request首次请求调用 wx.login() 和 wx.getUserInfo() 接口获得 code、rawData 和 signaturerequset 的头部带上 code、rawData 和 signature保存 code 供下次调用非首次请求request 的头部带上保存的 code服务器收到请求 request，中间件从头部提取 code、rawData 和 signature 字段如果 code 为空，跳到第 4 步如果 code 不为空，且 rawData 不为空，需要进行签名校验使用 code，appid、app_secret 请求微信接口获得 session_key 和 openid如果接口失败，响应 ERR_SESSION_KEY_EXCHANGE_FAILED使用签名算法通过 rawData 和 session_key 计算签名 signature2对比 signature 和 signature2签名一致，解析 rawData 为 wxUserInfo把 openid 写入到 wxUserInfo把 (code, wxUserInfo) 缓存到 Redis把 wxUserInfo 存放在 request.$wxUserInfo 里跳到第 4 步签名不一致，响应 ERR_UNTRUSTED_RAW_DATA如果 code 不为空，但 rawData 为空，从 Redis 根据 code 查询缓存的用户信息找到用户信息，存放在 request.$wxUserInfo 字段里，跳到第 4 步没找到用户信息（可能是过期），响应 ERR_SESSION_EXPIREDrequest 被业务处理，可以使用 request.$wxUserInfo 来获取用户信息（request.$wxUserInfo 可能为空，业务需要自行处理）源代码可从 Github 获取 https://github.com/CFETeam/weapp-session"}
{"title": "微信小程序架构分析《一》调试技巧，模块构成，理念分析 ", "author": "天下雪", "pub_time": "2016-10-15 17:21", "content": "本文分为以下几个部分：小程序调试技巧小程序主要模块构成小程序模块间通信设计理念分析小程序调试技巧微信开发者工具默认禁用了右键打开调试面板功能，我们可以修改开发者工具部分代码移除该限制。找到 app.nw 项目根目录，Mac 下为/Applications/wechatwebdevtools.app/Contents/Resources/app.nw使用 js-beautify 对代码批量格式化：cd /Applications/wechatwebdevtools.app/Contents/Resources/app.nw\r\nfind . -type f -name '*.js' -not -path \"./node_modules/*\" -not -path \"./modified_modules/*\" -exec js-beautify -r -s 2 -p -f '{}' \\;\r\n注释掉文件 app/dist/app.js 44 行和app/dist/components/simulator/webviewbody.js 149 行preventDefault 调用。101100 版本还需要修改 package.json 文件，去掉 --disable-devtools。执行完以上操作就可以右键打开页面的调试面板了，需要特别注意的是，使用 view 页面的面板后会导致 wxml 面板不可用，touch 事件无法响应等种种问题，请慎重使用。通过代码可以发现，在配置目录下添加 config.json 文件，然后加入{isDev:true} 可以启用开发者工具所谓的调试模式， 但是我在配置后程序无法正常启动，只好暂时先放弃这种方式。小程序主要模块构成小程序自身分为两个主要部分独立运行：view 模块和 service 模块。在开发者工具中，它们独立运行于不同的 webivew tag 中。view 模块负责 UI 显示，它由开发者编写的 wxml 和 wxss 转换后代码以及微信提供相关辅助模块组成。 一个 view 模块对应一个 webview 组件（也就是我们常规理解的一个页面）, 小程序支持同时多个 view 存在。view 模块通过 WeixinJSBridge 对象来跟后台通信。service 模块负责应用的后台逻辑，它由小程序的 js 代码以及微信提供的相关辅助模块组成。 一个应用只有一个 service 进程，它同样也是一个页面（至少在开发者工具内如此，上线后可能运行于 WeixinJSCore 之内），与 view 模块不同的是，它在程序生命周期内后台运行，service 模块通过与 view 模块实现不同但接口格式一样的 WeixinJSBridge 对象跟后台通信。小程序模块间通信(开发者工具内各模块通信图)做过微信开发相关的开发者会对 WeixinJSBridge 这个对象有所了解，它就是负责 UI 与后台 进行交互的一个中间层。应用号的 WeixinJSBridge 相比与之前的微信 webview 多出 publish 和 subscribe 两个公共方法来发布和订阅事件，从而进行双向通信。service 模块的 WeixinJSBridge 对象在文件app/dist/weapp/appservice/asdebug.js 中定义， view 层的 WeixinJSBridge 在文件 app/dist/inject/jweixindebug.js 中定义。 尽管两者都使用一样的接口以及使用 postMessage 方法与后台通信，但是其内部所做的事情确是完全不同的， 例如 service 模块可以直接通过 prompt 方法来通过 prompt调起底层组件，而 view 层的 WeixinJSBridge 只能发送消息 (参考 H5与Native交互之JSBridge技术)。我们来看一个典型的交互流程：用户点击界面触发事件对应 view 模块接收事件后将事件封装成所需格式后调用 publish 方法发送:WeixinJSBridge.publish('PAGE_EVENT', data)\r\ndata 参数举例：{\r\n\"data\": {\r\n  \"eventName\": \"onhidetap\",\r\n  \"data\": {\r\n    \"target\": {\r\n      ...\r\n    },\r\n    \"currentTarget\": {\r\n      ...\r\n    },\r\n    \"type\": \"tap\",\r\n    \"timeStamp\": 11457,\r\n    \"touches\": [ ...  ],\r\n    \"detail\": {\r\n      ...\r\n    }\r\n  }\r\n},\r\n\"options\": {\r\n  \"timestamp\": 1475445858336\r\n}\r\n}\r\n后台(开发者工具内为 nwjs 运行环境)将数据处理后发送给 service 模块，数据形如：{\r\n\"to\": \"appservice\",\r\n\"msg\": {\r\n  \"eventName\": \"PAGE_EVENT\",\r\n  \"data\": {\r\n    \"data\": {\r\n      \"eventName\": \"onhidetap\",\r\n      \"data\": {\r\n        \"target\": {\r\n          ...\r\n        },\r\n        \"currentTarget\": {\r\n          ...\r\n        },\r\n        \"type\": \"tap\",\r\n        \"timeStamp\": 75329,\r\n        \"touches\": [ ...  ],\r\n        \"detail\": {\r\n          ...\r\n        }\r\n      }\r\n    },\r\n    \"options\": {\r\n      \"timestamp\": 1475445858336\r\n    }\r\n  },\r\n  \"webviewID\": 0\r\n},\r\n\"command\": \"MSG_FROM_WEBVIEW\"\r\n}\r\nservice 模块的 WeixinJSBridge 内回调函数依据传来数据找到对应 view 的 page 模块后执行 对应名为 eventName 指向的函数回调函数调用 this.setData({hidden: true}) 改变 data，serivce 层计算该页面 data 后向后台发送 send_app_data 和 appdataChange 事件，具体数据格式如下：{\r\n\"appData\": {\r\n  \"page/index\": {\r\n    ...\r\n  }\r\n},\r\n\"sdkName\": \"send_app_data\",\r\n\"to\": \"backgroundjs\",\r\n\"comefrom\": \"webframe\",\r\n\"command\": \"COMMAND_FROM_ASJS\",\r\n\"appid\": \"touristappid\",\r\n\"appname\": \"chat\",\r\n\"apphash\": 70475629,\r\n\"webviewID\": 100000\r\n}\r\n{\r\n\"eventName\": \"appDataChange\",\r\n\"data\": {\r\n  \"data\": {\r\n    \"data\": {\r\n      \"hidden\": true\r\n    }\r\n  },\r\n  \"options\": {\r\n    \"timestamp\": 1475528706311\r\n  }\r\n},\r\n\"sdkName\": \"publish\",\r\n\"webviewIds\": [\r\n  0\r\n],\r\n\"to\": \"backgroundjs\",\r\n\"comefrom\": \"webframe\",\r\n\"command\": \"COMMAND_FROM_ASJS\",\r\n\"appid\": \"touristappid\",\r\n\"appname\": \"chat\",\r\n\"apphash\": 70475629,\r\n\"webviewID\": 100000\r\n}\r\n后台(文件 dist/components/simulator/webviewbody.js) 接收到appDataChange 事件数据后再将数据进行简单封装， 最后转发给到 view 层。 具体数据格式为：{\r\n\"to\": \"webframe\",\r\n\"msg\": {\r\n  \"eventName\": \"appDataChange\",\r\n  \"data\": {\r\n    \"data\": {\r\n      \"data\": {\r\n        \"hidden\": true\r\n      }\r\n    },\r\n    \"options\": {\r\n      \"timestamp\": 1475528706311\r\n    }\r\n  },\r\n  \"sdkName\": \"publish\",\r\n  \"webviewIds\": [\r\n    0\r\n  ],\r\n  \"to\": \"backgroundjs\",\r\n  \"comefrom\": \"webframe\",\r\n  \"command\": \"COMMAND_FROM_ASJS\",\r\n  \"appid\": \"touristappid\",\r\n  \"appname\": \"chat\",\r\n  \"apphash\": 70475629,\r\n  \"webviewID\": 100000,\r\n  \"act\": \"sendMsgFromAppService\"\r\n},\r\n\"command\": \"MSG_FROM_APPSERVICE\",\r\n\"webviewID\": 0,\r\n\"id\": 0.10577065353216675\r\n}\r\nview 层的 WeixinJSBridge 接收到后台的数据，如果 webviewID 匹配则将 data 与现有页面 data 合并， 然后就是 virtual dom 模块进行 diff 和 apply 操作改变 dom。小程序模块间消息传递除了界面事件和应用数据还包括触发原生方法、握手以及生命周期等类型， 尽管处理对象和处理方式不同，大体流程跟上面是一样的。view 模块和 service 模块的 WeixinJSBridge 都使用了 postMessage 接口 (参考MDN 文档) 与后台通信，但是由于该接口无法直接与 nwjs 后台进程通信，所以开发者工具会将 app/dist/contentscript/contentScript.js 文件做为contentScript 注入到 view 模块和 service 模块所在页面，contentScript.js 的代码提供了 message 消息到 chrome.runtime通信接口的转换。微信开发者工具扩展了 devtools 提供了 AppData 面板，开发者可以修改里面数据然后直接看到 view 界面的变化效果。这里修改数据后 nwjs 会将消息发送给 service 层，之后发生的事就跟上面 4 5 6 步一样：service 传递消息给 nwjs，最后到 view 层。设计理念分析小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 js 代码里面是不能直接使用浏览器提供的 DOM 和 BOM 接口的，这一方面是因为 js 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM 接口，它们对应的 也是 service 模块页面，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。理解了以上机制，再对 view 模块和 service 模块的 WeixinJSBridge 加以改造，我们便不难做到让 小程序跑在自己的环境下，这样就可以做些手机调试以及单页面测试等操作。"}
{"title": "微信小程序架构分析《二》：view 模块和 service 模块的构成 ", "author": "天下雪", "pub_time": "2016-10-15 17:27", "content": "你可以在app.nw/app/dist/weapp/tpl/pageFrameTpl.js 和app.nw/app/dist/weapp/tpl/appserviceTpl.js 文件内找到页面的模板。打开微信 web 开发者工具，然后输入 openVendor() 便会打开 WeappVendor这个目录，这里包含了 view 模块和 service 模块使用的几个核心文件：wcc 可执行程序，用于将 wxml 转为 view 模块使用的 js 代码，使用方式为wcc xxx.wxmlwcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 wcsc xxx.wxssWAService.js 提供 service 模块大部分功能，下面会有详细介绍WAWebview.js 提供 view 模块大部分功能，下面会有详细介绍view 页面详解view 页面的 template 如下：<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <meta charset=\"UTF-8\" />\r\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" />\r\n\r\n  <script>\r\n    var __webviewId__;\r\n  </script>\r\n\r\n  <!-- percodes -->\r\n\r\n  <!--{{WAWebview}}-->\r\n\r\n  <!--{{reportSDK}}-->\r\n\r\n  <!--{{webviewSDK}}-->\r\n\r\n  <!--{{exparser}}-->\r\n\r\n  <!--{{components_js}}-->\r\n\r\n  <!--{{virtual_dom}}-->\r\n\r\n  <!--{{components_css}}-->\r\n\r\n  <!--{{allWXML}}-->\r\n\r\n  <!--{{eruda}}-->\r\n\r\n  <!--{{style}}-->\r\n\r\n  <!--{{currentstyle}}-->\r\n\r\n  <!--{{generateFunc}}-->\r\n</head>\r\n\r\n<body>\r\n  <div></div>\r\n</body>\r\n\r\n</html>\r\n其中 <!-- percodes --> 会在 dev 模式开启后被替换为一个时间锚点，例如：<script>var pageFrameStartTime = new Date();</script>\r\n<!--{{WAWebview}}--> 会被 WAWebview.js 内代码替换<!--{{WAWebview}}--> 到 <!--{{generateFunc}}--> 之间暂时没有被使用到<!--{{generateFunc}}--> 会被 wcc 命令生成后的 js 代码替换除了上面这些，页面上还会被插入页面和应用的 style 标签，如：<link rel=\"stylesheet\" type=\"text/css\" href=\"index.wxss\">\r\n这里的 wxss 文件包含的是原始 wxss 文件转换后的 css以及生成 DOM 的启动脚本：<script>\r\n  document.dispatchEvent(new CustomEvent(\"generateFuncReady\", {\r\n    detail: {\r\n      generateFunc: $gwx('./page/index.wxml')\r\n    }\r\n  }))\r\n</script>\r\nWAWebview.js 文件中的各个模块(行号为 jsbeautify 之后代码行号，开发者工具版本：092300)：1-77 行： WeixinJSBridge 对象兼容层，这个大概只会在调试时用到，因为开发时和运行时页面都会被后台以注入的方式添加 WeixinJSBridge 这个对象。我们可以通过这段代码看到它暴露的方法： invoke invokeCallbackHandleron publish subscribe subscribe subscribeHandler。78-235 行：Reporter 对象，它的作用就是发送错误和性能统计数据给后台236-596 行：wx 对象，页面的核心之一，一方面封装 WeixinJSBridge 的 invokeMethod 方位为易于调用的形式（例如 redirectTo, navigateTo等），另一方面封装 WeixinJSBridge 回调方法，调用者可以使用wx.onAppDataChange(callback) 添加数据变更的回调函数，最后提供wx.publishPageEvent 发送页面事件到后台607-1267 行：wxparser 对象，提供 dom 到 wx element 对象之间的映射操作，提供元素操作管理和事件管理功能1268-1285 行：转发 window 上的 animation 和 transition 相关的动画事件到 exparser1286-1313 行：订阅并转发 WeixinJSBridge 提供的全局事件到 exparser1324-1345 行：转发 window 上的 error 以及各种表单事件到 exparser1347-3744 行：使用 exparser.registerBehavior 和exparser.registerElement 方法注册各种以 wx- 做为标签开头的元素到 exparser3744-4498 行：virtual dom 渲染算法实现，提供 diff apply render 等方法，该模块接口基本与 virtual-dom 一致，这里特别的地方在于它所 diff 和生成的并不是原生 DOM，而是各种模拟了 DOM 接口的 wx element 对象4599-4510 行：插入默认样式到页面从页面 data 到 dom 的主要流程如下：var vtree\r\nvar rootNode\r\n\r\ndocument.addEventListener(\"generateFuncReady\", function(e) {\r\n  var generateFunc = e.detail.generateFunc;\r\n  wx.onAppDataChange(function(obj) {\r\n    // 合并 data 到现有 data\r\n    DataStore.setData(obj.data)\r\n    // 生成 virtual dom 的 javascript plain object\r\n    var props = generateFunc(DataStore.getData())\r\n\r\n    // 第一次渲染\r\n    if (obj.options.firstRender) {\r\n      vtree = createVirtualTree(props, true)\r\n      rootNode = vtree.render()\r\n      rootNode.replaceDocumentElement(document.body)\r\n      wx.initReady()\r\n    } else {\r\n      var other_vtree = createVirtualTree(props, false)\r\n      var patches = vtree.diff(other_vtree)\r\n      patches.apply(rootNode)\r\n      vtree = other_vtree\r\n      document.dispatchEvent(new CustomEvent(\"pageReRender\", {}));\r\n    }\r\n  })\r\n})\r\n上面的 DataStore 对象提供合并和获取当前页面 data 对象的功能，其实现如下：var DataStore = (function() {\r\n  var data = {}\r\n  return {\r\n    getData: function() {\r\n      return data\r\n    },\r\n    setData: function(e) {\r\n      for (var t in e) {\r\n        for (var n = (0, parsePath)(t), o = data, a = void 0, s = void 0, c = 0; c < n.length; c++) Number(n[c]) === n[c] && Number(n[c]) % 1 === 0 ? Array.isArray(o) || (a[s] = [], o = a[s]) : \"[object Object]\" !== Object.prototype.toString.call(o) && (a[s] = {}, o = a[s]), s = n[c], a = o, o = o[n[c]];\r\n        a && (a[s] = e[t])\r\n      }\r\n    }\r\n  }\r\n})()\r\n\r\n// 解析 key 为 data 内对象的路径字符串\r\nfunction parsePath(e) {\r\n  for (var t = e.length, n = [], i = \"\", r = 0, o = !1, a = !1, s = 0; s < t; s++) {\r\n    var c = e[s];\r\n    if (\"\\\\\" === c) s + 1 < t && (\".\" === e[s + 1] || \"[\" === e[s + 1] || \"]\" === e[s + 1]) ? (i += e[s + 1], s++) : i += \"\\\\\";\r\n    else if (\".\" === c) i && (n.push(i), i = \"\");\r\n    else if (\"[\" === c) {\r\n      if (i && (n.push(i), i = \"\"), 0 === n.length) throw new Error(\"path can not start with []: \" + e);\r\n      a = !0, o = !1\r\n    } else if (\"]\" === c) {\r\n      if (!o) throw new Error(\"must have number in []: \" + e);\r\n      a = !1, n.push(r), r = 0\r\n    } else if (a) {\r\n      if (c < \"0\" || c > \"9\") throw new Error(\"only number 0-9 could inside []: \" + e);\r\n      o = !0, r = 10 * r + c.charCodeAt(0) - 48\r\n    } else i += c\r\n  }\r\n  if (i && n.push(i), 0 === n.length) throw new Error(\"path can not be empty\");\r\n  return n\r\n}\r\n可以看到，每次 data 变化之后，小程序就会开始整个页面的 diff patch 过程。对于原生实现的组件， exparser 会在监视到数据变化后发送对应事件到 WeixinJSBridge。service 页面详解service 页面会被被拼接为以下的样子：<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <script>\r\n  var __wxAppData = {}\r\n  var __wxRoute\r\n  var __wxRouteBegin\r\n  </script>\r\n  <script>var __wxConfig = {\"pages\":[\"page/index\"],\r\n  // app 相关各种配置\r\n  }</script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/asdebug.js\"></script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/WAService.js\"></script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/app.js\"></script>\r\n  <script>\r\n    __wxRoute = 'page/index';\r\n    __wxRouteBegin = true\r\n  </script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/page/index.js\"></script>\r\n</head>\r\n\r\n<body>\r\n  <script>\r\n    window._____sendMsgToNW({\r\n      sdkName: 'APP_SERVICE_COMPLETE'\r\n    })\r\n  </script>\r\n</body>\r\n\r\n</html>\r\n除了配置和开发者编写的页面、app.js，页面还在加载了 asdebug.js 和 WAService.js 两个文件。asdebug.js 文件位于 nwjs 项目目录下，路径为app/dist/weapp/appservice/asdebug.js。 它包含了两个部分，一个是 WeixinJSBridge 针对 service 模块的实现，另一块是一些方便命令使用的接口， 例如：help() 会告诉你一些可用的函数：该文件只会在开发者工具内被引入，如果小程序在微信内运行，应该会由微信底层提供 WeixinJSBridge。WAService 负责 service 模块的一些核心逻辑，它包含以下部分 (行号为 jsbeautify 之后代码行号，开发者工具版本：092300)：1-78 行： 跟 WAWebview.js 一样的 WeixinJSBridge 兼容模块79-245 行： 跟 WAWebview.js 一样的 Reporter 模块246-1664 行：比 WAWebview.js 中 wx 功能更为丰富 wx 接口模块1665-2304 行：appServiceEngine 模块，提供 Page，App，GetApp 接口2305-2360 行： 为 window 对象添加 AMD 接口 require define现在的 WAService 还有有很多地方依赖 window 对象，所以很有可能它在微信中和开发者工具内一样，依然运行于 webview 标签之内。"}
{"title": "微信小程序架构分析《三》：实现过程以及实时更新 ", "author": "天下雪", "pub_time": "2016-10-15 17:36", "content": "小程序实时运行工具 wept 的开发已经基本完成了， 你可以通过我的代码对小程序的 web 环境实现有更全面的认识。下面我将介绍它的实现过程以及实时更新的原理。小程序 web 服务实现我在 wept 的开发中使用 koa 提供 web 服务，以及 et-improve 提供模板渲染。第一步： 准备页面模板我们需要三个页面，一个做为控制层 index.html，一个做为 service 层service.html，还有一个做为 view 层的 view.htmlindex.html:<div class=\"head\">\r\n</div>\r\n<div class=\"scrollable\">\r\n</div>\r\n<div class=\"tabbar-root\">\r\n</div>\r\n<script>\r\n  var __wxConfig__ = {{= _.config}}\r\n  var __root__ = '{{= _.root}}'\r\n</script>\r\n<script src=\"/script/build.js\"></script>\r\nservice.html:<head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <script>\r\n  var __wxAppData = {}\r\n  var __wxRoute\r\n  var __wxRouteBegin\r\n  global = {}\r\n  var __wxConfig = {{= _.config}}\r\n  </script>\r\n  <script src=\"/script/bridge.js\" type=\"text/javascript\"></script>\r\n  <script src=\"/script/service.js\" type=\"text/javascript\"></script>\r\n  {{each _.utils as util}}\r\n  <script src=\"/app/{{= util}}\" type=\"text/javascript\"></script>\r\n  {{/}}\r\n  <script src=\"/app/app.js\" type=\"text/javascript\"></script>\r\n  {{each _.routes as route}}\r\n  <script> var __wxRoute = '{{= route | noext}}', __wxRouteBegin = true;</script>\r\n  <script src=\"/app/{{= route}}\" type=\"text/javascript\"></script>\r\n  {{/}}\r\n</head>\r\n<body>\r\n  <script>\r\n    window._____sendMsgToNW({\r\n      sdkName: 'APP_SERVICE_COMPLETE'\r\n    })\r\n  </script>\r\n</body>\r\nview.html:<head>\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <meta charset=\"UTF-8\" />\r\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" />\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/default.css\">\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/app/app.wxss\">\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/app/{{= _.path}}.wxss\">\r\n  <script> var __path__ = '{{= _.path}}'</script>\r\n  <script src=\"/script/ViewBridge.js\" async type=\"text/javascript\"></script>\r\n  <script src=\"/script/view.js\" type=\"text/javascript\"></script>\r\n  <script>\r\n  {{= _.inject_js}}\r\n  </script>\r\n  <script>\r\n    document.dispatchEvent(new CustomEvent(\"generateFuncReady\", {\r\n      detail: {\r\n        generateFunc: $gwx('./{{= _.path}}.wxml')\r\n      }\r\n    }))\r\n  </script>\r\n</head>\r\n<body>\r\n  <div></div>\r\n</body>\r\n第二步： 实现 http 服务用 koa 实现的代码逻辑非常简单：server.js// 日志中间件\r\napp.use(logger())\r\n// gzip\r\napp.use(compress({\r\n  threshold: 2048,\r\n  flush: require('zlib').Z_SYNC_FLUSH\r\n}))\r\n// 错误提醒中间件\r\napp.use(notifyError)\r\n// 使用当前目录下文件处理 404 请求\r\napp.use(staticFallback)\r\n// 各种 route 实现\r\napp.use(router.routes())\r\napp.use(router.allowedMethods())\r\n// 对于 public 目录启用静态文件服务\r\napp.use(require('koa-static')(path.resolve(__dirname, '../public')))\r\n// 创建启动服务\r\nlet server = http.createServer(app.callback())\r\nserver.listen(3000)\r\nrouter.jsrouter.get('/', function *() {\r\n  // 加载 index.html 模板和数据，输出 index 页面\r\n})\r\n\r\nrouter.get('/appservice', function *() {\r\n  // 加载 service.html 模板和数据，输出 service 页面\r\n})\r\n\r\n// 让 `/app/**` 加载小程序所在目录文件\r\nrouter.get('/app/(.*)', function* () {\r\n  if (/\\.(wxss|js)$/.test(file)) {\r\n    // 动态编译为 css 和相应 js\r\n  } else if (/\\.wxml/.test(file)) {\r\n    // 动态编译为 html\r\n  } else {\r\n    // 查找其它类型文件, 存在则返回\r\n    let exists = util.exists(file)\r\n    if (exists) {\r\n      yield send(this, file)\r\n    } else {\r\n      this.status = 404\r\n      throw new Error(`File: ${file} not found`)\r\n    }\r\n  }\r\n})\r\n第三步：实现控制层功能实现完上面两步，就可以访问 view 页面了，但是你会发现它只能渲染，并不会有任何功能，因为 view 层功能依赖于控制层进行的通讯， 如果控制层收不到消息，它不会响应任何事件。控制层是整个实现过程中最复杂的一块，因为官方工具的代码与 nwjs 以及 react 等第三方组件耦合过高，所以无法拿来直接使用。 你可以在 wept 项目的 src 目录下找到控制层逻辑的所有代码，总体上控制层要负责以下几个功能：实现 service 层，view 层以及控制层之间的通讯逻辑依据路由指令动态创建 view （wept 使用 iframe 实现）根据当前页面动态渲染 header 和 tabbar实现原生 API 调用，返回结果给 service 层wept 里面 iframe 之间的通讯是通过 message.js 模块实现的，控制页面（index.html）代码如下：window.addEventListener('message', function (e) {\r\n  let data = e.data\r\n  let cmd = data.command\r\n  let msg = data.msg\r\n  // 没有跟 contentscript 握手阶段，不需要处理\r\n  if (data.to == 'contentscript') return\r\n  // 这是个遗留方法，基本废弃掉了\r\n  if (data.command == 'EXEC_JSSDK') {\r\n    sdk(data)\r\n  // 直接转发 view 层消息到 service，主要是各种事件通知\r\n  } else if (cmd == 'TO_APP_SERVICE') {\r\n    toAppService(data)\r\n  // 除了 publish 发送消息给 view 层以及控制层可以处理的逻辑（例如设置标题），\r\n  // 其它全部转发 service 处理，所有控制层的处理结果统一先返回 service\r\n  } else if (cmd == 'COMMAND_FROM_ASJS') {\r\n    let sdkName = data.sdkName\r\n    if (command.hasOwnProperty(sdkName)) {\r\n      command[sdkName](data)\r\n    } else {\r\n      console.warn(`Method ${sdkName} not implemented for command!`)\r\n    }\r\n  } else {\r\n    console.warn(`Command ${cmd} not recognized!`)\r\n  }\r\n})\r\n具体实现逻辑可以查看 src/command.js src/service.jssrc/sdk/*.js。对于 view/service 页面只需把原来 bridge.js 的window.postMessage 改为 window.top.postMessage 即可。view 层的控制逻辑由 src/view.js 以及 src/viewManage.js 实现，viewManage 实现了 navigateTo， redirectTo 以及 navigateBack 来响应 service 层通过名为 publish 的 command 传来的对应页面路由事件。header.js 和 tabbar.js 包含了基于 react 实现的 header 和 tabbar 模块（原计划是使用 vue，但是没找到与原生 js 模块通讯的 API）sdk 目录下包含了 storage，录音，罗盘模块，其它比较简单一些的原生底层调用我直接写在 command.js 里面了。以上就是实现运行小程序所需 webserver 的全部逻辑了，其实现并不复杂，主要困难在与理解微信这一整套通讯方式。实现小程序实时更新第一步： 监视文件变化并通知前端wept 使用了 chokidar 模块监视文件变化，变化后使用 WebSocket 告知所有客户端进行更新操作。 具体实现位于 lib/watcher.js 和 lib/socket.js, 发送内容是 json 格式的字符串。前端控制层收到 WebSocket 消息后再通过 postMessage 接口转发消息给 view/service 层：view.postMessage({\r\n  msg: {\r\n    data: {\r\n      data: { path }\r\n    },\r\n    eventName: 'reload'\r\n  },\r\n  command: 'CUSTOM'\r\n})\r\nview/service 层监听 reload 事件：WeixinJSBridge.subscribe('reload', function(data) {\r\n  // data 即为上面的 msg.data\r\n})\r\n第二步： 前端响应不同文件变化前端需要对 4 种（wxml wxss json javascript）不同类型文件进行 4 种不同的热更新处理，其中 wxss 和 json 相对简单。wxss 文件变化后前端控制层通知（postMessage 接口）对应页面（如果是 app.wxss 则是所有 view 页面）进行刷新，view 层收到消息后只需要更改对应 css 文件的时间戳就可以了，代码如下：o.subscribe('reload', function(data) {\r\n    if (/\\.wxss$/.test(data.path)) {\r\n    var p = '/app/' + data.path\r\n    var els = document.getElementsByTagName('link')\r\n    ;[].slice.call(els).forEach(function(el) {\r\n      var href = el.getAttribute('href').replace(/\\?(.*)$/, '')\r\n      if (p == href) {\r\n        console.info('Reload: ' + data.path)\r\n        el.setAttribute('href', href + '?id=' + Date.now())\r\n      }\r\n    })\r\n  }\r\n})\r\njson 文件变化首先需要判断，如果是 app.json 我们无法热更新，所以目前做法是刷新页面，对于页面的 json， 我们只需要在控制层上对 header 设置相应状态就可以了 (渲染工作由 react 帮我们处理)：socket.onmessage = function (e) {\r\n  let data = JSON.parse(e.data)\r\n  let p = data.path\r\n  if (data.type == 'reload'){\r\n    if (p == 'app.json') {\r\n      redirectToHome()\r\n    } else if (/\\.json$/.test(p)) {\r\n      let win = window.__wxConfig__['window']\r\n      win.pages[p.replace(/\\.json$/, '')] = data.content\r\n      // header 通过全局 __wxConfig__ 获取 state 进行渲染\r\n      header.reset()\r\n      console.info(`Reset header for ${p.replace(/\\.json$/, '')}`)\r\n    }\r\n  }\r\n}\r\nwxml 使用 VirtualDom API 提供的 diff apply 进行处理。首先需要一个接口获取新的 generateFunc 函数（用于生成 VirtualDom）， 添加 koa 的 router：router.get('/generateFunc', function* () {\r\n  this.body = yield loadFile(this.query.path + '.wxml')\r\n  this.type = 'text'\r\n})\r\n\r\nfunction loadFile(p, throwErr = true) {\r\n  return new Promise((resolve, reject) => {\r\n    fs.stat(`./${p}`, (err, stats) => {\r\n      if (err) {\r\n        if (throwErr) return reject(new Error(`file ${p} not found`))\r\n        // 文件不存在有可能是文件被删除，所以不能使用 reject\r\n        return resolve('')\r\n      }\r\n      if (stats && stats.isFile()) {\r\n        // parer 函数调用 exec 命令执行 wcsc 文件生成 wxml 对应的 javascript 代码\r\n        return parser(`${p}`).then(resolve, reject)\r\n      } else {\r\n        return resolve('')\r\n      }\r\n    })\r\n  })\r\n}\r\n有了接口就可以请求接口，然后执行返回函数进行 diff apply：// curr 为当前的 VirtualDom 树\r\nif (!curr) return\r\nvar xhr = new XMLHttpRequest()\r\nxhr.onreadystatechange = function() {\r\n  if (xhr.readyState === 4) {\r\n    if (xhr.status === 200) {\r\n      var text = xhr.responseText\r\n      var func = new Function(text + '\\n return $gwx(\"./' +__path__+ '.wxml\")')\r\n      window.__generateFunc__ = func()\r\n      var oldTree = curr\r\n      // 获取当前 data 生成新的树\r\n      var o = m(p.default.getData(), false),\r\n      // 进行 diff apply\r\n      a = oldTree.diff(o);\r\n      a.apply(x);\r\n      document.dispatchEvent(new CustomEvent(\"pageReRender\", {}));\r\n      console.info('Hot apply: ' + __path__ + '.wxml')\r\n    }\r\n  }\r\n}\r\nxhr.open('GET', '/generateFunc?path=' + encodeURIComponent(__path__))\r\nxhr.send()\r\njavascript 更新逻辑相对复杂一些, 首先依然是一个接口来获取新的 javascript 代码：router.get('/generateJavascript', function* () {\r\n  this.body = yield loadFile(this.query.path)\r\n  this.type = 'text'\r\n})\r\n然后我们在 window 对象上加入 Reload 函数执行具体的更换逻辑：window.Reload = function (e) {\r\nvar pages = __wxConfig.pages;\r\nif (pages.indexOf(window.__wxRoute) == -1) return\r\n// 替换原来的构造函数\r\nf[window.__wxRoute] = e\r\nvar keys = Object.keys(p)\r\n// 判定是否当前使用中页面\r\nvar isCurr = s.route == window.__wxRoute\r\nkeys.forEach(function (key) {\r\n  var o = p[key];\r\n  key = Number(key)\r\n  var query = o.__query__\r\n  var page = o.page\r\n  var route = o.route\r\n  // 页面已经被创建\r\n  if (route == window.__wxRoute) {\r\n    // 执行封装后的 onHide 和 onUnload\r\n    isCurr && page.onHide()\r\n    page.onUnload()\r\n    // 创建新 page 对象\r\n    var newPage = new a.default(e, key, route)\r\n    newPage.__query__ = query\r\n    // 重新绑定当前页面\r\n    if (isCurr) s.page = newPage\r\n    o.page = newPage\r\n    // 执行 onLoad 和 onShow\r\n    newPage.onLoad()\r\n    if (isCurr) newPage.onShow()\r\n    // 更新 data 数据\r\n    window.__wxAppData[route] = newPage.data\r\n    window.__wxAppData[route].__webviewId__ = key\r\n    // 发送更新事件, 通知 view 层\r\n    u.publish(c.UPDATE_APP_DATA)\r\n    u.info(\"Update view with init data\")\r\n    u.info(newPage.data)\r\n    // 发送 appDataChange 事件\r\n    u.publish(\"appDataChange\", {\r\n      data: {\r\n        data: newPage.data\r\n      },\r\n      option: {\r\n        timestamp: Date.now()\r\n      }\r\n    })\r\n    newPage.__webviewReady__ = true\r\n  }\r\n})\r\nu.info(\"Reload page: \" + window.__wxRoute)\r\n}\r\n以上代码需要添加到 t.pageHolder 函数后才可运行最后在 view 层初始化后把 Page 函数切换到 Reload 函数(当然你也可以在请求返回 javascript 前把 Page 重命名为 Reload) 。<body>\r\n<script>\r\n  window._____sendMsgToNW({\r\n    sdkName: 'APP_SERVICE_COMPLETE'\r\n  })\r\n</script>\r\n</body>\r\n总算是把这个坑填上了。希望通过这一系列的分析带给前端开发者更多思路。"}
{"title": "微信小程序开发教程：Flex布局 ", "author": "天下雪", "pub_time": "2016-10-15 21:22", "content": "微信小程序页面布局方式采用的是Flex布局。Flex布局，是W3c在2009年提出的一种新的方案，可以简便，完整，响应式的实现各种页面布局。Flex布局提供了元素在容器中的对齐，方向以及顺序，甚至他们可以是动态的或者不确定的大小的。Flex布局的主要特征是能够调整其子元素在不同的屏幕大小中能够用最适合的方法填充合适的空间。Flex布局的特点:任意方向的伸缩，向左，向右，向下，向上在样式层可以调换和重排顺序主轴和侧轴方便配置子元素的空间拉伸和填充沿着容器对齐微信小程序实现了Flex布局,简单介绍下Flex布局在微信小程序中的使用。伸缩容器设有display:flex或者display:block的元素就是一个flex container(伸缩容器)，里面的子元素称为flex item(伸缩项目)，flex container中子元素都是使用Flex布局排版。display:block 指定为块内容器模式，总是使用新行开始显示，微信小程序的视图容器(view,scroll-view和swiper)默认都是dispaly:block。display:flex:指定为行内容器模式，在一行内显示子元素，可以使用flex-wrap属性指定其是否换行，flex-wrap有三个值:nowrap(不换行),wrap(换行),wrap-reverse(换行第一行在下面)使用display:block(默认值)的代码:  <view class=\"flex-row\" style=\"display: block;\">        <view class=\"flex-view-item\">1</view>        <view class=\"flex-view-item\">2</view>        <view class=\"flex-view-item\">3</view>    </view>显示效果:改换成display:flex的显示效果:可以从效果图看到block和flex的区别，子元素view是在换行显示(block)还是行内显示(flex)。主轴和侧轴Flex布局的伸缩容器可以使用任何方向进行布局。容器默认有两个轴：主轴(main axis)和侧轴(cross axis)。主轴的开始位置为主轴起点(main start)，主轴的结束位置为主轴终点(main end),而主轴的长度为主轴长度(main size)。同理侧轴的起点为侧轴起点(cross start),结束位置为侧轴终点(cross end),长度为侧轴长度(cross size)。详情见下图:注意，主轴并不是一定是从左到右的，同理侧轴也不一定是从上到下，主轴的方向使用flex-direction属性控制,它有4个可选值:row :从左到右的水平方向为主轴row-reverse：从右到左的水平方向为主轴column:从上到下的垂直方向为主轴column-reverse从下到上的垂直方向为主轴如果水平方向为主轴，那个垂直方向就是侧轴，反之亦然。四种主轴方向设置的效果图:图中的实例展示了使用了不同的flex-direction值排列方向的区别。实例代码:<view >    <view class=\"flex-row\" style=\"display: flex;flex-direction: row;\">        <view class=\"flex-view-item\">1</view>        <view class=\"flex-view-item\">2</view>        <view class=\"flex-view-item\">3</view>    </view>    <view class=\"flex-column\" style=\"display:flex;flex-direction: column;\" >        <view class=\"flex-view-item\">c1</view>        <view class=\"flex-view-item\">c2</view>        <view class=\"flex-view-item\">c3</view>    </view></view>运行效果：对齐方式子元素有两种对齐方式：justify-conent 定义子元素在主轴上面的对齐方式align-items 定义子元素在侧轴上对齐的方式jstify-content有5个可选的对齐方式:flex-start 主轴起点对齐(默认值)flex-end 主轴结束点对齐center 在主轴中居中对齐space-between 两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等space-around 每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同。justify-content的对齐方式和主轴的方向有关，下图以flex-direction为row，主轴方式是从左到右,描述jstify-content5个值的显示效果:align-items表示侧轴上的对齐方式:stretch 填充整个容器(默认值)flex-start 侧轴的起点对齐flex-end 侧轴的终点对齐center 在侧轴中居中对齐baseline 以子元素的第一行文字对齐align-tiems设置的对齐方式，和侧轴的方向有关，下图以flex-direction为row,侧轴方向是从上到下,描述align-items的5个值显示效果:有了主轴和侧轴的方向再加上设置他们的对齐方式，就可以实现大部分的页面布局了。案例地址：https://github.com/jjz/weixin-mina/blob/master/pages/flex/flex.wxml"}
{"title": "梁兴臣:微信小程序开发三宗罪和解决方案 ", "author": "天下雪", "pub_time": "2016-10-15 22:33", "content": "在微信公布小程序的文档和开发工具后，脉冲软件在第一时间进行了学习和体验，我们发现微信小程序的技术架构和开发体验让我们非常失望。由于微信小程序的运行环境并不是一个标准的浏览器环境，而且微信的封装工作并不完善，所以我们以往开发中的很多经验并不适用。这并非简单的开发习惯不适应，更重要的是我们的开发流程、规范将不适用。微信小程序开发第一宗罪: 无法调用NPM包虽然微信小程序开发工具打包时实现了require函数加载依赖，但并不是完整的CommonJS依赖管理。因为require函数仅仅能够加载项目中的JS文件，而且必须严格定义JS文件路径，路径不支持CommonJS的路径风格。例如如下加载方式都将出错：require('lodash');require('lodash/map');require('./foo');在微信小程序开发工具中，我们必须对应写为如下格式：require('node_modules/lodash/lodash.js');require('node_modules/lodash/map.js');require('./foo.js');虽然我们可以像上面代码一样加载node_modules目录中的库，但是实际运行时却发生了：在调试工具的Network选项卡中，我们看到运行时加载了1000多个文件，总数据量1.8MB，而我们仅仅是在代码中加载了一个lodash库而已！这是因为微信小程序开发工具会将所有项目下的js文件视为项目文件，并进行打包。而实际开发中，我们需要安装很多的NPM扩展库，而这些扩展库中有大量的不需要打包的文件，例如lodash中有上千文件，而我们只需要用到其中的非常少的一部分。另外，在开发中，我们往往需要安装babal、eslient、webpack、grunt等待开发工具，微信小程序开发工具会一视同仁将这些工具的源码也进行打包......实测开发者工具将崩溃！开发者将崩溃！我崩溃！所以不支持NPM包的原因，是微信开发者工具不支持CommonJS标准，不支持CommonJS标准的原因，是微信开发者工具想当然地认为项目目录下的js文件一定是项目文件，所以只实现了简单的require函数，想当然的原因是。。。微信小程序开发第二宗罪: 无法使用Babel转码无法使用Babel转码的原因其实仍然归结于无法加载NPM库。但是后果将十分严重。因为你将不能再安全使用ES6/7特性，你将无法使用async/await函数，你将和无尽的callback做斗争，你该怎样描述自己？回调地狱中的苦逼程序员？如果你看到这里不明白Babel为何物，那么祝贺你，因为不曾见过天堂就不知何为地狱，你无须为不支持ES6/7而烦恼。但一旦你的大脑支持了ES6/7，用过了Babel，你就回不去了，像我一样，无Babel不编码。微信小程序开发第三宗罪: 无法重用组件其实微信小程序开发是并非完全不能重用组件，比如WXML语法中支持import和 include。但是那仅仅是视图模板可重用，并非组件可重用，因为我们认为组件在应当包含视图和逻辑。WXML其实是基于可重用的组件，但是不允许我们自定义组件。如果你有React经验，你就会明白我的意思。例如，你的小程序是个电商APP，项目中有两个页面中同时包含了商品列表组件，比如某分类下商品列表和搜索结果列表，我们知道这两个列表其实仅仅是参数不同而已。但是在小程序开发中，你只能将列表的模板抽象出来，不能将逻辑抽象出来，所以你就需要在两个页面上都实现一遍列表组件的控制逻辑，比如刷新、加载更多。。。我们的实践只吐槽、管杀不管埋是不道德的，既然发现了微信小程序开发中的各种弊端，我们脉冲软件在开发之中总结出了一套流程和工具，专为解决上述三个问题，并免费发布到了开源社区，这就是Labrador。接下来我们一起来尝试一下我们脉冲软件的开发体验。安装Labrador通过命令 npm install -g labrador-cli 全局安装Labrador控制行工具。初始化项目通过如下命令新建一个Labrador项目：mkdir democd demonpm initlabrador init项目初始化完成后，该目录是这个样子的：图中的src是我们的源码目录，node_modules是NPM包目录，dist是目标输出目录。请在开发者工具中新建一个项目，并设置路径到dist目录，请勿设置为demo目录！使用WebStorm或Sublime打开demo目录，开发过程中，我们使用WebStorm或Sublime修改src目录下的源码，请勿直接修改dist目录中的文件，因为dist目录是通过labrador命令生成的。在demo目录中运行 labrador build 命令编译项目，该命令会将src目录下的文件一一处理并生成dist目录下对应的文件。我们也可以运行 labrador watch 命令监控src目录下的文件变化，这样就不用每次修改后手动运行编译命令。加载NPM包我们以lodash包为例，在src/app.js中键入代码 const _ = require('lodash'); 编译后，我们看到dist目录下的文件是这样的：我们看到dist目录下有一个npm/lodash目录，该目录下只有一个lodash.js文件，那么在微信web开发者工具中打包预览，lodash的库将只有这个文件被加载。这一切是怎么发生的？我们看一下dist/app.js的源码，发现源码中const _ = require('lodash'); 被编译为 var _ = require('./npm/lodash/lodash.js'); 然后labrador命令将node_modules/lodash/lodash.js 文件复制到了dist/npm/lodash/lodash.js 。这就是通过labrador可以调用NPM包的原理。重要的是，只有真正用到的js文件才被labrador命令加入到项目目录中。这样一个小小的改进象征着我们的小程序可以便捷调用NPM仓库中海量的扩展库！Babel转码在初始化的示例代码src/app.js中的内容是这样的：图中timer和getUserInfo属性都为async函数，函数体内使用await调用异步操作。labrador 库对微信API进行了封装，使用 const wx = require('labrador'); 覆盖默认的全局变量wx; 封装后的wx对象提供的异步方法返回的都是Promise异步对象，结合async/await函数彻底终结callback，将异步代码同步写，轻松逃离回调地狱！但目前async/await函数是不被浏览器支持的，我们需要使用babel对其转码，labrador编译命令已经内置了babel转码，转码后的代码可以查看dist/app.js，内容过长，不再张贴。重用组件重用组件最需要解决的问题是组件的逻辑代码怎样重用。在实例代码中有一个src/components目录，用来存放项目内的可重用组件，其结构是这样的：子目录src/components/list中存放着一个可重用的组件。list.js / list.less / list.xml 分别对应微信小程序的 js / wxss / wxml 文件。JS为控件的逻辑层，其代码如下：文件导出一个List类，这个组件类拥有像Page一样的生命周期函数onLoad, onReady, onShow, onHide, onUnload 以及setData函数。LESS文件对应微信的WXSS文件，因为微信小程序实现的限制，LESS中无法使用连级选择语法，但是可以定义变量，方便开发。XML文件对应微信的WXML文件，是组件视图描述文件，list.xml内容为：文件中导出一个名为list的template。组件不但可以存放在src/components目录内，还可以单独做成NPM包，这样就可以轻松做到跨项目间的组件共享。组件定义完成后，接下来是在页面中调用，在 src/pages/index/index.js 中有如下代码：代码中首先引入了labrador库替换全局的默认wx对象，并使用labrador.createPage方法代替全局的Page函数声明页面。然后加载List组件类，在页面声明配置中，增加了components属性，并将List组件类实例化传入。labrador.createPage方法是对Page方法的一层封装，目的是在页面初始化时和组件对象进行关联。在 src/pages/index/index.less 中加入代码 @import 'list' 即可调用list组件的样式，如果在src/components/list中找不到list.less，那么编译命令将在NPM包中寻找 node_modules/list/index.less 。在 src/pages/index/index.xml 中加入代码 <component key=\"list\"/> 即可调用list组件的模板文件，component 是Labrador自定义的组件，编译后对应生成 import 和 template。如果在src/components/list中找不到list.xml，那么编译命令将在NPM包中寻找 node_modules/list/index.xml"}
{"title": "微信小程序技术教程：集成 Redux ", "author": "天下雪", "pub_time": "2016-10-15 21:48", "content": "示例Redux是什么Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux官方文档为什么要使用Redux小程序俨然是一个类似Hybrid App的东西，前面是SPA，小程序提供一些原生功能的接口。现在前端程序规模都比较大，页面状态，数据缓存，需要管理的东西太多。引入Redux可以方便的管理这些状态。并且Redux丰富的周边工具也是很有吸引力的。集成Redux小程序的模块化微信的文档并没有指出如何使用第三方库，所以只能从微信小程序的模块化入手。文档中提到，模块化的关键是：module.exports = function(){}同时，如果我们去观察小程序开发环境的network面板，点击任何一个js，我们可以发现：项目目录中的所有js文件都会自动被加载，无论我们是否在代码中require所以的模块都会被套上下面的代码：define(\"reducers/visibilityFilter.js\", function(require, module){var window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;/*******************//******你写的代码******/                                                                 /********************/})这实际上是类似AMD的加载方式，但是跟标准的AMD又有些不同，缺少了依赖部分的声明。function(require, module){}: 这个函数包裹的是模块的实现，也就是我们自己写的代码，小程序给我们暴露了两个参数require和module，require用来在模块中加载其他模块，module用来将模块中的方法暴露出去：module.exports = function(){}所以只要需要让第三方库的代码使用这种形式的export就可以了。构建Redux的微信小程序包这里主要目标是打一个Redux包，让它可以兼容微信小城的加载方式下载Redux的代码到本地：git clone https://github.com/reactjs/redux.git安装依赖：npm install打包：npm run build:umd && npm run build:umd这些命令的详细内容可以到redux项目的package.json中查看。这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到。带min.js后缀的是minify过的。      4.微调加载方式：用编辑器打开dist目录下的redux.js文件(function webpackUniversalModuleDefinition(root, factory) {    if(typeof exports === 'object' && typeof module === 'object')        module.exports = factory();    else if(typeof define === 'function' && define.amd)        define([], factory);    else if(typeof exports === 'object')        exports[\"Redux\"] = factory();    else        root[\"Redux\"] = factory();})(this, function() {...  })这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来。将第二行代码：if(typeof exports === 'object' && typeof module === 'object')      修改成：if(typeof module === 'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入了拷贝进工程目录例如，我们拷贝到libs目录下，那么我们在程序中使用时，只要当做是一个本地模块去require就可以了：var redux = require('./libs/redux.js')通过这里的示例，其实我们发现，我们可以通过类似的方法，使用Webpack打包第三方库，就可以集成任何库了。使用Redux我们可以使用Redux的微信小程序绑定库来简化一些代码：wechat-weapp-redux，详细的安装和使用说明可以参照wechat-weapp-redux的README集成Redux-devtools如果没有redux-devtools那么使用redux的效果可能是要减半的。因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装redux-devtool的插件。这里使用remote-redux-devtools，remotedev-server安装remote-redux-devtools原版的remote-redux-devtools使用的一个websocket的依赖会使用原生的WebSocket，小程序是不支持的，所以需要改成小程序的websocket实现。修改好的包在这里：remote-redux-devtools把代码下载到工程目录里面就可以用了。安装和启动remotedev-servernpm install -g remotedev-serverremotedev --hostname=localhost --port=5678          因为没办法用npm安装到本地（开头提到的，微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动remotedev-server，hostname和port分别指定为localhost和5678。     3.  集成devtoolconst {createStore, compose} = require('./libs/redux.js');const devTools = require('./libs/remote-redux-devtools.js').default;const reducer = require('./reducers/index.js')function configureStore() {  return createStore(reducer, compose(devTools({    hostname: 'localhost',    port: 5678,    secure: false  })));}module.exports = configureStore;把devtool使用redux的compose加到store中去。hostname和port是指定为之前启动remotedev-server启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了      4.  打开监视器          可以在浏览器中访问localhost:5678，这是remotedev-server自带的监视器，正常打开的话是这样的：          左边有一个@@INIT说明小程序的redux连接成功了。但是这里这个自带的监视器可能打不开，因为它的一些js包是存在国外的cdn上的，偶尔访问不到。这个时候可以使用http://remotedev.io/local/，点击下面的setting，设置使用本地的server。保存之后刷新页面，应该跟上面显示的结果一样。示例详细的代码示例，可以参照：wechat-weapp-redux-todos"}
{"title": "新手入门福音：微信小程序试水体验过程 ", "author": "天下雪", "pub_time": "2016-10-16 13:26", "content": "1. https://mp.weixin.qq.com注册一个公众号，成为开发者，拿到一个appId。2. 下载微信开发者工具，https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1476197489869。3. 使用微信扫码登录4. 添加一个项目，把注册公众号获得到的appId复制到appId，名称目录填写好后，点击添加项目，显示小程序还处于内测阶段，没有被邀请的用户获取的appId无法使用，尝试认证，但个人用户无法认证（有说关注大于500的可以，一时难以凑齐，弃之），因2013年以后公众号无法升级为服务号，于是又开始注册服务号，因为不是企业，没有各种相关信息，又弃之，最后只能选择无appId进行项目添加，虽少些功能，但也大体可以使用。往一个空的文件夹中添加项目，会自动创建一个获取信息和登录日志的小demo，结构非常清晰（加了几个接口和一个文件夹detail图）.js => .js   .wxml => .html  .wxss => .css  .json => .json 点击调试可以看到效果，头像，昵称，和helloword（因为是扫码登录，开发者工具绑定了开发者信息，所以可以拿到个人信息）。点击左侧编辑可对代码进行编辑，编辑完后保存、编译就可查看新效果。"}
{"title": "微信小程序试水教程：参数传递 ", "author": "天下雪", "pub_time": "2016-10-16 13:42", "content": "教程一：参数传递这里我找到两种小程序上的参数传递方式，为了方便，我单独拿出来和大家分享下.一、通过事件进行参数传递先来看眼小程序对事件的定义：#什么是事件?\r\n\r\n这里是列表文本事件是视图层到逻辑层的通讯方式。\r\n这里是列表文本事件可以将用户的行为反馈到逻辑层进行处理。\r\n这里是列表文本事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。\r\n这里是列表文本 事件对象可以携带额外信息，如id, dataset, touches。\r\n很明确的指出了是视图层【wxml】到逻辑层【js】的通信方式，时间对象可以携带额外信息，用这个事件来传递参数肯定没错了，接下来我们就来实际看下例子：视图.wxml  <view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view>\r\n逻辑.jsPage({\r\n  tapName: function(event) {\r\n            console.log(event.target)\r\n  }\r\n})\r\nlog打印可以看到 dataset 里面就是我们设置的data-hi=\"MINA\"的值了。现在我们来看下刚刚我们写的， 首先 bindtap,以bind开头的就是要给他绑定个事件，这个事件的名字就是“=”号后面的数值就是绑定的事件名称，需要在 逻辑【js】层定义上。 然后就是传值了，注意到的朋友可以看到 我们这里写了data-hi 和我们平时写js的传值是同一个定义方法。这个data-*就对应事件的属性target里的dataset 值。这里我们需要调用的话就是event.target.dataset.hi就能取到data-hi所对应的值。这里需要注意下 data的定义名称： 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。官方示例：<view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindtap=\"bindViewTap\"> DataSet Test </view>\r\n\r\nPage({\r\n  bindViewTap:function(event){\r\n    event.target.dataset.alphaBeta == 1 // - 会转为驼峰写法\r\n    event.target.dataset.alphabeta == 2 // 大写会转为小写\r\n  }\r\n})\r\n二、navigator 跳转url传参*.wxml<view class=\"btn-area\">\r\n  <navigator url=\"navigate?title=navigate\" hover-class=\"navigator-hover\">跳转到新页面</navigator>\r\n  <navigator url=\"redirect?title=redirect\" redirect hover-class=\"other-navigator-hover\">在当前页打开</navigator>\r\n</view>\r\n*.js 跳到新页面之后在onload里面直接接收参数，接收方法也就是 options.[参数值]Page({\r\n  onLoad: function(options) {\r\n    this.setData({\r\n      title: options.title\r\n    })\r\n  }\r\n})\r\n好啦，今天就写到这里，我顺便把文档链接写上，上面写的文档里都有。我只是把它们搬出来了，用我的话说了一遍。 …(⊙＿⊙；)…什么是事件navigator"}
{"title": "微信小程序试水教程：富文本转文本 ", "author": "天下雪", "pub_time": "2016-10-16 13:47", "content": "最近小程序这么火，我也来搞搞。发现了一个恶心的问题。小程序没有组件能支持富文本内容的，改接口又不太合适，于是有了这问，没技术含量纯粹记录首先我们看眼没有被格式的富文本显示：*.wxml内代码。content是富文本内容    <view>\r\n     <text>{{content}}</text>\r\n    </view>\r\n显示结果：由以上图片看到，小程序无法解析html文件我们需要处理html富文本内容，让其显示好看点下面直接上代码了，主要功能就是利用js的replace 对富文本经行处理，大家可以看一下。一起优化，方便对富文本更好的处理。convertHtmlToText: function convertHtmlToText(inputText) {\r\n    var returnText = \"\" + inputText;\r\n    returnText = returnText.replace(/<\\/div>/ig, '\\r\\n');\r\n    returnText = returnText.replace(/<\\/li>/ig, '\\r\\n');\r\n    returnText = returnText.replace(/<li>/ig, '  *  ');\r\n    returnText = returnText.replace(/<\\/ul>/ig, '\\r\\n');\r\n    //-- remove BR tags and replace them with line break\r\n    returnText = returnText.replace(/<br\\s*[\\/]?>/gi, \"\\r\\n\");\r\n\r\n    //-- remove P and A tags but preserve what's inside of them\r\n    returnText=returnText.replace(/<p.*?>/gi, \"\\r\\n\");\r\n    returnText=returnText.replace(/<a.*href=\"(.*?)\".*>(.*?)<\\/a>/gi, \" $2 ($1)\");\r\n\r\n    //-- remove all inside SCRIPT and STYLE tags\r\n    returnText=returnText.replace(/<script.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/script>/gi, \"\");\r\n    returnText=returnText.replace(/<style.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/style>/gi, \"\");\r\n    //-- remove all else\r\n    returnText=returnText.replace(/<(?:.|\\s)*?>/g, \"\");\r\n\r\n    //-- get rid of more than 2 multiple line breaks:\r\n    returnText=returnText.replace(/(?:(?:\\r\\n|\\r|\\n)\\s*){2,}/gim, \"\\r\\n\\r\\n\");\r\n\r\n    //-- get rid of more than 2 spaces:\r\n    returnText = returnText.replace(/ +(?= )/g,'');\r\n\r\n    //-- get rid of html-encoded characters:\r\n    returnText=returnText.replace(/&nbsp;/gi,\" \");\r\n    returnText=returnText.replace(/&amp;/gi,\"&\");\r\n    returnText=returnText.replace(/&quot;/gi,'\"');\r\n    returnText=returnText.replace(/&lt;/gi,'<');\r\n    returnText=returnText.replace(/&gt;/gi,'>');\r\n\r\n   return returnText;\r\n}\r\n将上面代码放入任意适合的小程序js文件中， 然后在需要处理数据的js文件里，引入文件，下面给出放入app.js文件中的调用示例：var app = getApp()//获取app小程序实例\r\n onLoad: function (options) {\r\n       wx.request({\r\n      url: 'http://example.com/api' + options.id+'.json',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n       res.data.content =  app.convertHtmlToText(res.data.content )\r\n         that.setData({\r\n           art: res.data.content\r\n         })\r\n         console.log(res.data)\r\n      }\r\n    })\r\n｝\r\n然后编译刷新下，可以看到结果了：这里可以继续调整下css，使显示得更好看点。"}
{"title": "前端之巅：在Chrome浏览器上运行微信小程序 ", "author": "天下雪", "pub_time": "2016-10-16 17:36", "content": "微信小程序的开发框架体验起来，还不错——自带了UI框架。但是问题是它的IDE，表现起来相当的糟糕——其实主要是因为，我当时买WebStorm License买了好多年。所以，我觉得他的IDE真不如我这个付费好用。而且，作为一个拥护自由和开源的“GitHub 中国区首席Markdown程序员”。微信在微信小程序引导着Web开向封闭，我们再也不能愉快地分享我们的代码了。如果我们放任下去，未来的Web世界令人堪忧。好了，废话说完了，本文只是一个Demo的介绍。文章太长不想看，可以直接看Demo哈哈：GitHub: https://github.com/phodal/weapp-webdemo 预览：http://weapp.phodal.com/真实世界下的MINA三基本元素微信小程序的背后运行的是一个名为MINA框架。在之前的几篇文章里，我们介绍得差不多了。现在让我们来作介绍pipeline：Transform WXML和WXSS当我们修改完WXML、WXSS的时候，我们需要重新编译项目才能在浏览器上看到效果。这时候后台就会执行一些transform动作： WCC来转换WXML为一个genrateFun，执行这个方法将会得到一个Virtual DomWXSS就会转换WXSS为CSS——这一点有待商榷。WCC和WXSS，可以从vendor目录下获取到，在“微信Web开发者工具”下敲入help，你就会得到下面的东东：运行openVendor()，你就会得到上面的WCSS、WXSS、WAService.js、WAWebview.js四个文件了。Transform js文件对于JS文件来说，则是一个拼装的过程，如下是我们的app.js文件：它在转换后会变成：我假装你已经知道这是什么了，反正我也不想、也不会解释了~~。同理于：至于它是如何replace或者apend到HTML中，我就不作解释了。MINA如何运行？为了运行一个Page，我们需要有一个Virtual Dom，即用WCC转换后的函数，如：然后在我们的HTML中加一个script，如就会凑发这个事件了。我简单的拆分了WXWebview.js得到了几个功能组件：define.js，这里就是定义AMD模块化的地方exparser.js，用于转换WXML标签到HTML标签exparser-behvaior.js，定义不同标签的一些行为mobile.js，应该是一个事件库，好像我并不关心。page.js，核心代码，即Page、App的定义所在。report.js，你所说的一切都能够用作为你的呈堂证供。virtual_dom.js，一个virtual dom实现结合wcc使用，里面应该还有component.css，也可能是叫weuiwa-wx.js，定义微信各种API以及WebView和Native的地方，和下面的WX有冲突。wx.js，同上，但是略有不同。wxJSBridge.js，Weixin JS Bridge于是，我就用上面的组件来定义不同的位置好了。当我们触发自定义的generateFuncReady事件时，将由virtual_dom.js来接管这次Render：因此，这里就是负责DOM初始化的地方了，这里得到的Dom结果是这样的：而我们写的WXML是这样的：很明显view会被转换为wx-view，text会被转换为wx-text等等，以此类推。这个转换是在virtual dom.js中调用的，调用的方法就是exparser。遗憾的是我现在困在 data 初始化上面了~~，这里面有两套不同的事件系统，有一些困扰。其中有一个是：WeixinJSBridge、还有一个是app engine中的事件系统，两个好像不能互调。使用WebStorm开发在浏览器上运行之前，我们需要简单的mock一些方法，如： window.webkit.messageHandlers.invokeHandler.postMessagewindow.webkit.messageHandlers.publishHandler.postMessageWeixinJSCore.publishHandlerWeixinJSCore..invokeHandler然后把 config.json中的一些内容变成__wxConfig，如： 如这里我们的appname是哈哈哈哈哈哈哈——我家在福建。然后在我们的HTML中引入各个JS文件，啦啦。我们还需要一个自动化的glup脚本来watch wxml和wxss的修改，然后编译，如：说了这么多，你还不如去看代码好了：GitHub: https://github.com/phodal/weapp-webdemo 预览：http://weapp.phodal.com/"}
{"title": "微信小程序canvas篇，实现全过程展示含demo ", "author": "天下雪", "pub_time": "2016-10-16 17:45", "content": "Demo效果图如下：                          一、Demo思路来源之所以写了这样一个Demo，是因为很久之前在慕课网看到了一个很好玩很酷炫利用canvas绘制的时钟，于是想着这样炫酷好玩的东西在小程序当中是否也能够得以实现呢？答案肯定是可以的。接下来我将把这个Demo的思路一步一步分享给大家。二、Demo实现1.微信小程序开发环境搭建 http://www.helloxcx.com/jc/devtools/download.html，如果这个地址无法下载，请使用官方地址下载；2.开发环境搭建后利用开发工具创建自己的Demo项目  1）创建项目                   2）添加核心代码countdown.js ，digit.js到index目录下3.核心代码实现(代码中有详细的开发注释)  1）digit.js（这里实现倒计时数字的排列，是一个3维数组）// 数字排列var digit = [  [    [0,0,1,1,1,0,0],    [0,1,1,0,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,0,1,1,0],    [0,0,1,1,1,0,0]  ],//0  [    [0,0,0,1,1,0,0],    [0,1,1,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [1,1,1,1,1,1,1]  ],//1  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,1,1,0,0,0],    [0,1,1,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,0,0,0,1,1],    [1,1,1,1,1,1,1]  ],//2  [    [1,1,1,1,1,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,1,1,1,0,0],    [0,0,0,0,1,1,0],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//3  [    [0,0,0,0,1,1,0],    [0,0,0,1,1,1,0],    [0,0,1,1,1,1,0],    [0,1,1,0,1,1,0],    [1,1,0,0,1,1,0],    [1,1,1,1,1,1,1],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,1,1,1,1]  ],//4  [    [1,1,1,1,1,1,1],    [1,1,0,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,1,1,1,1,0],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//5  [    [0,0,0,0,1,1,0],    [0,0,1,1,0,0,0],    [0,1,1,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,0,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//6  [    [1,1,1,1,1,1,1],    [1,1,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0]  ],//7  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//8  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,1,1,0,0,0,0]  ]//9];module.exports = {    digit : digit}  2）countdown.js（这里实现倒计时数字的绘图以及倒计时）var sort = require(\"./digit.js\")  , digit = sort.digit;   // 接收数字排列数组var CANVAS_WIDTH = 375    // canvas宽度  , CANVAS_HEIGHT = 500   // canvas高度  , RADIUS = 8            // 小球半径  , MARGIN_TOP = 60       // 图例距离右边距离  , MARGIN_LEFT = 60;     // 图例距离左边距离/** * [render 数字渲染] * @param  {[type]} time [倒计时时间] * @param  {[type]} cxt  [绘制对象] */function render(time,cxt){  cxt.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);  renderDigit(MARGIN_LEFT , MARGIN_TOP , parseInt(time/10) , cxt );  renderDigit(MARGIN_LEFT + 15*(RADIUS+1) , MARGIN_TOP , parseInt(time%10) , cxt );}/** * [renderDigit 单独小球的绘制] * @param  {[type]} x   [每个小球x轴距离] * @param  {[type]} y   [每个小球y轴距离] * @param  {[type]} num [需要绘制出来的数字] * @param  {[type]} cxt [绘制对象] */function renderDigit(x,y,num,cxt){  for(var i=0;i<digit[num].length;i++){    for(var j=0;j<digit[num][i].length;j++){      if (digit[num][i][j]){        cxt.beginPath();        cxt.arc(x+j*2*(RADIUS+1)+(RADIUS+1) , y+i*2*(RADIUS+1)+(RADIUS+1) , RADIUS , 0 ,2*Math.PI);        cxt.closePath();        cxt.fill();      }    }   }}/** * [loopTime 倒计时绘图] * @param  {[type]} time [倒计时需要绘制的数字] * @param  {[type]} cxt  [绘制对象] */function loopTime(time,cxt){  render(time,cxt);   // 获取当前context上存储的绘图动作  wx.drawCanvas({    canvasId:\"canvas\",    actions:cxt.getActions()  });}/** * [init 倒计时实现] * @param  {[type]} time [倒计时需要绘制的数字] * @param  {[type]} cxt  [绘制对象] */function init(time,cxt){  loopTime(time,cxt)  var loop = setInterval(function(){    time--;    (time < 1 ) && (      clearInterval(loop)    )    loopTime(time,cxt)  },1000);}// 将init方法暴露出去module.exports = {  render:render,  init:init}3）index.js三、Demo源码源码已托管github，地址为：https://github.com/xuqiang521/Wechat"}
{"title": "解决小程序中webview页面多层history返回问题 ", "author": "Rolan", "pub_time": "2019-8-21 00:15", "content": "小程序开发中遇到的问题：小程序中嵌套了一个webview页面，webview页面中有静默授权（A1页面静默授权后重定向到A2页面），点小程序原生的返回按钮会返回到A1页面，然后页面就会反复静默授权预期表现：点小程序原生的返回按钮后返回到小程序上个页面解决方案：通过\thistory.pushState 添加历史记录名目，\thistory.onpopstate 监听历史记录条目发生变化时，调用小程序API\twx.navigateBackwindow.addEventListener('popstate', (event) => {\r\n    wx.miniProgram.navigateBack();\r\n});\r\nconst code = getSearch('code'); // 伪代码，获取查询参数\r\nif (!code) { // 页面A1\r\n    if (isWeixin()) {\r\n        // 微信环境\r\n        const redirectUrl = window.location.href + '&code=1';\r\n        window.location.href = 'https://open.weixin.qq.com/connect/oauth2/authorize' + '?appid=' + appId +\r\n        '&redirect_uri=' + encodeURIComponent(redirectUrl) +\r\n        '&response_type=code&scope=snsapi_userinfo' +\r\n        '#wechat_redirect'; // 静默授权伪代码\r\n    } else {\r\n        alert('当前不是微信环境');\r\n    }\r\n} else { // 页面A2\r\n    history.pushState({page: 1}, null, window.location.href);\r\n}刚开始想的解决办法是用localStorage，跳转到A2时存储一个值，返回到A1时获取这个值，如果有值就清除这个值并且回退到小程序页面。听起来似乎也可行，但小程序的缓存和微信的缓存是同步的，如果在微信环境中直接访问A1页面，重定向到A2会存值，如果直接关闭页面，不会被清除，那么在小程序中访问时就直接回退了。"}
{"title": "微信小程序 webview 与 h5 实时通讯的实现 ", "author": "Rolan", "pub_time": "2019-8-21 00:07", "content": "在做 React Native 应用时，如果需要在 App 里面内嵌 H5 页面，那么 H5 与 App 之间可以通过 Webview 的 PostMessage 功能实现实时的通讯，但是在小程序里面，虽然也提供了一个\twebview 组件，但是，在进行\tpostMessage 通讯时，官方文档里面给出了一条很变态的说明：网页向小程序\tpostMessage 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息。\te.detail = { data } ，\tdata 是多次\tpostMessage 的参数组成的数组这里面已经说的很明白了，不管我们从 H5 页面里面\tpostMessage 多少次，小程序都是收不到的，除非：用户做了回退到上一页的操作组件销毁用户点击了分享这里面其实我没有完全说对，官方其实说的是\t小程序后退 ，并没有说是用户做回退操作，经过我的实测，确实人家表达得很清楚了，我们通过微信官方的SDK调起的回退也是完全可行的：wx.miniProgram.navigateBack()大体思路从上面的分析和实测中我们可以知道，要实现无需要用户操作即可完成的通讯，第三种情况我们是完全不需要考虑了的，那么来仔细考虑第 1 和第 2 种场景。第 1 种方式：回退当我们想通过网页向小程序发送数据，同时还可以回退到上一个页面时，我们可以在\twx.miniProgram.postMessage 之后，立马调用一次\twx.miniProgram.navigateBack() ，此时小程序的操作是：postMessage\r\n我们在处理\tpostMessage 的时候做一些特殊操作，可以将这些数据保存下来第 2 种方式：组件销毁这是我感觉最合适的一种方式，可以让小程序拿到数据，同时还保留在当前页面，只需要销毁一次\twebview 即可，大概的流程就是：小程序\tpostMessage小程序\tnavigateTo 将小程序页面导向一个特殊的页面小程序的那个特殊页面立马回退到\twebview 所在的页面webview 所在的页面的\tonShow 里面，做一次处理，将\twebview 销毁，然后再次打开触发\tonMessage 拿到数据H5 页面再次被打开这种方式虽然变态，但是至少可以做到实时拿到数据，同时还保留在当前 H5 页面，唯一需要解决的是，在做这整套操作前，H5 页面需要做好状态的缓存，要不然，再次打开之后，H5 的数据就清空了。第 1 种方式：通过回退，将数据提交给小程序之后传递给\twebview 的上一页面这种方式实现起来其实是很简单的，我们现在新建两个页面：sandbox/canvas-by-webapp/index.jsconst app = getApp();\r\n\r\nPage({\r\n  data: {\r\n    url: '',\r\n    dimension: null,\r\n    mime: '',\r\n  },\r\n  handleSaveTap: function() {\r\n    wx.navigateTo({\r\n      url: '/apps/browser/index',\r\n      events: {\r\n        receiveData: data => {\r\n          console.log('receiveData from web browser: ', data);\r\n          if (typeof data === 'object') {\r\n            const { url, mime, dimension } = data;\r\n            if (url && mime && dimension) {\r\n              this.setData({\r\n                url,\r\n                dimension,\r\n                mime,\r\n              });\r\n\r\n              this.save(data);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  save: async function({ url, mime, dimension }) {\r\n    try {\r\n      await app.saveImages([url]);\r\n      app.toast('保存成功！');\r\n    } catch (error) {\r\n      console.log(error);\r\n      app.toast(error.message || error);\r\n    }\r\n  },\r\n});上面的代码中，核心点，就在于\twx.navigateTo 调用时，里面的\tevents 参数，这是用来进行与\t/apps/browser/index 页面通讯，接收数据用的。apps/browser/index.js我省略了绝大多数与本文无关的代码，保存最主要的三个：Page({\r\n  onLoad() {\r\n    if (this.getOpenerEventChannel) {\r\n      this.eventChannel = this.getOpenerEventChannel();\r\n    }\r\n  },\r\n  handleMessage: function(message) {\r\n    const { action, data } = message;\r\n    if (action === 'postData') {\r\n      if (this.eventChannel) {\r\n        this.eventChannel.emit('receiveData', data);\r\n      }\r\n    }\r\n  },\r\n\r\n  handlePostMessage: function(e) {\r\n    const { data } = e.detail;\r\n    if (Array.isArray(data)) {\r\n      const messages = data.map(item => {\r\n        try {\r\n          const object = JSON.parse(item);\r\n          this.handleMessage(object);\r\n          return object;\r\n        } catch (error) {\r\n          return item;\r\n        }\r\n      });\r\n\r\n      this.setData({\r\n        messages: [...messages],\r\n      });\r\n    }\r\n  },\r\n})其实，\tonLoad 方法中，我们使用了自微信 SDK\t2.7.3 版本开始提供的\tgetOpenerEventChannel 方法，它可以创建一个与上一个页面的事件通讯通道，这个我们会在\thandleMessage 中使用。handlePostMessage 就是被\tbindmessage 至\twebview 上面的方法，它用于处理从 H5 页面中\tpostMessage 过来的消息，由于小程序是将多次\tpostMessage 的消息放在一起发送过来的，所以，与其它的Webview不同点在于，我们拿到的是一个数组：\te.detail.data ，\thandlePostMessage的作用就是遍历这个数组，取出每一条消息，然后交由\thandleMessage 处理。handleMessage 在拿到\tmessage 对象之后，将\tmessage.action 与\tmessage.data 取出来（*这里需要注意，这是我们在 H5 里面的设计的一种数据结构，你完全可以在自己的项目中设计自己的结构），根据\taction 作不同的操作，我在这里面的处理是，当\taction === 'postData' 时，就通过\tgetOpenerEventChannel 得到的消息通道\tthis.eventChannel 将数据推送给上一级页面，也就是\t/sandbox/canvas-by-webapp ，但是不需要自己执行\tnavigateBack ，因为这个需要交由H5 页面去执行。H5 页面的实现我的 H5 主要就是使用\thtml2canvas 库生成 Canvas 图（没办法，自己在小程序里面画太麻烦了），但是这个不在本文讨论过程中，我们就当是已经生成了\tcanvas 图片了，将其转为\tbase64文本了，然后像下面这样做：wx.miniProgram.postMessage({\r\n  data: JSON.stringify({\r\n    action: 'postData',\r\n    data: 'BASE 64 IMAGE STRING'\r\n  })\r\n});\r\n\r\nwx.miniProgram.navigateBack()将数据\tpostMessage 之后，立即\tnavigateBack() ，来触发一次回退，也就触发了\tbindmessage 事件。使用销毁\twebview 实现实时通讯接下来，咱就开始本文的重点了，比较变态的方式，但是也没想到更好的办法，所以，大家将就着交流吧。"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《上》 ", "author": "天下雪", "pub_time": "2016-10-16 18:55", "content": "本文已获得原作者授权微信小程序内测至今也有20天左右，也有很多人作出了很多不错的DEMO并发布到github了。前几日看见了豆瓣电影这个demo，感觉很不错，也跟着做了一个，作为复习巩固文档API用。废话不多说，直接进入正题：第一节只写一个首页的展示，数据用的是自己写的虚拟的数据 新建一个demo，不要使用微信自带的DEMO，直接从零开始写起：首先创建3个文件：app.jsonapp.jsapps.wxss app.json  : 主要写配置项：内容如下，具体的每个key值对应的意思，这里就不再细说了，可以看我之前的配置指南，{\"pages\":[\"pages/index/index\",\"pages/rank/rank\",],\"window\":{\"enablePullDownRefresh\":true,\"backgroundColor\":\"#eee\",\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" },\"tabBar\": {\"color\": \"#d7ced5\",\"selectedColor\": \"#535f71\",\"borderStyle\": \"white\", \"backgroundColor\": \"#f9f9f9\",\"list\": [ {\"pagePath\": \"pages/index/index\", \"text\": \"推荐电影\", \"iconPath\": \"images/board.png\", \"selectedIconPath\": \"images/board-actived.png\" },{\"pagePath\": \"pages/rank/rank\",\"text\": \"北美票房\",\"iconPath\": \"images/note.png\",\"selectedIconPath\": \"images/note-actived.png\"}]},\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},\"debug\": true} app.js  :  主要用来注册一个小程序的实例 App({onLaunch: function () {},onShow: function () {},onHide: function () {},globalData: 'I am global data'});  app.wxss : 公用样式，基本等同于CSS，暂时不需要写内容。 创建好3个文件后，就可以开始写页面的内容了：新创建2个文件夹images和pages，一个放图片一，个放页面。目前只pages下面再创建2个文件夹index和rank，每个文件下分别创建json,js,wxml,wxss文件，此时目录如下：虽然不一定4个文件类型都需要用到，但为了之后方便，建议还是先创建好，需要用到的时候就比较方便了，不用再去创建。首先写index.js:   (为了模拟循环数组，data下面的moivelist还需要多复制几份，这里只写了一份出来，imgsrc路径要写好) Page({    data:{    moivelist:[{    imgsrc: \"../../images/AN2.jpg\",    title: \"肖申克的救赎\",    introduce: \"The shrakwos RedenpeTion(1994)\",    author: \"弗兰克*德拉立邦\",    rank: \"9.6\"}]},onLoad: function(options) {console.log(1);},onReady: function() {// Do something when page ready.},onShow: function() {// Do something when page show.},onHide: function() {// Do something when page hide.},onUnload: function() {// Do something when page close.},onPullDownRefresh: function() {// Do something when pull down},// Event handler.viewTap: function() {this.setData({text: 'Set some data for updating view.'})}})这里出现了很多on函数事件，对应页面的生命周期每个过程对应的事件，这里暂时先关注data对象小程序是以数据驱动的，页面进来的时候通过动态获取数据，通过{{xxx}}将数据绑定，并将数据渲染到视图层，这里先以一个虚拟的data数据模拟 然后写index.wxml文件：从上面显示的首页的图片来看，主要是1个标题，以及下面一个列表，列表用过循环来渲染出所有的数据标题:  标题比较简单，主要是写css<view class=\"head-title\"><text>豆瓣电影top250</text></view>这里主要讲下面的列表循环，可以发现我们只要写好列表中的第一个就可以了，其他的通过循环来展示列表主要分为左中右三块，分别为图片，内容，以及评分3块<block wx:for=\"{{moivelist}}\">  //循环渲染，wx:for=\"{{ xxx }}\" 代表循环js文件里面的data数据中的xxx<view>//微信循环时会给出每个项目的内容以及每个项目的下标，默认为item和index，item.imgsrc意为对象的（imgsrc）  key值图片：<image class=\"moive-img\" style=\"\" mode=\"\" src=\"{{item.imgsrc}}\" binderror=\"\" bindload=\"\"></image>内容：<view class=\"moive-content\">     <view class=\"content-titile\">        <text >{{item.title}}</text>    </view>    <view class=\"content-introduce\">         <text >{{item.introduce}}</text>    </view>    <view class=\"content-author\">        < text >{{item.author}}</text>\t    </view>\t</view>评分：<text class=\"content-rank\">{{item.rank}}</text></view></block>   基本都这里wxml就结束了，样式主要通过wxss来操作，样式比较简单，就不写了，主要讲一下左中右这三块通过将左中右这三块的父级设置为display:flex;左边和右边都设置为固定rpx，中间设置为flex:1。这样写代表中间这一块的内容占满：左边和右边布局后生下来的空间 ，即左右布局好后，剩多少，flex：1就等于多少。 第一节项目代码见：demo1https://github.com/linrunzheng/wx-samll-demo"}
{"title": "微信小程序使用车牌号输入法 ", "author": "Rolan", "pub_time": "2019-8-21 00:21", "content": "在做小程序时，做了一个关于车的项目，然后需要添加车辆信息、添加车牌号，使用车牌键盘输入，当时我把这个需求给砍了，然后在添加车辆信息时，老大看到数据库里我乱填的车牌号，又让我把他加上了^o^1.效果图2.相关代码使用组件形式实现键盘输入组件代码index.wxml<view class=\"carPlate\" wx:if=\"{{show}}\">\r\n  <block wx:if=\"{{type==1}}\">\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword1}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword2}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword3}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{cityKeyword4}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"1\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n  </block>\r\n  <block wx:else>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{keyNumber}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"2\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{wordList1}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"2\" data-item=\"{{item}}\">{{item}}</view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{wordList2}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-type=\"2\" data-item=\"{{item}}\">{{item}}</view>\r\n      <view class=\"wordItem wordClear\" bindtap=\"handleClick\" data-item=\"delete\">\r\n        <image src=\"/images/input-clear.png\" class=\"clearImg\"></image>\r\n      </view>\r\n    </view>\r\n    <view class=\"wordList\">\r\n      <view class=\"wordItem\" wx:for=\"{{wordList3}}\" wx:key=\"{{item}}\" bindtap=\"handleClick\" data-item=\"{{item}}\">{{item}}</view>\r\n      <view class=\"wordItem wordConfirm\" bindtap=\"handleClick\" data-item=\"confirm\">确定</view>\r\n    </view>\r\n  </block>\r\n</view>index.css.carPlate{\r\n  position: fixed;\r\n  padding: 12rpx 12rpx 30rpx;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n  /* height: 150px; */\r\n  font-size: 30rpx;\r\n  background: #fff;\r\n  box-sizing: border-box;\r\n  border-top: 1px solid rgb(211, 207, 207);\r\n  z-index: 200;\r\n}\r\n.wordList{\r\n  display: flex;\r\n  width: 100%;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n.wordItem{\r\n  margin: 5rpx;\r\n  width: 70rpx;\r\n  height: 70rpx;\r\n  line-height: 70rpx;\r\n  text-align: center;\r\n  border: 1px solid #eee;\r\n  border-radius: 10rpx;\r\n}\r\n.wordConfirm{\r\n  width: 130rpx;\r\n  color: #fff;\r\n  background: #473af0;\r\n}\r\n.wordClear{\r\n  width: 100rpx;\r\n}\r\n.clearImg{\r\n  width: 60rpx;\r\n  height: 60rpx;\r\n  vertical-align: middle;\r\n}index.jsComponent({\r\n\r\n  properties: {\r\n    type: {\r\n      type: Number,\r\n      default: 1,\r\n    },\r\n    show: {\r\n      type: Boolean,\r\n      default: false,\r\n    }\r\n  },\r\n\r\n  data: {\r\n    cityKeyword1: '京沪浙苏粤鲁晋冀豫',\r\n    cityKeyword2: '川渝辽吉黑皖鄂湘赣',\r\n    cityKeyword3: '闽陕甘宁蒙津贵云',\r\n    cityKeyword4: '桂琼青新藏港澳台',\r\n    keyNumber: '1234567890',\r\n    wordList1: 'QWERTYUIOP',\r\n    wordList2: 'ASDFGHJKL',\r\n    wordList3: 'ZXCVBNM',\r\n  },\r\n\r\n  methods: {\r\n    handleClick(e) {\r\n      let value = e.currentTarget.dataset.item;\r\n      let type = e.currentTarget.dataset.type;\r\n      switch(value) {\r\n        case 'confirm':\r\n          this.triggerEvent('confirm');\r\n          break;\r\n        case 'delete':\r\n          this.triggerEvent('delete');\r\n          break;\r\n        default: \r\n          this.triggerEvent('change', { value, type });\r\n      }\r\n    }\r\n  }\r\n})3.父组件引入我想实现点击输入后有上拉的效果，开始我想使用offset来实现的，但是下班后洗衣服想了下，不太好实现，我就想到了我以前做购物车时，有用到transform，原理差不多，我就把他用上了然后就是点击键盘外实现收起键盘，开始我想到的就是在父组件的最外层定义关闭事件，父级里面的盒子都使用catch方法阻止冒泡，但想下阻止冒泡好像又有点不合情理，就又把阻止冒泡给去掉了父组件index.wxml<view class=\"container\" bindtap=\"handlePlateConfirm\">\r\n  <view class=\"translateView\" style=\"transform: translateY({{translateSpace}}px)\">\r\n    <view class=\"list\">\r\n      <view class=\"item\">\r\n        <view class=\"label\">*车牌号码</view>\r\n        <view class=\"contentBox\" catchtap=\"handleClick\">\r\n          <view class=\"inputBox\" wx:if=\"{{carNo}}\">{{carNo}}</view>\r\n          <view class=\"promptText\" wx:else>请输入车牌号</view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n</view>\r\n<car-plate show=\"{{showPlateInput}}\" bindchange=\"handlePlateChange\" type=\"{{inputType}}\" bindconfirm=\"handlePlateConfirm\" binddelete=\"handlePlateDelete\" />父组件index.jsPage({\r\n  data: {\r\n    carNo: '',\r\n    translateSpace: 0,\r\n    inputType: 1, // 车牌输入类型，1简称，2数字或者字母,\r\n    showPlateInput: false,\r\n  },\r\n  /* 用于点击弹出键盘输入，space为键盘弹出后向上拉取的距离 */\r\n  handleClick(e) {\r\n    /* 150为键盘的高度 */\r\n    let space = -(e.currentTarget.offsetTop - 150);\r\n    /* regExp用于判断当前已输入的车牌号是否是中文，并让键盘显示中文还是英文输入 */\r\n    let regExp = /^[\\u4e00-\\u9fa5]+/;\r\n    let inputType = 1;\r\n    if(regExp.test(this.data.carNo)) {\r\n      inputType = 2;\r\n    }\r\n\r\n    this.setData({\r\n      translateSpace: space,\r\n      showPlateInput: true,\r\n      inputType\r\n    })\r\n  },\r\n  /* 键盘输入操作 */\r\n  handlePlateChange(e) {\r\n    let value = e.detail.value;\r\n    let type = e.detail.type;\r\n    let carNo = this.data.carNo;\r\n    carNo += value;\r\n\r\n    if(type == 1) {\r\n      this.setData({\r\n        inputType: 2\r\n      })\r\n    }\r\n    this.setData({\r\n      carNo\r\n    })\r\n  },\r\n  /* 点击键盘上的确定 */\r\n  handlePlateConfirm() {\r\n    /* isCarPlate用于判断输入的车牌号是否符合规范 */\r\n    if (!this.isCarPlate(this.data.carNo)) {\r\n      wx.showToast({\r\n        title: '请输入正确的车牌号',\r\n        icon: 'none',\r\n        duration: 2000\r\n      })\r\n      return false;\r\n    }\r\n    this.setData({\r\n      translateSpace: 0,\r\n      showPlateInput: false,\r\n      inputType: 1\r\n    })\r\n  },\r\n  /* 用于键盘输入删除 */\r\n  handlePlateDelete(e) {\r\n    let carNo = this.data.carNo;\r\n    carNo = carNo.substring(0, carNo.length - 1);\r\n    if(carNo.length == 0) {\r\n      this.setData({\r\n        inputType: 1\r\n      })\r\n    }\r\n    this.setData({\r\n      carNo,\r\n    })\r\n  },\r\n  /* 判断车牌号 */\r\n  isCarPlate(value) {\r\n    return /^(([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-Z](([0-9]{5}[DF])|([DF]([A-HJ-NP-Z0-9])[0-9]{4})))|([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-Z][A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳使领]))$/.test(value);\r\n  }\r\n})父组件index.css.container{\r\n  height: 100vh;\r\n  background: #fff;\r\n}\r\n.translateView{\r\n  background: #eee;\r\n}\r\n.list{\r\n  margin-bottom: 20rpx;\r\n  background: #fff;\r\n}\r\n.list:last-child{\r\n  margin: 0;\r\n}\r\n.item{\r\n  display: flex;\r\n  padding: 0 26rpx;\r\n  width: 100%;\r\n  height: 116rpx;\r\n  box-sizing: border-box;\r\n  align-items: center;\r\n  border-bottom: 1px solid #eee;\r\n}\r\n.item:last-child{\r\n  border: none;\r\n}\r\n.label{\r\n  margin-right: 10rpx;\r\n  width: 140rpx;\r\n}\r\n.contentBox{\r\n  display: flex;\r\n  width: calc(100% - 150rpx);\r\n  height: 90rpx;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n}\r\n.promptText{\r\n  color: #c7c7c7;\r\n}\r\n.inputBox{\r\n  width: 100%;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n}正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）"}
{"title": "小程序自定义弹层禁止页面滚动方案详解 ", "author": "Rolan", "pub_time": "2019-8-21 00:52", "content": "方案一：通过小程序自定义组件\tscroll-view 实现布局，动态修改\tscroll-y 属性组件及属性介绍：\tdevelopers.weixin.qq.com/miniprogram…缺点： 布局局限于\tscroll-view 组件， 大部分需求都满足不了方案二：自定义弹层蒙层或者外层容器添加\tcatchtouchmove 事件<view class=\"mask-box\" catchtouchmove=\"preventTouchMove\">\r\n    <!--弹层内容-->\r\n</view>\r\n复制代码缺点： 弹层滑动不了；适用于自定义弹层不滑动的布局。方案三：动态添加给最外层元素增加\tposition:fixed 样式<view style=\"{{isMask ? 'position:fixed; top: 0; left: 0;' : ''}}\">\r\n  <!--内容区-->\r\n</view>\r\n复制代码缺点： 当\tisMask 为\ttrue 时，页面始终会回到顶部；体验过不了关；方案四：通过动态修改样式处理 （推荐）原理： 小程序没提供\tAPI 给我们动态修改\tpage 样式， 那我们换个思路，最开始给\tpage 设置\toverflow: hidden , 最外层布局设置\toverflow: auto 但是设置\theight 属性时还是有坑。 如下：height: 100vh 时，上拉加载、下拉刷新在安卓端失效，ios没问题； 适用于当前页面不需要上拉、下拉刷新page 设置\toverflow: hidden 时， 安卓端页面整体滑动不了； 适用于底层布局不需要滑动page 设置\toverflow: visible ， 以上问题均解决 （推荐）代码如下： wxml:view class=\"content {{isMask? 'page-hidden' : ''}}\">\r\n复制代码wxss:page {\r\n  overflow: visible;\r\n  height: 100%;\r\n}\r\n.group-buying-list{\r\n  height: 100%;\r\n  overflow: auto;\r\n  -webkit-overflow-scrolling: touch;\r\n}\r\n.page-hidden{\r\n  overflow: hidden\r\n}\r\n复制代码若有疑问欢迎留言指正"}
{"title": "小程序拼接图片链接无底洞探究 ", "author": "Rolan", "pub_time": "2019-8-21 00:42", "content": "由于小程序包大小限制，我们一般都会将icon存放到cdn上。现在的开发流程需要在\t开发测试环境 下图片使用开发域名，线上使用生产域名。问题重现在小程序onLaunch的时候读取配置文件获取当前环境，并得到开发环境图片域名:./app.jsconst { imgHostDev, imgHostProd, env } = require('./app.config.js')\r\nApp({\r\n  onLaunch: function () {\r\n    this.globalData.imageHost = env == 'dev' ? imgHostDev : imgHostProd\r\n  },\r\n  globalData: {\r\n    imageHost: ''\r\n  }\r\n})\r\n复制代码在页面中：./pages/index/index.jsconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgHost: ''\r\n  },\r\n  onLoad: function () {\r\n    this.setData({\r\n      imgHost: app.globalData.imageHost\r\n    })\r\n  }\r\n})\r\n复制代码./pages/index/index.wxml<image src=\"{{imgHost}}/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg\" mode=\"aspectFit\"></image>\r\n复制代码图片渲染出来了，但是在开发者工具中有报错VM1334:1 Failed to load local image resource /4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg the server responded with a status of 500 (HTTP/1.1 500 Internal Server Error)\r\n手机预览就看不到图片。。。分析看一下报错信息，说本地不存在\t/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg 这个文件。 也就是说页面在执行onLoad之前就已经渲染了，这个时候\timgHost 值为空字符串，image的src拿到的图片链接就是\t/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg ，image标签就以为这是本地图片导致的。修复当然修复的方法有很多，可以将\timgHost 在初始化的时候就赋值：const app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    imgHost: app.globalData.imageHost\r\n  },\r\n  onLoad: function () {\r\n\r\n  }\r\n})\r\n复制代码也可以在标签中做判断<image src=\"{{imgHost ? imgHost + '/4jZ1L1qECEOsikW2JKsyHQ==/109951164304393164.jpg' : ''}}\" mode=\"aspectFit\"></image>\r\n复制代码更多尝试之前都是渲染网络图片，如果读取本地图片更换不同文件夹中的同名图片呢？发现也是如此。如果图片链接里有多个变量，就建议在wxs文件中写一个方法来配置图片"}
{"title": "【小程序 + 云开发】体重排行榜 上手笔记 ", "author": "Rolan", "pub_time": "2019-8-22 00:23", "content": "前一段时间上线的小程序记录体重功能运行基本稳定，没想到还真的有小伙伴们用，而且还热心的反馈问题，真是感谢，刚刚发布了一个体重记录排行榜，记录一下笔记吧。\r\n\r\n收集用户昵称与头像\r\n定时任务与关联查询\r\n查询排序\r\n\r\n\r\n\r\n收集用户昵称与头像\r\n之前的功能里没有储存用户信息，只是在分享的时候获取昵称和头像生成图片，不过排行榜的功能肯定是需要的，就建了一个users的表，在登录时收集昵称，如果用户拒绝也不能影响记录体重功能的使用。\r\n\r\nPage({\r\n  data: {\r\n    isAuthorize:'loading'  // 是否授权\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  async onLoad(options) {\r\n\r\n    let getSetting =  promisify(wx.getSetting)\r\n\r\n    // 是否授权判断\r\n    let isAuthorize = await getSetting().then(res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          this.getInfo()\r\n          return true\r\n        }else{\r\n          return false\r\n        }\r\n    })\r\n    this.setData({isAuthorize})\r\n\r\n    // 授权通过 执行登录\r\n    isAuthorize ? this.toAddPage() : ''\r\n    wx.checkSession({\r\n      success (a) {\r\n        //session_key 未过期，并且在本生命周期一直有效\r\n      },\r\n      fail () {\r\n        // session_key 已经失效，需要重新执行登录流程\r\n        wx.login() //重新登录\r\n      }\r\n    })\r\n  },\r\n  async bindGetUserInfo(e){\r\n  \r\n    if(e.detail.userInfo == undefined ){\r\n    \r\n      wx.showToast({\r\n        icon: 'none',\r\n        title: '好气哦，排行榜数据不能显示你的昵称。'\r\n      })\r\n\r\n      setTimeout(()=> {\r\n        // 执行登录\r\n        this.toAddPage()\r\n      },3000)\r\n\r\n    }else{\r\n\r\n      await this.saveName(e.detail.userInfo)\r\n      wx.hideLoading()\r\n      // 执行登录\r\n      this.toAddPage()\r\n    }\r\n  },\r\n    getInfo(){\r\n        wx.getUserInfo({\r\n          success: (res) => {\r\n            this.saveName(res.userInfo)\r\n          }\r\n        })\r\n      },\r\n  // 更新昵称\r\n  saveName(Param){\r\n    return new Promise((resolve, reject)=> {\r\n      wx.cloud.init()\r\n      // 云函数调用\r\n      wx.cloud.callFunction({\r\n           name: 'addTest',\r\n           data: {\r\n            ...Param\r\n           },\r\n           success: res => {\r\n              wx.showToast({\r\n                title: '昵称更新成功',\r\n              })\r\n\r\n              resolve(res)\r\n           },\r\n           fail: err => { \r\n              wx.showToast({\r\n                icon: 'none',\r\n                title: '昵称更新失败'\r\n              })\r\n              reject(err)\r\n           }\r\n         })\r\n    })\r\n  },\r\n  // 执行登录\r\n  toAddPage(){\r\n    wx.cloud.init({})\r\n    wx.cloud.callFunction({\r\n      name: 'login',\r\n      data: {},\r\n      success: res => {\r\n        app.globalData.openid = res.result.openid\r\n        wx.switchTab({\r\n          url: '/pages/add/add'\r\n        })\r\n      },\r\n    })\r\n\r\n  },\r\n复制代码定时任务与关联查询\r\n特意新建了一张表，用来存排行榜的数据，目前云开发还没有多表关联查询的功能，如果自己匹配挺耗费配额，就弄了一个表存起来数据，每天定时跑出排行榜的数据。\r\n说下流程\r\n1、批量删除表里的数据\r\n2、查询今日签到信息\r\n3、查询用户昵称\r\n4、储存信息\r\n主要用async + for...of 实现异步串行的读、存效果，下边是代码。\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\nconst _ = db.command\r\nconst moment = require('moment')\r\n\r\n// 昨日签到列表\r\nconst getList = () => {\r\n    return db.collection('list').where({\r\n\t\t      // date:'2019-08-03'\r\n          date:moment().format('YYYY-MM-DD')\r\n          // date:moment().subtract(1, 'days').format('YYYY-MM-DD')\r\n\t\t    }).get()\r\n}\r\n\r\n// 获取昵称\r\nconst getName = (openId) => {\r\n    return db.collection('users').where({\r\n\t\t      _openid: openId\r\n\t\t    }).get()\r\n}\r\n\r\n\r\n// 保存排行榜\r\nconst addTopUserInfo = (openId,Param) => {\r\n    return db.collection('topList').add({\r\n        data: {\r\n            _openid: openId,\r\n            ...Param\r\n        }\r\n    })\r\n}\r\n\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext()\r\n\r\n  try {\r\n    console.log(moment().subtract(1, 'days').format('YYYY-MM-DD'))\r\n\r\n    // 删除之前数据\r\n    let removeList = await db.collection('topList').where({'_openid':_.neq('123')}).remove()\r\n\r\n    // 获取列表数据\r\n  \tlet result\r\n  \tawait getList().then(res => {\r\n  \t\tresult = res.data\r\n  \t})\r\n\r\n    console.log(result)\r\n\r\n    let arr = []\r\n    // 循环存储\r\n    for(let item of result) {\r\n       await getName(item._openid).then(res => {\r\n          res.data.length == 1 ? item.name = res.data[0].nickName : item.name = '匿名用户'\r\n          res.data.length == 1 ? item.url = res.data[0].avatarUrl : item.avatarUrl = '../../images/null.png'\r\n\r\n        })\r\n    }\r\n\r\n    for(let item of result) {\r\n      await addTopUserInfo(item._openid,item).then(res => {\r\n        console.log(res,1)\r\n      }) \r\n    }\r\n    console.log('end')\r\n    \r\n  \treturn result\r\n\r\n  }catch(e){\r\n\r\n  }\r\n}\r\n\r\n复制代码定时任务在云函数的描述文件中定义，详见官方文档\r\n{\r\n  \"triggers\": [\r\n    {\r\n      \"name\": \"myTrigger\",\r\n      \"type\": \"timer\",\r\n      \"config\": \"0 0 23 * * * *\"\r\n    }\r\n  ]\r\n}\r\n\r\n复制代码查询排序\r\n新建排行榜页面，在页面中使用，limit为指定条数，orderBy指定排序条件，很简单了。\r\nwx.cloud.init()\r\n    const db = wx.cloud.database()\r\n    db.collection('topList').limit(100).orderBy('index', 'desc').get({\r\n      success:  (res) => {\r\n        console.log(res)\r\n        this.setData({\r\n          resault:res.data\r\n        })\r\n      }\r\n    })\r\n复制代码\r\n欢迎使用，哈哈哈"}
{"title": "小程序echart图层级显示问题 ", "author": "Rolan", "pub_time": "2019-8-22 00:26", "content": "前言\r\n使用过echart插件开发小程序的同学，应该都会遇到这个问题。尤其常见的是需求是：顶部固定，其他内容可以滚动 ，这时你会发现绘制的图形是会穿透所固定的顶部，并且无论你怎么给顶部区域设置css的z-index都是无效的。\r\n来看下案发现场例子：\r\n\r\n\r\n其实微信官方有写到，诸如canvas，video等组件是使用客户端创建的原生组件，而原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。为了解决这个问题，官方提供了cover-view 与 cover-image这两个组件，这两个组件其实也是使用原生组件进行渲染，所以可以在显示层级上覆盖其他原生组件，但是也有一些明显使用限制：\r\n\r\n我从实际开发来看，最棘手的限制就是cover-view能嵌套的组件太少，内部只能嵌套cover-view,cover-image及button，样式上不支持单边border，单边radius，及shadow阴影。\r\n下面这张是设计师原图，可以看到顶部tab按钮是用到了单边radius，这就无法实现了。\r\n\r\n实战踩坑分享(基于taro框架开发)\r\n头部实现\r\n其实这里只需要将普通的view组件换成cover-view即可，fixed定位于顶部\r\n画线\r\n既然无法实现单边border，那要怎么画单条线呢？\r\n聪明的你可能想到了利用移动端1px线条的画法，例如：\r\n    background-size: 100% 1px;\r\n    background-repeat: no-repeat;\r\n    background-position: bottom left;\r\n    background-image: linear-gradient(0, #ededed, #ededed 50%, transparent 50%);\r\n复制代码遗憾的是经过测试，该写法无效；\r\n\r\n需要注意的是，很多情况下开发者工具模拟器可以达到正常想要效果，真机就不能，所以开发时一定要用真机调试\r\n\r\n这边就利用一个空壳cover-view实现，例如底部线条：\r\n.cover-border-b{\r\n        position: absolute;\r\n        bottom: 0;\r\n        left: 0;\r\n        width: 100%;\r\n        height: 2px; // 这边开发用了taro框架，实际高度相当于小程序2rpx单位\r\n        background-color: #ededed; // 边框颜色\r\n   }\r\n复制代码使用：放置直接父元素下面，并将其父元素设置position:relative属性;\r\n<CoverView className='cover-border-b'></CoverView>\r\n复制代码弹出层选择器\r\n穿透问题\r\n同理，将弹出层实现全部换成cover-view，上面提到过cover-view能嵌套的组件只有cover-view,cover-image及button,这样有个很大的问题就是无法使用picker组件了。\r\n遇到的坑\r\n正常情况下，弹出层都会以一个单独的组件抽离出来。这边实践发现，抽离出来后，却无法直接在组件中通过this.props.children获取到数据进行渲染：\r\n<FloatLayoutCover>\r\n        <CoverView>test text</CoverView>\r\n        <CoverView>test text</CoverView>\r\n        <CoverView>test text</CoverView>\r\n</FloatLayoutCover>\r\n复制代码以上写法真机中是无法渲染出数据的，测试发现只传文字时才会进行渲染：\r\n<FloatLayoutCover>\r\n        test text\r\n        test text\r\n        test text\r\n</FloatLayoutCover>\r\n复制代码但这个写法是毫无意义的，都无法对其设置样式。最后是以数据形式传入，在组件内部对数据进行处理：\r\n<FloatLayoutCover\r\n     title='选择时间'\r\n     isOpened={panelShow}\r\n     onConfirm={this.handleResult.bind(this)}\r\n     showCloseIcon={false}\r\n     contentHeight={400}\r\n     data={data}\r\n     activeIndex={activeIndex}\r\n>\r\n</FloatLayoutCover>\r\n复制代码<CoverView className='layout-body' style={{height: contentHeight + 'rpx'}}>\r\n     {\r\n        data.map((item, index) => {\r\n            return \r\n              <CoverView \r\n                  className={`${index === activeIndex && 'active'} option-item`} \r\n                  onClick={() => this.props.onConfirm(index)}>\r\n              {item}\r\n            </CoverView>\r\n       })\r\n     }\r\n</CoverView>\r\n复制代码最后实现效果：\r\n\r\n最后\r\n如果你也是基于taro框架进行echart开发的话，在初始编译完成打开项目运行的时候（npm run dev:weapp），应该也会遇到下面这个报错。\r\n\r\n被这个问题坑了很长一段时间，最后发现是每次重新编译时，taro框架不仅仅是将我存放echart.js文件移动到dist对应目录下，还对它进行了某种处理，导致实际运行的dist目录下的echart.js文件被破坏了，只能每次冷编译完成后，手动将开发目录下的echart.js替换掉dist目录下编译生成的。\r\n如果你对此问题有更好的办法，欢迎留言，谢谢。"}
{"title": "研究了多个出行类小程序后，我们发现了留住用户的秘密 ", "author": "Rolan", "pub_time": "2019-8-26 00:02", "content": "上一期，我们聊到小程序“蓝牙能力”就像篮球场上力挽狂澜的“第六人”。这次微信公开课与晓程序观察（yinghoo-tech）一起，继续研究“蓝牙”能力在出行场景里发挥的作用。我们发现除了智能家居、共享充电设备领域，蓝牙在出行领域更是一个“神器”，堪比“好邻居”蜘蛛侠一样，能解决各种身边的问题。日常出行中这些“奇葩”景象不陌生： 过高速收费站时，人工收费通道排长龙，ETC通道廖无几人；充值交通卡时，明明手机就能解决，很多人却去窗口“人挤人”；好不容易发现一辆共享单车，却因网络太差而开不了锁，只好放弃... 这些新技术的出现，原本是为方便我们出行生活的，如今却因为网络问题，或者是体验不好成为“bug”，如ETC难办、充值App下载有门槛、共享单车网络开锁不稳定等。另一方面，对于开发者来说，因此流失用户也不值当。 “小程序+蓝牙”，是怎么来解决这些问题的？ 我们邀请到ETC助手、e行卡、卡亭、青桔单车等四款小程序的开发者，来谈谈如何发挥蓝牙的“超能力”。12.5亿车主需要的ETC业务 小程序+蓝牙都不能少截至2019年6月，全国汽车保有量达2.5亿。在国家ETC政策的推动下，办理ETC成了全国车主们纷纷关心的大事。但ETC难办，确是落实困难的主要原因。 去线下办理过ETC的朋友应该清楚，不仅网点覆盖少，办理过程更是繁琐，期间一度想要放弃，“还是踏踏实实走人工通道吧，反正也很少走高速”。现在，通过小程序，车主像是拥有了一位“私人助理”，足不出户就能办理ETC。一款叫做「ETC助手」的小程序正是使用了蓝牙能力，成为了很多车主办理ETC的首选。 「ETC助手」小程序团队感叹：“有了小程序蓝牙能力后，用户不用专门花上几个小时的时间去找ETC服务网点了。ETC设备激活只需十几秒，可以随时进行。”以前，这一步骤是线下ETC网点工作人员来完成的。另一款小程序「e行卡」也可以自助办理ETC，用户通过「e行卡」进行申请，收到电子标签（OBU）与e行卡之后，就可以自己安装激活设备了。过程很简单，先将电子标签贴在车前挡风玻璃，插入e行卡。等OBU蓝牙打开，进入「e行卡」小程序内的“装标签”，与OBU蓝牙连接成功后，按照流程操作就行。看似复杂的过程，车主实际操作起来不到1分钟就能搞定。蓝牙充当了激活ETC设备的关键角色。“蓝牙”秒速连接的能力，让车主几乎无门槛地享受到了不用停车直接过收费站的快感。 对于开发者来说，实现也不复杂，相比App蓝牙能力较高的开发难度，小程序则直接调用蓝牙能力就能完成。正是有了“蓝牙”的助攻，这两个小程序也出现了“前所未有”增长现象。 “自去年7月上线以来，现在还能保持每月100万以上的用户增长”，「e行卡」小程序团队说。ETC助手小程序的最新用户也达到了2500万。2蓝牙竟然能充公交卡？这是真的……针对出行场景，小程序蓝牙能力不仅能让有车一族更加便利，对习惯“环保出行”的用户，蓝牙能力照样能出一份力。比如，充值公交卡。 你一定有过这样的经历：早高峰，飞奔着来到地铁站，一刷卡，却显示“余额不足”，此时心中肯定是想把自己“打死”。充值公交卡这件事，似乎是一个“魔咒”，越是赶时间的时候，公交卡越容易出现“余额不足”的情况。 虽然可以选择现金充值、下载App充值，但带现金和下载App本身就是一道“槛”。 而“小程序+蓝牙”，可以“神奇”地实现充值。以「卡亭」小程序为例，用户只需找到充值设备，将公交卡放入卡槽内，然后打开手机蓝牙，用微信扫描二维码充值即可，既方便又高效。（小程序蓝牙公交卡充值机器）它充值的逻辑就是，小程序通过蓝牙与充值设备形成连接，然后将充值后的数据同步到公交卡，而蓝牙能力在这一过程中起到了核心作用。开发难度上也不大，直接将蓝牙能力放进小程序即可。3解锁共享单车有时候蓝牙比4G更好用有时候，明明触手可及，却又“不可触摸”。说的就是网络信号弱时，打开了共享单车小程序，但没法连接单车。原来3秒就能开锁的简单动作，就变成了长时间的等待甚至开不了锁。因此，拓展更多解锁方式，是共享单车们都在做的“功课”。「青桔单车」曾在扫码之外，还用过短信通知的方式开锁，但成本、效率上都不尽如人意。于是，开发成本低、解锁速度又快的“蓝牙”脱颖而出。用户打开蓝牙，扫码进入小程序就能直接解锁。“不论什么环境下，蓝牙锁依然能保持非常高的开锁成功率。”开锁成功率的提升，也标志着用户留存的提升，青桔单车小程序项目组表示，蓝牙能力给「青桔」单车带来了5%以上的订单增量。 随着「青桔」单车对蓝牙能力的理解加深，他们也为开发者总结了一些经验：  01 尽可能去掌握蓝牙（BLE）的协议，及特性，比如通信的距离，数据传输的方式。  02 iOS、Android在通信的方式上有差异，比如IOS搜索到的蓝牙设备需要转一层才是MAC地址。  03 在进行蓝牙写动作，不能连续写，可以每次写的时候加个100ms的延时，同时传输的数据超过20字节需要进行分片发送。  04 多看文档，一定要多看文档，因为各平台对蓝牙接口的处理方式不一定相同，一定要注意细节。 细节决定成败，或许未来，不仅仅是出行、智能家居、通讯、车载设备等场景，会有更多小程序发现“蓝牙”的更多玩法。"}
{"title": "【微信小程序】图片压缩-纯质量压缩，非长宽裁剪压缩 ", "author": "Rolan", "pub_time": "2019-8-26 00:06", "content": "原理：利用canvas来实现，将图片绘制到canvas上，然后canvas转图片时，微信提供的一个方法wx.canvasToTempFilePath(Object object, Object this)，此方式可以指定生成图片的质量，下图是从官方API截的图：其中quality可以指定图片的质量，quality的值越小，图片越模糊，通过此方法可以实现图片的压缩注意：1.quality设置只对jpg格式的图片有效，使用时要将fileType设置为“jpg”， 此举可能会导致其它格式的图片变为jpg格式\r\n\r\n2.透明背景的png图片，绘制到canvas上使用此方式导出的图片是黑色背景，有需求的话是需要canvas先设置背景色的，请小伙伴们注意爬坑。\r\n复制代码有了这个参数，压缩就简单很多了，下面是代码：wxml<view>\r\n  <button bindtap=\"chooseImage\">选择图片</button>\r\n</view>\r\n\r\n<!-- 展示压缩后的图片 -->\r\n<view style=\"display: flex;justify-content: center;flex-direction: column\">\r\n  <image width=\"50\" mode=\"widthFix\" src=\"{{imagePath}}\"></image>\r\n</view>\r\n\r\n<button wx:if=\"{{imagePath.length>0}}\" bindtap=\"save\">点击下载压缩后的图片</button>\r\n\r\n<!-- 用来渲染的canvas --> \r\n<canvas canvas-id='attendCanvasId' class='myCanvas' style='width:{{cWidth}}px;height:{{cHeight}}px;position: fixed;top: -9999px;left: -9999px;'></canvas>\r\n复制代码jsPage({\r\n  data: {\r\n    imagePath: '',\r\n    quality: 0.2\r\n  },\r\n  onLoad: function (options) {\r\n  \r\n  },\r\n  /**\r\n  * 选项添加图片事件\r\n  */\r\n  chooseImage: function (e) {\r\n    var that = this;\r\n    wx.chooseImage({\r\n      sizeType: ['compressed'],  //可选择原图或压缩后的图片\r\n      sourceType: ['album', 'camera'], //可选择性开放访问相册、相机\r\n      success: result => {\r\n        wx.getImageInfo({\r\n          src: result.tempFilePaths[0],\r\n          success: function (res) {\r\n            that.setData({\r\n              cWidth: res.width,\r\n              cHeight: res.height\r\n            })\r\n            that.getCanvasImg(result.tempFilePaths, res.width, res.height, that.data.quality, function (res) {\r\n              that.setData({\r\n                imagePath: res.tempFilePath\r\n              });\r\n            });\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  /**\r\n   * 质量压缩\r\n   */\r\n  getCanvasImg(tempFilePaths, canvasWidth, canvasHeight, quality, callback) {\r\n    var that = this; \r\n    const ctx = wx.createCanvasContext('attendCanvasId');\r\n    ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n    ctx.drawImage(tempFilePaths[0], 0, 0, canvasWidth, canvasHeight);\r\n    ctx.draw(false, function () {\r\n      wx.canvasToTempFilePath({\r\n        canvasId: 'attendCanvasId',\r\n        fileType: 'jpg',\r\n        quality: quality,\r\n        success: function success(res) {\r\n          callback && callback(res)\r\n        }, fail: function (e) {\r\n          wx.showToast({\r\n            title: '图片上传失败，请重新上传！',\r\n            icon: 'none'\r\n          })\r\n        }\r\n      });\r\n    });\r\n  },\r\n  /**\r\n   * 图片保存到相册\r\n   */\r\n  save(e) {\r\n    let that = this;\r\n    wx.saveImageToPhotosAlbum({\r\n      filePath: that.data.imagePath,\r\n      success: function (res) {\r\n        console.log('图片已保存');\r\n      },\r\n      fail: function (res) {\r\n        console.log('保存失败');\r\n      }\r\n    })\r\n  },\r\n})\r\n复制代码注意点：注意设置canvas-id='attendCanvasId'canvas要离屏渲染，就是移出屏幕之外，但是元素还是显示的，position: fixed;top: -9999px;left: -9999px; 不能使用 display: none; 这样是获取不到canvas元素的。最后h5页面中也有提供这样的方法例如这样子：let canvas = document.createElement('canvas');\r\nlet ctx = canvas.getContext('2d');\r\nctx.drawImage(imagePath, 0, 0, w, h);\r\ncanvas.toDataURL('image/jpeg', quality);\r\n复制代码需要的小伙伴也可以自己研究研究哈...ok, 结束， :clap:"}
{"title": "Remax - 使用真正的 React 构建小程序 ", "author": "Rolan", "pub_time": "2019-8-27 00:11", "content": "为什么要用 React 来构建小程序\r\n因为 React 是我们最熟悉的技术。\r\n小程序糟糕的 API 设计已经有很多文章吐槽，这里就不再赘述了。再加上现在一大堆小程序平台，每个平台之间又有大大小小的差异，这对于有跨平台需求的小程序来说无异于是一场灾难。\r\nReact 的社区生态体系非常庞大，通过在小程序中引入 React 以及 React Hooks 提供的逻辑抽象能力，我们可以在小程序中直接利用 React 生态体系中大量的技术沉淀（比如：react-use、field-form)。\r\n更完整的 TypeScript 支持。当然你也可以用 TypeScript 去写现有的小程序，但是由于小程序的架构原因，模板层跟逻辑层（也就是 Page）有天然的割裂，即使在逻辑层使用了 TypeScript，在模板层也无法享受类型检查和自动补全带来的便利。引入 React 后，我们的代码全部运行在逻辑层中，可以全程静态类型护航，给你满满的安全感。\r\n现有的方案\r\n目前社区中使用 React 构建小程序的方案大都使用静态编译的方式实现。所谓静态编译，就是使用工具把代码语法分析一遍，把其中的 JSX 部分和逻辑部分抽取出来，分别生产小程序的模板和 Page 定义。\r\n这种方案最大的问题就是会有很多限制，因为语法分析是静态的，所以这些方案都会去限制一些动态的写法。另外正是因为 JavaScript 语言的动态性，要去做语法分析本身就是件很复杂的事情，所以这些方案实现起来往往也非常复杂。\r\n最重要的，静态编译后的你的代码就转换成了小程序代码，运行时其实并没有 React 的存在，你只是用了 React 的写法， 而不是真正的在用 React 做应用。\r\n我们的方案\r\n今年初的时候，@xcodebuild 向大家介绍了如何在小程序中使用 React with Hooks。这是一个非常创新的方案，我们在对这个方案做了完善，并且在线上小程序中得到验证后，正式发布了基于 React 的小程序开发框架：\r\n\r\nwww.remaxjs.org\r\nRemax 让你可以使用真正的 React 去构建小程序，你可以他理解成面向小程序的 React Native。\r\nRemax 原理\r\n首选来看一下小程序的架构（支付宝和微信大同小异）：\r\n\r\n正如上面提到的，小程序架构分为两层，你写的逻辑代码独立运行在一个进程中，每个页面会有自己独立的渲染进程（也就是一个 webview）用来渲染模板。而整个小程序又运行在 APP 容器中（也就是支付宝和微信本身）。逻辑层和视图层之间通过建立一个消息通道来通信。\r\n再来看下 React 的架构：\r\n\r\n最下面一层是 React 本身，上层的 ReactDOM 和 ReactNative 我们称之为「Renderer」。Renderer 跟 React 之间通过 ReactReconciler 连接把元素（也就是通常所说的「虚拟 DOM」）渲染到对应的平台上。而 Remax 就是一个我们实现的 Renderer，它把「虚拟 DOM」渲染到了小程序的视图层上。\r\n\r\n可以看到，我们把 React 和 ReactReconciler 运行在小程序的逻辑层中，并通过 Remax 把生成的「虚拟 DOM」渲染到视图层。从而做到了使用真正的 React 去构建小程序。\r\n最后\r\n正如第一段中提到的，把 React 运行在小程序中可以带来非常大的想象力。小程序本身可以说是一种创新，它把应用分为两层来提高视图层的渲染速度，但是微信从一开始就选择使用私有且落后（起码目前看来是落后的）的技术方案来定义小程序，而后面的追随者为了吸引开发者亦使用了跟微信小程序类似的设计。Remax 希望能打破这个局面，通过开放的生态为开发者带来全新的小程序开发体验。"}
{"title": "用小程序·云开发两天搭建mini论坛丨实战 ", "author": "Rolan", "pub_time": "2019-8-26 00:09", "content": "笔者最近涉猎了小程序相关的知识，于是利用周末时间开发了一款类似于同事的小程序， 深度体验 了小程序云开发模式提供的 云函数、数据库、存储 三大能力。关于云开发，可参考文档： 小程序·云开发 。个人感觉云开发带来的最大好处是 鉴权流程的简化和对后端的弱化 ，所以像笔者这种从未接触过小程序开发的人也能够在周末两天时间内开发出一个功能完备、体验闭环的勉强能用的产品。最后，本文并不是搬运官方文档，也不会详细介绍开发工具和云开发后台的使用，所以建议结合上面给出文档链接一起消化本文。功能分析该小程序功能目前较为简单（发布帖子、浏览帖子、发布评论），可用下图表示，无需赘述：由架构图可知，云开发的数据库（存帖子、存评论）、存储（图片）、云函数（读、写、更新数据库等）都将涉及， 很好地达到了练手的目的 。发布帖子如果帖子不带图片，直接写数据库即可，如果带图片则需要先存入图片到云开发提供的存储中，拿到返回的fileId（可理解为图片的url）再一并写入数据库，核心代码：for (let i = 0; i < img_url.length; i++) {\r\n      var str = img_url[i];\r\n      var obj = str.lastIndexOf(\"/\");\r\n      var fileName = str.substr(obj + 1)\r\n      console.log(fileName)\r\n      wx.cloud.uploadFile({\r\n        cloudPath: 'post_images/' + fileName,//必须指定文件名，否则返回的文件id不对\r\n        filePath: img_url[i], // 小程序临时文件路径\r\n        success: res => {\r\n          // get resource ID: \r\n          console.log(res)\r\n          //把上传成功的图片的地址放入数组中\r\n          img_url_ok.push(res.fileID)\r\n          //如果全部传完，则可以将图片路径保存到数据库\r\n          if (img_url_ok.length == img_url.length) {\r\n            console.log(img_url_ok)\r\n            that.publish(img_url_ok)\r\n          }\r\n        },\r\n        fail: err => {\r\n          // handle error\r\n          console.log('fail: ' + err.errMsg)\r\n        }\r\n      })\r\n    }通过 img_url_ok.length == img_url.length 我们确定所有图片已经上传完成并返回了对应的id，然后执行写入数据库的操作：/**\r\n   * 执行发布时图片已经上传完成，写入数据库的是图片的fileId\r\n   */\r\n  publish: function(img_url_ok) {\r\n    wx.cloud.init()\r\n    wx.cloud.callFunction({\r\n      name: 'publish_post',\r\n      data: {\r\n        openid: app.globalData.openId,// 这个云端其实能直接拿到\r\n        author_name: app.globalData.userInfo.nickName,\r\n        content: this.data.content,\r\n        image_url: img_url_ok,\r\n        publish_time: \"\",\r\n        update_time: \"\"//目前让服务器自己生成这两个时间\r\n      },\r\n      success: function (res) {\r\n        // 强制刷新，这个传参很粗暴\r\n        var pages = getCurrentPages();             //  获取页面栈\r\n        var prevPage = pages[pages.length - 2];    // 上一个页面\r\n        prevPage.setData({\r\n          update: true\r\n        })\r\n        wx.hideLoading()\r\n        wx.navigateBack({\r\n          delta: 1\r\n        })\r\n      },\r\n      fail: console.error\r\n    })\r\n  },通过 wx.cloud.callFunction 我们调用了一个 云函数 （通过 name 指定函数名），并将帖子内容 content 和图片 image_url 以及其他信息（发布者昵称、id等）一并传到云端。然后再看看这个云函数：exports.main = async (event, context) => {\r\n  try {\r\n    return await db.collection('post_collection').add({\r\n      // data 字段表示需新增的 JSON 数据\r\n      data: {\r\n        // 发布时小程序传入\r\n        //author_id: event.openid,不要自己传，用sdk自带的\r\n        author_id: event.userInfo.openId,\r\n        author_name: event.author_name,\r\n        content: event.content,\r\n        image_url: event.image_url,\r\n        // 服务器时间和本地时间会造成什么影响，需要评估\r\n        publish_time: new Date(),\r\n        // update_time: event.update_time,// 最近一次更新时间，发布或者评论触发更新,目前用服务器端时间\r\n        update_time: new Date(),\r\n        // 默认值，一些目前还没开发，所以没设置\r\n        // comment_count: 0,//评论数，直接读数据库，避免两个数据表示同一含义\r\n        watch_count: 3,//浏览数\r\n        // star_count: 0,//TODO：收藏人数\r\n      }\r\n    })\r\n  } catch (e) {\r\n    console.error(e)\r\n  }\r\n}可以看到，云函数写入了一条数据库记录，我们的参数通过 event 这个变量带了进来。获取帖子列表所谓获取帖子列表其实就是读上一节写入的数据库，但是我们并不需要全部信息（例如图片url），并且要求按照时间排序，如果熟悉数据库的话，会发现这又是一条查询语句罢了：exports.main = async (event, context) => {\r\n  return {\r\n    postlist: await db.collection('post_collection').field({// 指定需要返回的字段\r\n      _id: true,\r\n      author_name: true,\r\n      content: true,\r\n      title: true,\r\n      watch_count: true\r\n    }).orderBy('update_time', 'desc').get(),//指定排序依据\r\n\r\n  }\r\n}浏览帖子内容浏览帖子内容及给定一个帖子的id，由帖子列表点击时带入：onItemClick: function (e) {\r\n    console.log(e.currentTarget.dataset.postid)\r\n    wx.navigateTo({\r\n      url: '../postdetail/postdetail?postid=' + e.currentTarget.dataset.postid,\r\n    })\r\n  },然后在云函数中根据这个id拿到全部数据：exports.main = async (event, context) => {\r\n  \r\n  return {\r\n    postdetail: await db.collection('post_collection').where({\r\n      _id: event.postid\r\n    }).get(),\r\n  }\r\n}拿到全部数据后，再根据图片id去加载贴子的图片：// 获取内容\r\n    wx.cloud.callFunction({\r\n      // 云函数名称 \r\n      name: 'get_post_detail',\r\n      data: {\r\n        postid: options.postid\r\n      },\r\n      success: function (res) {\r\n        var postdetail = res.result.postdetail.data[0];\r\n        that.setData({\r\n          detail: postdetail,\r\n          contentLoaded: true\r\n        })\r\n        that.downloadImages(postdetail.image_url)\r\n      },\r\n      fail: console.error\r\n    })这里 that.downloadImages(postdetail.image_url) 即加载图片：/**\r\n   * 从数据库获取图片的fileId，然后去云存储下载，最后加载出来\r\n   */\r\n  downloadImages: function(image_urls){\r\n    var that = this\r\n    if(image_urls.length == 0){\r\n      return\r\n    } else {\r\n      var urls = []\r\n      for(let i = 0; i < image_urls.length; i++) {\r\n        wx.cloud.downloadFile({\r\n          fileID: image_urls[i],\r\n          success: res => {\r\n            // get temp file path\r\n            console.log(res.tempFilePath)\r\n            urls.push(res.tempFilePath)\r\n            if (urls.length == image_urls.length) {\r\n              console.log(urls)\r\n              that.setData({\r\n                imageUrls: urls,\r\n                imagesLoaded: true\r\n              })\r\n            }\r\n          },\r\n          fail: err => {\r\n            // handle error\r\n          }\r\n        })\r\n      }\r\n    }\r\n  },发表评论发表评论和发布帖子逻辑类似，只是写入的数据不同，不做赘述。总结前面说过，云开发弱化了后端（简化鉴权本质也是弱化后端），这样带来的好处就是提高了开发效率，因为前后端联调向来都是一件耗时间的事情，而且小程序本身主打的就是小型应用，实在没有必要引入过多的开发人员。但云开发也不是万能的，例如我一开始想做RSS阅读器，那么后端就需要聚合信息，目前云开发还做不了。个人感觉只要是信息类的小程序，如新闻类、视频类，云开发目前都很乏力，因为数据库的支持还过于简陋（也可能是我太菜，没发现很好的解决办法，欢迎拍砖）。但如果是本文提及的这种用户自己也会产生信息的小程序，那么云开发则会有开发效率上的优势。最后就是云开发目前提供的2G数据库和5G存储，对于一些用户量较多的小程序是否足够也是个问题，目前也没见有付费版。总的类说，初次接触小程序开发，还是发现有不少值得借鉴学习之处。源码链接https://github.com/TencentCloudBase/Good-practice-tutorial-recommended如果你有关于使用云开发CloudBase相关的技术故事/技术实战经验想要跟大家分享，欢迎留言联系我们哦~比心！"}
{"title": "微信小程序和Jenkins不得不说的二三事 ", "author": "Rolan", "pub_time": "2019-8-27 00:09", "content": "微信开发工具是我们开发微信小程序的重要工具，提供了预览、上传代码的功能，但是里面的上传代码在协作过程中是很痛苦的，同时只能有一个预览版，这个预览版还是跟某个开发者绑定的。想象下，5个开发者，里面可能要麻烦1个人专职负责发布。除此之外，小程序的发布严重依赖于开发者以及Ta的电脑，一旦有紧急情况可能就面临无人可发的问题。在我们的团队中就遇到这样那样的问题，我们都知道 jenkins 用来做自动化构建，在很多项目中都会用它，所以最终开发了 mimi-deploy 脚本插件来配合 jenkins 使用。当然 mini-deploy 不仅限于此，也可以在任何 node.js 的环境中执行并和您的程序配套使用，想象力有多大，效率就有多大。本来以在 jenkins 中使用的角度来介绍 mini-deploy 的使用，让我们开始吧。1. 准备要求要求如下：运行在 windows 或 Mac 系统的电脑jenkins 运行在该电脑微信开发工具安装在该电脑一个微信号2. 如何配置2.1 创建任务假设我们已经运行 jenkins ，点击\"新建任务\"开始填写任务信息，输入任务名称并选择\"构建一个自由风格的软件项目\"。如果需要创建多个任务，可以最后的\"复制\"功能。2.2 配置任务2.2.1 源码管理\"源码管理\"中配置项目代码，以 Git 为例，需要配置两个参数：$branch\r\n ￼2.2.2 参数化构建过程在\"General\"中勾选\"参数化构建过程\"，然后点击\"添加参数\"，在候选列表中选择 Git Parameter，配置以下两项：Name\r\nParameter Type\r\n这样在前面\"源码管理\"中配置的 $branch 就可以访问到仓库的所有分支。另外还需要添加两个文本参数： upload_version 和 upload_desc (用于发布小程序时的版本号和描述)。 ￼以及一个选项参数： build_type (指定打包小程序的目标环境)。候选数据一行一条记录输入即可。2.2.3 添加构建执行Shell在\"构建\"中点击\"增加构建步骤\"按钮，在候选列表中选择\"执行 shell\"。这一步是最关键之处，我们会调用 mini-deploy 来发布小程序，先贴出来我在用的 shell 脚本：#!/bin/bash\r\necho -------------------------------------------------------\r\necho 代码分支: ${GIT_BRANCH}\r\necho -------------------------------------------------------\r\n# 准备工作\r\n\r\n# 加速包安装以及node-sass\r\n# 因为使用的是taro，所以会有node-sass\r\nyarn config set registry https://registry.npm.taobao.org\r\nyarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass\r\n\r\n# 安装依赖\r\nyarn install \r\n\r\n# 删除dist并执行打包\r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  rm -rf dist && yarn run build\r\nelse\r\n  rm -rf dist && yarn run $build_type\r\nfi\r\n\r\nif [ \"$build_type\" == \"prod\" ] || [ \"$build_type\" == \"build\" ]\r\n  then\r\n    mini-deploy --mode=upload --ver=$upload_version --desc=\"$upload_desc\" --login.format=image --login.qr='login.png' --no-resume\r\n\r\n    let \"result |= $?\"\r\n\r\n    if [ \"$result\" == \"0\" ]\r\n      then\r\n        # 发送通知到钉钉群\r\n        yarn run notify\r\n      fi\r\nelse\r\n  rm -rf ./preview.png\r\n  rm -rf ./login.png\r\n  mini-deploy --mode=preview --login.format=image --login.qr='login.png' --no-resume\r\n  \r\n  let \"result |= $?\"\r\n      \r\n  if [ \"$result\" == \"2\" ]\r\n    then\r\n        echo \"need login\"\r\n  fi\r\nfi使用 mini-deploy 时有两种方式：开发预览和上传代码，这里需要讲解下里面参数的用处。用户扫码登录微信开发工具后，过了一段时间可能被登录失效，这个时候再调用上传和预览是无效的，我们要再次扫码登录。在 mini-deploy 中需要登录时会自动重新获取登录二维码， login.format 和 login.qr 就是指定二维码的存储方式和文件名，目前包含 terminal （命令行输出）, base64 , image 三类。因为 jenkins 中无法实时获取执行结果，我们需要配置 no-resume 阻止 mini=deploy 自从续传任务，获取到登录二维码后直接完成任务。另外，我们配置二维码的格式为 image ，并且输出到项目工作区的 login.png 中，接下来再配合其他配置我们就可以在 jenkins 中看到登录二维码。# 上传代码\r\nmini-deploy --mode=upload --ver=$upload_version --desc=\"$upload_desc\" --login.format=image --login.qr='login.png' --no-resume\r\n\r\n# 预览\r\nmini-deploy --mode=preview --login.format=image --login.qr='login.png' --no-resume2.2.4 二维码结果展示在\"构建后操作\"中点击\"增加构建后操作步骤\"，选择 Set build description ：Regular expression : \\[mini-deploy\\] (.*)Description : \\1  ￼这里配置是为了把提醒信息显示出来，这样才能告知用户需要登录，以及显示开发码、上传的成功信息。// 日志中包含这样一条记录\r\n[mini-deploy] 进入Build详情扫开发码进入小程序'\r\n\r\n// 匹配成功后，`\\1`就代表以下信息\r\n进入Build详情扫开发码进入小程序3. 运行结果大功告成，最终我们的运行结果如下：开发预览版可以再构建历史扫描二维码进入需要登录时就显示登录二维码上传代码成功则只提示信息"}
{"title": "ProcessBuilder waitFor 调用外部应用 ", "author": "Rolan", "pub_time": "2019-8-27 00:14", "content": "小程序项目最初使用ffmpeg转换微信录音文件为wav格式，再交给阿里云asr识别成文字。视频音频转换最常用是ffmpeg。1ffmpeg -i a.mp3 b.wav相关文章：小程序实现语音识别转文字，坑路历程问题变成怎样使用java调用系统的ffmpeg工具。在java中，封装了进程Process类，可以使用Runtime.getRuntime().exec()或者ProcessBuilder新建进程。从Runtime.getRuntime().exec()说起最简单启动进程的方式，是直接把完整的命令作为exec()的参数。1234567try {    log.info(\"ping 10 times\");    Runtime.getRuntime().exec(\"ping -n 10 127.0.0.1\");    log.info(\"done\");} catch (IOException e) {    e.printStackTrace();}输出结果1217:12:37.262 [main] INFO com.godzilla.Test - ping 10 times17:12:37.272 [main] INFO com.godzilla.Test - done我期望的是执行命令结束后再打印done，但是明显不是。waitFor阻塞等待子进程返回Process类提供了waitFor方法。可以阻塞调用者线程，并且返回码。0表示子进程执行正常。1234567891011121314151617/** * Causes the current thread to wait, if necessary, until the * process represented by this {@code Process} object has * terminated.  This method returns immediately if the subprocess * has already terminated.  If the subprocess has not yet * terminated, the calling thread will be blocked until the * subprocess exits. * * @return the exit value of the subprocess represented by this *         {@code Process} object.  By convention, the value *         {@code 0} indicates normal termination. * @throws InterruptedException if the current thread is *         {@linkplain Thread#interrupt() interrupted} by another *         thread while it is waiting, then the wait is ended and *         an {@link InterruptedException} is thrown. */public abstract int waitFor() throws InterruptedException;123456789101112try {    log.info(\"ping 10 times\");    Process p =  Runtime.getRuntime().exec(\"ping -n 10 127.0.0.1\");    int code = p.waitFor();    if(code == 0){        log.info(\"done\");    }} catch (IOException e) {    e.printStackTrace();} catch (InterruptedException e) {    e.printStackTrace();}输出结果1217:15:28.557 [main] INFO com.godzilla.Test - ping 10 times17:15:37.615 [main] INFO com.godzilla.Test - done似乎满足需要了。但是，如果子进程发生问题一直不返回，那么java主进程就会一直block，这是非常危险的事情。对此，java8提供了一个新接口，支持等待超时。注意接口的返回值是boolean，不是int。当子进程在规定时间内退出，则返回true。1public boolean waitFor(long timeout, TimeUnit unit)测试代码1234567891011121314try {    log.info(\"ping 10 times\");    Process p = Runtime.getRuntime().exec(\"ping -n 10 127.0.0.1\");    boolean exit = p.waitFor(1, TimeUnit.SECONDS);    if (exit) {        log.info(\"done\");    } else {        log.info(\"timeout\");    }} catch (IOException e) {    e.printStackTrace();} catch (InterruptedException e) {    e.printStackTrace();}输出结果1217:43:47.340 [main] INFO com.godzilla.Test - ping 10 times17:43:48.352 [main] INFO com.godzilla.Test - timeout获取输入、输出和错误流要获取子进程的执行输出，可以使用Process类的getInputStream()。类似的有getOutputStream()、getErrorStream()。12345678910111213141516try {    log.info(\"ping\");    Process p = Runtime.getRuntime().exec(\"ping -n 1 127.0.0.1\");    p.waitFor();    BufferedReader bw = new BufferedReader(new InputStreamReader(p.getInputStream(), \"GBK\"));    String line = null;    while ((line = bw.readLine()) != null) {        System.out.println(line);    }    bw.close();    log.info(\"done\")} catch (IOException e) {    e.printStackTrace();} catch (InterruptedException e) {    e.printStackTrace();}注意，GBK是Windows平台的字符编码。输出结果1234567891018:28:21.396 [main] INFO com.godzilla.Test - ping正在 Ping 127.0.0.1 具有 32 字节的数据:来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128127.0.0.1 的 Ping 统计信息:    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 0ms，最长 = 0ms，平均 = 0ms18:28:21.444 [main] INFO com.godzilla.Test - done这里牵涉到一个技术细节，参考Process类的javadoc123456789101112* <p>By default, the created subprocess does not have its own terminal* or console.  All its standard I/O (i.e. stdin, stdout, stderr)* operations will be redirected to the parent process, where they can* be accessed via the streams obtained using the methods* {@link #getOutputStream()},* {@link #getInputStream()}, and* {@link #getErrorStream()}.* The parent process uses these streams to feed input to and get output* from the subprocess.  Because some native platforms only provide* limited buffer size for standard input and output streams, failure* to promptly write the input stream or read the output stream of* the subprocess may cause the subprocess to block, or even deadlock.翻译过来是，子进程默认没有自己的stdin、stdout、stderr，涉及这些流的操作，到会重定向到父进程。由于平台限制，可能导致缓冲区消耗完了，导致阻塞甚至死锁！网上有的说法是，开启2个线程，分别读取子进程的stdout、stderr。不过，既然说是By default，就是有非默认的方式，其实就是使用ProcessBuilder类，重定向流。此功能从java7开始支持。ProcessBuilder和redirect12345678try {    log.info(\"ping\");    Process p = new ProcessBuilder().command(\"ping -n 1 127.0.0.1\").start();    p.waitFor();    log.info(\"done\")}  catch (IOException | InterruptedException e) {    e.printStackTrace();}输出结果1234567891019:01:53.027 [main] INFO com.godzilla.Test - pingjava.io.IOException: Cannot run program \"ping -n 1 127.0.0.1\": CreateProcess error=2, 系统找不到指定的文件。\tat java.lang.ProcessBuilder.start(ProcessBuilder.java:1048)\tat com.godzilla.Test.main(Test.java:13)Caused by: java.io.IOException: CreateProcess error=2, 系统找不到指定的文件。\tat java.lang.ProcessImpl.create(Native Method)\tat java.lang.ProcessImpl.<init>(ProcessImpl.java:386)\tat java.lang.ProcessImpl.start(ProcessImpl.java:137)\tat java.lang.ProcessBuilder.start(ProcessBuilder.java:1029)\t... 1 more此处有坑：ProcessBuilder的command列表要用字符串数组或者list形式传入！ ps. 在小程序项目上，一开始把ffmpeg -i a.mp3 b.wav传入ProcessBuilder，却看不到生成的wav文件，查了日志CreateProcess error=2, 系统找不到指定的文件。还以为是ffmpeg路径问题。后来查了api才发现掉坑了。正确的写法1Process p = new ProcessBuilder().command(\"ping\", \"-n\", \"1\", \"127.0.0.1\").start();刚才说的重定向问题，可以这样写123Process p = new ProcessBuilder().command(\"ping\", \"-n\", \"1\", \"127.0.0.1\")        .redirectError(new File(\"stderr.txt\"))        .start();工作目录默认子进程的工作目录继承于父进程。可以通过ProcessBuilder.directory()修改。一些代码细节ProcessBuilder.Redirectjava7增加了ProcessBuilder.Redirect抽象，实现子进程的流重定向。Redirect类有个Type枚举1234567public enum Type {    PIPE,    INHERIT,    READ,    WRITE,    APPEND};其中PIPE: 表示子流程IO将通过管道连接到当前的Java进程。 这是子进程标准IO的默认处理。INHERIT: 表示子进程IO源或目标将与当前进程的相同。 这是大多数操作系统命令解释器（shell）的正常行为。对于不同类型的Redirect，覆盖下面的方法appendappendTofilefromtoRuntime.exec()的实现Runtime类的exec()底层也是用ProcessBuilder实现1234567public Process exec(String[] cmdarray, String[] envp, File dir)    throws IOException {        return new ProcessBuilder(cmdarray)        .environment(envp)        .directory(dir)        .start();}ProcessImplProcess的底层实现类是ProcessImpl。上面讲到流和Redirect，具体在ProcessImpl.start()方法123FileInputStream  f0 = null;FileOutputStream f1 = null;FileOutputStream f2 = null;然后是一堆繁琐的if…else判断是Redirect.INHERIT、Redirect.PIPE，是输入还是输出流。总结Process类是java对进程的抽象。ProcessImpl是具体的实现。Runtime.getRuntime().exec()和ProcessBuilder.start()都能启动子进程。Runtime.getRuntime().exec()底层也是ProcessBuilder构造的Runtime.getRuntime().exec()可以直接消费一整串带空格的命令。但是ProcessBuilder.command()必须要以字符串数组或者list形式传入参数默认子进程的执行和父进程是异步的。可以通过Process.waitFor()实现阻塞等待。默认情况下，子进程和父进程共享stdin、stdout、stderr。ProcessBuilder支持对流的重定向（since java7）流的重定向，是通过ProcessBuilder.Redirect类实现。"}
{"title": "微信-小程序开发基础知识笔记 ", "author": "Rolan", "pub_time": "2019-11-22 00:41", "content": "绑定事件的方法：1.bindtab和catchtab，catchtab可以阻止事件冒泡\r\n<view bindtap='onClick'></view>\r\n\r\n<view catchtap='onClick'></view>\r\n2.互斥事件绑定 mut-bind一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。在想要规定冒泡区间时可以用到。\r\n<view mut-bind:tap='onClick'></view>\r\n在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点\r\n<view mark:myMark=\"last\" bindtap=\"bindViewTap\">\r\n\r\n<button mark:anotherMark=\"leaf\" bindtap=\"bindButtonTap\">按钮</button>\r\n\r\n</view>\r\n在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。\r\nPage({\r\n\r\nbindViewTap: function(e) {\r\n\r\ne.mark.myMark === \"last\" // true\r\n\r\ne.mark.anotherMark === \"leaf\" // true\r\n\r\n}\r\n\r\n})\r\nmark 和 dataset 很相似，主要区别在于：1.mark可以冒泡，如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。2.在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark。3.不同于 dataset ，节点的 mark 不会做连字符和大小写转换。.wxs文件的应用个人理解 .wxs文件就相当于cocos的prefab。执行起来比js性能要快。但是wxs是一门语言，平行于JavaScript。wxs基础语法有频繁用户交互的效果在小程序上表现是比较卡顿的，这时建议使用wxs，为什么？因为小程序分为视图层和逻辑层，比如需要拖动的功能，touchmove事件从视图层抛到逻辑层，逻辑层经过处理，通过this.setData到视图层。1. 一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。2. 此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。WXS 函数的除了纯逻辑的运算，还可以通过封装好的ComponentDescriptor 实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class 很方便。代码示例：\r\nvar wxsFunction = function(event, ownerInstance) {\r\n\r\nvar instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例\r\n\r\ninstance.setStyle({\r\n\r\n\"font-size\": \"14px\" // 支持rpx\r\n\r\n})\r\n\r\ninstance.getDataset()\r\n\r\ninstance.setClass(className)\r\n\r\n// ...\r\n\r\nreturn false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault\r\n\r\n}\r\n自定义组件上边在分析复杂交互时我们知道，频繁的调用this.setData会使页面卡顿，甚至导致小程序僵死。那么不想写或者说不会写wxs的开发者该怎么办呢？此时可以通过将页面的 setData 改为 自定义组件 中的 setData 来提升性能。原因：自定义组件中的setData不会进行深复制。（深复制会在这个值被组件间传递时才发生）自定义组件的规范1.在组件wxss中不应使用ID选择器、属性选择器和标签名选择器，就只使用class选择器准没错。2.在自定义组件的 js 文件中，需要使用 Component() 来注册组件。3.使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。4.自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。5.<slot></slot>相当于react的this.props.children。\r\n<!-- component-tag-name组件 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<view>这里是组件的内部节点</view>\r\n\r\n<slot></slot>\r\n\r\n</view>\r\n\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot> 的位置上 -->\r\n\r\n<view>这里是插入到组件slot中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n6.默认情况下，一个组件的wxml中只能有一个slot。需要使用多slot时，可以在组件js中声明启用。\r\nComponent({\r\n\r\noptions: {\r\n\r\nmultipleSlots: true // 在组件定义时的选项中启用多slot支持\r\n\r\n},\r\n\r\nproperties: { /\\* ... \\*/ },\r\n\r\nmethods: { /\\* ... \\*/ }\r\n\r\n})\r\n此时，可以在这个组件的wxml中使用多个slot，以不同的 name 来区分。\r\n<!-- 组件模板 -->\r\n\r\n<view class=\"wrapper\">\r\n\r\n<slot name=\"before\"></slot>\r\n\r\n<view>这里是组件的内部细节</view>\r\n\r\n<slot name=\"after\"></slot>\r\n\r\n</view>\r\n使用时，用 slot 属性来将节点插入到不同的slot上。\r\n<!-- 引用组件的页面模板 -->\r\n\r\n<view>\r\n\r\n<component-tag-name>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"before\"> 的位置上 -->\r\n\r\n<view slot=\"before\">这里是插入到组件slot name=\"before\"中的内容</view>\r\n\r\n<!-- 这部分内容将被放置在组件 <slot name=\"after\"> 的位置上 -->\r\n\r\n<view slot=\"after\">这里是插入到组件slot name=\"after\"中的内容</view>\r\n\r\n</component-tag-name>\r\n\r\n</view>\r\n7.设置自定义组件的捕获和冒泡机制需要使用 triggerEvent 方法。\r\n// 组件 my-component.js\r\n\r\nComponent({\r\n\r\nmethods: {\r\n\r\nonTap: function(){\r\n\r\nthis.triggerEvent('customevent', {}, { bubbles: true, composed: true })\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的behaviors个人理解：多个页面可能会共用一个功能，这个功能抽象后称为组件。多个组件共用一个方法或者多个方法，这类方法的集合称为behaviors。就tm理解成高阶组件就完了。组件间关系relations官方说：有时需要实现这样的组件：\r\n<custom-ul>\r\n\r\n<custom-li> item 1 </custom-li>\r\n\r\n<custom-li> item 2 </custom-li>\r\n\r\n</custom-ul>\r\n说custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。具体怎么个复杂需要单独拎出来一个ralations属性来处理，咱也不知道。使用方法：\r\n// path/to/custom-ul.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-li': {\r\n\r\ntype: 'child', // 关联的目标节点应为子节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n},\r\n\r\n// path/to/custom-li.js\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'./custom-ul': {\r\n\r\ntype: 'parent', // 关联的目标节点应为父节点\r\n\r\nlinked: function(target) {\r\n\r\n// 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后\r\n\r\n},\r\n\r\nlinkChanged: function(target) {\r\n\r\n// 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后\r\n\r\n},\r\n\r\nunlinked: function(target) {\r\n\r\n// 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n注意：必须在两个组件定义中都加入relations定义，否则不会生效。还有一种情况，如果你两个自定义组件都用了相同的behaviors，你可以使用这个behavior来代替组件路径作为关联的目标节点。\r\n// path/to/custom-form.js\r\n\r\nvar customFormControls = require('./custom-form-controls')\r\n\r\nComponent({\r\n\r\nrelations: {\r\n\r\n'customFormControls': {\r\n\r\ntype: 'descendant', // 关联的目标节点应为子孙节点\r\n\r\ntarget: customFormControls\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n组件中的observers官方定义他叫数据监听器，呵呵。使用方法：\r\nComponent({\r\n\r\nattached: function() {\r\n\r\nthis.setData({\r\n\r\nnumberA: 1,\r\n\r\nnumberB: 2,\r\n\r\n})\r\n\r\n},\r\n\r\nobservers: {\r\n\r\n'numberA, numberB': function(numberA, numberB) {\r\n\r\n// 在 numberA 或者 numberB 被设置时，执行这个函数\r\n\r\nthis.setData({\r\n\r\nsum: numberA + numberB\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n如果需要监听所有子数据字段的变化，可以使用通配符 。\r\nComponent({\r\n\r\nobservers: {\r\n\r\n'some.field.**': function(field) {\r\n\r\n// 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发\r\n\r\n// （除此以外，使用 setData 设置 this.data.some 也会触发）\r\n\r\nfield === this.data.some.field\r\n\r\n},\r\n\r\n},\r\n\r\nattached: function() {\r\n\r\n// 这样会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样也会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some.field.xxx': { /* ... */ }\r\n\r\n})\r\n\r\n// 这样还是会触发上面的 observer\r\n\r\nthis.setData({\r\n\r\n'some': { /* ... */ }\r\n\r\n})\r\n\r\n}\r\n\r\n})\r\n特别地，仅使用通配符 可以监听全部 setData 。**纯数据字段就是局部变量，不参与渲染，也不会传递。官方说这样声明后再用能提高性能，要不我才不用。使用方式：\r\nComponent({\r\n\r\noptions: {\r\n\r\npureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段\r\n\r\n},\r\n\r\ndata: {\r\n\r\na: true, // 普通数据字段\r\n\r\n_b: true, // 纯数据字段\r\n\r\n},\r\n\r\nmethods: {\r\n\r\nmyMethod() {\r\n\r\nthis.data._b // 纯数据字段可以在 this.data 中获取\r\n\r\nthis.setData({\r\n\r\nc: true, // 普通数据字段\r\n\r\n_d: true, // 纯数据字段\r\n\r\n})\r\n\r\n}\r\n\r\n}\r\n\r\n})\r\n抽象节点又一个新名词，呵呵呵。说白了就是有一个父容器组件A，因为条件不同有可能A中会渲染组件B，也可能渲染组件C。举个例子，当页面需要单选和多选组件的时候,方法1是按条件引用两个封装好的组件（<单选/>，</多选>），方法2是你也可以只引用一个组件<啦啦啦/>，只不过这个<啦啦啦/>组件去帮你按需渲染<单选/>或者<多选/>。需要在父容器组件A的.json文件声明：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": true\r\n\r\n}\r\n\r\n}\r\n在使用组件时，必须指定父组件具体是渲染哪个子组件：<啦啦啦 generic:selectable=\"单选\" /><啦啦啦 generic:selectable=\"多选\" />在页面的.json文件<啦啦啦/>，<单选/>，<多选/>都要引用。代码\r\n//page下页面的.json文件中\r\n\r\n{\r\n\r\n\"usingComponents\": {\r\n\r\n\"啦啦啦\": \"path/*/*\",\r\n\r\n\"多选\": \"*/checkbox\",\r\n\r\n\"单选\": \"*/radio\"\r\n\r\n}\r\n\r\n}\r\n当然，你也可以在容器组件.json中指定默认用哪个组件：\r\n{\r\n\r\n\"componentGenerics\": {\r\n\r\n\"selectable\": {\r\n\r\n\"default\": \"*/checkbox\"// 多选\r\n\r\n}\r\n\r\n}\r\n\r\n}\r\n计算属性今天真是开眼了，学到了这么多新词汇。。( 计算属性的作用）：是为了解决HTML代码中复杂的js代码（HTML代码中可以嵌套js代码），把复杂的js代码通过计算属性来解决这是计算属性的应用？？？ 听着词这么厉害干这事真是大才小用了。计算属性会使用缓存机制，如果这个数据的值没有改变，则计算属性将不会调用方法这点应该是它实际有价值的地方。实现原理很简单，就是对已有的 setData 进行二次封装，在每次 setData 的时候计算出 computed 里各字段的值，这期间可以增加缓存机制，属性值没有变化的复用。自定义组件拓展在react中想拓展一个组件怎么办，会用高阶组件。小程序中，自然是使用behaviors。\r\n// behavior.js\r\n\r\nmodule.exports = Behavior({\r\n\r\ndefinitionFilter(defFields) {\r\n\r\ndefFields.data.from = 'behavior'\r\n\r\n},\r\n\r\n})\r\n\r\n// component.js\r\n\r\nComponent({\r\n\r\ndata: {\r\n\r\nfrom: 'component'\r\n\r\n},\r\n\r\nbehaviors: [require('behavior.js')],\r\n\r\nready() {\r\n\r\nconsole.log(this.data.from) // 此处会发现输出 behavior 而不是 component\r\n\r\n}\r\n\r\n})\r\nBehavior() 构造器提供了新的定义段 definitionFilter ，用于支持自定义组件扩展。"}
{"title": "uniapp登录流程详解uni.login ", "author": "Rolan", "pub_time": "2019-11-25 00:16", "content": "uni.login(OBJECT)登录H5平台登陆注意事项：微信内嵌浏览器运行H5版时，可通过js sdk实现微信登陆，需要引入一个单独的js，详见普通浏览器上实现微信登陆，并非开放API，需要向微信申请，仅个别开发者有此权限H5平台的其他登陆，比如QQ登陆、微博登陆，uni-app未封装，请在条件编译里按普通H5写法编写。OBJECT 参数说明参数名 类型 必填 说明 平台差异说明provider String 否 登录服务提供商，通过 uni.getProvider 获取，如果不设置则弹出登录列表选择界面scopes String/Array 见平台差异说明 授权类型，默认 auth_base。支持 auth_base（静默授权）/ auth_user（主动授权） / auth_zhima（芝麻信用） 支付宝小程序timeout Number 否 超时时间，单位ms 微信小程序、百度小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）success 返回参数说明参数名 说明authResult 登录服务商提供的登录信息，服务商不同返回的结果不完全相同errMsg 描述信息uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n  }\r\n});uni.checkSession检查登录状态是否过期属性 类型 必填 说明success function 否 接口调用成功的回调函数fail function 否 接口调用失败的回调函数complete function 否 接口调用结束的回调函数（调用成功、失败都会执行）uni.getUserInfo(OBJECT)获取用户信息。UNI-APP 开发微信公众号（H5）JSSDK 的使用方式在 uniapp 中可以使用模块方式引用微信 js-sdk ，微信官网直接下载的使用有问题，可以使用 jweixin-module。安装下载使用方式下载地址： https://unpkg.com/jweixin-mod...使用、var jweixin = require('jweixin-module')  \r\njweixin.ready(function(){  \r\n    // TODO  \r\n});一、小程序:1、使用 button 组件，并将 open-type 指定为 getUserInfo 类型，获取用户基本信息。详情参考文档:https://developers.weixin.qq....2、使用 open-data 展示用户基本信息。详情参考文档:https://developers.weixin.qq....provider String 否 登录服务提供商，通过 uni.getProvider 获取withCredentials Boolean 否 是否带上登录态信息。 微信小程序、头条小程序lang Number 否 指定返回用户信息的语言，默认为 en。更多值请参考下面的说明。 微信小程序timeout Number 否 超时时间，单位 ms。 微信小程序success Function 否 接口调用成功的回调fail Function 否 接口调用失败的回调函数complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行）userInfo 参数说明参数 类型 说明 平台差异说明nickName String 用户昵称openId String 该服务商唯一用户标识 5+AppavatarUrl String 用户头像uni.login({\r\n  provider: 'weixin',\r\n  success: function (loginRes) {\r\n    console.log(loginRes.authResult);\r\n    // 获取用户信息\r\n    uni.getUserInfo({\r\n      provider: 'weixin',\r\n      success: function (infoRes) {\r\n        console.log('用户昵称为：' + infoRes.userInfo.nickName);\r\n      }\r\n    });\r\n  }\r\n});说明：调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。注意：会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录凭证 code 只能使用一次uni.getProvider(OBJECT)获取服务供应商。仅App平台支持。在App平台，可用的服务商，是打包环境中配置的服务商，与手机端安装了什么app没有关系。云打包在manifest中配置相关模块和SDK信息，离线打包在原生工程中配置。某个服务商配置被打包进去，运行时就能得到相应的服务供应商。关于目前文章内容即涉及前端，PHP知识点，如果有兴趣即可关注，很荣幸，能被您发现，真是慧眼识英！也感谢您的关注，在未来的日子里，希望能够一直默默的支持我，我也会努力写出更多优秀的作品。我们一起成长，从零基础学编程，将 Web前端领域、数据结构与算法、网络原理等通俗易懂的呈现给小伙伴。分享 Web 前端相关的技术文章、工具资源、精选课程、热点资讯。若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。请点赞！因为你们的赞同/鼓励是我写作的最大动力！"}
{"title": "浅谈微信小程序流量变现的常见模式 ", "author": "Rolan", "pub_time": "2019-11-26 00:01", "content": "什么是小程序，小程序是基于微信平台发展而衍生出的即用即走、无需下载的第三方工具。由于其具有操作简单、使用便捷的天然优势，因而现在使用微信小程序人数的增长速度犹如闪电般一样。同时，现在小程序的变现流量也是大幅度的增长，这为商家企业带来了红利期。那么，今天小编将为大家介绍几种常见的小程序流量变现模式，供大家学习与参考。模式一 : 电商变现在微信社交关系链和微信支付体系里，电商小程序流量变现优势明显。电商类的小程序用户直接完结购买流程，包含产品选购、购买、付出一系列的流程，直接变现。如：拼多多、享物说、每日优鲜等社交电商小程序依靠微信社交关系链裂变传播，日订单数也在千万量级。模式二：广告变现广告变现是小游戏、工具类、资讯类小程序变现的主要方式。小程序官方开放了Banner广告，只要活跃用户达到一定量级，可通过广告点击直接变现流量。模式三 : 内容付费付费流量变现方式带动了微信小程序内容付费的发展，如Reader、读书知乎live等小程序，都选用的是付费程序。将公众号绑定小程序可以在公众号推文中嵌入付费产品的小程序贴片。小程序不必下载不占内存，界面清新，用小程序付费体验比APP更好，用户形成习惯后，可直接通过内容付费小程序模式完成引流、推广和变现的流量闭环营销操作。模式四 : 游戏付费微信官方发布了小游戏支撑微信交际关系链玩法，小程序游戏中道具、会员等等这些都能成为商家盈利的方法。游戏底部 banner 位、原生广告植入、续命激励来引导用户点击广告、通过设置付费关卡和道具等，都是游戏小程序的付费方式。当然，关于小程序的变现模式，不局限于以上四种，例如电商卖货、平台卖货等新型盈利模式，也赢得了强烈的反响度。因此，商家应当根据自己的用户群体和产品属性，来选择合适的流量变现模式。"}
{"title": "小程序云开发：菜鸟也能全栈做产品 ", "author": "Rolan", "pub_time": "2019-11-25 00:25", "content": "我想独立实现一个全栈产品为什么这么难#日常生活中，我们会使用很多软件产品。在使用这些产品的时候，我们看得见的东西称为“前端界面”如一个输入框、一个按钮，点击按钮之后发生的一切看不见的东西称为“后端服务”。与之对应的创造者分别称为“前端程序员”、“后端程序员”，然而，一个完整产品的开发不仅仅是只有前端和后端，还有设计师，架构师，运维等。有没有可能这些所有的事情都一个人干呢？有可能，事实上如今就有很多的“全栈工程师”，他们身兼数职，是多面手。能独立完成一个产品的方方面面。这种人固然十分了得，他们通常具有多年的经验，涉猎广泛，是老手，也是高手，当有一个产品想法的时候，他们可以用自己的全面专业技能，尽情的发挥去实现自己的想法。所以，从某种意义上讲“全栈也是一种自由”，你可以自由的实现你的想法，这简直太美妙了！然而，很多时候当我们有一个产品想法的时候，我们往往发现，前端写完了，后端怎么搞？数据库怎么搞？域名怎么搞？域名还要备案？应用部署怎么搞？我的买什么样的服务器啊？静态资源 CDN 怎么搞？文件上传服务器怎么搞？万一访问用户多了能撑住吗？等等……问题很多，导致你的一个个想法，都只是在脑海中昙花一现，从来都无法将她们实现，或者说你激情饱满的实现了其中自己最擅长的一部分，当碰到其他难题的时候就止步了。于是仰天长啸：我就想独立做一个完整的产品为什么这么难？年轻人，这一切都不怪你……破局：小程序云开发#为什么使用小程序云开发来破局？#为啥是用“小程序云开发”来破局？首先，我们的目的是全栈实现一个产品。全栈可以有多种技术方案，你可用任何你能会的技能来达到全栈的目的。你可以开发安卓，IOS，或者 PC 站，然而小程序是最实际的！为啥？手机上能做的事情为啥要用 PC 版？OK,既然手机版比较好，那能不能再简单一点？能，就是小程序，不需要开发IOS，安卓两个版本。可以快速产出，快速试错。其次，前面说到了，全栈实现一个产品并不容易，对很多人来说甚至是巨难！选择了小程序已经是比较划算的方案。而再集成云开发，全栈立马就有了。这就是为什么选择“小程序云开发”来破局。小程序云开发是什么?#小程序云开发是什么？官方文档是这么说的：开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。看完上面的描述，也许你仍然无法非常清楚的知道什么是“小程序云开发”，没关系，你只需要注意加粗的部分，大概知道它“无需搭建服务器”，从传统观念将，这个似乎“毁三观”咋可能没服务器啊？是的，可以没有传统意义上的服务器，这种模式是 serveless 的。那么，小程序云开发提供了哪些东西来破局呢？且看下面的表格：能 力作 用说 明云函数无需自建服务器在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库无需自建数据库一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储无需自建存储和 CDN在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理云调用原生微信服务集成基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力上面的表格中提到了“云开发”中的一些能力：“云函数”，“数据库”，“存储”，“云调用”，我们可以将这些词带入你曾经开发过的应用，看看它们分别代表了哪些部分。对于程序员来说，如果有疑问的话，没有什么是一个 helloword 解决不了的。实战：独立开发一个简易的零售小程序#哆嗦再多，不如实战。下面我们就来使用小程序云开发实现一个简单的零售小程序。项目构思#既然是一个零售小程序，那么我们可以思考一下零售小程序的大致业务流程，以及粗略的梳理一下，其功能点。现根据自己的想法，大致画一下草图，如果没有灵感可以参考一下别的 APP 是如何设计的。我根据自己的想法设计之后是这样的：功能模块：首页，商品列表页，购物车，确认订单，个人中心，个人订单，管你模块（商品添加，分类添加）其中商品需要上传图片。梳理完功能之后，我们对于要实现的东西已经有个初步的概念了。接下来，我们需要大概画一下页面设计、及功能流转。初次设计可能没有太多经验，没关系，开始做就行了，做着做着就会想法越来越多，然后优化的越来越好。。我也是经过了多番修改调整，最终找到了一些思路。我的（拙劣）设计如下，图片如果看不清楚可复制图片链接在新窗口打开查看：说明，以上图片是根据成品（我真的开发了一个云小程序并上线使用了）截图的，而实际我再设计的时候也是经过几番修改才最终定成这样。同时，补充说明一下，这里前端页面使用的是 vant-weapp控件，非常好用。推荐！如果你和我一样是一个纯后端程序员，建议使用 vant-weapp 来作为 ui，非常方便。否则自己写页面样式的话可能就做不出来了。全栈不是那么好干的啊。选择自己能驾驭的，能实现最终功能，就是一个合格的全栈。创建小程序云开发项目#我们先下载微信小程序开发工具，下载地址在这里,安装好了之后，新建项目，界面如下，APPID 需要你自己去注册一个。然后注意，选择“小程序云开发”，如下图所示：创建好了之后，项目目录如下,先看 1 标注的地方：如果你曾经有过小程序的开发经验，那么miniprogram文件夹下面的结构你肯定熟悉了，miniprogram下面的子目录分别是小程序对应的组件、图片、页面、样式以及app.js,app.json,sitemap.json,其中components下面的vant-weapp就是上面提到的 ui 组件。最后一个比较重要的文件夹就是cloudfunctions，这个目录是用来存放“云函数的”，云函数就是我们的后端。每一个云函数提供一个服务。一个个的云函数组成了我们整体的后端服务。云函数可以看做是 FaaS（function as a service）。途中，2 标记的位置的“云开发”按钮，我们点进去，就可以看到“云开发的控制台”，如下图所示：如果上图看不清楚，可以复制链接到新的浏览器窗口查看，如图，小程序云开发默认的免费套餐有一定的额度可供使用。首页便是使用统计。然后我们能看到，有“数据库”，“存储”，“云函数”。这里的“数据库”其实就是类似于一个 MongoDB，你可以点进去创建一个个的 collection（即：关系型数据库中的table）;这里的“存储”其实就是“文件夹”，我们可以通过微信提供的 api把图片上传到“存储”中；这里的“云函数”就是我们需要实现的后端业务逻辑，他就是一个个的函数（函数由我们自己写好后上传）。一般开发过程中我们在开发者工具中的cloudfunctions目录下创建云函数（比方说是:user-add）开发完成之后在云函数目录点击右键——上传即可。然后就可以在小程序的代码中调用这个user-add云函数。云开发之——3 分钟实现文件上传#注意：在开始云开发之前，我们现在 小程序代码的 app.js 中加入wx.cloud.init,如下：CopyApp({\r\n  onLaunch: function () {\r\n    if (!wx.cloud) {\r\n      console.error('请使用 2.2.3 或以上的基础库以使用云能力')\r\n    } else {\r\n      wx.cloud.init({\r\n        // env 参数说明：\r\n        //   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源\r\n        //   此处请填入环境 ID, 环境 ID 可打开云控制台查看\r\n        //   如不填则使用默认环境（第一个创建的环境）\r\n        env: 'your-env-id',\r\n        traceUser: true,\r\n      })\r\n    }\r\n    this.globalData = {}\r\n  }\r\n})上面的图中，我们已经看到了“商品添加”页面的效果，它需要我们输入商品名称、价格、并上传图片，然后保存。传统架构中，上传图片需要前端页面摆一个控件，然后后端提供一个 api用来接收前端传来的文件，通常来说这个后端 api 接收到图片之后，会将图片文件保存到自己的文件服务器或者是阿里云存储、或者是七牛云存储之类的。然后返回给你一个文件链接地址。非常麻烦，然而，小程序云开发上传文件超级简单，上代码：Copy页面代码：\r\n<van-notice-bar\r\n  scrollable=\"false\"\r\n  text=\"发布商品\"\r\n/>\r\n  <van-field\r\n    value=\"{{ productName }}\"\r\n    required\r\n    clearable\r\n    label=\"商品名称\"\r\n    placeholder=\"请输入商品名称\"\r\n    bind:change=\"inputName\"\r\n  />\r\n    <van-field\r\n    value=\"{{ productPrice }}\"\r\n    required\r\n    clearable\r\n    label=\"价格\"\r\n    icon=\"question-o\"\r\n     bind:click-icon=\"onClickPhoneIcon\"\r\n    placeholder=\"请输入价格\"\r\n    error-message=\"{{phoneerr}}\"\r\n    border=\"{{ false }}\"\r\n    bind:change=\"inputPrice\"\r\n  />\r\n\r\n<van-action-sheet\r\n  required\r\n  show=\"{{ showSelect }}\"\r\n  actions=\"{{ actions }}\"\r\n  close-on-click-overlay=\"true\"\r\n  bind:close=\"toggleSelect\"\r\n  bind:select=\"onSelect\" cancel-text=\"取消\"\r\n/>\r\n  <van-field\r\n    value=\"{{ productCategory }}\"\r\n    center\r\n    readonly\r\n    label=\"商品分类\"\r\n    border=\"{{ false }}\"\r\n    use-button-slot\r\n  >\r\n    <van-button slot=\"button\" size=\"small\" plain type=\"primary\"  \r\n     bind:click=\"toggleSelect\">选择分类</van-button>\r\n  </van-field>\r\n  \r\n  <van-button class=\"rightside\" type=\"default\" bind:click=\"uploadImage\" >上传商品图片</van-button>\r\n  <view class=\"imagePreview\">\r\n    <image src=\"{{productImg}}\" />\r\n  </view>\r\n <van-submit-bar\r\n  price=\"{{ totalShow }}\"\r\n  button-text=\"提交\"\r\n  bind:submit=\"onSubmit\"\r\n  tip=\"{{ false }}\"\r\n >\r\n </van-submit-bar> \r\n<van-toast id=\"van-toast\" />\r\n<van-dialog id=\"van-dialog\" />这里有个控件，绑定了uploadImage方法，其代码为：Copy  uploadImage:function(){\r\n    let that = this;\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success(res) {\r\n        wx.showLoading({\r\n          title: '上传中...',\r\n        })\r\n        const tempFilePath = res.tempFilePaths[0]\r\n        const name = Math.random() * 1000000;\r\n        const cloudPath = name + tempFilePath.match(/\\.[^.]+?$/)[0]\r\n        wx.cloud.uploadFile({\r\n          cloudPath:cloudPath,//云存储图片名字\r\n          filePath: tempFilePath,//临时路径\r\n          success: res => {\r\n            let fileID = res.fileID;\r\n            that.setData({\r\n              productImg: res.fileID,\r\n            });\r\n            wx.showToast({\r\n              title: '图片上传成功',\r\n            })\r\n          },\r\n          fail: e =>{\r\n            wx.showToast({\r\n              title: '上传失败',\r\n            })\r\n          },\r\n          complete:()=>{\r\n            wx.hideLoading();\r\n          }\r\n        });\r\n      }\r\n    })\r\n  }这里，wx.chooseImage用于调起手机选择图片（相册/相机拍照），然后wx.cloud.uploadFile用于上传图片到上面说到的云开发能力之一的“存储”中。上传图片成功之后返回一个文件 ID，类似：Copycloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  这个链接可以直接在小程序页面展示：Copy<image src=\"cloud://release-0kj63.7265-release-0kj63-1300431985/100477.13363146288.jpg  \" />也可以通过微信 api，装换成 http 形式的图片链接。云开发之——操作数据库，1 分钟写完保存商品到数据库的代码#上面我们实现了商品图片上传，但是，商品图片并没有保存到数据库。正常录入商品的时候，我们会填好商品名称，价格等，然后上传图片，最终点击“保存”按钮，将商品保存到数据库。传统模式下，前端仍然是需要调用一个后端接口，通过 post 提交数据，最终由后端服务（比如 java 服务）将数据保存到数据库。小程序云开发使得操作数据库十分简单，首先我们在云开发控制台创建“商品表”，即一个 collection,取名为：products。然后我们就可以保存数据到数据库了，代码如下：CopyonSubmit:function(){\r\n    // 校验代码，略\r\n    let product = {};\r\n    product.imgId = this.data.productImg;\r\n    product.name= this.data.productName;\r\n    product.categoryId = this.data.productCategoryId;\r\n    product.price = this.data.productPrice;\r\n    // 其他赋值，略\r\n    const db = wx.cloud.database();\r\n    db.collection('products').add({\r\n     data: product,\r\n     success(res) {\r\n       wx.showToast({\r\n         title: '保存成功',\r\n       })\r\n     }\r\n   });\r\n  }以上就实现了数据入库，就这点代码，超简单，1 分钟写完，诚不欺我。其中这里的products就是我们的“商品表”，之前说过，类似 MongoDB 数据库，这里操作的是db.collection，这和 MongoDB 的语法差不多。云开发之——使用云函数完成后端业务逻辑，订单创建#小程序云开发提供了几大能力：“数据库”，“存储”，“云函数”，前两项我们已经有所体会了。下面我们能创建一个云函数来实现订单创建。这里说明，云函数其实就是 一段JavaScript 代码，上传至云服务器之后，最终也是运行在 nodejs 环境的，只是这一切，我们不需要关心。我们只需要关心我们这个云函数提供的功能是什么就可以了。创建云函数很简单，直接在开发工具中右键“新建Node.js 云函数”。然后以创建订单为例，假设我们创建一个云函数名为c-order-add,创建好了之后，目录是这样：云函数的主要代码在 index.js 中，其完整代码是这样：Copy// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\n  env: 'release-xxx'// your-env-id\r\n})\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext();\r\n  console.log(\"云函数 c-order-add : \")  \r\n  // 这里是一些逻辑处理...\r\n  \r\n  return await db.collection('uorder').add({\r\n    data: {\r\n      openid: event.userInfo.openId,\r\n      address: event.address,\r\n      userName: event.userName,\r\n      phone: event.phone,\r\n      shoppingInfo: event.shoppingInfo,\r\n      totlePrice: event.totlePrice,\r\n      shoppingStr: event.shoppingStr,\r\n      remark:event.remark,\r\n      createTime: now,\r\n      // ...\r\n    }\r\n  });\r\n}这个云函数写好之后，需要上传到服务器，直接在云函数目录点击右键，然后点击“上传并部署”即可，这就相当于部署好了后端服务。前端小程序页面调用的写法是这样的：Copylet orderData={};\r\norderData.userName = this.data.userName;\r\norderData.phone = this.data.phone;\r\norderData.address = this.data.address;\r\n// ....\r\nwx.cloud.callFunction({\r\n      // 云函数名称\r\n      name: 'c-order-add',\r\n      // 传给云函数的参数\r\n      data: orderData,\r\n      complete: res => {\r\n        Dialog.alert({\r\n          title: '提交成功',\r\n          message: '您的订单成功，即将配送，请保持手机通畅。'\r\n        }).then(() => {\r\n          // ....\r\n          wx.redirectTo({\r\n            url: '../uorder/uorder'\r\n          });\r\n        });\r\n      }\r\n})这里，向程序前端，通过wx.cloud.callFunction完成了对云函数的调用，也可以理解为对后端服务的调用。至此我们我们介绍完了，小程序云开发的功能。虽然，我只贴出了少量的代码，即保存商品，和提交订单。由于时间和篇幅有限，我不可能把整个完整的程序代码贴出来。但是你可以参照这个用法示例，将剩下的业务逻辑补充完整，最终完成“项目构思”一节中展示的成品截图效果。小程序审核的一点经验#我开发的小程序审核在提交审核的时候遭遇了两次退回，第一次是因为：“小程序具备电商性质，个人小程序号不支持”。所以，我只好申请了一个企业小程序号，使用的是超市的营业执照。服务类目的选择也被打回了一次，最后选择了食品还提交了食品经营许可证。第二次打回是因为：“用户体验问题”。其实就是“授权索取”的问题，微信不让打开首页就“要求授权”，同时不能强制用户接受授权，得提供拒绝授权也能使用部分功能。上面两条解决之后，更新新了好几版，都没有出现过被拒的情况。并且，有次我是夜晚 10 左右提价的审核，结果10 点多就提示审核通过，当时没看具体时间，就是接盆水泡了个脚的时间审核通过了。所以，我推断小程序审核初次审核会比较严，之后如果改动不大应该直接机审就过了。总结及对比#这里我们可以对小程序云开发和传统模式做一个对比：就对比这么多吧，总之，我非常喜欢小程序云开发，小程序真的可以让你轻松干全栈。或者咱们别动不动就提“全栈”，姑且说，小程序云开发可以让你更简单、更快速、更便宜的实现你的产品落地。我自己开发的云小程序上线之后，使用了一两个月，没出现任何问题。我也不用操心服务器什么的。所以，我已经给身边很多人安利了小程序云开发了。这里我就不贴出我的小程序码了，因为已经正式给我同学的超市使用了，所以不方便让别人去产生测试数据。如果你感兴趣想看的话，可以联系我。作者： 逃离沙漠出处：https://www.cnblogs.com/demingblog/p/11914354.html本站使用「CC BY 4.0」创作共享协议，转载请在文章明显位置注明作者及出处。如果本文对您有帮助，不妨点个「推荐」及「赞赏」"}
{"title": "小程序顶部导航栏，可滑动，可动态选中放大效果 ", "author": "Rolan", "pub_time": "2019-11-25 00:36", "content": "老规矩，先看效果图可以看到我们实现了如下功能1，顶部导航栏 2，可以左右滑动的导航栏 3，选中条目放大 原理其实很简单，我这里把我研究后的源码发给大家吧。wxml文件如下<!-- 导航栏 --><scroll-view scroll-x class=\"navbar\" scroll-with-animation scroll-left=\"{{scrollLeft}}rpx\">  <view class=\"nav-item\" wx:for=\"{{tabs}}\" wx:key=\"id\" bindtap=\"tabSelect\" data-id=\"{{index}}\">    <view class=\"nav-text {{index==tabCur?'tab-on':''}}\">{{item.name}}</view>  </view></scroll-view>wxss文件如下/* 导航栏布局相关 */.navbar {  width: 100%;   height: 90rpx;  /* 文本不换行 */  white-space: nowrap;  display: flex;  box-sizing: border-box;  border-bottom: 1rpx solid #eee;  background: #fff;  align-items: center;  /* 固定在顶部 */  position: fixed;  left: 0rpx;  top: 0rpx;}.nav-item {  padding-left: 25rpx;  padding-right: 25rpx;  height: 100%;  display: inline-block;  /* 普通文字大小 */  font-size: 28rpx;}.nav-text {  width: 100%;  height: 100%;  display: flex;  align-items: center;  justify-content: center;  letter-spacing: 4rpx;  box-sizing: border-box;}.tab-on {  color: #fbbd08;  /* 选中放大 */  font-size: 38rpx !important;  font-weight: 600;  border-bottom: 4rpx solid #fbbd08 !important;}js文件如下// pages/test2/test2.jsPage({  data: {    tabCur: 0, //默认选中    tabs: [{        name: '等待支付',        id: 0      },      {        name: '待发货',        id: 1      },      {        name: '待收货',        id: 2      },      {        name: '待签字',        id: 3      },      {        name: '待评价',        id: 4      },      {        name: '五星好评',        id: 5      },      {        name: '差评订单',        id: 6      },      {        name: '编程小石头',        id: 8      },      {        name: '小石头',        id: 9      }    ]  },  //选择条目  tabSelect(e) {    this.setData({      tabCur: e.currentTarget.dataset.id,      scrollLeft: (e.currentTarget.dataset.id - 2) * 200    })  }})代码里注释很明白了，大家自己跟着多敲几遍就可以了。后面会更新更多小程序相关的知识，请持续关注。"}
{"title": "捕获web与小程序JS异常的方法 ", "author": "Rolan", "pub_time": "2019-11-26 00:50", "content": "前段时间，我们发现小程序异步代码里的错误没有上报到异常监控平台，经过排查这部分小程序没法直接监听到，需要我们手动上报。再者，开发过程中，异常处理一直是不太受重视且容易遗漏的模块。本文总结了JS异常的类型及捕获方法，最后针对小程序给出错误处理经验。JS异常分类Error：常规异常，一般为用户自定义的异常，如 new Error(\"error message\")，这类自定义的错误用来统计异常数据，直接上报即可；RangeError：数值溢出越界异常，当 Number 类型变量超过指定的范围，如var pi = 3.14159;  pi.toFixed(100000);d（toFixed()方法参数只能接受 0~100） ；ReferenceError：引用异常，当不存在的变量被使用的时候，这类错误一般在编码检查阶段就会暴露；SyntaxError：语法错误，作为解释型语言的 JavaScript 只有到执行的时候才能识别出语法错误，这类错误在编码检查和构建阶段就会暴露；TypeError：类型错误，当调用不存在的对象方法或对象不存在时，例如：var foo = {}; foo.bar();为了避免这类错误出现，可使用防御式编程，但如若数据有误则应抛出异常；URIError：encodeURI() 和 decodeURI() 方法参数不正确抛出的异常，例如：decodeURIComponent(\"%\");EvalError：eval() 方法参数不正确抛出的异常；Web端对异常的捕获能力了解了异常的分类后，我们还需要知道浏览器如何捕获到这些异常。1）try-catchJavaScript 里有 try-catch 语法块，可用于异常捕获处理。try-catch 可以成功捕获大部分错误，但对于 SyntaxError 语法错误 和 异步代码中的错误，则无法捕获。例如：SyntaxError 语法错误try {\r\n    var p = \r\n} catch(e) { \r\n    console.log('caught error: ', e.message)\r\n}\r\n\r\n// 输出：Uncaught SyntaxError: Unexpected token '}'复制代码例如：异步代码中的错误try {\r\n    setTimeout(function() {\r\n        var p = error + 1\r\n    }, 0)\r\n} catch(e) {\r\n    console.log('caught error:', e.message)\r\n}\r\n\r\n// 输出：Uncaught ReferenceError: error is not defined复制代码2）error 事件try-catch 针对我们预感到可能会有问题的代码，捕获异常进行处理，而对于一些我们未知的错误，可以使用 window 对象的 error 事件进行监听。error 事件可以捕获到同步或异步（非 Promise ）代码中的非语法错误。例如：异步代码中的错误window.addEventListener('error', e => {\r\n  console.log('caught error', e.message);\r\n  e.preventDefault();\r\n});\r\nsetTimeout(function() {\r\n    var p = error + 1\r\n}, 0)\r\n\r\n// 输出：caught error Uncaught ReferenceError: error is not defined复制代码需要注意的是：e.preventDefault() 在 error 监听事件中调用，可以阻止报告异常给浏览器，别让浏览器默认地在控制台输出错误。另外，文档中也提到关于资源加载失败的错误：When a resource (such as an <img> or <script>) fails to load, an error event using interface Event is fired at the element that initiated the load, and the onerror() handler on the element is invoked. These error events do not bubble up to window, but (at least in Firefox) can be handled with a window.addEventListener configured with useCapture set to True.对于图片或脚本资源加载失败，这类错误不会冒泡给 window，但可以在捕获阶段进行处理，即addEventListener 最后一个参数置为 true：window.addEventListener('error', e => {\r\n    console.log('资源加载失败');\r\n}, true)复制代码3）unhandledRejection 与 rejectionhandled 事件error 事件可以捕获到非 Promise 的异步错误，而针对 Promise，window对象有专门的事件来处理这类错误。当异步错误没被 catch 住时，触发 unhandledRejection 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\n\r\n// 输出：caught unhandledrejection ReferenceError: error is not defined复制代码而当异步错误一开始未被 catch 住，过后才被 catch 的情况，会先触发 unhandledRejection 事件，当被 catch 的时候，会触发 rejectionhandled 事件：window.addEventListener('unhandledrejection', e => {\r\n    console.log('caught unhandledrejection', e.reason);\r\n    e.preventDefault();\r\n})\r\nwindow.addEventListener('rejectionhandled', e => {\r\n    console.log('caught rejectionhandled', e.reason);\r\n    e.preventDefault();\r\n})\r\nvar p = new Promise(function(resolve, reject) {\r\n    tp = error + 1\r\n})\r\nsetTimeout(() => {\r\n    p.catch(e => console.log('catch', e.message))\r\n}, 1000)\r\n\r\n// 输出：\r\n// caught unhandledrejection ReferenceError: error is not defined\r\n// （1s后）\r\n// catch error is not defined\r\n// caught rejectionhandled ReferenceError: error is not defined复制代码也就是说未处理的异常增加时会触发 unhandledRejection，而未处理的异常（被处理后）减少时会触发 rejectionhandled，这在上报异常中可以避免上报那些已经被处理过的异常。关于兼容性，截止至本文成稿，移动端的支持程度还是可以的，iOS主流版本 和 Chrome 都支持：（图来源：unhandledrejection/rejectionhandled events，caniuse.com/#search=unh…）小程序端对异常的捕获能力小程序的 App 对象中有 onError 方法，相当于 web 端的 error 事件，可以捕获到同步或异步（非 Promise ）代码中的非语法错误。而对于 Promise，小程序并没有如 window 对象中的 unhandledRejection 与 rejectionhandled 事件，无法像 web 端那样统一处理异常。不过，既然都是 Promise 相关的错误，那么，我们可以改写或覆盖 Promise 对象，将其进行封装把所有错误都 catch 住也就可以了。推荐 promise-polyfill 这个轻量级的 promise 实现包，其中提供了 _unhandledRejectionFn 方法，用于捕获那些未被处理的 Promise 异常。import Promise from 'promise-polyfill';\r\nPromise._unhandledRejectionFn = function(rejectError) {\r\n    // 处理异常或上报\r\n}\r\n复制代码总结关于JS的异常总结已经差不多了，之前一直觉得这部分知识不够系统，一来自己重视程度不够，二来也是知识点不多但都较零散。经过这段时间收集资料，捋清思路，编码实现还算有所收获，便总结成文，若有不尽不祥不对之处烦请各位读者多多指点。参考文献Exceptional Exception Handling in JavaScript前端代码异常监控实战GlobalEventHandlers.onerrorPromise rejection events in Using Promisespromise-polyfill"}
{"title": "微信小程序——基础知识 ", "author": "Rolan", "pub_time": "2019-11-26 00:02", "content": "目录结构介绍一个小程序至少由俩个文件组成 app.js 和 app.json 1. app.js 小程序逻辑 2. app.json 小程序全局配置 3. app.wxss 小程序公共样式表 4. project.config.json 开发项目时工具配置文件。一个小程序页面由四个文件组成传统web小程序结构HTMLwxml样式表CSSwxss逻辑Javascriptjs配置无json初始化页面的俩个警告:warning::warning:根据 sitemap 的规则[0]，当前页面 [pages/index/index] 将被索引 解决方案：小程序项目配置文件 project.config.json 的 setting 中配置字段 \"checkSiteMap\": false\"setting\": {\r\n    \"checkSiteMap\": false\r\n},\r\n复制代码:warning:获取 wx.getUserInfo 接口后续将不再出现授权弹窗，请注意升级解决方案：清空 App.js全局配置路由、导航栏和tabBar小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。路由 Pages路由 Pages | 微信开放文档项目开发目录为：├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── pages\r\n│   │── index\r\n│   │   ├── index.wxml\r\n│   │   ├── index.js\r\n│   │   ├── index.json\r\n│   │   └── index.wxss\r\n│   └── logs\r\n│       ├── logs.wxml\r\n│       └── logs.js\r\n└── utils\r\n复制代码则需要在 app.json 中写{\r\n    \"pages\": [\r\n        \"pages/index/index\",\r\n        \"pages/logs/logs\"\r\n    ],\r\n}\r\n复制代码顶部导航 window顶部导航 window | 微信开放文档用于设置小程序的状态栏、导航条、标题、窗口背景色。window属性说明文档属性描述backgroundTextStyle下拉 loading 的样式，仅支持 dark / lightnavigationBarBackgroundColor导航栏背景颜色，如 #000000navigationBarTitleText导航栏标题文字内容`navigationBarTextStyle导航栏标题颜色，仅支持 black / whiteenablePullDownRefresh是否开启当前页面的下拉刷新 true / false代码实例{\r\n    \"window\": {\r\n        \"backgroundTextStyle\": \"dark\",\r\n        \"navigationBarBackgroundColor\": \"#0081ff\",\r\n        \"navigationBarTitleText\": \"教育Top10\",\r\n        \"navigationBarTextStyle\": \"white\",\r\n        \"enablePullDownRefresh\": true\r\n    },\r\n}\r\n复制代码如何设置某个单页面的导航栏？自定义顶部栏,文字、背景色，在该单页面的 json里添加如下：{\r\n\t\"usingComponents\": {},\r\n    \"navigationBarTitleText\": \"课程列表\",\r\n    \"navigationBarBackgroundColor\": \"#0081ff\",\r\n    \"navigationBarTextStyle\": \"white\"\r\n}\r\n复制代码隐藏顶部栏，在该单页面的 json 里添加如下：{\r\n    \"navigationStyle\": \"custom\"\r\n}\r\n复制代码底部 tabBar底部 tabBar | 微信开放文档 小程序是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，及切换时显示的对应页面。tabBar属性说明文档属性描述colortab 上的文字默认颜色，仅支持十六进制颜色selectedColortab 上的文字选中时的颜色，仅支持十六进制颜色backgroundColortab 的背景色，仅支持十六进制颜色borderStyletabbar上边框的颜色， 仅支持 black / whitecustom自定义 tabBar，见 详情listtab 的列表，详见 list 属性说明list 数组，包含 tab 最少 2 个、最多 5 个list属性描述pagePath路由：跳转到指定页面text底部导航文字iconPath底部导航图标、未选中状态selectedIconPath底部导航图标、选中状态代码实例{\r\n    \"tabBar\": {\r\n        \"color\": \"#333\",\r\n        \"selectedColor\": \"#0081ff\",\r\n        \"borderStyle\": \"black\",\r\n        \"backgroundColor\": \"#fff\",\r\n        \"list\": [\r\n            {\r\n                \"pagePath\": \"pages/tabBar/tabBar_home/tabBar_home\",\r\n                \"text\": \"首页\",\r\n                \"iconPath\": \"images/Tabbar/home.png\",\r\n                \"selectedIconPath\": \"images/Tabbar/home_cur.png\",\r\n            },\r\n            {\r\n                \"selectedIconPath\": \"images/Tabbar/my_cur.png\",\r\n                \"iconPath\": \"images/Tabbar/my.png\",\r\n                \"pagePath\": \"pages/tabBar/tabBar_myCenter/tabBar_myCenter\",\r\n                \"text\": \"个人中心\"\r\n            }\r\n        ],\r\n    }\r\n}\r\n复制代码基础组件view 视图容器text 文本<text>纯文本</text> 组件之间只能包含纯文本，在text中写其他标签，将会被忽略掉<text \r\n    class=\"info\" \r\n    id=\"zbc\" \r\n    style=\"\" \r\n    bindtap=\"_fun\" 点击事件\r\n    hidden=\"true\" 显示隐藏[微信小程序--hidden不生效原因及解决方案?]\r\n    data-user=\"user\" 自定义组件\r\n>\r\n    hello world\r\n</text>\r\n复制代码image 图片微信小程序 Image 图片实现宽度100%，高度自适应 mode=\"widthFix\"<image class=\"img\" src=\"../../images/hello.png\" mode=\"widthFix\">\r\n\r\n.img{width: 100vw;}\r\n复制代码Flex 布局Flex 布局兼容性Flex 布局属性要使用弹性布局，通过 display: flex 或者 display: inline-flex 来将此元素定义为弹性容器。flex-direction 决定元素的排列方向row\r\ncolumn\r\nflex-wrap 决定元素如何换行nowrap\r\nwrap\r\njustify-content 定义主轴为水平方向，分布方式。flex-start\r\nflex-end\r\ncenter\r\nspace-between\r\nspace-around\r\nalign-items 定义主轴为垂直方向，分布方式。flex-start\r\nflex-end\r\ncenter\r\nflex: 1 权重，分配主轴上剩余的空间（有图）<view style=\"display:flex;\">\r\n    <view class=\"A\" style=\"width: 140rpx;height: 80rpx; flex: 1;\"></view>\r\n    <view class=\"B\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n    <view class=\"C\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n    <view class=\"D\" style=\"width: 140rpx;height: 80rpx;\"></view>\r\n</view>\r\n复制代码数据绑定数据绑定 | 微信开放文档简单绑定<view> {{ message }} </view>\r\n复制代码Page({\r\n  data: {\r\n    message: 'Hello MINA!'\r\n  }\r\n})\r\n复制代码三元运算<view hidden=\"{{flag ? true : false}}\"> Hidden </view>\r\n复制代码算数运算<view> {{a + b}} + {{c}} + d </view>\r\n复制代码Page({\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n    c: 3\r\n  }\r\n})\r\n复制代码view中的内容为 3 + 3 + d。是否同意该协议表单按钮<checkbox checked=\"{{false}}\"> </checkbox>\r\n复制代码特别注意：不要直接写  checked=\"false\" ，其计算结果是一个字符串，转成 boolean 类型后代表真值。列表渲染wx:for列表渲染 | 微信开放文档在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index ，数组当前项的变量名默认为 item 数据绑定使用 {{}} 将变量包起来，可以作用于：轮播图wx:for<swiper>\r\n    <swiper-item wx:for=\"{{banner}}\" wx:key=\"{{index}}\">\r\n        <image src=\"{{item.img}}\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码Page({\r\n    data: {\r\n        banner: [{\r\n            img: '../../images/swiper-1.jpeg',\r\n        }, {\r\n            img: '../../images/swiper-2.jpeg',\r\n        }]\r\n    }\r\n})\r\n复制代码上述代码的简略版<swiper>\r\n    <swiper-item wx:for=\"{{2}}\" wx:key=\"{{index}}\">\r\n        <image src=\"../../images/swiper-{{index + 1}}.jpeg\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码wx:for-item 和 wx:for-index使用 wx:for-item 可以指定数组当前元素的变量名， 使用 wx:for-index 可以指定数组当前下标的变量名：<swiper>\r\n    <swiper-item wx:for=\"{{banner}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">\r\n        <image src=\"{{itemName.img}}\"></image>\r\n    </swiper-item>\r\n</swiper>\r\n复制代码wx:keywx:key 是列表中唯一的字符串或数字，且不能动态改变。例如：<switch wx:for=\"{{objectArray}}\" wx:key=\"unique\" style=\"display: block;\"> {{item.id}} </switch>\r\n复制代码Page({\r\n    data: {\r\n        objectArray: [\r\n            { id: '时间', unique: 'unique_5' },\r\n            { id: '速度', unique: 'unique_4' },\r\n            { id: '路程', unique: 'unique_3' },\r\n            { id: 2, unique: 'unique_2' },\r\n        ],\r\n    },\r\n})\r\n复制代码小鹿咖啡的菜单【实例】<scroll-view scroll-y class=\"rightBar\">\r\n        <view class=\"rightBar_Item\" wx:for=\"{{foodList}}\" wx:key=\"{{index}}\">\r\n            <view class=\"series_Title flex\">\r\n                <view class=\"drink_Title_name\">{{item.title}}</view>\r\n                <view class=\"drink_Title_line\"></view>\r\n            </view>\r\n            <view class=\"drink_List\">\r\n                <view class=\"drink_Item flex\" wx:for-item=\"it\" wx:for=\"{{item.food}}\" wx:key=\"{{index}}\">\r\n                    <view class=\"drink_Img\">\r\n                        <image class=\"drink_Img\" src=\"{{it.img}}\"></image>\r\n                        <view class=\"tip\" wx:if=\"{{it.tip}}\">{{it.tip}}</view>\r\n                    </view>\r\n                    <view class=\"drink_Cont\">\r\n                        <view class=\"drink_Title\">\r\n                            <view class=\"drink_Ch_Title\">{{it.name}}</view>\r\n                            <view class=\"drink_En_Title\">{{it.enname}}</view>\r\n                        </view>\r\n                        <view class=\"ju_between\">\r\n                            <view class=\"drink_price\">¥{{it.price}}</view>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </scroll-view>\r\n复制代码Page({\r\n    data: {\r\n        \"foodList\": [\r\n            {\r\n                \"id\": 1,\r\n                \"title\": \"大师咖啡\",\r\n                \"food\": [\r\n                    {\r\n                        \"id\": 1,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/SvHL13tH2g5UKUmVrbCjAPs4sLNBvAo7fhdJGpEU1.s!/r/dFQBAAAAAAAA\",\r\n                        \"name\": \"摩卡\",\r\n                        \"enname\": \"Mocha\",\r\n                        \"price\": \"27\",\r\n                        \"tip\": \"买2增1\"\r\n                    },\r\n                ]\r\n            },\r\n            {\r\n                \"id\": 2,\r\n                \"title\": \"小鹿茶\",\r\n                \"food\": [\r\n                    {\r\n                        \"id\": 1,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/VoBwYjGp2dIkV1owMWjVr4rm6Tp3wl8H1Gsa7n5hh08!/r/dFQBAAAAAAAA\",\r\n                        \"name\": \"活力柠檬红宝石茶\",\r\n                        \"enname\": \"Lemon Ruby Tea\",\r\n                        \"price\": \"24\",\r\n                        \"tip\": \"买2增1\"\r\n                    },\r\n                    {\r\n                        \"id\": 2,\r\n                        \"img\": \"http://r.photo.store.qq.com/psb?/V12jhopW1tjEiY/o7p7XoYAGaeMH6EtQNPVbU8tHFnKZitOcl9RarOcqNA!/r/dAgBAAAAAAAA\",\r\n                        \"name\": \"桃桃山雾乌龙茶\",\r\n                        \"enname\": \"White & Yellow Peach Oolong Tea\",\r\n                        \"price\": \"24\"\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    },\r\n})\r\n复制代码条件渲染wx:if条件渲染 | 微信开放文档wx:if使用方法wx:if=\"{{false}}\" , wx:if=\"{{true}}\"在小程序里面识别boolean值时，只要属性的值 不为空时，boolean就判断为真，就算里面随便几个字符，例如 wx:if=\"11223\" ，也判断为真， 如果需要为false,就必须采用数据绑定的方式{{false}},才能被小程序解析为假。在框架中，使用 wx:if=\"\" 来判断是否需要渲染该代码块： 也可以用  wx:elif 和  wx:else 来添加一个 else 块：<view wx:if=\"{{length > 85}}\">优秀</view>\r\n<view wx:elif=\"{{length > 60}}\">及格</view>\r\n<view wx:else>不及格</view>\r\n复制代码Page({\r\n    data: {\r\n        length: 61,\r\n    }\r\n})\r\n复制代码结果：及格的使用注意： <block/> 并不是一个组件，它仅仅是一个包装元素，将多个组件包装起来,不会在页面中做任何渲染，只接受控制属性。 wx:if 和 wx:for 含有 <block/> 的写法data: {\r\n        modalToggle: false,\r\n    },\r\n复制代码<block wx:if=\"{{modalToggle}}\">\r\n    \t<view class=\"modalWrap\">\r\n        \t<view class=\"modal\"></view>\r\n    \t</view>\r\n\t</block>\r\n\r\n复制代码不含有 <block/> 的写法data: {\r\n        modalToggle: false,\r\n    },\r\n复制代码<view class=\"modalWrap\" wx:if=\"{{modalToggle}}\">\r\n    \t<view class=\"modal\"></view>\r\n\t</view>\r\n复制代码教育Top10收藏列表【实例】页面描述：当有数据时，显示左侧列表。当没有数据时，则显示右侧内容<block wx:if=\"{{list.length>0}}\">\r\n    <block wx:for=\"{{list}}\" wx:key=\"idx\">\r\n        <view>{{item}}</view>\r\n    </block>\r\n</block>\r\n<block wx:else>\r\n    <view>暂时未收藏哦~</view>\r\n</block>\r\n复制代码Page({\r\n    data: {\r\n        list: ['月落乌啼霜满天','江枫渔火对愁眠']\r\n    },\r\n})\r\n复制代码wx:if vs  hidden1. wx:if 在初始渲染条件为  false ，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。所以当  wx:if 的条件值切换时，框架有一个局部渲染的过程，确保条件块在切换时销毁或重新渲染。 2. hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。总结: wx:if 有更高的切换消耗，而  hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用  hiddenhidden不生效原因及解决方案?<view hidden=\"true\" style=\"display:flex;\">\r\n    <text>text1</text>\r\n    <text>text2</text>\r\n</view>\r\n复制代码你会发现 hidden 没生效。经我实验发现 hidden 元素对块状布局才生效，所以这段代码里导致 hidden 没生效的罪魁祸首是 display:flex 。把这个去掉就可以了。如果一定要用flex布局怎么办？其实这里想用 hidden 无非就是想影藏这个布局， display:none 也能做到隐藏。这里可以用一个取巧的方法，动态设置 display 属性，示例如下：<view style=\"display:{{hideview ? 'none' : 'flex'}};\">\r\n    <text>text1</text>\r\n    <text>text2</text>\r\n</view>\r\n复制代码这里的 hideview 是在对应的 js 里是一个变量，由 js 来动态控制。"}
{"title": "微信小程序：扭蛋抽奖机-css3动画实现 ", "author": "Rolan", "pub_time": "2019-11-26 00:59", "content": "最近快速上线一个抽奖活动，又不想用canvas做，思考了很久，还是决定使用css3的动画来做，只要小球动得快，就没人发现我这些个小球的运动路径都是一样的了。先上动图。扭蛋机抽奖.gifwxml文件：<view class=\"ball-box\">      <image class=\"ball ball_1 {{start?'weiyi_1':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_2 {{start?'weiyi_2':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_3 {{start?'weiyi_3':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_4 {{start?'weiyi_4':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_5 {{start?'weiyi_5':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball1.png\"></image>      <image class=\"ball ball_6 {{start?'weiyi_6':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball2.png\"></image>      <image class=\"ball ball_7 {{start?'weiyi_7':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_8 {{start?'weiyi_8':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_9 {{start?'weiyi_9':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball3.png\"></image>      <image class=\"ball ball_10 {{start?'weiyi_10':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball4.png\"></image>      <image class=\"ball ball_11 {{start?'weiyi_11':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball4.png\"></image></view>这个做得我头皮发麻，但是写这篇文章时突然想到，为啥不用个for循环来做呢？！<view class=\"ball-box\">  <image wx:for=\"ballList\" wx:for-index=\"i\" class=\"ball ball_{{i}} {{start?'weiyi_{{i}}':''}}\" src=\"https://acceleratepic.miniso.com/miniso/ball{{i}}.png\"></image></view>这样看起来是不是舒服多了，因为是这段代码现场手写，如果有啥bug也不好说。wxss文件：.weiyi_1 {  animation: around1 1.5s linear infinite;  -webkit-animation: around1 1.5s linear infinite;}简单的动画/* 位移 */@-webkit-keyframes around1 {  0% {    -webkit-transform: translate(0rpx, 0rpx)  }  20% {    -webkit-transform: translate(100rpx, -250rpx)  }  40% {    -webkit-transform: translate(200rpx, -100rpx)  }  60% {    -webkit-transform: translate(50rpx, -230rpx)  }  80% {    -webkit-transform: translate(300rpx, -50rpx)  }  100% {    -webkit-transform: translate(0, 0)  }}@keyframes around1 {  0% {    transform: translate(0rpx, 0rpx)  }  20% {    transform: translate(100rpx, -250rpx)  }  40% {    transform: translate(200rpx, -100rpx)  }  60% {    transform: translate(50rpx, -230rpx)  }  80% {    transform: translate(300rpx, -50rpx)  }  100% {    transform: translate(0, 0)  }}简单的位移 其他就不一一列出来了，反正都差不多，改变一下运动轨迹就行了。js文件：相比丧病的样式，js文件就简单多了。_this.setData({  start: true})控制抽奖开始setTimeout(() => {        _this.setData({          start: false,          end: true        })      //其他代码部分      //time是接口请求开始到结束的时间}, Math.ceil(time / 1500) * 1500 - time)这里用了一个setTimeout，用于设置动画结束时间，优化一下动画，不让结束看起来太突兀。 1500是wxss里这是的动画时间。总结：简单的扭蛋机，有时间用canvas来做做。"}
{"title": "Taro+react自定义导航条/Tabbar菜单 ", "author": "Rolan", "pub_time": "2019-11-27 00:38", "content": "基于taro自定义导航栏Navbar|仿微信顶部导航|taro自定义tabbar这几天研究taro发现，官网提供的都是H5、小程序案例，至于RN案例甚少。恰好之前有过react及react-native项目经验，经过一番探究，终于实现能编译到多端，不过采坑不少，尤其是在RN环境下的样式问题。react仿微信web版聊天室： blog.csdn.net/yanxinyun19…如下图：在H5/小程序/RN效果均测试通过项目中用到的图标都是阿里iconfont字体图标，下载好后将fonts文件夹拷贝到项目目录下。import './styles/fonts/iconfont.scss' 在h5、小程序下 这种写法即可： <Text className=\"iconfont icon-back\"></Text>不过为了兼容RN，只能通过Unicode方式这样写： <Text className=\"iconfont\">&#xe84c;</Text>如果是通过变量传递： let back = '\\ue84c' <Text>{back}</Text>Taro自定义导航栏在App.js配置navigationStyle，将设置为custom，就可以自定义导航栏class App extends Component {\r\n    config = {\r\n        pages: \r\n            'pages/index/index',\r\n            ...\r\n        ],\r\n        window: {\r\n            backgroundTextStyle: 'light',\r\n            navigationBarBackgroundColor: '#fff',\r\n            navigationBarTitleText: 'Taro',\r\n            navigationBarTextStyle: 'black',\r\n            navigationStyle: 'custom'\r\n        },\r\n        ...\r\n    }\r\n    \r\n    ...\r\n}\r\n复制代码components目录下新建导航栏Navbar组件/*\r\n * @desc   Taro自定义导航条navbar组件\r\n * @about  Q：282310962  wx：xy190310\r\n */\r\n\r\nimport Taro from '@tarojs/taro'\r\nimport { View, Text, Input, Image } from '@tarojs/components'\r\nimport classNames from \"classnames\";\r\nimport './index.scss'\r\n \r\nexport default class NavBar extends Taro.Component {\r\n    // 默认配置\r\n    static defaultProps = {\r\n        isBack: false,\r\n        leftIcon: '\\ue84c',\r\n        title: ' ',\r\n        background: '#6190e8',\r\n        color: '#fff',\r\n        center: false,\r\n        search: false,\r\n        searchStyle: '',\r\n        fixed: false,\r\n        headerRight: [],\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            searchText: '',\r\n        }\r\n    }\r\n\t\r\n\t...\r\n \r\n    render() {\r\n        const { isBack, leftIcon, title, background, color, center, search, searchStyle, fixed, height, headerRight } = this.props\r\n        const { searchText } = this.state\r\n        \r\n        let weapp = false\r\n        if (process.env.TARO_ENV === 'weapp') {\r\n            weapp = true\r\n        }\r\n \r\n        return (\r\n            <View className={classNames('taro__navbar', fixed && 'taro__navbar--fixed', fixed && weapp && 'taro__navbar-weapp--fixed')}>\r\n                <View className={classNames('taro__navbar-wrap', fixed && 'taro__navbar-wrap--fixed', weapp && 'taro__navbar-wrap__weapp')} style={{backgroundColor: background}}>\r\n                    {/* 返回 */}\r\n                    <View className={classNames('taro__navbar-left__view', isBack && 'taro__navbar-left__view--isback')}>\r\n                    {isBack &&\r\n                        <TouchView activeOpacity={.5} onClick={this.handleNavigateBack}>\r\n                            <View className=\"taro__navbar-icon__item\"><Text className=\"iconfont taro__navbar-iconfont\" style={{color: color}}>{leftIcon}</Text></View>\r\n                        </TouchView>\r\n                    }\r\n                    </View>\r\n                    \r\n                    {/* 标题 */}\r\n                    {!search && center && !weapp ? <View className=\"flex1\" /> : null}\r\n                    {search ? \r\n                    (\r\n                        <View className=\"taro__navbar-search flex1\">\r\n                            <Input className=\"taro__navbar-search__input\" placeholder=\"搜索...\" onInput={this.updateInputText} style={{color: color, ...searchStyle}} />\r\n                        </View>\r\n                    )\r\n                    :\r\n                    (\r\n                        <View className={classNames('taro__navbar-title flex1', center && !weapp && 'taro__navbar-title--center')}>\r\n                            {title && <Text className=\"taro__navbar-title__text\" style={{color: color}}>{title}</Text>}\r\n                        </View>\r\n                    )\r\n                    }\r\n \r\n                    {/* 右侧 */}\r\n                    <View className=\"taro__navbar-right__view\">\r\n                    {headerRight.map((item, index) => (\r\n                        <TouchView activeOpacity={.5} key={index} onClick={()=>item.onClick && item.onClick(searchText)}>\r\n                            <View className=\"taro__navbar-icon__item\">\r\n                                {item.icon && <Text className=\"iconfont taro__navbar-iconfont\" style={{color: color, ...item.style}}>{item.icon}</Text>}\r\n                                {item.text && <Text className=\"taro__navbar-iconfont__text\" style={{color: color, ...item.style}}>{item.text}</Text>}\r\n                                {item.img && <Image className=\"taro__navbar-iconfont__img\" src={item.img} mode='aspectFit' />}\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__navbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__navbar-badge--dot\"></Text>}\r\n                            </View>\r\n                        </TouchView>\r\n                    ))\r\n                    }\r\n                    </View>\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码在页面引入组件即可： import NavBar from '@components/navbar'支持自定义背景、颜色、左侧图标、标题居中、搜索框，右侧按钮支持图标/文字/图片，还可以设置样式，红点提示、事件处理<NavBar title='Taro标题栏' fixed\r\n    headerRight={[\r\n        {icon: '\\ue614', style: {color: '#e93b3d'}},\r\n        {img: require('../../assets/taro.png'), dot: true, onClick: this.handleCallback},\r\n        {icon: '\\ue600', style: {marginRight: 10}},\r\n    ]} \r\n/>复制代码<NavBar isBack leftIcon={'\\ue69f'} title='搜索栏' background='#42b983' color='#fcc' search\r\n    searchStyle={{\r\n        backgroundColor:'rgba(255,255,255,.6)', borderRadius: Taro.pxTransform(50), color: '#333'\r\n    }}\r\n    headerRight={[\r\n        {icon: '\\ue622', style: {color: '#6afff9'}},\r\n        {icon: '\\ue63a'},\r\n    ]} \r\n/>复制代码Taro自定义底部Tabbarimport Taro from '@tarojs/taro'\r\nimport { View, Text } from '@tarojs/components'\r\nimport classNames from 'classnames'\r\nimport './index.scss'\r\n \r\nexport default class TabBar extends Taro.Component {\r\n    // 默认参数配置\r\n    static defaultProps = {\r\n        current: 0,\r\n        background: '#fff',\r\n        color: '#999',\r\n        tintColor: '#6190e8',\r\n        fixed: false,\r\n        onClick: () => {},\r\n        tabList: []\r\n    }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            updateCurrent: props.current\r\n        }\r\n    }\r\n    ...\r\n \r\n    render() {\r\n        const { background, color, tintColor, fixed } = this.props\r\n        const { updateCurrent } = this.state\r\n        \r\n        return (\r\n            <View className={classNames('taro__tabbar', fixed && 'taro__tabbar--fixed')}>\r\n                <View className={classNames('taro__tabbar-list', fixed && 'taro__tabbar-list--fixed')} style={{backgroundColor: background}}>\r\n                    {this.props.tabList.map((item, index) => (\r\n                        <View className=\"taro__tabbar-item taro__tabbar-item--active\" key={index} onClick={this.updateTabbar.bind(this, index)}>\r\n                            <View className=\"taro__tabbar-icon\">\r\n                                <Text className=\"iconfont taro__tabbar-iconfont\" style={{color: updateCurrent == index ? tintColor : color}}>{item.icon}</Text>\r\n                                {/* 圆点 */}\r\n                                {!!item.badge && <Text className=\"taro__badge taro__tabbar-badge\">{item.badge}</Text>}\r\n                                {!!item.dot && <Text className=\"taro__badge-dot taro__tabbar-badge--dot\"></Text>}\r\n                            </View>\r\n                            <Text className=\"taro__tabbar-title\" style={{color: updateCurrent == index ? tintColor : color}}>{item.title}</Text>\r\n                        </View>\r\n                    ))}\r\n                </View>\r\n            </View>\r\n        );\r\n    }\r\n}\r\n复制代码自定义tabbar也支持自定义背景、颜色、图标，点击选项事件返回索引值<TabBar current={currentTabIndex} background='#f8f8f8' color='#999' tintColor='#6190e8' fixed onClick={this.handleTabbar}\r\n    tabList={[\r\n        {icon: '\\ue627', title: '首页', badge: 8},\r\n        {icon: '\\ue61e', title: '商品'},\r\n        {icon: '\\ue605', title: '个人中心', dot: true},\r\n    ]}\r\n/>\r\n复制代码好了，今天就介绍到这里，后续会考虑使用Taro技术开发个多端实战项目。ReactNative聊天APP实战|仿微信聊天/朋友圈/红包界面"}
{"title": "微信小程序推送消息简单Demo ", "author": "Rolan", "pub_time": "2019-11-27 00:45", "content": "在开始前，你需要准备：注册微信小程序一个简单的springBoot 项目微信开发者工具正式微信小程序发送消息主要通过WxMaTemplateMessage 类来推送public class WxMaTemplateMessage implements Serializable {\r\n    private String toUser;       // 给谁推送(用户openId)\r\n    private String templateId;  // 消息ID\r\n    private String page;    // 用户点开消息跳转到对应的小程序界面\r\n    private String formId;  // 表单formId\r\n    private List<WxMaTemplateData> data; // 消息的数据列表\r\n    private String emphasisKeyword;  \r\n...\r\n复制代码所以我们在推送前需要构造这些信息，formId 和toUser(openId) 是从前端传过来的。formId 可以通过表单或者支付来获取，表单比较简单，只需要把report-submit 设置为true 就可以获得。简单通过微信开发者工具来获取formId(openId 数据库存了)先建立一个前端项目，AppID 就是小程序的id，在微信公众号后台可以看到。修改index/index.js 和index.wxml (百度某位同学的)，通过表单来获取formId ，并发送到后台。// index.wxml\r\n<form bindsubmit='registerFormSubmit' report-submit='true'>\r\n  <view class='buttons'>\r\n    <button class='confirmbtn' form-type='submit'>确定</button>\r\n  </view>\r\n\r\n</form>\r\n<view>formid： {{formid}}</view>\r\n<button bindtap='push'>\r\n    发送\r\n</button>\r\n\r\n复制代码//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({\r\n  \r\n  data: {\r\n    formid: \"\"\r\n  },\r\n  //事件处理函数\r\n  registerFormSubmit: function (e) {\r\n    //    打印formId\r\n    console.log(e.detail.formId);\r\n    this.setData({\r\n      formid: e.detail.formId\r\n    })\r\n   },\r\n  //测试推送\r\n push() {\r\n    let formid = this.data.formid;\r\n   let openid = 'oT-H-40ZHdRX1REZFKQhPg3jJZoQ';\r\n    wx.request({\r\n      url: 'http://localhost:8080/push?openId=' + openid + \"&formId=\" + formid,\r\n      success(res) {\r\n        console.log(\"推送结果：\", res)\r\n      },\r\n      fail(err) {\r\n        console.log(\"推送失败：\", err)\r\n      }\r\n    })\r\n  }\r\n})\r\n\r\n复制代码这里formid 在测试的时候获取不到，调到真机调试，或者用预览就行了。请求后台接口来发送消息（ctrl c v 百度某同学）import cn.binarywang.wx.miniapp.api.WxMaService;\r\nimport cn.binarywang.wx.miniapp.api.impl.WxMaServiceImpl;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateData;\r\nimport cn.binarywang.wx.miniapp.bean.WxMaTemplateMessage;\r\nimport cn.binarywang.wx.miniapp.config.WxMaInMemoryConfig;\r\nimport me.chanjar.weixin.common.error.WxErrorException;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@RestController\r\npublic class PushController {\r\n\r\n    @GetMapping(\"/push\")\r\n    public String push(@RequestParam String openId, @RequestParam String formId) {\r\n        //1,配置小程序信息\r\n        WxMaInMemoryConfig wxConfig = new WxMaInMemoryConfig();\r\n        wxConfig.setAppid(\"你的appId\");\r\n        wxConfig.setSecret(\"你的secret\");\r\n\r\n        WxMaService wxMaService = new WxMaServiceImpl();\r\n        wxMaService.setWxMaConfig(wxConfig);\r\n\r\n        //2,设置模版信息（keyword1：类型，keyword2：内容）\r\n        List<WxMaTemplateData> templateDataList = new ArrayList<>(2);\r\n        WxMaTemplateData data1 = new WxMaTemplateData(\"keyword1\", \"获取老师微信\");\r\n        WxMaTemplateData data2 = new WxMaTemplateData(\"keyword2\", \"2501902696\");\r\n        WxMaTemplateData data3 = new WxMaTemplateData(\"keyword3\", \"2501902696\");\r\n        WxMaTemplateData data4 = new WxMaTemplateData(\"keyword4\", \"2501902696\");\r\n        templateDataList.add(data1);\r\n        templateDataList.add(data2);\r\n        templateDataList.add(data3);\r\n        templateDataList.add(data4);\r\n\r\n        //3，设置推送消息\r\n        WxMaTemplateMessage templateMessage = WxMaTemplateMessage.builder()\r\n                                                  .toUser(openId)\r\n                                                  .formId(formId)\r\n                                                  .templateId(\"你的消息id\") // 在微信公众号后台可以申请消息模版\r\n                                                  .data(templateDataList)\r\n                                                  .page(\"pages/index/index\")\r\n                                                  .build();\r\n\r\n        //4，发起推送\r\n        try {\r\n            wxMaService.getMsgService().sendTemplateMsg(templateMessage);\r\n        } catch (WxErrorException e) {\r\n            System.out.println(\"推送失败：\" + e.getMessage());\r\n            return e.getMessage();\r\n        }\r\n        return \"推送成功\";\r\n    }\r\n\r\n}\r\n复制代码"}
{"title": "从0到1开发一个小程序cli脚手架（三） --自定义命令 ", "author": "Rolan", "pub_time": "2019-11-29 00:52", "content": "本文主要讲述关于如何实现自定义命令\r\ngithub地址：github.com/jinxuanzhen…\r\n觉得有用的朋友帮忙给项目一个star，谢谢\r\n\r\n系列内容，推荐从第一篇开始阅读：从0到1开发一个小程序cli脚手架（一）--创建页面/组件模版篇从0到1开发一个小程序cli脚手架（二） --版本发布/管理篇从0到1开发一个小程序cli脚手架（三） --自定义命令\r\n\r\n背景\r\n在写不同小程序的时候，突然发现每个小程序面临的场景和需求或多或少会有些差异化，比如说程序A会有生成doc的功能，程序B会有开启数据埋点的debug模式等等\r\n为了保证脚手架的通用性，我们并不能将这些差异化的功能一一实现，这时候就需要让用户实现自定义了\r\n\r\n准备工作\r\n最好看过之前的两篇文章并搭建过demo，里面有介绍一些项目的结构，实现思路，第三方包使用相关的东西\r\n\r\n开始\r\n\r\n梳理大概流程\r\n这里不多说了，老套路: config注册方法 -> 脚手架路由读取注册方法 -> 执行回调函数\r\n\r\n注册自定义命令\r\n既然是给开发者在实际项目中进行配置，那么自然在配置文件 xdk.config.js 文件中动手了，在配置文件中预留出一个口子，方便我们读取配置文件时获取json，因为开发者可能会注册多个自定义命令，我这里字段类型直接给的数组类型\r\n\r\n将字段customScripts配置好后，就开始配置自定义命令了，首先确定需要的属性\r\n\r\n[name], 命令名称肯定是要的\r\n[desc], 描述本质上可有可无，不影响功能，但是比较方便记忆\r\n[callback], 输入完命令之后要执行什么(回调函数主体)\r\n\r\n\r\n大概是这个样子，后续我会以生成sass文档为例来写一个自定义命令\r\n\r\n读取配置项\r\n回到xdk-cli这个项目，找到入口文件index.js，如果看过前面两篇文章，会知道首先要配置路由，这里调用第三方包commander来解析命令\r\n\r\n配置路由\r\n\r\n这里先看第一行，我用了前缀 run <cmd> 来解析，也就是说我们使用的时候必须输入xdk-cli run <cmd>，那么为什么不直接xdk-cli <cmd>呢？\r\n主要是为扩展考虑，避免命名重复导致功能被覆盖，而且自定义指令本质上只是xdk-cli脚手架诸多功能中的一项，放在第一层级实在有些不合时宜\r\n有些情况下，不太清楚当前项目下的自定义命令都有哪些，可以直接xdk-cli -h查看\r\n\r\n加装方法\r\n通过run 命令我们可以准确到达当前的action，接下来要做什么？\r\n自然是执行自定义命令的回调，在执行之前我们可以给他加装一系列方法，更利于去二次开发，我这里采用的是改变this指向的方法，将当前函数作用于绑定到originPrototype上\r\n\r\n\r\n方法库列表\r\n我这里道导出了封装好log的开启子进程方法，log方法，还有交互命令行方法，当然也可以导出更多，主要看自己的需求\r\n\r\n到这里为止，这样一套流程就跑通了，下面我写一个小例子\r\n\r\n案例：生成sass文档\r\n可以看到我调用的子进程，和日志都是通过接口公开出来已经在脚手架进行过统一处理的方法，并没有去多做事情\r\n当然你也可以使用交互命令，让自定义命令更加友好，例如：\r\n\r\n配合package.json\r\n可以在package.json的scripts里注册命令，简化我们的调用\r\n直接可以简写为npm start\r\n\r\n最后\r\n这篇比较简单，基本上只是针对回调方法做了包装与回传，目标是为了方便让开发者去定制一些功能\r\n到此为止，三篇文章下来整个小程序开发脚手架的大概逻辑和框架已经非常清晰明了，后续的话有可能会针对npm支持, 和npm包的开发模板进行更新，觉得有帮助的同学可以关注下~~"}
{"title": "微信小程序把base64的图片保存到手机相册 ", "author": "Rolan", "pub_time": "2019-12-2 00:17", "content": "var file = wx.getFileSystemManager();\r\nconsole.log('1')\r\nfile.writeFile({\r\n    //读写文件路径filePath需要使用wx.env.USER_DATA_PATH + '/tmp.txt'才可以读写成功。\r\n    filePath:  wx.env.USER_DATA_PATH + '/poster.png',\r\n    data: self.preurl.slice(22),\r\n    encoding:'base64',\r\n    success:async()=>{\r\n        console.log('123')\r\n        const res2 = await wepy.saveImageToPhotosAlbum({\r\n            filePath: wx.env.USER_DATA_PATH + '/poster.png'\r\n        })\r\n        wepy.$toast('图片已保存到相册，赶紧晒一下吧~')\r\n        self.isShow = false\r\n        self.$apply();\r\n    },\r\n    fail:function(e){\r\n        console.log(e)\r\n    }\r\n})wx.getFileSystemManager()  是获取文件管理器对象；aa.writeFile  是写文件，详细参数可\t点击查看 官方文档说明。String wx.env.USER_DATA_PATH文件系统中的用户目录路径wx.env.USER_DATA_PATH +'/test.png'  这里是创建一个临时文件的文件名。that.data.scene.slice(22)   这里是把 data:image/png;base64这一段去除，需要注意的是去除这一段之后 base64 编码之间放到image组件的src里面是不能显示图片的。"}
{"title": "小程序图像处理：图片配色分析 ", "author": "Rolan", "pub_time": "2019-12-2 00:10", "content": "背景\r\n小程序的canvas是微信基于原生组件自行封装的，因此接口跟web的canvas有不少区别，早期更是没有支持像素级的处理能力。\r\n在18年初的小程序基础库1.9.0版本更新中，出现了wx.canvasGetImageData和wx.canvasPutImageData两个重要的API，补全了像素处理能力，因此，小程序在客户端进行图片处理成为了可能。\r\n具体可以参考：\r\n偷偷迭代的重磅功能---小程序的像素处理能力\r\nwx.canvasGetImageData\r\n图片配色分析小程序：小色卡\r\n为了尝试小程序的图像处理能力，我做了个用于图片配色分析的小程序-小色卡。\r\n功能主要是：用户选择一张图片，程序会分析图片的配色，并把配色展示为一张色卡给用户。用户可以保存、编辑、复制自己的色卡。这个功能对初级的UI设计师有一定的帮助（可能吧...）。\r\n源码：github：mini-color-card\r\n体验小程序：\r\n\r\n原理\r\n小程序实现配色分析主要步骤如下：\r\n\r\n用户选择图片，拿到imgPath后绘制到canvas上。\r\n通过wx.canvasGetImageData这个接口读取图片数据\r\n对图片数据进行预处理，剔除alpha比较小并且不是白色的点。（非必要）\r\n对图片像素数据进行聚类。每个像素的颜色可以作为一个三维向量来看。\r\n\r\n基本逻辑如下：\r\nwx.chooseImage({\r\n  count: 1,\r\n  sizeType: ['original', 'compressed'],\r\n  sourceType: ['album', 'camera'],\r\n  success: (res) => {\r\n    wx.getImageInfo({\r\n      src: res.tempFilePaths[0],\r\n      success: (imgInfo) => {\r\n        let {\r\n          width,\r\n          height,\r\n          imgPath\r\n        } = imgInfo;\r\n        let ctx = wx.createCanvasContext(this.canvasID);\r\n        ctx.drawImage(imgPath,0,0,width,height);\r\n        ctx.draw(false,()=>{\r\n          wx.canvasGetImageData({\r\n            canvasId: this.canvasID,\r\n            x: 0,\r\n            y: 0,\r\n            width: width,\r\n            height: height,\r\n            success(res) {\r\n              var pixels = res.data;\r\n              var pixelCount = width*height;\r\n              var pixelArray = [];\r\n              // 对像素数据进行预处理\r\n              for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\r\n                offset = i * 4;\r\n                r = pixels[offset + 0];\r\n                g = pixels[offset + 1];\r\n                b = pixels[offset + 2];\r\n                a = pixels[offset + 3];\r\n                if (a >= 125) {\r\n                  if (!(r > 250 && g > 250 && b > 250)) {\r\n                    pixelArray.push([r, g, b]);\r\n                  }\r\n                }\r\n              }\r\n              var cmap = MMCQ.quantize(pixelArray, colorCount);//聚类，MMCQ是个用于图像分析的库\r\n              var palette = cmap ? cmap.palette() : null;\r\n              console.log('配色为：',palette);\r\n            }\r\n          })\r\n        })\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码小结\r\n一开始我是不想把canvas显示出来的，只想用它获取图像内容，但是实践下来是不可行的。小程序的canvas并不允许离屏渲染，想要用它进行图片处理，就要老老实实用它进行展示。\r\n这里只实践了wx.canvasGetImageData读取数据进行图像分析，不过结合wx.canvasPutImageData，滤镜之类的图像处理应该都是可以做了。小程序的想象空间还是挺大的。"}
{"title": "如何使用不到50行代码实现一个小而美的依赖收集库？ ", "author": "Rolan", "pub_time": "2019-12-2 00:02", "content": "现代web开发，大多数都遵循着视图与逻辑分离的开发原则，一反面使得代码更加易懂且易扩展，另一方面带来的问题就是如何优雅的管理数据。因而，社区诞生了很多优秀的状态管理库，比如为React而生的 Redux ，专为 Vue 服务的 Vuex ，还有不限定框架的 Mobx 等等。在为使用这些库提升开发效率而叫好的同时，我觉得我们也应该从内部去真正的了解它们的核心原理，就比如今天这篇文章的主题 依赖收集 ，就是其中的一个很大的核心知识。这篇文章将会带您一步一步的以最少的代码去实现一个小而美的依赖收集库，同时给您展现如何将这个库运用到小程序中去实现跨页面的状态共享。二 实现过程1. 基本原理依赖收集的基本原理可以概括为以下3步：创建一个可观察（observable）对象视图或者函数（effect）引用这个对象的某个属性，触发依赖收集改变数据，视图或者函数自动更新或运行我们要实现的例子：import { observable, observe } from \"micro-reaction\";\r\n\r\nconst ob = observable({\r\n    a: 1\r\n});\r\n\r\nobserve(() => console.log(ob.a));\r\n\r\n// logs: 1\r\n// logs: 2\r\nob.a = 2;\r\n复制代码下面开始我将一步一步的进行实现过程讲解2. 创建一个可观察对象首先，我们需要创建一个可观察对象，其本质就是将传入的对象进行代理，并且返回这个代理对象，这里我们使用 es6 的 Proxy 来修改对象的一些行为，从而实现在返回真正对象前作一些拦截操作。我们定义了一个名叫 observable 方法来代理对象，代码如下：export function observable(obj = {}) {\r\n    return createObservable(obj)\r\n}\r\n\r\nfunction createObservable(obj) {\r\n    const proxyObj = new Proxy(obj, handlers());\r\n    return proxyObj\r\n}\r\n复制代码可以看到 observable 方法内部就是通过 new Proxy（obj,handler） 生成一个代理对象，传参分别是原始对象和代理操作方法 handlers ， handlers 返回一个对象，定义了对象的原始方法，例如 get 、 set ，通过重新定义这两个方法，我们可以修改对象的行为，从而完成代理操作，我们来看看 handlers 方法。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            return result\r\n        },\r\n        set: (target, key, value, receiver) => {\r\n            const result = Reflect.set(target, key, value, receiver);\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码如上，我们在 get 和 set 方法里面没有做任何操作，取值赋值操作都是原样返回。3. 关联副作用函数effect完成了对数据的初始定义，我们明确下我们的目的，我们的最终目的是数据改变，副作用函数 effect 自动运行，而这其中的关键就是必须有个地方引用我们创建的代理对象，从而触发代理对象内部的 get 或者 set 方法，方便我们在这两个方法内部做一些依赖收集和依赖执行的工作。因而，这里我们定义了一个 observe 方法，参数是一个 Function ，我们先看看这个方法的实现：export function observe(fn) {\r\n    <!--这一行可以先忽略，后面会有介绍-->\r\n    storeFns.push(fn);\r\n    <!--Reflect.apply()就相当于fn.call(this.arguments)-->\r\n    Reflect.apply(fn, this, arguments)\r\n}\r\n复制代码可以看到，内部执行了传入的函数，而我们传入的函数是 () => console.log(ob.a.b) ，函数执行，输出 ob.a ，引用了代理对象的 a 属性值，就触发了代理对象内部的 get 方法。 在 get方法内部我们就可以进行依赖收集。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            <!--触发依赖收集-->\r\n            depsCollect({ target, key })\r\n            return result\r\n        },\r\n        set: (target, key, value, receiver) => {\r\n            const result = Reflect.set(target, key, value, receiver);\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码depsCollect 依赖收集方法需要做的操作就是将当前的依赖也就是 () => console.log(ob.a)这个函数 fn 保存起来，那 fn 怎么传过来呢？ get 方法本身的入参是没有这个 fn 的，回顾之前的 observe 方法，这个方法有传入 fn ，其中内部有个 storeFns.push(fn) 这样的操作，就是通过一个数组将当前依赖函数临时收集起来。可光收集没用，我们还要和对应的属性进行映射，以便后续某个属性变化时，我们能够找出对应的 effect ，故我们定义了一个 Map 对象来存储相应的映射关系，那需要怎样的一个映射关系呢？一个对象有多个属性，每个属性可能都有对应的 effect ，结构看起来应该是这样的：{\r\n    obj:{\r\n        \"key-1\":fn1,\r\n        \"key-2\":fn2,\r\n        ....\r\n    }\r\n}\r\n复制代码我们定义了一个全局变量 storeReactions 来存储整个映射关系，它的 key 是 obj ，就是原始对象， obj 的值也是个 Map 结构，存储了其属性和 effect 的映射关系。我们的最终目的其实也就是建立一个这样的关系。理清楚了数据存储，再来看看我们的 depsCollect 方法，其实就是将临时保存在 storeFns 里面的函数取出和属性 key 映射。// 存储依赖对象\r\nconst storeReactions = new WeakMap();\r\n// 中转数组，用来临时存储当前可观察对象的反应函数，完成收集之后立即释放\r\nconst storeFns = [];\r\nfunction depsCollect({ target, key }) {\r\n    const fn = storeFns[storeFns.length - 1];\r\n    if (fn) {\r\n        const mapReactions = storeReactions.get(target);\r\n        if (!mapReactions.get(key)) {\r\n            mapReactions.set(key, fn)\r\n        }\r\n    }\r\n}\r\n复制代码至此，我们的依赖收集算是完成了，接下来就是要实现如何监听数据改变，对应 effect 自动运行了。4. 数据变更，effect自动运行数据变更，就是重新设置数据，类似 a=2 的操作，就会触发代理对象里面的 set 方法，我们只需要在 set 方法里面取出对应的 effect 运行即可。set: (target, key, value, receiver) => {\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        executeReactions({ target, key })\r\n        return result\r\n    }\r\n    \r\nfunction executeReactions({ target, key }) {\r\n    <!-- 一时看不懂的，回顾下我们的映射关系 -->\r\n    const mapReactions = storeReactions.get(target);\r\n    if (mapReactions.has(key)) {\r\n        const reaction = mapReactions.get(key);\r\n        reaction();\r\n    }\r\n}\r\n复制代码ok，我们的例子的实现过程讲解完了，整个实现过程还是很清晰的，最后看看我们的整个代码，去掉空行不到50行代码。const storeReactions = new WeakMap(),storeFns = [];\r\n\r\nexport function observable(obj = {}) {\r\n  const proxyObj = new Proxy(obj, handlers());\r\n  storeReactions.set(obj, new Map());\r\n  return proxyObj\r\n}\r\n\r\nexport function observe(fn) {\r\n  if (storeFns.indexOf(fn) === -1) {\r\n    try {\r\n      storeFns.push(fn);\r\n      Reflect.apply(fn, this, arguments)\r\n    } finally {\r\n      storeFns.pop()\r\n    }\r\n  }\r\n}\r\n\r\nfunction handlers() {\r\n  return {\r\n    get: (target, key, receiver) => {\r\n      depsCollect({ target, key })\r\n      return Reflect.get(target, key, receiver)\r\n    },\r\n    set: (target, key, value, receiver) => {\r\n      Reflect.set(target, key, value, receiver)\r\n      executeReactions({ target, key })\r\n    }\r\n  }\r\n}\r\n\r\nfunction depsCollect({ target, key }) {\r\n  const fn = storeFns[storeFns.length - 1];\r\n  if (fn) {\r\n    const mapReactions = storeReactions.get(target);\r\n    if (!mapReactions.get(key)) {\r\n      mapReactions.set(key, fn)\r\n    }\r\n  }\r\n}\r\n\r\nfunction executeReactions({ target, key }) {\r\n  const mapReactions = storeReactions.get(target);\r\n  if (mapReactions.has(key)) {\r\n    const reaction = mapReactions.get(key);\r\n    reaction();\r\n  }\r\n}\r\n复制代码5. 多层级数据结构到目前为止，我们实现的还只能观察单级的对象，如果一个对象的层级深了，类似 ob.a.b 的结构，我们的库就无法观察数据的变动， effect 也不会自动运行。那如何支持呢？核心原理就是在 get 方法里面判断返回的值，如果返回的值是个对象，就递归调用 observable 方法，递归调用完，接着运行 observe 方法就会构建出完整的一个属性 key 和反应 effect 的映射关系。function handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            depsCollect({ target, key })\r\n            if (typeof result === 'object' && result != null && storeFns.length > 0) {\r\n                return observable(result)\r\n            }\r\n            return result\r\n        }\r\n    }\r\n}\r\n复制代码回到 ob.a.b 这样的结构，此时实际的代理对象应该是这样的 {proxy(proxy(c))} ，如果这个时候我们去修改数据，比如 ob.a.b = 2 这样。ob.a.b = 2 的运行过程会是怎样？要知道js这门语言是先编译后执行的，所以js引擎首先会去分析这段代码（编译阶段），先分析左边的表达式 ob.a.b ，故先会编译 ob.a ，触发了第一次 get 方法，在 get 方法中， result 得到的值是个对象，如果按照上述代码，又去重新观察这个对象，会导致 observe 方法中构建好的映射关系丢失，其中就是对象 {b:1} 中 key 为 b 对应的 fn 丢失，因为我们存储 fn 是在 observe 方法中执行的，那怎么办呢？方法是我们应该在第一次 observable 方法执行的时候，将每一个 key 对应的代理对象都保存起来，在赋值操作再一次触发 get 方法的时候，如果已经代理过，直接返回就行，不需要重新代理。// 存储代理对象\r\nconst storeProxys = new WeakMap();\r\nexport function observable(obj = {}) {\r\n    return storeProxys.get(obj) || createObservable(obj)\r\n}\r\nfunction createObservable(obj) {\r\n    const proxyObj = new Proxy(obj, handlers());\r\n    storeReactions.set(obj, new Map())\r\n    storeProxys.set(obj, proxyObj)\r\n    return proxyObj\r\n}\r\nfunction handlers() {\r\n    return {\r\n        get: (target, key, receiver) => {\r\n            const result = Reflect.get(target, key, receiver);\r\n            depsCollect({ target, key })\r\n            <!--如果代理存储中有某个key对应的代理直接返回即可-->\r\n            const observableResult = storeProxys.get(result);\r\n            if (typeof result === 'object' && result != null && storeFns.length > 0) {\r\n                return observable(result)\r\n            }\r\n            return observableResult || result\r\n        }\r\n    }\r\n}\r\n复制代码如此， ob.a.b = 2 ，控制台就会依次输出 1 和 2 ，另外说一句，数组也是对象，故动态增加数组的值或者赋值操作都能触发响应的 effect 。const ob = observable({\r\n  a: {\r\n    b: 1,\r\n    c: []\r\n  }\r\n});\r\n\r\nobserve(() => console.log(ob.a.c.join(\", \")));\r\n//logs: 2\r\nob.a.c.push(2);\r\n复制代码三 如何结合小程序使用全部完整代码我已发布到我的github中，名字叫做 micro-reaction ，这个库完全无依赖的，纯粹的，故可以为其它界面框架状态管理提供能量，由于小程序跨页面状态共享相关的库不多，故这里以小程序举例，如何结合 micro-reaction 实现跨页面状态共享。1. 核心原理描述下场景，有两个页面 A 和 B ，全局数据 C ， A 和 B 都引用了 C ，之后，页面 A 中某个交互改变了 C ， A 和 B 都需要自动渲染页面。结合我们的库， C 肯定是需要 observable的， observe 方法传入的 fn 是会动态执行的，小程序渲染页面的方式是 setData 方法，故 observe 方法里面肯定执行了 setData() ，因而只要我们在 observe 方法里面引用 C ，就会触发依赖收集，从而在下次 C 改变之后， setData 方法重新运行渲染页面。2. 关键步骤首先，我们需要拿到每个小程序页面的 this 对象，以便自动渲染使用，故我们需要代理 Page方法里面传入的参数，我们定一个了 mapToData 方法来代理，代码如下：<!--全局数据-->\r\nimport homeStore from \"../../store\"\r\n<!--将数据映射到页面，同时出发依赖收集，保存页面栈对象-->\r\nimport { mapToData } from \"micro-reaction-miniprogram\"\r\nconst connect = mapToData((store) => ({ count: store.credits.count }), 'home')\r\n\r\nPage(connect({\r\n  onTap(e) {\r\n    homeStore.credits.count++\r\n  },\r\n  onJump(e) {\r\n    wx.navigateTo({\r\n      url: \"/pages/logs/logs\"\r\n    })\r\n  }\r\n}))\r\n复制代码mapToData 方法返回一个函数， function mapToData(fn,name){return function(pageOpt){}}，这里用到了闭包，外部函数为我们传入的函数，作用是将全局数据映射到我们的页面 data 中并触发依赖收集，内部函数传入的参数为小程序页面本身的参数，里面包含了小程序的生命周期方法，因而我们就可以在内部重写这些方法，并拿到当前页面对象并存储起来供下一次页面渲染使用。import { STORE_TREE } from \"./createStore\"\r\nimport { observe, observable } from 'micro-reaction';\r\n\r\nfunction mapToData(fn, name) {\r\n  return function (pageOpt) {\r\n    const { onLoad } = pageOpt;\r\n    pageOpt.onLoad = function (opt) {\r\n      const self = this\r\n      const dataFromStore = fn.call(self, STORE_TREE[name], opt)\r\n      self.setData(Object.assign({}, self.data, dataFromStore))\r\n\r\n      observe(() => {\r\n        <!--映射方法执行，触发依赖收集-->\r\n        const dataFromStore = fn.call(self, STORE_TREE[name], opt)\r\n        self.setData(Object.assign({}, self.data, dataFromStore))\r\n      })\r\n\r\n      onLoad && onLoad.call(self, opt)\r\n    }\r\n    return pageOpt\r\n  }\r\n}\r\n\r\nexport { mapToData, observable }\r\n复制代码然后，页面 A 改变了数据 C ， observe 方法参数 fn 自动执行，触发 this.setData 方法，从而页面重新渲染，完整代码点击 micro-reaction-miniprogram ，也可以点击查看 在线Demo。四 总结希望我的文章能够让您对依赖收集的认识更深，以及如何举一反三的学会使用，此外，最近在学习周爱民老师的《JavaScript核心原理解析》这门课程，其中有句话对我触动很深，引用的是金庸射雕英雄传里面的文本： 教而不得其法，学而不得其道 ，意思就是说，传授的人没有用对方法，学习的人就不会学懂，其实我自己对学习的方法也一直都很困惑，前端发展越来越快，什么 SSR ，什么 serverless ，什么 前端工程化 ，什么 搭建系统 各种知识概念越来越多，不知道该怎么学习，说不焦虑是不可能的，但坚信只有一个良好的基础，理解一些技术的本质，才能在快速发展的前端技术浪潮中，不至于被冲走，与局共勉！最后，在贴下文章提及的两个库，欢迎star试用，提pr，感谢~依赖收集库 micro-reaction小程序状态管理库 micro-reaction-miniprogram"}
{"title": "记《高校考勤系统》小程序（1） ", "author": "Rolan", "pub_time": "2019-11-28 00:03", "content": "引言这是我自学小程序并上线的第一个算是完整的项目(其实是♀朋友的毕业设计需求 )，前端萌新一枚.其中肯定会有许多不合理或需要改进的地方请大家指出，谢谢！:sunglasses::sunglasses:(前期准备工作就不介绍啦，我们直接进入正题)一.功能需求整理，思路规划1.用户注册登录.2.教师及学生课程表信息关联、课程表信息查看.3.校园信息发布、签到任务发布、请假管理、用户管理.4.自己顺手加的天气，海报生成功能.拿到需求想了想除了注册登录，主要划分两大块，一为普通学生用户功能，二为管理员教师功能.因为要在一个小程序中全部展示，所以思考在用户注册时添加‘status’字段作为后续用户权限判断依据来展示相对应的页面及功能。(也不知道这样做对不对:cry:，头大)根据理解画了流程图二.项目整体布局搭建小程序主要划分为四块，所以首先我们在app.json中创建对应的tabbar.其中素材用到了阿里巴巴图标库 ( www.iconfont.cn )实现效果：三.用户注册登录在此前我们需要开通云开发并在数据库中创建存储用户信息的集合.引入Vant Weapp 和ColorUI组件库（组件丰富，上手方便，色彩搭配beautiful:+1:） youzan.github.io/vant-weapp/… www.color-ui.com/这里我新建了三张页面分别为启动动画过渡页、登录页、注册页.启动动画过渡页:点击查看js代码Page({\r\n    data: {\r\n            openid: '', //获取用户_openid\r\n            panduan: '', //判断用是否存在\r\n            arr: []\r\n    },\r\n    onLoad: function(options) {\r\n            wx.cloud.callFunction({ //获取用户openid\r\n            name: 'login',\r\n            data: {},\r\n        }).then(res => {\r\n            this.openid = res.result.openid\r\n        }).then(res => {\r\n            const db = wx.cloud.database({ \r\n                env: 'env-urae8'  //数据库环境名\r\n            })\r\n            db.collection('users').get().then(res => { //获取用户数据\r\n                this.arr = res.data\r\n                for (let i = 0; i < this.arr.length; i++) { //循环判断用户数据中是否存在用户\r\n                    if (this.openid == this.arr[i]._openid) {\r\n                        this.panduan = 'true'\r\n                    }\r\n                }\r\n            }).then(res => {\r\n                if (this.panduan == 'true') { //存在用户跳转登录页面\r\n                    wx.reLaunch({\r\n                        url: '/pages/index/index',\r\n                    })\r\n                } else if (this.data.panduan == '') {\r\n                    wx.redirectTo({\r\n                        url: '/pages/login/login' //不存在用户跳转登录页\r\n                    })\r\n                }\r\n            })\r\n            }).catch(err => {\r\n                wx.showToast({\r\n                    icon: 'none',\r\n                    title: '用户信息获取失败，请检查网络',\r\n                })\r\n            })\r\n    }\r\n})\r\n复制代码用户登录页:点击查看js代码Page({\r\n    data: {\r\n        userid:'',\r\n        haveuserid:'no',\r\n        openid: '',\r\n        errMsg:''\r\n    },\r\n    onGotUserInfo(e){\r\n        this.data.errMsg = e.detail.errMsg\r\n        if (e.detail.errMsg == 'getUserInfo:ok'){\r\n        this.setData({\r\n            userBtn: true,\r\n            trueBtn:false\r\n        })\r\n    }\r\n    },\r\n    useridInput(e){\r\n        this.userid = e.detail.value\r\n    },\r\n    loginBtn(){\r\n        this.data.haveuserid = 'no'  //清除判断是否存在用户名\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').get().then(res => {\r\n            for (let i = 0; i < res.data.length; i++) {\r\n                if (res.data[i].userid === this.userid && res.data[i]._openid == this.openid) {\r\n                    this.data.haveuserid = 'yes'\r\n                }\r\n            }\r\n            var pattern = /^\\d{6,12}$/\r\n            if(this.userid == '000001'){\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }else if (pattern.test(this.userid) && this.data.haveuserid == 'yes' && this.data.errMsg == 'getUserInfo:ok'){\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }else if (this.data.errMsg == 'getUserInfo:fail auth deny' || this.data.errMsg == '') {\r\n                wx.showToast({\r\n                    title: '请授权后再登录',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n            }else if (!pattern.test(this.userid)) {  //判断是否符合用户名\r\n                wx.showToast({\r\n                    title: '请输入6-12位数字',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n            }else if (this.data.haveuserid == 'no') {\r\n                wx.showToast({\r\n                    title: '学号或工号错误或不存在,请重新输入或注册',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n            } \r\n        })\r\n    },\r\n    registerBtn(){\r\n        wx.redirectTo({\r\n            url: '/pages/register/register'\r\n        })\r\n    },\r\n    onLoad: function (options) {\r\n        this.setData({\r\n            trueBtn:true  //用户授权框样式\r\n        })\r\n        wx.cloud.callFunction({ //获取用户openid\r\n            name: 'login',\r\n            data: {},\r\n            success: res => {\r\n                this.openid = res.result.openid\r\n            },\r\n            fail: err => {\r\n                wx.showToast({\r\n                    icon: 'none',\r\n                    title: '用户信息获取失败，请检查网络',\r\n                })\r\n            }\r\n        })\r\n    }\r\n})\r\n复制代码<view class=\"title\">登录</view>\r\n<view>\r\n    <view class=\"input\">\r\n        <image src=\"../../images/userimg.png\"></image>\r\n        <input class=\"inputBtn\" bindinput=\"useridInput\" placeholder=\"请输入学号或工号\"></input>\r\n    </view>\r\n    <view class=\"userBtn\">\r\n        <button hidden=\"{{ userBtn }}\" open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\"\r\n            class=\"onGotUserInfo\"></button>\r\n        <image hidden=\"{{ trueBtn }}\" class=\"true\" src=\"../../images/true.png\"></image>\r\n        <text class=\"userTit\">用户授权</text>\r\n    </view>\r\n    <button class=\"loginBtn shadow bg-blue\" bindtap=\"loginBtn\">登 录</button>\r\n    <button class=\"registerBtn shadow bg-blue\" bindtap=\"registerBtn\">注 册</button>\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    position: relative;\r\n    background-color: white;\r\n}\r\n.title {\r\n    margin-top: 200rpx;\r\n    text-align: center;\r\n    font-size: 40rpx;\r\n}\r\n.input{\r\n    width: 60%;\r\n    margin: 0 auto;\r\n    margin-top: 120rpx;\r\n    padding: 20rpx;\r\n    border-radius: 10rpx;\r\n    background-color: #f6f6f6;\r\n    display: flex;\r\n    justify-content: start;\r\n}\r\n.input image{\r\n    width: 30rpx;\r\n    height: 30rpx;\r\n    margin-top: 6rpx;\r\n    display: block;\r\n}\r\n.inputBtn {\r\n    width: 100%;\r\n    height: 40rpx;\r\n    margin-left: 20rpx;\r\n}\r\n.loginBtn, .registerBtn {\r\n    width: 400rpx;\r\n    margin: 0 auto;\r\n    background-color: #07c160;\r\n    color: white;\r\n    font-weight: 600;\r\n}\r\n.loginBtn {\r\n    margin-bottom: 60rpx;\r\n    margin-top: 60rpx;\r\n}\r\n.userBtn {\r\n    margin-top: 160rpx;\r\n    margin-left: 190rpx;\r\n    display: flex;\r\n    justify-content: flex-start;\r\n}\r\n.onGotUserInfo {\r\n    width: 44rpx;\r\n    height: 44rpx;\r\n    border-radius: 20rpx;\r\n    padding: 0;\r\n    margin: 0;\r\n    border: 6rpx solid #07c160;\r\n}\r\n.true{\r\n    width: 44rpx;\r\n    height: 44rpx;\r\n}\r\n.userTit{\r\n    margin-left: 12rpx;\r\n}\r\n复制代码用户注册页:点击查看js代码const app = getApp()\r\nwx.cloud.init();\r\nPage({\r\n    data: {\r\n        steps: [{\r\n                text: '第一步',\r\n                desc: '授权登录'\r\n            },\r\n            {\r\n                text: '第二步',\r\n                desc: '输入信息'\r\n            },\r\n            {\r\n                text: '第三步',\r\n                desc: '完成注册'\r\n            }\r\n        ],\r\n        active: 0,\r\n        nextOne: true, //第一个下一步\r\n        hiddenName: false, //授权登录\r\n        userid: '', // 用户学号或者工号\r\n        nickName: '', //用户名\r\n        avatarUrl: '', //用户头像\r\n        userStatus: '0', //用户注册状态\r\n        step: 1,\r\n        openid: '',\r\n        haveuserid:'no'//判断是否存在用户名\r\n    },\r\n    nextOne() {\r\n        this.setData({\r\n            active: 1, //状态为步骤2\r\n            firstBoxHide: true, //隐藏步骤1框\r\n            secondBoxHide: false //显示步骤2框\r\n        })\r\n    },\r\n    onGotUserInfo(e) {\r\n        this.setData({\r\n            nickName: e.detail.userInfo.nickName, //获取用户名\r\n            avatarUrl: e.detail.userInfo.avatarUrl, //获取头像\r\n            nextOne: false, //下一步按钮显示\r\n            hiddenName: true, //授权按钮隐藏\r\n            firstHide: false //显示用户信息\r\n        })\r\n        this.nickName = e.detail.userInfo.nickName\r\n        this.avatarUrl = e.detail.userInfo.avatarUrl\r\n    },\r\n    useridInput(e) {\r\n        this.userid = e.detail.value\r\n    },\r\n    secondBtn() {\r\n        this.data.haveuserid = 'no'  //清除判断是否存在用户名\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').get().then(res => {\r\n            for(var i = 0;i < res.data.length ; i++){\r\n                if (res.data[i].userid === this.userid || res.data[i]._openid == this.openid){\r\n                    this.data.haveuserid = 'yes'\r\n                }\r\n            }   \r\n            var pattern = /^\\d{6,12}$/\r\n            if (!pattern.test(this.userid)) {  //判断是否符合用户名\r\n                wx.showToast({\r\n                    title: '请输入6-12位数字',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n            } else if (this.data.haveuserid == 'yes') {  //判断数据库是否存在用户名\r\n                wx.showToast({\r\n                    title: '用户已存在,请直接登录',\r\n                    icon: 'none',\r\n                    duration: 1500\r\n                })\r\n                this.setData({\r\n                    backBtn: false, //显示返回登录按钮\r\n                })\r\n            } else {\r\n                this.setData({\r\n                    secondBtn: true, //隐藏确定按钮\r\n                    nextTwo: false //显示second框下一步按钮\r\n                })\r\n            }\r\n        })\r\n    },\r\n    backBtn(){ //返回登录页面\r\n        wx.redirectTo({\r\n            url: '/pages/login/login'\r\n        })\r\n    },\r\n    nextTwo() {\r\n        this.setData({\r\n            userid: this.userid,\r\n            nickName: this.nickName,\r\n            avatarUrl: this.avatarUrl,\r\n            secondBoxHide: true, //隐藏second框\r\n            thirdBoxHide: false, //显示third框\r\n            nextTwo: true, //隐藏下一步2按钮\r\n            active: 3, //初始状态为步骤3\r\n        })\r\n    },\r\n    thirdBtn() { //完成注册按钮\r\n        const db = wx.cloud.database({   //数据库新增用户注册信息\r\n            env: 'env-urae8'\r\n        })\r\n        db.collection('users').add({\r\n            data: {\r\n                userid: this.userid,\r\n                nickName: this.nickName,\r\n                userStatus: this.data.userStatus\r\n            },\r\n            success: res => {\r\n                wx.switchTab({\r\n                    url: '/pages/index/index'\r\n                })\r\n            }\r\n        })\r\n    },\r\n    onLoad: function(options) {\r\n        this.setData({\r\n            active: 0, //初始状态为步骤1\r\n            nextOne: true, //隐藏下一步按钮\r\n            firstHide: true, //隐藏用户框信息\r\n            firstBoxHide: false, //\r\n            secondBoxHide: true, //隐藏步骤2框\r\n            nextTwo: true, //隐藏second框下一步按钮\r\n            thirdBoxHide: true, //显示third框\r\n            backBtn:true,  //隐藏返回登录按钮\r\n        })\r\n        //获取用户openid\r\n        if (this.data.step === 1 && !this.data.openid) {\r\n            wx.cloud.callFunction({\r\n                name: 'login',\r\n                data: {},\r\n                success: res => {\r\n                    app.globalData.openid = res.result.openid\r\n                    this.step = 2,\r\n                    this.openid = res.result.openid\r\n                },\r\n                fail: err => {\r\n                    wx.showToast({\r\n                        icon: 'none',\r\n                        title: '用户信息获取失败，请检查网络',\r\n                    })\r\n                }\r\n            })\r\n        }\r\n    }\r\n})\r\n复制代码<view class=\"cont\">\r\n    <view class=\"title\">注册</view>\r\n    <view class=\"cont_box\">\r\n        <van-steps class=\"van-steps\" steps=\"{{ steps }}\" active=\"{{ active }}\" active-color=\"#07c160\"\r\n            inactive-icon=\"../../images/true.png\" />\r\n    </view>\r\n    <view class=\"first\" hidden=\"{{ firstBoxHide }}\">\r\n        <view class=\"user_box\" hidden=\"{{ firstHide }}\">\r\n        <image class=\"avatarUrl\" src=\"{{ avatarUrl }}\"></image>\r\n    </view>\r\n    <view class=\"nickName\" hidden=\"{{ firstHide }}\">{{ nickName }}</view>\r\n        <button hidden=\"{{hiddenName}}\" open-type=\"getUserInfo\" lang=\"zh_CN\"\r\n            bindgetuserinfo=\"onGotUserInfo\" class=\"loginBtn shadow bg-blue\">微信授权</button>\r\n        <button class=\"nextOne shadow bg-blue\" bindtap=\"nextOne\" hidden=\"{{ nextOne }}\">下一步</button>\r\n    </view>\r\n    <view class=\"second\" hidden=\"{{ secondBoxHide }}\">\r\n        <input class=\"useridInput\" bindinput=\"useridInput\" placeholder=\"请输入学号或工号\"></input>\r\n        <button class=\"secondBtn shadow bg-blue\" bindtap=\"secondBtn\" hidden=\"{{ secondBtn }}\">确定</button>\r\n        <button class=\"nextTwo shadow bg-blue\" bindtap=\"nextTwo\" hidden=\"{{ nextTwo }}\">下一步</button>\r\n        <button class=\"backBtn shadow bg-blue\" bindtap=\"backBtn\" hidden=\"{{ backBtn }}\">返回登录</button>\r\n    </view>\r\n    <view class=\"third\" hidden=\"{{ thirdBoxHide }}\">\r\n        <view class=\"user_box\" >\r\n            <image class=\"avatarUrl\" src=\"{{ avatarUrl }}\"></image>\r\n        </view>\r\n        <view class=\"nickName\">微信名：{{ nickName }}</view>\r\n        <view class=\"userid\">学号：{{ userid }}</view>\r\n        <button class=\"thirdBtn shadow bg-blue\" bindtap=\"thirdBtn\">完成注册</button>\r\n    </view>\r\n</view>\r\n复制代码点击查看wxss代码page {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n    background-color: white;\r\n}\r\n.register_bg {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n}\r\n.cont {\r\n    width: 100%;\r\n    margin-top: 200rpx;\r\n    color: black;\r\n    z-index: 1;\r\n    display: flex;\r\n    justify-content: start;\r\n    flex-direction: column;\r\n}\r\n.cont .title {\r\n    font-size: 46rpx;\r\n    text-align: center;\r\n    margin-bottom: 60rpx;\r\n}\r\n.van-steps {\r\n    width: 82%;\r\n    margin: 0 auto;\r\n}\r\n.first, .second, .third {\r\n    width: 100%;\r\n    height: 500rpx;\r\n    position: relative;\r\n    text-align: center;\r\n}\r\n.first .user_box, .third .user_box {\r\n    width: 160rpx;\r\n    height: 160rpx;\r\n    border-radius: 80rpx;\r\n    margin: 0 auto;\r\n    margin-top: 50rpx;\r\n    position: relative;\r\n    overflow: hidden;\r\n    box-shadow:0 2rpx 4rpx rgba(0, 0, 0, .3);\r\n}\r\n.nickName{\r\n    height: 40rpx;\r\n    line-height: 40rpx;\r\n    margin-top: 26rpx;\r\n    font-size: 30rpx;\r\n}\r\n.first .avatarUrl, .third .avatarUrl {\r\n    width: 160rpx;\r\n    height: 160rpx;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n}\r\n.first .success {\r\n    margin-top: 20rpx;\r\n}\r\n.loginBtn, .nextOne, .nextTwo, .backBtn,.secondBtn,.thirdBtn {\r\n    width: 240rpx;\r\n    height: 80rpx;\r\n    background-color: #07c160;\r\n    color: white;\r\n    line-height: 80rpx;\r\n    text-align: center;\r\n    font-size: 30rpx;\r\n    font-weight: 600;\r\n    border: none;\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: calc(50% - 120rpx);\r\n}\r\n.secondBtn{\r\n    bottom: 260rpx;\r\n}\r\n.backBtn {\r\n    bottom: 130rpx;\r\n}\r\n/* 清除button样式 */\r\nbutton {\r\n    font-size: 28rpx;\r\n    background-color: transparent;\r\n    border: none;\r\n    padding: 0;\r\n    margin: 0;\r\n    line-height: 1;\r\n}\r\nbutton::after {\r\n    border: none;\r\n    background-color: transparent;\r\n}\r\n.button-hover {\r\n    color: rgba(0, 0, 0, 0.8);\r\n    background-color: transparent;\r\n}\r\n.second .useridInput {\r\n    width: 60%;\r\n    height: 40rpx;\r\n    padding: 20rpx;\r\n    border-radius: 12rpx;\r\n    margin: 50rpx auto;\r\n    text-align: left;\r\n    background-color: #f6f6f6;\r\n}\r\n.third .userid {\r\n    margin-top: 30rpx;\r\n}\r\n复制代码三.首页页面搭建天气数据来自阿凡达数据，也是比较了许多接口，这个相对返回数据比较可观且收费也在承受范围之内 www.avatardata.cn/ .UI样式参考了许多其他小程序（墨迹天气、小天气等）; 天气小模块参考 juejin.im/post/5d2f3f… ; 腾讯地图api lbs.qq.com/qqmap_wx_js… ; 感谢他们给予的帮助及参考:+1::+1::+1:先来看看完成后的效果图1.获取当前定位城市信息.前期需要注册腾讯地图并认证，获取key，在项目中引入微信小程序JavaScript SDK，具体步骤可以参考腾讯地图api:point_up_2:（链接见上）getUserLocation() {\r\n    var qqmapsdk;\r\n    var _this = this;\r\n    wx.getSetting({ //判断是否授权\r\n    success(res) {\r\n    wx.getLocation({\r\n      type: 'gcj02', //返回可以用于wx.openLocation的经纬度\r\n      success(res) {\r\n        // console.log('已授权')\r\n        qqmapsdk = new QQMapWX({\r\n          key: \"****\", //自己申请的key\r\n        })\r\n        qqmapsdk.reverseGeocoder({\r\n          location: {\r\n            latitude: res.latitude,\r\n            longitude: res.longitude\r\n          },\r\n          success(addressRes) {\r\n            // console.log(addressRes) //这里就可以获取到当前经纬度所在城市的详细信息\r\n            _this.city = addressRes.result.ad_info.city; //获取当前所在城市\r\n            })\r\n          },\r\n          fail(res) {\r\n            console.log(res)\r\n          }\r\n        })\r\n      },\r\n      fail(res) {\r\n        // console.log('未授权')\r\n      }\r\n    })\r\n  }\r\n})\r\n},\r\n复制代码2.根据定位获取到的城市信息，调用天气接口获取当前城市天气数据.wx.request({\r\n    url: 'https://api.avatardata.cn/Weather/Query?key=你注册后的key值&cityname=' + 定位获取到的城市名,\r\n    header: {\r\n        'content-type': 'application/json' // 默认值\r\n    },\r\n    success(res) {\r\n        //返回城市天气数据\r\n    }\r\n})\r\n复制代码3.根据当前天气状况判断天气模块的显示隐藏. 例如：if (res.data.result.weather[i].info.day[1].indexOf('晴') >= 0) { //判断条件为接口返回数据\r\n        //晴天天气模块显示其他隐藏\r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('阴') >= 0 || \r\n    res.data.result.weather[i].info.day[1].indexOf('云') >= 0) {\r\n        //多云或阴天天气模块显示其他隐藏\r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('小雨') >= 0) {\r\n        //小雨气模块显示其他隐藏 \r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('大雨') >= 0) {\r\n        //大雨气模块显示其他隐藏           \r\n    } else if (res.data.result.weather[i].info.day[1].indexOf('雪') >= 0) {\r\n        //下雪天气模块显示其他隐藏            \r\n    }\r\n复制代码4.因为返回的接口数据有些是自己不想要的，或者想自己添加一些新的图片文字，所以将数据重新编写成对象数组的形式，最后渲染出来就可以了.例如下面这个模块let weather = []\r\nweather.push({\r\n    date: date,\r\n    week: res.data.result.weather[i].week, //星期\r\n    daywea: res.data.result.weather[i].info.day[1], //白天天气\r\n    daytemp: res.data.result.weather[i].info.day[2], //白天温度\r\n    daywind: daywind, //风向\r\n    daywindli: res.data.result.weather[i].info.day[4], //风力\r\n    nightwea: res.data.result.weather[i].info.night[1], //晚上天气\r\n    nighttemp: res.data.result.weather[i].info.night[2], //晚上温度\r\n})\r\nconsloe.log(weather)//打印结果\r\n//(5) [{…}, {…}, {…}, {…}, {…}]\r\n//0: {date: \"11-27\", week: \"三\", daywea: \"小雨\", daytemp: \"10\", daywind: \"西风\",\r\n        daywindli: \"4-5级\"，nighttemp: \"8\"，nightwea: \"小雨\"，week: \"三\"}\r\n//1: {date: \"11-28\", week: \"四\", daywea: \"多云\", daytemp: \"10\", daywind: \"西风\", …}\r\n//2: {date: \"11-29\", week: \"五\", daywea: \"阴\", daytemp: \"11\", daywind: \"东北风\", …}\r\n//3: {date: \"11-30\", week: \"六\", daywea: \"小雨\", daytemp: \"13\", daywind: \"无风\", …}\r\n//4: {date: \"12-01\", week: \"日\", daywea: \"阴\", daytemp: \"11\", daywind: \"西风\", …}\r\n复制代码先写到这里，如果有什么写的不好的地方，请大家多多包涵，之后会继续分享后面的内容。大家也可以提前扫码查看小程序，欢迎指出不足，谢谢"}
{"title": "微信小程序中悬浮窗功能的实现（主要探讨和解决在原生组件上的拖动） ... ", "author": "Rolan", "pub_time": "2019-8-5 00:54", "content": "所谓悬浮窗就是图中微信图标的按钮，采用fixed定位，可拖动和点击。这算是一个比较常见的实现场景了。为什么要用cover-view做悬浮窗？原生组件出来背锅了~最初我做悬浮窗用的不是cover-view，而是view。这是简化的代码结构：index.wxml:<view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </image>\r\n</view>\r\n<textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n<view>\r\n  一大段test，占个位，表示下存在感\r\n</view>index.js:Page({\r\n\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250,\r\n    isIos: true\r\n  },\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  setTouchMove: function (e) {\r\n    if (e.touches[0].clientX > 0 && e.touches[0].clientY > 0) {\r\n      this.setData({\r\n        left: e.touches[0].clientX - 30,\r\n        top: e.touches[0].clientY - 30\r\n      })\r\n    } else {\r\n      this.setData({\r\n        left: 20, //默认显示位置 left距离\r\n        top: 250  //默认显示位置 top距离\r\n      })\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})为什么要用cover-view呢？因为页面上有个textarea组件，这个组件是原生组件，当悬浮窗移动到这个textarea组件上时，将无法继续拖动和点击。如果悬浮窗一开始就定位在textarea上，那么就更惨了，一开始就不能点击和拖动了。这个原因是因为微信小程序的原生组件层级高于非原生组件，不是你修改几下样式就能解决的问题。这里就不讲什么原生组件了，如果想进一步了解，可以参考我之前写的一篇博客：微信小程序在ios下Echarts图表不能滑动的解决方案。如果你的页面上面没有原生组件，那么像上面的代码一样用view做悬浮窗即可。如果有，那么就可以跟着我继续踩坑，使用cover-view这个原生组件层级的组件来做悬浮窗。安卓下的cover-view拖动起来，抖得不像帕金森，像是魔鬼的步伐以下是我们修改为cover-view之后的代码：<cover-view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <cover-image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </cover-image>\r\n</cover-view>\r\n<textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n<view>\r\n  一大段test，占个位，表示下存在感\r\n</view>注意这里，我们的image也改为了cover-image，因为cover-view只支持嵌套 cover-view、cover-image，不过可在 cover-view 中使用 button。这样虽然解决了可在原生组件上自由拖动点击的问题，但是在安卓上出现了一个很奇怪的现象，以至于我认为已经无法用抖动可以来形容了：上图是就是我滑动这个悬浮窗之后的效果，我只是很缓慢地在移动手指，但是这个悬浮窗的表现简直就像一个受惊的兔子。当我第一眼看见这个效果的时候一脸懵逼，我都不知道说什么好。虽然在ios上cover-view移动起来表现良好，但是在安卓上拖动起来的表现简直没法看。勉强能看的补丁方案安卓上这么挫，还不如原来的呢。所以来个补丁方案好了，在ios下用cover-view完美拖动，在安卓上用view先跑着。<cover-view wx-if=\"{{isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <cover-image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </cover-image>\r\n</cover-view>\r\n<view wx-if=\"{{!isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"setTouchMove\">\r\n    <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n    </image>\r\n</view>\r\n<textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n<view>\r\n  一大段test，占个位，表示下存在感\r\n</view>当然少不了要在js里面加上这句代码：onLoad: function (options) {\r\n  wx.getSystemInfo({\r\n    success: (res) => {\r\n      if (res.platform == \"android\") {\r\n        this.setData({\r\n          isIos: false\r\n        })\r\n      }\r\n    }\r\n  })\r\n}不要忘记isIos默认为true哦。反正ios环境下可以完美使用了，至于安卓下拖到textarea组件上没法再拖的问题，调整下悬浮框的初始位置就好了。而且只要不是刻意移动到textarea组件上，拖动着悬浮框经过textarea组件也是没有问题的嘛。像我这么聪明的用户还懂得滑动下面的页面来使悬浮窗移动到非原生组件的地方，这样就又可以拖动了嘛。你又以为你的测试一定能发现这个问题？发现了又怎样，我已经尽力了，还给你整出这么多理论依据，足够你把锅牢牢地按在微信小程序官方的头上。使用movable-view：仿佛发现了新大陆，结果发现这个还是个弟弟甩锅是一定要甩锅的，但是段位要高。所以要遍查官方文档，探讨一切可能性，以免甩锅的时候被打脸。我们仔细观察小程序官方文档，发现还是有个专门用来拖动的组件叫movable-view。这个组件和cover-view摆放在一起仿佛很厉害的样子，紧接着我们在原生组件使用限制文档中发现了它并不是原生组件。也就是说这个东西的层级一定还是低于咱们的textarea组件的。虽然已经很确定这个东西没什么用了，但是最后还是试探一把，结果发现是个真弟弟，这里就不给出代码了。我写这个弟弟方案放在这里的目的主要是为了不要浪费你的验证时间。理论上行得通的方案：将拖动事件的捕获放在父级现在我们确认的最优甩锅方案里，已经实现了功能和甩锅两不误。那么作为一名有追求的技术人员，还是需要去探讨以下这个问题到底有没有完美的解决方案。因为我最开始是把这个悬浮窗做成了一个组件，那么作为组件来讲，这个东西就只能做到这个地步了。不过如果你是像我现在的例子一样直接做在了页面里，那么实现起来也不是说没有办法的。我们将拖动的事件放在父级上就可以了，请看接下来的代码：index.wxml:<view bindtouchmove=\"setTouchMove\">\r\n    <view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\">\r\n        <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </image>\r\n    </view>\r\n    <textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n    <view>\r\n      一大段test，占个位，表示下存在感\r\n    </view>\r\n</view>index.js:Page({\r\n\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250\r\n  },\r\n\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  setTouchMove: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    const moveViewCenterPosX = this.data.left + MOVE_VIEW_RADIUS\r\n    const moveViewCenterPosY = this.data.top + MOVE_VIEW_RADIUS\r\n\r\n    // 确保手指在悬浮窗上才可以移动\r\n    if (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS + 60 && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS + 60) {\r\n      if (touchPosX > 0 && touchPosY > 0) {\r\n        this.setData({\r\n          left: touchPosX - MOVE_VIEW_RADIUS,\r\n          top: touchPosY - MOVE_VIEW_RADIUS\r\n        })\r\n      } else {\r\n        this.setData({\r\n          left: 20, // 默认显示位置 left距离\r\n          top: 250  // 默认显示位置 top距离\r\n        })\r\n      }\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})关键代码就是这块了：// 确保手指在悬浮窗上才可以移动\r\nif (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS + 60 && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS + 60) {\r\n\r\n}只要确保手指在悬浮窗的范围内就可以触发移动了，这里的60是为了确保你的手指太大，或者移动得比较快时超出了悬浮窗区域依然可以触发拖动，这个可以自己设定数值。这个方案在理论上很合理，并且还加上了60这个缓冲区域，但是实际在拖动的时候你仍然会面临下面三个问题：1.如果悬浮窗下方有滚动区域，那么拖动的时候就会滚动页面，效果会显得比较奇怪。2.实际移动没法移动太顺畅，只能拖着悬浮窗亦步亦趋,要不然很容易超过60这个缓冲区域，导致拖动不继续触发。2.如果将缓冲区域设置过大，那么又会出现一种比较奇怪的场景：明明不准备拖动悬浮窗，只是准备滑动页面，悬浮窗却跳到自己手指这里了。进阶解决方案：禁止冒泡的拖动 + 理论方案这个解决方案基于我们的最初方案，并且使用我们的理论方案作为补充。先上代码：index.wxml：<view bindtouchmove=\"handleSetMoveViewPos\">\r\n    <view class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"handleTouchMove\">\r\n        <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </image>\r\n    </view>\r\n    <textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n    <view>\r\n      一大段test，占个位，表示下存在感\r\n    </view>\r\n</view>index.js：Page({\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250\r\n  },\r\n  /**\r\n  * 拖拽移动(补丁)\r\n  */\r\n  handleSetMoveViewPos: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    const moveViewCenterPosX = this.data.left + MOVE_VIEW_RADIUS\r\n    const moveViewCenterPosY = this.data.top + MOVE_VIEW_RADIUS\r\n\r\n    // 确保手指在悬浮窗上才可以移动\r\n    if (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS+30 && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS+30 ) {\r\n      if (touchPosX > 0 && touchPosY > 0) {\r\n        this.setData({\r\n          left: touchPosX - MOVE_VIEW_RADIUS,\r\n          top: touchPosY - MOVE_VIEW_RADIUS\r\n        })\r\n      } else {\r\n        this.setData({\r\n          left: 20, // 默认显示位置 left距离\r\n          top: 250  // 默认显示位置 top距离\r\n        })\r\n      }\r\n    }\r\n  },\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  handleTouchMove: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    if (touchPosX > 0 && touchPosY > 0) {\r\n      this.setData({\r\n        left: touchPosX - MOVE_VIEW_RADIUS,\r\n        top: touchPosY - MOVE_VIEW_RADIUS\r\n      })\r\n    } else {\r\n      this.setData({\r\n        left: 20, //默认显示位置 left距离\r\n        top: 250  //默认显示位置 top距离\r\n      })\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})这个方案的核心点在于：catchtouchmove=\"handleTouchMove\" 。当我们正常拖动悬浮窗时，通过catchtouchmove，我们可以捕获在悬浮窗上的滑动事件，并且不冒泡到父元素，那么我们绑在父层级的滑动事件就不会触发。而当我们拖动在原生组件之上的悬浮窗时，因为点不到这个悬浮窗，就不会触发handleTouchMove函数，只会触发绑定在父元素上的handleSetMoveViewPos函数。另外如果你细心的话，就会发现在handleSetMoveViewPos函数这里我缩小了那个60的缓冲区域为30，这样做的目的是因为触发这个函数只会在原生组件上，所以多番权衡距离之后，尽量避免近距离滑动操作就触发拖动悬浮框。通过我们的方案，我们可以在非原生组件上自由拖动，在原生组件上比较顺畅地拖动。本来我是准备将这个方案作为最终方案的，但是ios下，悬浮窗在原生组件上时，在父元素上的滑动事件竟然不触发。棋差一招，棋差一招啊！最终解决方案：更多的补丁，更多的快乐这个最终解决方案，当然是把我们之前所有的补丁方案全部结合起来。代码如下：index.wxml:<view bindtouchmove=\"handleSetMoveViewPos\">\r\n    <view wx-if=\"{{!isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"handleTouchMove\">\r\n        <image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </image>\r\n    </view>\r\n    <cover-view wx-if=\"{{isIos}}\" class=\"move-view\" style=\" top:{{top}}px;left:{{left}}px;\" bindtap=\"goToHome\" catchtouchmove=\"handleTouchMove\">\r\n        <cover-image class=\"img\" src=\"https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4294841024,3545417298&fm=179&app=42&f=PNG?w=56&h=56\">\r\n        </cover-image>\r\n    </cover-view>\r\n    <textarea placeholder='我是textarea组件，用来输入一些信息'></textarea>\r\n    <view>\r\n      一大段test，占个位，表示下存在感\r\n    </view>\r\n</view>index.js:Page({\r\n\r\n  /**\r\n  * 页面的初始数据\r\n  */\r\n  data: {\r\n    left: 20,\r\n    top: 250,\r\n    isIos: true\r\n  },\r\n\r\n  /**\r\n  * 生命周期函数--监听页面加载\r\n  */\r\n  onLoad: function (options) {\r\n    wx.getSystemInfo({\r\n      success: (res) => {\r\n        if (res.platform == \"android\") {\r\n          this.setData({\r\n            isIos: false\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n\r\n  /**\r\n  * 拖拽移动(补丁)\r\n  */\r\n  handleSetMoveViewPos: function (e) {\r\n    // 在ios下永远都不会走这个方案，以免引起无用的计算\r\n    if (!ios) {\r\n      const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n      const touchPosX = e.touches[0].clientX\r\n      const touchPosY = e.touches[0].clientY\r\n\r\n      const moveViewCenterPosX = this.data.left + MOVE_VIEW_RADIUS\r\n      const moveViewCenterPosY = this.data.top + MOVE_VIEW_RADIUS\r\n\r\n      // 确保手指在悬浮窗上才可以移动\r\n      if (Math.abs(moveViewCenterPosX - touchPosX) < MOVE_VIEW_RADIUS && Math.abs(moveViewCenterPosY - touchPosY) < MOVE_VIEW_RADIUS) {\r\n        if (touchPosX > 0 && touchPosY > 0) {\r\n          this.setData({\r\n            left: touchPosX - MOVE_VIEW_RADIUS,\r\n            top: touchPosY - MOVE_VIEW_RADIUS\r\n          })\r\n        } else {\r\n          this.setData({\r\n            left: 20, // 默认显示位置 left距离\r\n            top: 250  // 默认显示位置 top距离\r\n          })\r\n        }\r\n      }\r\n    }\r\n  },\r\n  /**\r\n  * 拖拽移动\r\n  */\r\n  handleTouchMove: function (e) {\r\n    const MOVE_VIEW_RADIUS = 30 // 悬浮窗半径\r\n\r\n    const touchPosX = e.touches[0].clientX\r\n    const touchPosY = e.touches[0].clientY\r\n\r\n    if (touchPosX > 0 && touchPosY > 0) {\r\n      this.setData({\r\n        left: touchPosX - MOVE_VIEW_RADIUS,\r\n        top: touchPosY - MOVE_VIEW_RADIUS\r\n      })\r\n    } else {\r\n      this.setData({\r\n        left: 20, //默认显示位置 left距离\r\n        top: 250  //默认显示位置 top距离\r\n      })\r\n    }\r\n  },\r\n  /**\r\n  * 返回首页\r\n  */\r\n  goToHome: () => {\r\n    wx.reLaunch({\r\n      url: '/pages/index/index',\r\n    })\r\n  }\r\n})这个最终解决方案在ios下直接使用cover-view来做悬浮窗，而在android的非原生组件上移动时，使用view来做悬浮窗，不冒泡滑动事件，在原生组件上移动时捕获冒泡的滑动事件来继续移动操作。总结虽然问题解决了，但是这仍然只是一个补丁方案。最好的方式依然是微信小程序官方能修复cover-view在安卓移动时的BUG，但是我发现最早有人反馈这个问题是在2018年11月，到了现在2019年8月都没有结果。如果不是微信小程序的官方态度有问题，那么只能说明这个问题的解决确实有难度或者优先级并不高，无论是哪一种，暂时都还是得用补丁方案。这个方案并没有那么完美，他在一些边界的衔接上面可能还是会存在一些小问题，但它至少可用，并且应该是大多数用户可以接受的。"}
{"title": "小程序页面栈详解 ", "author": "Rolan", "pub_time": "2019-8-6 00:08", "content": "原文链接小程序页面栈详解在做小程序项目的时候不难发现，使用navigateTo进行页面跳转后，点击左上角或使用navigateBack返回，总是会按照之前的页面进入倒序来展示页面，那么问题来了，它们的跳转规则是什么样的呢？结合到实际业务中如何灵活运用呢？什么是页面栈？首先先来了解一下微信小程序的运行环境： 小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。 小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。我们可以看到，一个页面使用一个 WebView 线程进行渲染。如果打开10个页面，则会开启 10 个 WebView 线程，此时内存中的十个webView线程我们称之为页面栈。当然小程序也会对这块内存做限制，目前页面栈的限制是不能超过十条。在小程序中页面的路由是小程序框架本身控制的我们不要去手动管理， 小程序框架通过一个页面栈的设计来管理所有的界面，当发生路由跳转时，页面栈就会做出相应的变化，在小程序页面中通过 getCurrentPages() 就可以获取到当前的页面栈。举个栗子： 在父页面中先获取页面栈：const page = getCurrentPages(); // 父页面\r\nconsole.log('父页面', page); //父页面\r\n复制代码通过wx.navigateTo跳转子页面，在子页面中再获取页面栈：const page = getCurrentPages(); // 子页面\r\nconsole.log('子页面', page); //子页面\r\n复制代码输出：通过上面的例子可以看到，我们可以在页面中通过 getCurrentPages() 方法来获取当前页面栈，并且获取到的是一个数组，其中每个item都是每个页面的Page对象（也就是在页面中的this对象），由此我们引发一些思考……路由跳转时页面栈表现？当发生路由切换的时候，页面栈的表现如下： 当发生路由切换的时候，页面栈的表现如下：情景页面栈表现对应路由跳转API小程序初始化新页面入栈打开新页面新页面入栈wx.navigateTo 或使用组件页面重定向当前页面出栈，新页面入栈wx.redirectTo 或使用组件页面返回页面不断出栈，直到目标页wx.navigateBack 或使用组件或用户按左上角返回按钮Tab 切换页面全部出栈，只留下新的 Tab 页面wx.switchTab 或使用组件 或用户切换 Tab重加载页面全部出栈，只留下新的页面wx.reLaunch 或使用组件我们在做项目的时候，巧妙运用路由跳转和页面栈会节省很多代码，用户体验也会得到相应的提升，所以，在开始项目之前，定好页面跳转规则相当重要。页面栈的实际运用分析下面我们分析一下页面栈的变化过程，从分析中，我们需要明白的一个重要问题就是，当客户按返回按钮的时候究竟会跳转到那个界面，这是我们分析页面栈变化的的意义。 首先我们在页面中调用两次navigateTo，页面栈情况如下这时显示的界面是pageC ，如果客户在此时返回则会一切正常，回退的第一个界面是pageB，然后是pageA。但是如果在pageC 界面调用 wx.redirectTo({url:'pageD'}) 则情况就会不一样，我们先看一下跳转到pageD后页面栈的情况如何。根据栈的情况，我们可以分析出。如果使用 wx.redirectTo跳转到pageD页面，然后在回退的时候是不能再次回退到pageC的，而会直接回退到pageB。 通过上面对页面栈的分析，我们可以看到栈的变化是会影响客户回退页面的顺序的，所以根据自己的需求合理的使用不同的跳转方法是非常重要的。如果使用不当就会导致跳转混乱让人摸不清头脑 下面分析一种调转重复页面的情况：如图所示栈中出现了两个相同的pageB界面，这个时候如果用户按退出键就会出现一个页面出现2次的情况，而且有一个界面的数据也是旧的数据。因此为了避免这个问题，我们应该在 PageC 页面避免将 PageB重复压入栈中，所以在pageC页面使用wx.navigateBack({delta:1}); 进行页面回退。而数据刷新的问题则在页面的onShow函数中进行即可。情景：确认订单页用户点击左上角返回假设场景：用户在商品详情页直接点击“立即购买”下单购买，进入确认订单页，付款成功后跳转到付款成功页面，此时用户点击左上角箭头进行了返回…… 处理：此时理应进入商品详情页，所以在确认订单页付款成功跳转时应当将确认订单页出栈，新页面入栈，那么就不可以使用wx.navigateTo来进行页面跳转，应当使用wx.redirectTo情景：确认订单页用户选择已有收货人假设场景：在确认订单页，用户需要选择已有的收货人，而已有收货人列表在另一个页面，那么用户点击“选择收货人”之后，使用wx.navigateTo跳转到收货人列表，点击某个收货人，带参数返回确认订单页…… 处理：在确认订单页使用wx.navigateTo跳转到收货人列表，然后在收货人列表里click事件中获取页面栈，直接往上一个页面setData，然后退回上一个页面，show code：const page = getCurrentPages()\r\nif (page.length > 1) {\r\n  page[page.length - 2].setData({\r\n    收货人: 选中的某个收货人详情   //[object]\r\n  })\r\n  wx.navigateBack({\r\n    delta: 1\r\n  })\r\n}\r\n复制代码上面例子中提到过，在页面中通过 getCurrentPages() 方法来获取当前页面栈，并且获取到的是一个数组，其中每个item都是每个页面的Page对象，那么我们就可以使用 setData 方法直接改变上一个页面展示的数据，并且直接退回上一个页面。此时官方提醒：虽然这种方法简便，但是官方也给出提醒，页面栈数据可以自行修改，但是！一定要慎重，否则会导致页面状态错误。总结： 总觉得漏了点啥，又想不起来…… 官方文档应有尽有，多研究官方文档，多引发思考并手写demo尝试，总会有一些新的发现，另外，方法千万条，随便选一条，根据自己业务逻辑选用合适的方法。"}
{"title": "一步一步踩坑实现微信小程序自动预览 ", "author": "Rolan", "pub_time": "2019-8-6 00:14", "content": "在最近的工作中，主要做的是C端的小程序，在开发过程中倒是还好，一到改BUG的时候，可能就会进入保存，编译，自动预览的循环了，虽然微信已经提供了快简介自动预览，但是总归是一个手动的过程，要是能监听文件变化自动预览不是更好吗？查看文档于是我就去看了下文档，发现微信已经提供了这个API，可以用命令行调用，也可以用HTTP调用。一开始本着配置少一点的原则，我选择了HTTP调用，因为命令行调用需要配置微信开发者工具的安装目录，而HTTP调用可以通过微信指定的路径获取端口号（实践证明，too young, too simple， 认真你就输了，\tHTTP调用的问题太多，所以我后来又改成了命令行调用 ）。然后就去官方所指示的ide文件夹找端口号了，结果并没有发现那个文件。怎么回事呢？一顿搜索之后，才知道目前的版本需要如下才能开启http服务：\t微信开发者工具 -> 查看所有项目 -> 设置 -> 安全 ，里面有个服务端口，选择开启以后就能找到ide文件，进而得到端口号进行后续操作了。前置工作commander ，主要是从命令行读取参数，实现动态配置，方便调用。chalk 控制台输出格式多样化。axios 用于发起http请求。package.json中的bin 字段，用于实现自定义命令。路径区分，\tprocess.cwd()执行命令时所在的目录，__dirname执行文件所在的目录。 导入配置文件主要是用前者。使用\tfs.watch 进行目录和文件的监听，在文件变动后调用自动预览读取端口号文档中提到 端口号文件位置：macOS : ~/Library/Application Support/微信开发者工具/Default/.ide Windows : ~/AppData/Local/微信开发者工具/User Data/Default/.ide既然路径有了，那么就好说了，只要\t获取到用户目录，然后再拼接上不同平台的后续路径，那么通过读取.ide文件就可以得到端口号了 。代码如下:const fs = require(\"fs\");\r\nconst os = require(\"os\");\r\nconst isWin = os.platform() === `win32`;\r\n\r\nfunction getHttpPort() {\r\n  const home = os.homedir();\r\n  const suffix = isWin\r\n    ? `/AppData/Local/微信开发者工具/User Data/Default/.ide`\r\n    : `/Library/Application Support/微信开发者工具/Default/.ide`;\r\n  const idePath = home + suffix;\r\n\r\n  const port = fs.readFileSync(idePath, { encoding: \"utf8\" });\r\n\r\n  return port;\r\n}\r\n复制代码打开工具或指定项目HTTP调用实例：# 打开工具\r\nhttp://127.0.0.1:端口号/open\r\n# 打开/刷新项目\r\nhttp://127.0.0.1:端口号/open?projectpath=项目全路径\r\n复制代码先在浏览器中直接进行访问，很好，你会发现\t微信开发者工具并没有打开 ，再仔细看了下文档，用法肯定没错的，总共就端口号和项目路径两个变量，怎么可能会出错呢？被某厂坑久了，就知道有问题是必然的。算了，打不开就打不开吧，影响并不是很大，反正平时开发的时候，开发者工具都是打开的。这个问题呢，我猜测是因为\t工具每次打开端口号都会变化 ，而读取的端口号是之前的，所以就没用了。命令行调用-o, --open [projectpath]: 打开工具，如果不带 projectpath，只是打开工具。如果带 project path，则打开路径中的项目，每次执行都会自动编译刷新，并且自动打开模拟器和调试器。projectpath 不能是相对路径。项目路径中必须含正确格式的 project.config.json 且其中有 appid 和 projectname 字段。调用：cli -o /Users/username/demo\r\n复制代码这次的调用完全没有问题的。自动预览HTTP调用接口定义：URL：/autopreviewHTTP 方法：GETURL 参数必填说明projectpath是指定路径中的项目。如项目已打开，自动刷新项目。如项目未创建，自动创建并自动预览项目infooutput否指定后，会将本次自动预览的额外信息以 json 格式输出至指定路径，如代码包大小、分包大小信息。compilecondition否指定自定义编译条件，值为 json 字符串，条件可指定两个字段，pathName 表示打开的页面，不填表示首页，query 表示页面参数这个接口请求以后，倒是可以用，但是坑也不小。infooutput 这个参数我写了，却并没有生成相应的文件。compilecondition 这个参数其实是我从预览那个接口凑过来的，官方文档只有2个参数 。本来我也没想到这个参数的，但是没办法，我们的项目首页是pages/home/index，自动预览以后可能是没找到pages/index/index这种默认的首页，然后就随便跳了一个？文档总是缺三少四的，这里一块那里一块，稍微看漏一点这个功能可能就出不来了，说到底看文档就是得仔细。命令行调用自动预览必须处于登录状态，如果没有登录，会提示需先登录。--auto-preview <project_root> : 自动预览代码，project_root 指定项目根路径。--auto-preview-info-output <path> : 指定后，会将本次预览的额外信息以 json 格式输出至指定路径，如代码包大小、分包大小信息。官方文档只介绍了这两个参数，还是像之前一样，从预览那个的调用凑一下吧。--compile-condition '<json>' : 指定自定义编译条件，json 条件可指定两个字段，pathName 表示打开的页面，不填表示首页，query 表示页面参数用命令行测试：cli --auto-preview /Users/username/demo --compile-condition {\\\"pathName\\\": \\\"pages/home/index\\\",\\\"query\\\":\\\"a=1\\\"}\r\n复制代码大坑命令行调用的时候编译条件应该是调用\tJSON.stringify(obj).replace(/\\\"/g, `\\\\\"`) 所获得的字符串，\t注意要把\"换成\\\"，且前后不需要单引号 ，文档里面那种调用方式会报错，不信的小伙伴可以自己尝试。查询参数query只能有一个参数 ，如果用&链接多个参数的话，提示信息是成功，但是手机并没有自动预览，害得我还纳闷了好久。这个问题必须得给官方反应一下，太影响使用了。node脚本编写思路辅助函数// 将D:\\\\www\\\\soft转换成D:/www/soft这种形式\r\n// msg为路径不存在时的报错信息\r\nfunction getPath(projectpath, msg) {\r\n  if (!projectpath) {\r\n    throw new Error(msg);\r\n  }\r\n  return projectpath.split(path.sep).join(`/`);\r\n}\r\n\r\n// 获取打包路径\r\nfunction getDist(config = {}) {\r\n  const { projectpath } = config;\r\n  return (\r\n    config.dist ||\r\n    (/dist\\/?$/.test(projectpath) ? projectpath : (projectpath || \"\") + `/dist`)\r\n  );\r\n}\r\n\r\n// 将exec转为promise类型的函数，方便使用async await\r\nconst promisify = require(\"util\").promisify;\r\nlet { exec } = require(\"child_process\");\r\nexec = promisify(exec);\r\n复制代码这里介绍一下execchild_process.exec(command[, options][, callback])\r\n复制代码参数类型说明commandstringThe command to run, with space-separated arguments. (需要运行的命令，参数用空格分开)optionsobject{ cwd: \"子进程工作目录，默认为null\", }\t其他参数我没怎么用过callback否回调函数: (error: Error, stdout: string | Buffer, stderr: string | Buffer）spawn和exec的却别在于，spawn的输出是实时的，而exec是执行完之后统一返回。前者还得监听事件略显麻烦，所以我选择了exec。open.jsasync function open({ projectpath, cli, }) {\r\n  return new Promise(async (resolve, reject) => {\r\n    log();\r\n    log(chalk.green(`打开开发者工具中...`));\r\n    const result = await exec(\r\n      `cli -o ${projectpath}`,\r\n      {\r\n        cwd: cli\r\n      }\r\n    );\r\n\r\n    const isSuccess = result.stdout;\r\n    log(isSuccess ? chalk.green(`打开成功`) : chalk.red(`打开失败`));\r\n    isSuccess ? resolve() : reject();\r\n  })\r\n}\r\n复制代码preview.jsasync function preview(config) {\r\n  await open(config);\r\n\r\n  const port = getHttpPort();\r\n  const { dist, projectpath, time, compile, cli } = config;\r\n\r\n  log();\r\n  log(chalk.blue(`开始监听文件变动`));\r\n  log(`路径参数: `, compile);\r\n\r\n  fs.watch(\r\n    dist,\r\n    debounce(async (evt, filename) => {\r\n      log();\r\n      console.log(`${filename} ${evt}`);\r\n\r\n      log(chalk.green(`自动预览重启中...`));\r\n      log(\r\n        `执行命令： cli --auto-preview ${projectpath} --compile-condition ${compile}`\r\n      );\r\n      const result = await exec(\r\n        `cli --auto-preview ${projectpath} --compile-condition ${compile}`,\r\n        {\r\n          cwd: cli\r\n        }\r\n      );\r\n\r\n      const isSuccess = result.stdout;\r\n      log(isSuccess ? chalk.green(`自动预览成功`) : chalk.red(`自动预览失败`));\r\n    }, time || 1000)\r\n  );\r\n}\r\n复制代码lib/index.jsconst fn = {\r\n  preview,\r\n  upload,\r\n};\r\n\r\nfunction run(config, type) {\r\n  if (!fn[type]) {\r\n    throw new Error(`type参数不合法，请确保为preview, upload的一种`);\r\n  }\r\n\r\n  log(chalk.green(`本次启动类型为: ${type}`));\r\n  fn[type](config);\r\n}\r\n复制代码config参数从命令行参数中读取文件获得，type参数为命令行参数。bin/index.js#! /usr/bin/env node\r\nconst run = require(\"../lib/index\");\r\nconst program = require(\"commander\");\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst { getPath, getHttpPort, getDist } = require(\"../util/index\");\r\n\r\nprogram\r\n  .option(\"-c, --config <type>\", \"config file\", \"auto.js\")\r\n  .option(\"-t, --type <type>\", \"auto type, etc: preview, upload\", \"preview\")\r\n  .parse(process.argv);\r\n\r\n// 获取执行命令时所在的目录，拼接上配置文件目录，使用require(ConfigFile)即可获得相关配置\r\nconst CD = process.cwd();\r\nconst Config = program.config;\r\nconst ConfigFile = path.join(CD, Config);\r\n\r\nconst defaultCompile = {\r\n  pathName: `pages/home/index`\r\n};\r\n\r\n// 判断配置文件不存在，则直接报错\r\nif (!fs.existsSync(ConfigFile)) {\r\n  throw new Error(`[ERROR]: ${Config} not found in ${CD}`);\r\n} else {\r\n  start();\r\n}\r\n\r\nfunction start() {\r\n  let config = require(ConfigFile);\r\n  config = { ...config };\r\n  config.projectpath = getPath(\r\n    config.projectpath,\r\n    `配置文件中projectPath字段必须有值`\r\n  );\r\n  const projectpath = config.projectpath;\r\n  config.dist = getDist(config);\r\n  config.compile = JSON.stringify(config.compile || defaultCompile).replace(\r\n    /\\\"/g,\r\n    `\\\\\"`\r\n  );\r\n  // 这里可写可不写，打开工具后会进行再次获取\r\n  config.port = getHttpPort();\r\n\r\n  run(config, program.type);\r\n}\r\n复制代码至此，该功能已经大致完成了，我已经上传到了npm，可以直接进行使用。wx-auto微信开发者工具，HTTP调用，自动预览，提高工作效率局部安装npm i wx-auto -D 或者 yarn add wx-auto -D\r\n复制代码全局安装npm i wx-auto -g \r\n复制代码使用方法wxauto\r\n或者\r\nwxauto -t preview -c auto.js\r\n复制代码参数(均有默认值)-t, --type 类型，目前支持preview和upload\r\n-c, --config 配置文件名，默认值为auto.js\r\n复制代码文件路径为相对路径，相对于执行命令时所在的路径配置文件{\r\n  cli: \"D:/soft/微信web开发者工具\", // cli文件所在的目录\r\n  projectpath: `D:/www/react/heywoof-app-frontend`, // 项目地址\r\n  compile: {\r\n    pathName: `pages/scene/index`, // 自动预览的页面路径\r\n    query: `activityId=5d45050569515b000c5b740a` // 查询参数，微信目前有BUG，只能识别一个参数\r\n  },\r\n  build: `yarn build-test:weapp`, // 上传之前需要执行的命令\r\n  upload: {\r\n    version: \"1.0.1\",\r\n    desc: \"测试自动上传，不要乱动\"\r\n  }\r\n};\r\n复制代码此外还包含了自动打包上传的功能，配置之后执行\twxauto -t upload -c auto.js ，上传完毕后就会自动打开微信公众平台登录的网站，个人感觉还是挺实用的。自动化测试在查看文档的时候，我发现微信官方推出了一个\t多端统一开发工具——kbone ，这个是基于vue的，就是配置略显麻烦。除此之外，微信小程序现在已经支持自动化测试了，感兴趣的小伙伴可以自行尝试。注意：\t该功能需要最新版本支持 ，一定要符合文档所说的版本，我简单尝试了一下，自动化是可以实现的，更具体的测试就得看工作需要了。"}
{"title": "小程序在线答题系统设计 ", "author": "Rolan", "pub_time": "2019-8-6 00:58", "content": "前言帮一个可爱的小姐姐改一个uni-app构建的微信小程序时，在使用textarea组件时遇到的一点小问题。描述问题：在uni-app中,<textarea>的auto-hetght属性会出现高度不够，文字能够上下移动的问题,具体见下图:当输入的文字过多时,textarea内的文字可以上下滚动。 这不属于产品的需求，产品要的是输入框高度随着文字的变化而变化不能出现滚动条，而在uni-app打包的微信小程序中却出现了滚动解决思路排查原生微信小程序中是否有该问题 在微信小程序原生语法中尝试使用该组件：    <textarea placeholder=\"sxx是猪\" class=\"textarea\" auto-height=\"true\"></textarea>\r\nHTML.textarea{\r\n  margin-top: 80rpx;\r\n  width: 80vw;\r\n  border: 1rpx solid red;\r\n  min-height: 100rpx;\r\n  font-size: 20px\r\n}\r\nCSS发现在原生微信小程序语法中,使用auto-height属性，输入框高度会随着文字的增加而增加。在uni-app中新建项目，打包编译至微信小程序开发工具查看效果<textarea auto-height=\"true\" placeholder=\"sxx是猪\" class=\"textarea\"></textarea>\r\nHTML.textarea {\r\n        margin-top: 80upx;\r\n        width: 80vw;\r\n        border: 1rpx solid red;\r\n        min-height: 100upx;\r\n        font-size: 20px\r\n    }\r\nCSS跟在微信原生语法中写的一模一样，却产生了不同的效果。说明是uni-app编译的小程序会出现这个bug进一步排查，查看小程序工具中调试工具Wxml下的Dom以及style初始没有输入文本的时候，微信小程序的textarea有一个height:22.5px的行内样式而在uni-app(以下简称uni-app)编译的小程序下面，初始的高度只有17px输入一段相同的文本之后进行比较：sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪sxx是猪微信小程序uni-app输入相同的内容，微信小程序高度为73px,uni-app高度也为73px,但是uni-app文本的字体高度却大于微信小程序的文本行高，所以会出现滚动尝试修改uni-app的行高.textarea {\r\n        margin-top: 80upx;\r\n        width: 80vw;\r\n        border: 1rpx solid red;\r\n        min-height: 100upx;\r\n        font-size: 20px;\r\n        line-height: 20px;\r\n    }\r\nCSS运行之后，解决问题！！原理观察得知，微信小程序中由于输入框中文字比较紧凑，uni-app中文字比较稀疏。故猜测可能是行高将文字的整体高度撑起，大于了输入框的可视区域。所uni-app中出现了滚动的效果。所以，修改uni-app的输入框中文本的行高即可解决该问题。关于文章首发于:uni-app textarea auto-hetght 文字出现上下滚动本文采用 CC BY-NC-SA 3.0 Unported 协议进行许可本文链接： https://www.ahwgs.cn/uni-app-textarea-auto-hetght.html"}
{"title": "微信小程序预加载图片以及占位图片 ", "author": "Rolan", "pub_time": "2019-8-7 00:11", "content": "wxml页面利用三目运算：代码如下： 1 <image src=\"{{ima?ima:'../../images/4.jpg'}}\" /> （../../images/4.jpg）这里意思是预加载图片大概是一张黑白色的类似于js代码如下：Page({/*** 页面的初始数据*/data: {ima: \"\",},/*** 生命周期函数--监听页面加载*/internet:function(){  setTimeout(function(){    this.setData({  /*setData*/是为了模拟服务器传输的数据     ima:'http://pic4.nipic.com/20091217/3885730_124701000519_2.jpg',     })   }.bind(this),2000);},onLoad: function (options) {this.internet（）/*调用*/},// app.YoniClient.request(app.Func.LOGIN,)/*** 生命周期函数--监听页面初次渲染完成*/onReady: function () {},/*** 生命周期函数--监听页面显示*/onShow: function () {},/*** 生命周期函数--监听页面隐藏*/onHide: function () {},/*** 生命周期函数--监听页面卸载*/onUnload: function () {},/*** 页面相关事件处理函数--监听用户下拉动作*/onPullDownRefresh: function () {},/*** 页面上拉触底事件的处理函数*/onReachBottom: function () {},/*** 用户点击右上角分享*/onShareAppMessage: function () {}})那么如果是以数组形式的话也非常简单：wxml代码<image src='{{item.images?item.images:\"../../../images/sketch_169_102.jpg\"}}' class='news_list_img' mode='widthFix'></image>因为数组的话要用到参数item可能其他js代码如下：Page({  /**   * 页面的初始数据   */  data: {    items: [{      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月20日\",      images: '',    }, {      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月22日\",      images: '',    }],    ite: [{      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月20日\",      images: \"http://img2.niutuku.com/desk/1208/1401/ntk-1401-8806.jpg\",    }, {      title: \"第一届少儿足球比赛\",      txt: \"第一届郑州足球比赛开幕式z乒启动计划\",      time: \"2017年11月22日\",      images: \"http://img2.niutuku.com/desk/1208/1401/ntk-1401-8806.jpg\",    }]  },/**   * 生命周期函数--监听页面加载   */  internet: function () {    let ite = this.data.ite;    setTimeout(function () {      this.setData({        items: ite,      })    }.bind(this), 2000);  },  onLoad: function (options) {this.internet()  },  /**   * 生命周期函数--监听页面初次渲染完成   */  onReady: function () {  },  /**   * 生命周期函数--监听页面显示   */  onShow: function () {  },  /**   * 生命周期函数--监听页面隐藏   */  onHide: function () {  },  /**   * 生命周期函数--监听页面卸载   */  onUnload: function () {  },  /**   * 页面相关事件处理函数--监听用户下拉动作   */  onPullDownRefresh: function () {  },  /**   * 页面上拉触底事件的处理函数   */  onReachBottom: function () {  },  /**   * 用户点击右上角分享   */  onShareAppMessage: function () {  }})setData是为了实例化数据目的为了能够放在页面将ite模拟数据赋值给定义的ite（名字随便定义）既然是数据就会有data，bind的目的是为了捆绑，后面的数字是时间间隔多少秒显示要加载出来的数据。"}
{"title": "小程序页面通信、数据刷新、事件总线 、event bus 终极解决方案之 iny-bus ... ", "author": "Rolan", "pub_time": "2019-8-6 00:48", "content": "背景介绍\r\n在各种小程序中，我们经常会遇到 这种情况\r\n有一个 列表，点击列表中的一项进入详情，详情有个按钮，删除了这一项，这个时候当用户返回到列表页时,\r\n发现列表中的这一项依然存在，这种情况，就是一个 `bug`，也就是数据不同步问题，这个时候测试小姐姐\r\n肯定会找你，让你解决，这个时候，你也许会很快速的解决，但过一会儿，测试小姐姐又来找你说，我打开了\r\n四五个页面更改了用户状态，但我一层一层返回到首页，发现有好几个页面数据没有刷新，也是一个 bug，\r\n这个时候你就犯愁了，怎么解决，常规方法有下面几种\r\n复制代码\r\n解决方法\r\n  1. 将所有请求放到 生命周期 `onShow` 中，只要我们页面重新显示，就会重新请求，数据也会刷新\r\n  2. 通过用 `getCurrentPages` 获取页面栈，然后找到对应的 页面实例，调用实例方法，去刷新数据\r\n  3. 通过设置一个全局变量，例如 App.globalData.xxx，通过改变这个变量的值，然后在对应 onShow \r\n  \t 中检查，如果值已改变，刷新数据\r\n  4. 在打开详情页时，使用 redirectTo 而不是 navigateTo，这样在打开新的页面时，会销毁当前页面，\r\n     返回时就不会回到这个里面，自然也不会有数据不同步问题\r\n复制代码\r\n存在的问题\r\n1. 假如我们将 所有 请求放到 onShow 生命周期中，自然能解决所有数据刷新问题，但是 onShow \r\n  这个生命周期，有两个问题\r\n  \r\n  第一个问题，它其实是在 onLoad 后面执行的，也就是说，假如请求耗时相同，从它发起请求到页面渲染，\r\n  会比 onLoad 慢\r\n  \r\n  第二个问题，那就是页面隐藏、调用微信分享、锁频等等都会触发执行，请求放置于 `onShow` 中就会造成\r\n  大量不需要的请求，造成服务器压力，多余的资源浪费、也会造成用户体验不好的问题\r\n\r\n2. 通过 `getCurrentPages` 获取页面栈，然后找到对应的 页面实例，调用实例方法，去刷新数据，这也\r\n不失为一个办法，但是就如微信官方文档所说\r\n\r\n  > 不要尝试修改页面栈，会导致路由以及页面状态错误。\r\n  > 不要在 App.onLaunch 的时候调用 `getCurrentPages()`，此时 page 还没有生成。\r\n\r\n  同时、当需要通信的页面有两个、三个、多个呢，这里去使用 `getCurrentPages` 就会比较困难、繁琐\r\n\r\n3. 通过设置全局变量的方法，当需要使用的地方比较少时，可以接受，当使用的地方多的时候，维护起来\r\n就会很困难，代码过于臃肿，也会有很多问题\r\n\r\n4. 使用 redirectTo 而不是 navigateTo，从用来体验来说，很糟糕，并且只存在一个页面，对于\r\ntab 页面，它也无能为力，不推荐使用\r\n复制代码\r\n最佳实践\r\n在 Vue 中， 可以通过 new Vue() 来实现一个 event bus作为事件总线，来达到事件通知的功能，在各大\r\n框架中，也有自身的事件机制实现，那么我们完全可以通过同样的方法，实现一个事件中心，来管理我们的事件，\r\n同时，解决我们的问题。iny-bus 就是这样一个及其轻量的事件库,使用 typescript 编写，100% 测试覆\r\n盖率，能运行 js 的环境，就能使用\r\n复制代码\r\n传送门\r\n源码\r\nNPM\r\n文档\r\n简单使用\r\niny-bus 使用及其简单，在需要的页面 onLoad 中添加事件监听， 在需要触发事件的地方派发事件，使监\r\n听该事件的每个页面执行处理函数，达到通信和刷新数据的目的，在小程序中的使用可以参考以下代码\r\n复制代码\r\n\r\n  // 小程序\r\n  import bus from 'iny-bus'\r\n\r\n  // 添加事件监听\r\n  // 在 onLoad 中注册, 避免在 onShow 中使用\r\n  onLoad () {\r\n    this.eventId = bus.on('事件名', (a, b, c, d) => {\r\n      // 支持多参数\r\n      console.log(a, b, c, d)\r\n\r\n      this.setData({\r\n        a,\r\n        b,\r\n        c\r\n      }\r\n      // 调用页面请求函数，刷新数据\r\n      this.refreshPageData()\r\n    })\r\n\r\n    // 添加只需要执行一次的 事件监听\r\n\r\n    this.eventIdOnce = bus.once('事件名', () => {\r\n      // do some thing\r\n    })\r\n  }\r\n\r\n  // 移除事件监听，该函数有两个参数，第二个事件id不传，会移除整个事件监听，传入ID，会移除该\r\n  页面的事件监听，避免多余资源浪费, 在添加事件监/// 听后，页面卸载(onUnload)时建议移除\r\n\r\n  onUnload () {\r\n    bus.remove('事件名', this.eventId)\r\n  }\r\n\r\n  // 派发事件，触发事件监听处更新视图\r\n  // 支持多参传递\r\n  onClick () {\r\n    bus.emit('事件名', a, b, c)\r\n  }\r\n\r\n复制代码更详细的使用和例子可以参考 Github iny-bus 小程序代码\r\niny-bus 具体实现\r\n\r\niny-bus 我们是使用 typescript 编写，同时要发布到 npm 上供大家使用，那我们就需要搭建开发环境，选择编辑打包工具，编写发布脚本，具体的细节这里不讲，只列举以下使用到的工具和库\r\n\r\n\r\n\r\n基本打包工具，这里使用非常优秀的开源库 typescript-library-starter，具体细节不展开\r\n\r\n\r\n测试工具 使用 facebook 的 jest\r\n\r\n\r\nbuild ci 使用 [travis-ci](www.travis-ci.org/）\r\n\r\n\r\n测试覆盖率上传使用 codecov\r\n\r\n\r\n具体的其他细节大家可以看源码中的 package.json，这里就一一展开讲了，我们来看具体实现\r\n\r\n\r\n\r\n具体实现\r\n\r\n\r\n首先，我们来设计我们的事件中心，iny-bus 作为事件中心，我们就需要一个容器来储存我们的事件，同时我们不希望，使用者可以直接访我们的容器，所以我们就需要私有化,例如这样\r\n\r\n\r\n\r\n\r\n  class EventBus {\r\n\r\n    private events: any[] = []\r\n\r\n  }\r\n\r\n复制代码\r\n然后，我们的事件中心希望拥有那些能力呢，比如说事件监听 on，监听了就需要派发 emit, 也就需要移除 remove,移除就需要查找，我们也需要一次性事件，比如说 once，大概是这样子\r\n\r\n\r\n  interface EventBus {\r\n\r\n    // 监听，我们需要知道一个事件名字，也需要一个 派发时的执行函数，同时，我们返回一个\r\n    // id 给使用者，方便使用者移除 事件监听\r\n    on(name: string, execute: Function): string\r\n\r\n    // once 和 on在使用创建和使用时，没什么区别，唯一的区别就在 执行一次后移除，所以在\r\n    // 创建时 和 on 没有任何区别\r\n    once(name: string, execute: Function): string\r\n\r\n    // remove, 前面提到了我们需要删除事件监听，那我们就需要 事件名称，为了多个页面可以监\r\n    // 听同一个事件，所以我们不能一次性把该事件监听全部移除\r\n    // 那么我们就用到 创建 事件时的 id 了, 同时，我们返回 我们的事件中心，可以链式调用\r\n    remove(name: string, eventId?: string): EventBus\r\n\r\n    // emit 我们需要告诉系统，我们需要派发的事件名和所携带的参数，同时返回 事件实例\r\n    emit(name: string, ...args: any[]): EventBus\r\n\r\n    // find 函数返回一个联合类型，有可能存在 该事件，也有可能返回 null\r\n    find(name: string): Event | null\r\n\r\n  }\r\n\r\n复制代码\r\n上面我们大概设计好我们的事件中心了，这个时候，我们需要明确，我们的每一个事件所拥有的能力和属性\r\n\r\n\r\n  // 每一个东西，都有一个名字，方便记忆和寻找，我们的事件\r\n  // 也需要一个 name，同时，我们的每一个事件，都有可能被监听 n 次，那么我们就需要\r\n  // 每个事件来有一个容器，存放每个事件的执行者\r\n\r\n  interface Event {\r\n\r\n    // 名称\r\n    name: string\r\n\r\n    // 执行者容器\r\n    executes: Execute[]\r\n  }\r\n\r\n  // 我们也需要确定每个执行者的类型，为了能精确的找到执行者，所以需要一个 id，这也是 用来\r\n  // 删除的id， 这里的 eventType 是来标示是否是一次性执行者， execute 则为每个执行者\r\n  // 的执行函数\r\n  interface Execute {\r\n    id: string\r\n    eventType: EventType\r\n    execute: Function\r\n  }\r\n\r\n复制代码\r\n在上面，我们提到了 eventType，这是为了标示是否为 一次性执行者，在 typescript 中，没有比 枚举 更适合这种情况了\r\n\r\n\r\n// 申明事件执行者的类型\r\n\r\ntype EventType = 1 | 2\r\n\r\n\r\nenum EventTypeEnum {\r\n  // 普通事件\r\n  NORMAL_EVENT = 1,\r\n  // 一次性事件\r\n  ONCE_EVENT = 2\r\n}\r\n\r\n复制代码\r\n基本的类型是定义完了，我们来写具体实现的代码，第一步，实现 on once 方法\r\n\r\n\r\n  \r\n  class EventBus {\r\n\r\n    /**\r\n    * 储存事件的容器\r\n    */\r\n    private events: Event[] = []\r\n\r\n    /**\r\n    * on 新增事件监听\r\n    * @param name 事件名\r\n    * @param execute 回调函数\r\n    * @returns { string } eventId 事件ID，用户取消该事件监听\r\n    */\r\n\r\n\r\n    on(name: string, execute: Function): string {\r\n      \r\n      // 因为 on 和 once 在新建上没什么区别，所以这里我们统一使用 addEvent, 但为了区分 on 和 once，我们传入了 EventType\r\n      return this.addEvent(name, EventTypeEnum.NORMAL_EVENT, execute)\r\n    }\r\n\r\n    /**\r\n    * one 只允许添加一次事件监听\r\n    * @param name 事件名\r\n    * @param execute 回调函数\r\n    * @returns { string } eventId 事件ID，用户取消该事件监听\r\n    */\r\n\r\n    once(name: string, execute: Function): string {\r\n      // 同理 on\r\n      return this.addEvent(name, EventTypeEnum.ONCE_EVENT, execute)\r\n    }\r\n\r\n  }\r\n\r\n\r\n复制代码\r\n实现 addEvent 方法\r\n\r\n\r\n  class EventBus {\r\n\r\n    /**\r\n     * 添加事件的方法\r\n    * @param name\r\n    * @param execute\r\n    */\r\n\r\n    private addEvent(name: string, eventType: EventType, execute: Function): string {\r\n      const eventId = createUid()\r\n\r\n      const events = this.events\r\n\r\n      const event = this.find(name)\r\n\r\n      if (event !== null) {\r\n        event.executes.push({ id: eventId, eventType, execute })\r\n\r\n        return eventId\r\n      }\r\n\r\n      events.push({\r\n        name,\r\n        executes: [\r\n          {\r\n            id: eventId,\r\n            eventType,\r\n            execute\r\n          }\r\n        ]\r\n      })\r\n\r\n      return eventId\r\n    }\r\n\r\n  }\r\n\r\n复制代码\r\n实现 find 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * 查找事件的方法\r\n    * @param name\r\n    */\r\n\r\n    find(name: string): Event | null {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (name === events[i].name) {\r\n          return events[i]\r\n        }\r\n      }\r\n\r\n      return null\r\n    }\r\n  }\r\n\r\n复制代码\r\n实现 remove 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * remove 移除事件监听\r\n    * @param name 事件名\r\n    * @param eventId 移除单个事件监听需传入\r\n    * @returns { EventBus } EventBus EventBus 实例\r\n    */\r\n\r\n    remove(name: string, eventId: string): EventBus {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (events[i].name === name) {\r\n          // 移除具体的操作函数\r\n          if (eventId && events[i].executes.length > 0) {\r\n            const eventIndex = events[i].executes.findIndex(item => item.id === eventId)\r\n\r\n            if (eventIndex !== -1) {\r\n              events[i].executes.splice(eventIndex, 1)\r\n            }\r\n          } else {\r\n            events.splice(i, 1)\r\n          }\r\n\r\n          return this\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n复制代码\r\n实现 emit 方法\r\n\r\n\r\n  class EventBus {\r\n    /**\r\n     * emit 派发事件\r\n    * @param name 事件名\r\n    * @param args 其余参数\r\n    * @returns { EventBus } EventBus EventBus 实例\r\n    */\r\n\r\n    emit(name: string, ...args: any[]): EventBus {\r\n      const events = this.events\r\n\r\n      for (let i = 0; i < events.length; i++) {\r\n        if (name === events[i].name) {\r\n          const funcs = events[i].executes\r\n\r\n          funcs.forEach((item, i) => {\r\n            item.execute(...args)\r\n\r\n            if (item.eventType === EventTypeEnum.ONCE_EVENT) {\r\n              funcs.splice(i, 1)\r\n            }\r\n          })\r\n\r\n          return this\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n复制代码\r\n作为一个事件中心，为了避免使用者错误使用，创建多个实例，我们可以使用 工厂模式，创建一个全局实例供使用者使用，同时提供使用者一个方法，创建新的实例\r\n\r\n\r\n  // 不直接 new EventBus， 而是通过 一个工厂函数来创建实例, 参考 axios 源码\r\n  function createInstance (): EventBusInstance {\r\n\r\n    const bus = new EventBus()\r\n\r\n    return bus as EventBusInstance\r\n  }\r\n\r\n  const bus = createInstance()\r\n\r\n  // 扩展 create 方法，用于 使用者 创建新的 bus 实例\r\n  bus.create = function create () {\r\n    return createInstance()\r\n  }\r\n复制代码总结\r\niny-bus 的核心代码，其实就这么多，总的来说，非常少，但是能解决我们在小程序中遇到的大量 通信 和 数据刷新问题，是采用 各大平台小程序 原生开发时，页面通信的不二之选，同时，100% 的测试覆盖率，确保了 iny-bus 在使用中的稳定性和安全性，当然，每个库都是从简单走向复杂，功能慢慢完善，如果\r\n大家在使用或者源码中发现了bug或者可以优化的点，欢迎大家提 pr 或者直接联系我\r\n最后，如果 iny-bus 给你提供了帮助或者让你有任何收获，请给 作者 点个赞，感谢大家 点赞"}
{"title": "微信小程序七夕节礼物 ", "author": "Rolan", "pub_time": "2019-8-7 00:09", "content": "VSCode Node.js HbuilderX安装前端开发环境npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g lessHBuilderX是国内最优秀的前端开发工具，我们用它来开发Electron项目和小程序项目{  \"pages\": [    \"pages/index/index\"  ],  \"requiredBackgroundModes\": [    \"audio\",    \"location\"  ],  \"subPackages\": [],  \"window\": {    \"navigationBarTextStyle\": \"black\",    \"navigationBarTitleText\": \"我喜欢你\",    \"navigationBarBackgroundColor\": \"#F8F8F8\",    \"backgroundColor\": \"#F8F8F8\"  },  \"usingComponents\": {}}@import './common/main.wxss';require('./common/runtime.js')require('./common/vendor.js')require('./common/main.js').content {  padding: 0 40rpx;}.content image {  width: 100%;}.content .title {  display: block;  text-align: center;  font-size: 50rpx;  font-weight: bold;}.content .operate {  text-align: center;  margin-top: 30rpx;  margin-bottom: 30rpx;}.content .operate .btn {  width: 200rpx;  height: 80rpx;  display: inline-block;}.content .operate .btn:first-of-type {  margin-right: 40rpx;}.content .message {  font-size: 34rpx;  margin: 15rpx 0;  color: #333;}<view class=\"content\"><image src=\"../../static/g1.gif\" mode=\"widthFix\"></image><text class=\"title\">小姐姐，做我女朋友吧！</text><view class=\"operate\"><button class=\"btn\" type=\"primary\" data-event-opts=\"{{[['tap',[['agree',['$event']]]]]}}\" bindtap=\"__e\">好呀</button><button class=\"btn\" type=\"warn\" data-event-opts=\"{{[['tap',[['disagree',['$event']]]]]}}\" bindtap=\"__e\">不好</button></view><block wx:for=\"{{love}}\" wx:for-item=\"one\" wx:for-index=\"__i0__\" wx:key=\"*this\"><view class=\"message\">{{one}}</view></block></view>若本号内容有做得不到位的地方（比如：涉及版权或其他问题），请及时联系我们进行整改即可，会在第一时间进行处理。"}
{"title": "微信小程序云端解决方案探索之路 ", "author": "Rolan", "pub_time": "2019-8-7 00:58", "content": "小程序刚推出的时候，很多人都觉得它就是 H5，因为开发小程序的三大语言和 HTML、CSS、JS 是一脉相承的，即使改变了扩展名也改不了其实质。那么小程序的实质到底是不是 H5 呢？经过我们的论证分析，我们认为小程序并不是 H5 应用。主要原因如下：在小程序里面无法使用 DOM 接口，所以 HTML5 生态中一切基于 DOM 的库都无法使用（如 jQuery）小程序并非使用 URL 访问，所以没有域名的概念。这个特性有两个影响不存在跨域问题，所以访问控制是直接在微信 MP 上配置域名白名单不支持 Cookie 存储，这将导致后面我们重点研究了会话管理的实现从上面两个角度来考虑，我们认为小程序更偏向于传统的 CS 架构。那么，小程序和传统 CS 架构的区别在哪儿？主要包括下面两点：网络和续航小程序在移动端运行，网络环境会比较复杂，频繁的网络连接可能会过度消耗资源导致续航下降，所以小程序对网络和资源的优化都提出了要求。伸缩能力小程序寄托在微信平台上运行，作为一个十亿级的社交平台，业务可能会面临爆炸式的增长。如果在爆点小程序不能快速伸缩应对，那么将失去这样一个重要的机会。所以小程序对其后台架构的伸缩能力提出了比较高的要求。门槛和挑战在上面一些结论下，我们进行了一些尝试，包括上传下载、会话管理、WebSocket、视频点播等等。这次重点来分享会话管理和 WebSocket，因为我们面临的挑战主要集中在这两个案例上。会话管理我们最早开发了一个一笔到底的案例来实现会话管理，案例需要根据用户保存用户的作品，每次用户登录，都可以看到用户自己的绘画。但是，因为小程序不支持 Cookie 传输，所以会话服务需要自行实现。我们会话管理的实现目标是：完成微信要求的鉴权流程，生成用户会话利用会话确定每个请求对应哪个微信用户安全性和扩展性满足要求我们案例按照这个流程进行会话建立：其中在小程序和服务器我们分别提供 JS 和 Node SDK 来提供会话支持。这个案例完成了会话服务的功能性目标，可以提供会话建立和验证的能力。但是弊端在于，该能力只能被 Node 开发者使用，其他语言的开发者无法使用。同时，因为小程序的 appId 和 appSecret 存放在外网可以访问的服务器上，也有一定安全性问题。会话服务和我们的业务耦合在一起，也给后续的横向扩展带来了麻烦。于是，我们提出了改进的手段：会话管理服务器独立提供提供多语言的 SDKappId 和 appSecret 存放到数据库中其中多语言的 SDK 正式因为会话管理服务器的独立而可以快速开发到。优化后，会话的建立流程如下图所示：而会话的验证流程如下图所示：我们的会话服务改进取得的效果还是很明显的：流程和安全性上完全符合了微信的鉴权要求独立会话服务器，可以方便进行独立的升级和扩展，也为多语言 SDK 的开发打开了方便的大门信道服务我们面临的另外一个挑战就是 WebSocket。在进行案例分析之前，先跟大家分析一下微信支持 WebSocket 的原因。传统的 HTTPS 连接请求，每个请求都需要建立一次连接，耗费比较多的资源。同时微信有最大连接数的限制（5个），所以实时通信的需求不好做，长连接的方案也只能串行传输，这种方案耗电高体验差。当我们把目光转向 WebSocket 之后，会发现 WebSocket 通信全程只需要建立一次连接，就可以实现双向的实时通信，更省电的情况下获得更好的体验。这就是小程序支持 WebSocket 的一个重要原因，可以提高业务的体验并增加续航。鉴于很多同学可能对 WebSocket 还不了解，这里简单介绍一下。我们的 HTTP 连接是在 TCP 的基础上建立的，当服务器支持 WebSocket 的时候，可以相应一个头部，告知客户端进行协议升级。升级协议后，会复用之前的 TCP 连接，在上面实现 WebSocket 协议实现双向通信。更加详细的资料可以参考 MDN 上的说明。回到我们的案例上来，我们当时使用小程序提供的 WebSocket 做了一个实时的剪刀石头布游戏。我们使用 Socket.IO 实现其后端后，发现在小程序无法使用 Socket.IO 的客户端代码支持。我们只能自己去啃了一下 Socket.IO 的上层协议，实现了一个简版的客户端，从而实现剪刀石头布这个游戏逻辑。这个案例验证了在小程序上面 WebSocket 的可行性，但是由于客户端的实现是自行实现，和 Socket.IO 的后端配合可能会出现不可控的情况。同时，我们发现 WebSocket 的后端实现门槛比较高，并且进行横向扩展的话会更加困难。作为云服务厂商，我们首先想到的方案是使用 PaaS 提供服务来支持 WebSocket 连接。这是怎么一个思路呢？上图很好地解释了 PaaS 形式和传统 WebSocket 形式的不同之处，PaaS 实际上是要实现一个三方通信。我们看一下使用 PaaS 服务来建立 WebSocket 连接的过程：建立连接后，小程序和业务服务器之间可以通过下面的形式进行通信：经过 PaaS 的改造，我们得到了一个新的 WebSocket 方案。该方案的优劣在哪里？首先，优势比较明显，由平台来提供的服务，由平台自己完成扩展能力的支持以及稳定性和性能的保障，业务无需担心。同时，业务也无需关心 WebSocket 协议的实现，因为业务服务器和信道服务之前的通信都是传统的 HTTP，这样也可以节约业务服务器的长连接资源。但是这种方案也有它的局限之处。业务服务器和信道服务器之间采取公网通信，处于对信息安全的考虑，最好还是走 HTTPS 通信，这个过程的通信延迟比较客观。其次，三方通信的调试便利性也不如传统的连接方式。对于上面两个问题，其实我们也有对应方案。如果业务服务器在腾讯云机房运行，那么可以让业务服务器和信道服务器之间通过内网 HTTP 传输，延迟大大降低。信道服务后续也会提供调试日志供大家分析发现问题。总体来说，PaaS 方案会帮助更多开发者解决掉了门槛较高的部分。整合我们上面对于会话服务和信道服务都进行了一个有益的实践，那么这两个服务是否可以整合，信道服务里面是否可以支持会话识别？事实上我们可以做这个事情。下面的表格描述了会话服务和信道服务与服务模块之间的关系。我们可以把客户端的部分整合为客户端 SDK，把业务服务器的部分整合为服务器 SDK，并且提供会话服务器的源码开源。那么上面三个部分加起来，就是目前腾讯云的开源项目 - Wafer。Wafer 包含了会话服务和信道服务的支持，从全栈模块来提供开源的资源，并且提供了丰富的文档。有兴趣的开发者可以使用上面的连接来查看 Wafer 项目。产品化实践Wafer 帮开发者解决了小程序开发过程中信道服务和会话服务的门槛问题，但是作为小程序开发者，还要关心后台架构、资源采供、资源部署、扩展能力、安全性、域名申请等等与业务开发无关的部分。这部分，我们提出了一个一站式部署的方案。这个方案，会帮你分配好资源并自动部署下面的架构，让开发者可以专注于业务开发。自动部署的过程其实挺复杂的，有兴趣的同学可以参考下图了解。"}
{"title": "小程序中图片/等款高圆变形问题解决(安卓端) ", "author": "Rolan", "pub_time": "2019-8-12 00:39", "content": "在项目中遇到 zfb小程序 在安卓端变形问题， 等款高圆、icon会有此问题\r\n\r\n问题\r\n话不多说贴代码\r\n<view class=\"circle\"></view>\r\n复制代码原样式\r\n.circle {\r\n  width: 24rpx;\r\n  height: 24rpx;\r\n  border-radius: 12rpx;\r\n  background-size: 24rpx 24rpx;\r\n  background-color: green;\r\n}\r\n复制代码\r\n解决\r\n\r\n将background-color换成background-image 然后外部盒子变大, 可解决\r\n\r\n.circle {\r\n  width: 26rpx;\r\n  height: 26rpx;\r\n  border-radius: 12rpx;\r\n  background-size: 24rpx 24rpx;\r\n  background-repeat: no-repeat;\r\n  background-image: url('/imgs/icon/up.png');\r\n  background-position:  center;\r\n}\r\n复制代码\r\n官方回复\r\n\r\n\r\n最后\r\n原创文章，文笔有限，有更好的方式方法欢迎大家评论区留言讨论"}
{"title": "渗透测试之微信小程序破解 ", "author": "Rolan", "pub_time": "2019-8-8 00:20", "content": "在移动互联的时代，手机端业务越来越多，最普遍的就是微信小程序。最近项目测试的时候发现现在的程序员的安全意识越来越好，很多业务都采用了签名来校验数据包，这样，如果不知道sign算法的话对于安全测试人员来说就无法修改数据，也就无法得知漏洞是否存在了。本次以一个微信小游戏为例，第一次尝试，发现后面水很深，要学的好多，先学习个简单的，走个流程先。微信小游戏：消灭病毒0x01 抓包打开游戏->抓包手机抓包就不再详细说了，如果抓不到数据包，网上搜下方法。按照常规操作，修改个数据，发现返回错误代码{\"code\":1000}\r\n还原原始数据，发现正常返回{\"data\":{},\"code\":0}\r\n后续试了下，发现不论哪个字段，只要数据包被篡改就返回错误。看到最后的sign字段，然后也没有session、cookie等身份校验的字段，基本上就是因为sign校验不通过导致的。所以，只要知道了sign算法，应该就可以直接篡改数据了0x02 获取wxapkg文件使用模拟器（ROOT）打开微信，搜索小程序。可能会有打不开、闪退的情况，但是不要紧，因为资源已经被下载下来了。之前不知道，一直没办法获取源码，后来网上搜到个神器，使用“ RE管理器” 可以读取到对应的文件目录。安装完之后，打开小程序，然后在“ RE管理器 ”里面打开目录： /data/data/com.tencent.mm/MicroMsg/这一大串随机字符串就是微信目录了，打开目录： /appbrand/pkg这里面就是我们安装的小程序的源码包0x03 反编译wxapkg获取源文件Github上已经有大神写的node.js版本的，当然也有其它版本的，例如python版本，不用管什么版本的，能用就行了。GitHub地址：https://github.com/qwerty472123/wxappUnpacker进入到下载好的反编译脚本目录下，在node命令窗口中依次安装需要的依赖。项目中列出来的需要安装的依赖不全，如果报错，看下issues就行了，下面是在我能运行状态下安装的依赖。/Users/w2n1ck/Desktop/wx/wxappUnpacker\r\n├─┬ css-tree@1.0.0-alpha.34\r\n│ ├── mdn-data@2.0.4\r\n│ └── source-map@0.5.7\r\n├── cssbeautify@0.3.1\r\n├── esprima@4.0.1\r\n├─┬ js-beautify@1.10.1\r\n│ ├─┬ config-chain@1.1.12\r\n│ │ ├── ini@1.3.5\r\n│ │ └── proto-list@1.2.4\r\n│ ├─┬ editorconfig@0.15.3\r\n│ │ ├── commander@2.20.0\r\n│ │ ├─┬ lru-cache@4.1.5\r\n│ │ │ ├── pseudomap@1.0.2\r\n│ │ │ └── yallist@2.1.2\r\n│ │ ├── semver@5.7.0\r\n│ │ └── sigmund@1.0.1\r\n│ ├─┬ glob@7.1.4\r\n│ │ ├── fs.realpath@1.0.0\r\n│ │ ├─┬ inflight@1.0.6\r\n│ │ │ └── wrappy@1.0.2\r\n│ │ ├── inherits@2.0.4\r\n│ │ ├─┬ minimatch@3.0.4\r\n│ │ │ └─┬ brace-expansion@1.1.11\r\n│ │ │   ├── balanced-match@1.0.0\r\n│ │ │   └── concat-map@0.0.1\r\n│ │ ├── once@1.4.0\r\n│ │ └── path-is-absolute@1.0.1\r\n│ ├─┬ mkdirp@0.5.1\r\n│ │ └── minimist@0.0.8\r\n│ └─┬ nopt@4.0.1\r\n│   ├── abbrev@1.1.1\r\n│   └─┬ osenv@0.1.5\r\n│     ├── os-homedir@1.0.2\r\n│     └── os-tmpdir@1.0.2\r\n├─┬ uglify-es@3.3.9\r\n│ ├── commander@2.13.0\r\n│ └── source-map@0.6.1\r\n├── vm2@3.8.2\r\n然后运行运行脚本node wuWxapkg.js <file>\r\n这样就成功获取到该小程序的源代码了0x04 源码分析因为开始我们已经知道上传的接口是： api/archive/upload一个文件中都有四5万行代码，一行一行分析的话，太浪费时间了（主要是我也看不懂，2333…）所以，我是根据特征直接在源码中搜的定位到具体位置可以看到数据包都经过了sign处理然后搜索关键字： sign可以看到 t 中包含的所有的字段属性和我们抓包时候的一样，基本上可以确认就是这个了。同时，在传输数据的时候，将 wx_appid 、 wx_secret 删除了搜索关键字： zn ，定位具体函数可以看到就是使用了md5进行了加密。0x05 脚本编写根据源码看到，sign是将post的所有字段和 wx_appid 、 wx_secret 一起进行了md5加密，这样，sign的算法已经知道了。但是，死活没有在源码中找到两个变量，网上搜索，发现新版本是动态加载的，然后我在“ 微信开发者工具” 中导入源码之后一直卡在85%，没办法运行，也就导致没办法动态调试获取到 wx_appid 、 wx_secret 的变量值了。随后网上搜了下这个游戏的破解文章，发现早期版本的代码中是直接硬编码这两个变量的，后面试了下，没想到还能用。这样就全部都有了，写个脚本，根据修改后的数据生成对应的sign即可。# -*- coding: utf-8 -*-\r\nimport hashlib\r\nimport json\r\nimport time\r\nimport requests\r\n\r\ndef get_sign(data):\r\n    if 'sign' in data:\r\n        data.pop('sign')\r\n    items = list(data.items())\r\n    items.append(('wx_appid', 'wxa2c324b63b2a9e5e'))\r\n    items.append(('wx_secret', '8fbd540d0b23197df1d5095f0d6ee46d'))\r\n    items.sort()\r\n    _data = \"\"\r\n    for key, value in items:\r\n        _data += (key + \"=\" + str(value) + \"&\")\r\n    _data = _data[:-1]\r\n    return hashlib.md5(_data.encode('utf-8')).hexdigest()\r\n\r\ndef request_action(action, **kws):\r\n    url = 'https://wxwyjh.chiji-h5.com/api/archive/{}'.format(action)\r\n    data = {\r\n        'plat': 'wx',\r\n        'time': int(time.time() * 1000),\r\n    }\r\n    data.update(kws)\r\n    data['sign'] = get_sign(data)\r\n    r = requests.post(url, json=data)\r\n    data = r.json()\r\n    if data['code'] == 0:\r\n        print('[ * ] {} OK.'.format(action))\r\n    return data\r\n\r\ndef get_record(openid):\r\n    r = request_action('get', openid=openid)\r\n    record = json.loads(r['data']['record'])\r\n    return record\r\n\r\nif __name__ == '__main__':\r\n    uid = 'xxxx'\r\n    record = get_record(uid)\r\n    record['money'] = '9999999999'\r\n    record['zuanShi'] = '9000'\r\n    openid = record['uid']\r\n    record['sign'] = get_sign(record)\r\n    record = json.dumps(record)\r\n    request_action('upload', openid=openid, record=record)\r\n    new_record = get_record(uid)\r\n    print(new_record)\r\n看下效果图：至此，我们就可以达到任意篡改数据的目的了。当然，看到那些排行榜的用户不爽的话，直接将他们的数据改到解放前（openid在源码中能找到），哈哈哈…PS：以上想法纯属意淫，请勿当真！！！谨以此文献给我那位“为了升级打怪天天看广告”的兄弟."}
{"title": "微信小程序客服消息功能 php ", "author": "Rolan", "pub_time": "2019-8-12 00:21", "content": "项目说明：本项目是一个简单微信小程序客服消息类，实现客服消息相关功能。官方给的php示例有误，这里就不再吐槽了。本示例是采用开发者服务器，没有采用云调用的形式。官方文档：客服消息指南客服消息服务端适用场景客户消息流程图使用步骤1、开启客服消息https://mp.weixin.qq.com/wxam...登录-开发-开发设置-消息推送[]( https://raw.githubusercontent...点击“启动”[]( https://raw.githubusercontent...URL(服务器地址)：填开发者服务器对应的url，如 https://xxxxxx/demo.phpToken(令牌)：这个随便填，要求3-32位。EncodingAESKey(消息加密密钥)：这个点击“随机生成”即可。消息加密方式：可以根据自己需要选择，本例选择”兼容模式“。数据格式：json相对于xml来说，从压缩效率及传输效率更具优势，这里我们选json。注意：以上操作完后先不要提交，等配置好开发者服务端后再提交。2、配置开发者服务端检验signature的PHP示例代码：$signature = $_GET[\"signature\"];\r\n    $timestamp = $_GET[\"timestamp\"];\r\n    $nonce = $_GET[\"nonce\"];\r\n    $echostr=$_GET[\"echostr\"];\r\n\r\n    $token = TOKEN;//这里改成你第一步操作时填写的token\r\n    $tmpArr = array($token, $timestamp, $nonce);\r\n    sort($tmpArr, SORT_STRING);\r\n    $tmpStr = implode( $tmpArr );\r\n    $tmpStr = sha1( $tmpStr );\r\n\r\n    if ($tmpStr == $signature ) {\r\n        return $echostr;\r\n    } else {\r\n        return false;\r\n    }官方示例没有返回 $echostr ，这个检验开发者服务端是否成功的关键，必须返回。3、提交消息推送配置如果没有报错，证明配置成功。4、开发者服务端demo<?php\r\n\r\n\r\n\r\n//验证signature\r\n//$signature = $_GET[\"signature\"];\r\n//$timestamp = $_GET[\"timestamp\"];\r\n//$nonce = $_GET[\"nonce\"];\r\n//$echostr=$_GET[\"echostr\"];\r\n//\r\n//$token = TOKEN;//这里改成你第一步操作时填写的token\r\n//$tmpArr = array($token, $timestamp, $nonce);\r\n//sort($tmpArr, SORT_STRING);\r\n//$tmpStr = implode( $tmpArr );\r\n//$tmpStr = sha1( $tmpStr );\r\n//\r\n//if ($tmpStr == $signature ) {\r\n//    return $echostr;\r\n//} else {\r\n//    return false;\r\n//}\r\n\r\n\r\ninclude_once './Xcxmsg.php';\r\n$xcxmsg = new Xcxmsg();\r\n\r\n$postStr = file_get_contents('php://input');\r\nif (!$postStr)\r\n    return false;\r\n$postArr = json_decode($postStr, true);\r\nif (!isset($postArr['MsgType']) || !isset($postArr['FromUserName']))\r\n    return false;\r\n$data = [\"touser\" => $postArr['FromUserName']];\r\n\r\n$accessToken = $xcxmsg->getAccessToken();\r\n$url = \"https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=\" . $accessToken;\r\n\r\nswitch ($postArr['MsgType']) {\r\n    case \"text\":\r\n        //如用户发送的是文字信息，这里处理\r\n        //回复图文链接，也可以回复别的类型，根据需要\r\n        $data['msgtype'] = \"link\";\r\n        $data['link'] = [\r\n            \"title\" => \"hello\",\r\n            \"description\" => \"Is Really A Happy Day\",\r\n            \"url\" => \"LINK_URL\",//连接url\r\n            \"thumb_url\" =>\"THUMB_URL\" //图片url\r\n        ];\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n        break;\r\n    case \"image\": //如用户发送图片消息，进入这里\r\n\r\n        //服务端回复 图片，也可以回复别的类型，根据需要\r\n        $data['msgtype'] = \"image\";\r\n        $data['image'] = ['media_id' => 'media_id值']; // 执行 $xcxmsg->upload($accessToken)返回的 media_id\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n    case \"miniprogrampage\":\r\n        //如用户发送小程序卡片，进入这里\r\n        //这里服务端回复小卡片，也可以回复别的类型，根据需要\r\n        $data['msgtype'] = \"miniprogrampage\";\r\n        $data['miniprogrampage'] = [\r\n            \"title\" => \"title\",\r\n            \"pagepath\" => \"pages/index/index\",\r\n            \"thumb_media_id\" => \"media_id值\"];// 执行 $xcxmsg->upload($accessToken)返回的 media_id\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n        break;\r\n    case \"event\":\r\n        //如用户进入会话事件\r\n        //这里可以回复文本\r\n        $data['msgtype'] = \"text\";\r\n        $data['text'] = [\r\n            \"content\" => \"Hello World\",\r\n            ];\r\n        $json = json_encode($data, JSON_UNESCAPED_UNICODE);\r\n        $xcxmsg->curl($json, $url);\r\n        break;\r\n    default:\r\n}5、小程序前端在需要的地方添加以下代码：<button open-type=\"contact\" >客服消息</button>用微信开发工具的预览，生成二维码，扫描测试是否成功。项目地址： https://github.com/guyan0319/...在使用中如有任何问题，请回复指正，谢谢！"}
{"title": "撸一个微信小程序记事本备忘录-随微记 ", "author": "Rolan", "pub_time": "2019-8-12 00:37", "content": "废话不多说了，目的直接点微信上记录一些资料(比如公司信息以及开发票等)，方便查看可以随时分享出来，可以生成图片海报做一些工具（后续开放）最后总结就是弄它， 随微记 是自己想的，页面也是自己布局，海报的配置可能也有自己的喜好存在目前版本为 V1.0.0 ，在此篇文章不会有代码的东西认知(需要改善)：没有各种的app好用没有手机自带备忘录的好用微信小程序技术微信小程序原生apiTaroColorUi组件库功能列表还有未完成的功能后续更新界面介绍遇到问题editor\r\n云开发云开发数据主要的存储是用户的列表以及用户笔记本和笔记的数据本来想用存图片，第一版本的时候遇到了图片size限制的问题，因此近期改版为上传至阿里OssNode + koa + mysql 服务 koa-swagger-decorator自动生成api文档 文字笔记海报配置 图文笔记海报配置 分享海报配置 用户同步数据 模板使用情况记录 分享日志记录 https域名部署 node项目部署pm2进程监控 图片删除任务更新 后台session登录 mysql使用 后台未完成功能有点多，在此不列了\"dependencies\": {\r\n    \"@babel/polyfill\": \"^7.4.4\",\r\n    \"axios\": \"^0.19.0\",\r\n    \"debug\": \"^4.1.1\",\r\n    \"koa\": \"^2.7.0\",\r\n    \"koa-bodyparser\": \"^4.2.1\",\r\n    \"koa-convert\": \"^1.2.0\",\r\n    \"koa-generic-session\": \"^2.0.1\",\r\n    \"koa-json\": \"^2.0.2\",\r\n    \"koa-logger\": \"^3.2.0\",\r\n    \"koa-onerror\": \"^4.1.0\",\r\n    \"koa-redis\": \"^4.0.0\",\r\n    \"koa-router\": \"^7.4.0\",\r\n    \"koa-static\": \"^5.0.0\",\r\n    \"koa-swagger-decorator\": \"^1.5.16\",\r\n    \"koa-views\": \"^6.2.0\",\r\n    \"moment\": \"^2.24.0\",\r\n    \"mysql\": \"^2.17.1\",\r\n    \"pug\": \"^2.0.3\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel/cli\": \"^7.5.5\",\r\n    \"@babel/core\": \"^7.5.5\",\r\n    \"@babel/parser\": \"^7.5.5\",\r\n    \"@babel/plugin-proposal-class-properties\": \"^7.5.5\",\r\n    \"@babel/plugin-proposal-decorators\": \"^7.4.4\",\r\n    \"@babel/plugin-proposal-optional-chaining\": \"^7.2.0\",\r\n    \"@babel/plugin-transform-object-assign\": \"^7.2.0\",\r\n    \"@babel/plugin-transform-runtime\": \"^7.5.5\",\r\n    \"@babel/preset-env\": \"^7.5.5\",\r\n    \"@babel/register\": \"^7.5.5\",\r\n    \"cross-env\": \"^5.2.0\",\r\n    \"install\": \"^0.13.0\",\r\n    \"nodemon\": \"^1.19.1\",\r\n    \"npm\": \"^6.10.2\"\r\n  }\r\n复制代码路由配置const tag = tags(['WeChat']);\r\n@prefix('/api/user')\r\nexport default class WechatRouter {\r\n\t@request('post', '/authorize')\r\n  @summary('微信授权登录')\r\n  @description('登录之后返回sesscion和openid')\r\n  @tag\r\n\t@body({\r\n\t\tcode: { type: 'string', required: true, default: '', description: '小程序code' },\r\n\t})\r\n\tstatic async authorize(ctx) {\r\n\t\tlet { code } = ctx.request.body;\r\n    let str = ctx.request.body?.code;\r\n    // console.log('开始访问请求参数2', APPID, APPSECRET, str)\r\n    let res = await getOpenId(code);\r\n    ctx.body = new SuccessModal(res);\r\n\t}\r\n}\r\n复制代码资源链接koa-generatorkoakoa-swagger-decorator后续开发后续后开发围绕微信和备忘录的一系列的工具或者功能，欢迎指出不足和功能改善，或者你想要的功能"}
{"title": "小程序滚动条操作及导航组件实现 ", "author": "Rolan", "pub_time": "2019-8-9 00:27", "content": "当页面比较长内容较多的时候，会使用导航栏，给用户提供方便跳转到页面某一模块的功能。由于导航栏需要监听页面的滚动事件，在小程序中，很容易出现性能问题，需要时刻注意滚动监听中 setData 的次数。本文将介绍页面滚动条操作相关的微信 API，并利用这些 API 实现一个通用的导航栏组件。导航组件效果如下图：滚动到页面目标位置的相关API实现滚动到页面目标位置的功能，需要“滚动操作”和”目标位置“。将页面滚动到目标位置（wx.pageScrollTo）将页面滚动到页面中的目标位置，可以使用 wx.pageScrollTo 这个微信提供的 API。该方法可以接收一个对象作为参数，对象中可以指定：滚动的目标位置 scrollTop，单位为 px；滚动动画的时长 duration，单位为 ms；选择器 selector，但支持的基础库版本是从2.7.3；其实，直接使用选择器可以方便地完成我们想要的效果，但遗憾的是，我们的小程序大约只有60%用户的基础库是2.7.3以上。如果只有这些用户享受到新功能，用户量稍微少了些，不过我们可以使用 scrollTop 直接指定目标位置。获取元素在页面中的位置（SelectorQuery）首先，需要创建节点查询对象 selectorQuery，创建方法如下：wx.createSelectorQuery()\t\t// 返回selectorQuery对象\r\n复制代码selectorQuery 对象可以利用选择器选择匹配的节点，使用 selectAll 方法：wx.createSelectorQuery().selectAll('.nav-target') // 返回 NodesRef复制代码NodesRef 可以使用 fields 方法获取到节点的信息，比如大小、dataset等，使用 boundingClientRect 可以获取节点的位置信息，如上边界坐标等，最后调用 exec 方法才能执行：wx.createSelectorQuery().selectAll('.nav-target').fields({\r\n    dataset: true,\t    // 指定返回节点 dataset 的信息\r\n    size: true,\t\t    // 指定返回节点大小信息\r\n}, rects => {\r\n    rects.forEach(rect => {\r\n        rect.dataset;\r\n        rect.width;\r\n        rect.height;\r\n    })\r\n}).boundingClientRect(rects => {\r\n    rects.forEach(rect => {\r\n\trect.dataset;\r\n        rect.top;\r\n  })\r\n}).exec()\t\t// 最后要加 exec 才能执行\r\n复制代码导航栏组件实现问题及解决思路导航栏组件的实现，大致需要如下准备工作：获取锚点的信息，组成导航栏按钮文案；获取锚点的位置信息，以便点击导航滚动到对应位置；此外，还需要两个特性：点击导航栏，让页面滚动到对应位置；当页面滚动时，导航栏对应锚点的按钮需要改变active状态；准备工作1：获取锚点信息我们可以约定，所有锚点都需要加上：class: nav-target；data-label：导航栏中显示的文本；data-key：作为锚点标识；所以，一个锚点元素可能会编写成如下形式：<view class=\"nav-target\" data-key=\"overview\" data-label=\"概览\">...</view>复制代码有了class，我们就可以利用前文提到的selectorQuery取到这些锚点，进而利用boundingClientRect方法取到锚点上的dataset，关键代码如下：wx.createSelectorQuery().selectAll('.nav-target').boundingClientRect(res => {\r\n\tthis.setData({\r\n  \tnavList: res.map(item => item.dataset).filter(Boolean)\r\n  })\r\n})\r\n复制代码取到了锚点信息后，存入navList，其中的label作为导航栏的按钮文案，而key则用于接下来存储锚点位置。准备工作2：获取锚点的位置信息锚点的位置信息，也可以通过boundingClientRect获取，取到位置信息后，存入一个Map中，我们命名为positionMap，结合上面获取锚点信息，_getAllAnchorInfoAndScroll方法代码如下：_getAllAnchorInfoAndScroll(selectorIdToScroll) {\r\n  wx.createSelectorQuery().selectAll('.nav-target').boundingClientRect(res => {\r\n    if (!res || res.length === 0) return\r\n\r\n    this.setData({\r\n      navList: res.map(item => item.dataset).filter(Boolean)\r\n    })\r\n    \r\n    // 为了减少setData传输数据量，我们将视图层不需要用到的position信息存在Page实例上\r\n    res.forEach(item => {\r\n      const { top, dataset: { key} } = item\r\n      if (top >= 0) {\r\n        this.positionMap[key] = Math.max(top - 55, 0)\t// 向上留55px的空间给导航栏\r\n      }\r\n    })\r\n\r\n    // 如果需要做滚动的操作，则在这里执行\r\n    if (selectorIdToScroll) {\r\n      wx.pageScrollTo({ scrollTop: this.positionMap[selectorIdToScroll] })\r\n    }\r\n  }).exec()\r\n}\r\n复制代码模块动态加载由于需要加导航的页面长度都比较长，我们通常会对非首屏的模块使用动态加载技术。而页面模块的动态加载意味着，导航组件获取锚点位置的时机不能简单地设置在组件的 ready 事件。很显然，获取锚点位置的时机应该设置在所有模块都加载完成的时候。我们可以在模块（组件）加载完成后，通知导航组件进行锚点信息的更新。关键代码大致如下：页面 page.wxml<!-- 导航组件 -->\r\n<nav id=\"nav\" />\r\n\r\n<!-- 页面模块组件 -->\r\n<page-module bindupdate=\"updateNavList\" />\r\n复制代码页面 page.jsPage({\r\n  updateNavList() {\r\n     this.getNavComponent().updateNavInfo()\r\n  },\r\n  getNavComponent() {\r\n    // 避免多次调用 selectComponent，将其结果存入变量 _navComponent\r\n    if (!this._navComponent) {\r\n      this._navComponent = this.selectComponent('#nav')\r\n    }\r\n    return this._navComponent\r\n  },\r\n})\r\n复制代码模块组件 pageModule.js// 模块组件中，加载完成时触发页面实例的 updateNavList 方法\r\nthis.triggerEvent('update')\r\n复制代码导航组件 nav.jsComponent({\r\n  methods: {\r\n    ...,\r\n    updateNavInfo() {\r\n      this._getAllAnchorInfoAndScroll()\r\n    }\r\n  }\r\n})\r\n复制代码如此一来，页面模块更新后，导航组件也会更新锚点信息和位置，保证导航组件的信息是最新的。最后需要注意如果有懒加载的图片，需要提前设定好高度，否则等图片加载完锚点信息就错乱了。当然，也可以在图片加载完成的方法中，调用更新导航信息的 updateNavList 方法，这部分与模块组件的加载触发思路一致本文就不赘述。特性1：点击导航按钮，页面滚动到对应位置有了前面两项准备工作，这个特性实现起来，就简单多了。导航栏的按钮有可能一行放不下，应该使用 scroll-view 标签支持滚动。wxml 代码如下：导航组件 nav.wxml<scroll-view scroll-x>\r\n  <view class=\"scroll-inner\" bindtap=\"bindClickNav\">\r\n    <view class=\"nav {{index === currentIndex ? 'nav--active' : ''}}\"\r\n          wx:for=\"{{navList}}\" wx:key=\"{{index}}\" data-key=\"{{item.key}}\" data-index=\"{{index}}\">{{item.label}}</view>\r\n  </view>\r\n</scroll-view>复制代码其中，currentIndex 记录当前选中的导航项；bindClickNav 则处理点击导航项的更新 currentIndex 和页面滚动逻辑。导航组件 nav.jsbindClickNav(e) {\r\n  const { index, key } = e.target.dataset\r\n  this.setData({ currentIndex: index })\r\n  if (this.data.positionMap[selectorId] === undefined) {\r\n    // 如果点击时，锚点位置还未取得，则需要先获取位置并传入key，在获取位置之后滚动\r\n    this._getAllAnchorInfoAndScroll(key)\r\n    return\r\n  }\r\n  wx.pageScrollTo({ scrollTop: this.positionMap[selectorId] })\r\n},\r\n复制代码特性2：导航栏按钮的状态支持随着页面滚动而改变页面滚动的监听函数是 onPageScroll，我们需要在其中判断页面滚动到哪个锚点。判断滚动到哪个锚点的具体逻辑是在导航组件中的 watchScroll 实现，页面实例中的 onPageScroll 则传递页面滚动位置给导航组件 watchScroll 方法。页面实例 page.jsPage({\r\n  onPageScroll({ scrollTop }) {\r\n    const navComponent = () => {\r\n      if (!this._navComponent) {\r\n        this._navComponent = this.selectComponent('#nav')\r\n      }\r\n      return this._navComponent\r\n    }\r\n    navComponent && navComponent.watchScroll(scrollTop)\r\n  }\r\n})\r\n复制代码在导航组件中，应该如何判断页面滚动的位置与锚点的关系呢？以下图为例，页面滚动超过了”模块1“与”模块2“的锚点，但未超过”模块3“的锚点，此时导航栏显示的”模块2“应该是 active 态：总结一下实现思路：按照从上到下的顺序遍历各个模块，并将各个模块的锚点位置与页面的 scrollTop 进行对比，找到最后一个小于 scrollTop 的锚点模块，该模块的状态即为 active。由于“最后一个小于”比较难找，我们可以转换成找“第一个大于”的模块，该模块的上一个模块即为 active 态的模块。关键代码如下：导航组件 nav.jsComponent({\t\r\n  ...,\r\n  methods: {\r\n\t  ...,\r\n    watchScroll(pageScrollTop) {\r\n\r\n      // 判断是否为空，即初始化尚未完成\r\n      if (isEmpty(this.positionMap)) {\r\n        return\r\n      }\r\n\r\n      // 当页面滚动时，停止更新navIndex\r\n      if (_navIndexLock) {\r\n        return\r\n      }\r\n\r\n      // 判断滚动的scrolltop，然后设置 currentIndex\r\n      const lastIndex = this.data.navList.length - 1\r\n      for (let idx = 0; idx <= lastIndex; idx++) {\r\n        const navItem = this.data.navList[idx]\r\n        const top = this.positionMap[navItem.key]\r\n        const indexToSet = idx === 0 ? idx : idx - 1\r\n\r\n        // 寻找“第一个大于scrollTop”的模块，其上一个模块即为 active 态的模块\r\n        if (top > pageScrollTop) {\r\n          this.data.currentIndex !== indexToSet && this.setData({ currentIndex: indexToSet })\r\n          break\r\n        }\r\n\r\n        // 到最后一个tab还没有break，说明已经滚动到了最后tab\r\n        if (idx === lastIndex) {\r\n          this.data.currentIndex !== lastIndex && this.setData({ currentIndex: lastIndex })\r\n        }\r\n      }\r\n    }\r\n\t}\r\n})\r\n复制代码总结本文介绍了微信小程序对页面滚动和元素操作的支持情况，利用这些特性实现了一个导航组件。这个导航组件支持动态加载的模块，并能够根据页面滚动的位置更新导航组件的 active 状态。组件中，主要是模块动态加载完成这个时机比较难捕捉到，这里利用加载完的事件触发导航更新，这种方式的优化方案还待思考讨论。如果大家有好的建议也欢迎留言讨论~参考资料官方文档：developers.weixin.qq.com/miniprogram…"}
{"title": "干货分享：小程序项目实践和经验总结 ", "author": "Rolan", "pub_time": "2019-8-9 00:21", "content": "最近接触小程序开发，我特将本次开发过程中所使用到的相关知识点进行了总结，以作为经验的积累。希望给自己以后的开发，提供一些帮忙，同时提高解决问题的能力。如有错误，请大家指正。github地址；项目地址；weui：使用微信原生视觉体验样式库认识： WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。官网： https://weui.io/github地址: https://github.com/weui/weui-wxss微信推出了一套官方样式库,方便大家开发,对于一些类似的UI界面我们需要引入即可,无需重复造轮子。我们只需导入weui.wxss等即可减少大量的css布局工作.关于本地图片资源路径（background）小程序只有image标签支持本地图片资源路径，wxss里的background-image不支持。如果想在css中使用背景图，解决方法：1、将本地图片用线上地址转化成base64路径。线上转化base64的地址：http://imgbase64.duoshitong.com/2、url里面的图片来源必须填写外链。如下：area{\r\n   background: url('https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1' ) no-repeat center;\r\n}websocket问题体验版支持ws协议，需要打开调试模式如果websocket是连接的域名非IP地址，则不能通过连接代理更改电脑的host来指定socket域名的解析地址如果有测试环境，建议：建一个专有的测试环境websocket域名直接使用测试环境的IP地址访问websocket关于时间格式在ios中处理方法背景： 由于ios只识别格式yyy/mm/dd格式，如\"2018-10-31 20:30:00\"格式无法识别；默认情况下数据库拿到的日期格式为“2018-08-30 12:00:00”，如果不替换“-”的话，在IOS下是不能通过getDate(datestring)获取到日期对象的。Android下两种格式均表现正常。解决方法： 通过正则替换掉所有的\"-\",如下：var dateStr = \"2018-09-08 12:30:30\"; // 后台返回的时间字符串\r\ndateStr = dateStr.replace(/-/g, '/');\r\nconsole.log(dateStr); \r\n结果为：2018/09/08 12:30:30小程序DOM上附属参数，函数中获取参数方法view.wxml: // DOM上附属参数\r\n<view \r\n  data-id='{{fangyuanItem.id}}' \r\n  data-houseitemid='{{fangyuanItem.houseItemId}}' \r\n  catchtap='viewMendianDetail'>\r\n</view>view.js:  // 函数中获取参数\r\n  page({\r\n      data:{},\r\n      viewMendianDetail: function (e) {\r\n        var roomtypeid = e.currentTarget.dataset.id;\r\n        var houseItemId = e.currentTarget.dataset.houseitemid;\r\n      }\r\n  })注意： 附属参数时，data-key,key格式为小写;小程序 navigator 无法跳转 tabBar上的页面方法一：navigator 的 open-type 设置为 switchTab代码如下：<navigator url=\"../cart/index\" open-type=\"switchTab\">\r\n   <text>首页</text>\r\n</navigator>方法二：wx.switchTab({})代码如下:index.wxml: <text catchtap=\"toIndex\">首页</text>index.js： page({\r\n    toIndex(){\r\n        wx.switchTab({  \r\n          url: '../cart/index'\r\n        }) \r\n    }\r\n })wx.navigateTo和wx.switchTab导航传参wx.navigateTo导航传参1.wx.navigateTo，url通过参数拼接传参；// 访问房型详情\r\nviewMendianDetail: function (e) {\r\n  var roomtypeid = e.currentTarget.dataset.id;\r\n  var houseItemId = e.currentTarget.dataset.houseitemid;\r\n  wx.navigateTo({\r\n    url: '/pages/index/index?houseItemId=' + houseItemId + '&roomtypeid=' + roomtypeid,\r\n  })\r\n}2.定位到的组件中通过生命周期函数onLoad接收参数对象，并设置本组件中的数据pages/index/index： onLoad: function (options) {\r\n    //console.log(options)\r\n    var houseItemId = options.houseItemId\r\n    var roomtypeid = options.roomtypeid\r\n    this.setData({\r\n        houseItemId: houseItemId,\r\n        roomTypeId: roomtypeid\r\n    })\r\n}wx.switchTab导航传参1.前提：app.js中有定义全局变量searchInfo，如下：App({\r\n    globalData: {\r\n        searchInfo:{\r\n          searchInput:\"\",\r\n          laiyuan:0\r\n        }\r\n  }\r\n});2.通过app.globalData定义全局参数，如下：a.wxml:const app = getApp()\r\npage({\r\n    data:{},\r\n    toZhaofang:function(e){\r\n        app.globalData.searchInfo = {\r\n          \"searchInput\": searchInput,\r\n          \"laiyuan\": 1\r\n        }\r\n        wx.switchTab({\r\n          url: '/pages/tabbar/zhaofang/index',\r\n        })\r\n   }\r\n})3.通过app.globalData来接收全局参数，如下：zhaofang/index.wxml: const app = getApp()\r\n page({\r\n    onLoad(){ \r\n       let searchInfo = app.globalData.searchInfo\r\n       let searchInput = searchInfo.searchInput;\r\n    }\r\n })自定义小程序转发功能默认情况下，我们需要点击小程序右上角的...才能看到转发，这样并不能对用户起到引导作用，通常的做法是使用一个button，并且设置open-type为share，这样就可以通过按钮启动分享。但是原生按钮很难看，我们可以设置一个图片，并且调整按钮的样式；效果如图：share.wxml:<button open-type=\"share\"><image src=\"/images/icon-share.png\"></image></button>share.wxss:button {\r\n    padding:0;\r\n    width:70rpx;\r\n    height:70rpx;\r\n    display:block;\r\n    border:0;\r\n    background: transparent;\r\n}\r\nbutton::after {\r\n    border:0; \r\n}注意： 尤其是对 button::after 要进行设置，否则按钮的边框是无法去掉的。通过 wx.getSystemInfo()来获取手机信息(包括宽，高)小程序提供的getSystemInfo()方法,该方法可以获取到设备的常用信息,如手机型号.设备像素比.屏幕宽高等等.最常用的就是屏幕宽高了.为了保证获取信息的准确性，wx.getSystemInfoSync是在页面初始化的时候就计算了。所以最好的方法是使用异步接口，并且在onReady函数中调用。info.js:Page({\r\n  onReady: function (options) {\r\n    this.getSystemInfo();\r\n  },\r\n  getSystemInfo:function(){\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n         console.log(\"手机屏幕的宽度为：\" + res.screenWidth);\r\n         console.log(\"手机屏幕的高度为：\" + res.screenHeight);\r\n        console.log(\"可视网页的宽度为：\" + res.windowWidth);\r\n        console.log(\"可视网页的高度为：\" + res.windowHeight);\r\n        console.log(\"手机的系统为：\" + res.system);\r\n        console.log(\"微信版本号为：\" + res.version);\r\n      }\r\n    })\r\n  }\r\n})结果如图：模板（template）定义与传参定义： WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。使用 name 属性，作为模板的名字。如：1.定义模板文件baseTemplate.wxml:<template name=\"msgItem\">\r\n  <view>\r\n    <text> {{index}}: {{msg}} </text>\r\n    <text> Time: {{time}} </text>\r\n  </view>\r\n</template>2.使用模板并通过data传递参数使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入。如下：user.wxml:<import src=\"../template/baseTemplate.wxml\" />\r\n <block wx:for=\"{{goodlist}}\" wx:key=\"idx\">\r\n    <template is=\"msgItem\" data=\"{{...item}}\"></template>\r\n</block>注意：1.通过data=\"{{...item}}\"的方式传递参数时，被调用的模板中，不需要再写item;2.如果要传多个数据到模板,用逗号分开,item 是对象,index是单个数据,要用键值对.<view class=\"tab-list\" wx:for=\"{{list}}\" wx:key=\"index\">\r\n   <template is=\"day-tab\" data=\"{{item,index:index,target:target}}\" wx:key=\"index\"></template>\r\n</view>user.js,数据定义格式如下：page({\r\n   data:{\r\n       goodlist:[\r\n           { index: 0,msg: 'this is a template',time: '2016-06-18'},\r\n           { index: 1,msg: 'this is a template1',time: '2017-06-18'},\r\n           { index: 2,msg: 'this is a template2',time: '2018-06-18'}\r\n       ]\r\n   }\r\n})城市选择组件picker使用效果如图：组件介绍：picker：从底部弹起的滚动选择器。代码如下：picker.wxml:<picker  \r\n    mode='selector' \r\n    range=\"{{region}}\" \r\n    range-key=\"{{'cityName'}}\" \r\n    value='{{indexCity}}'\r\n    bindchange=\"chooseCity\" \r\n    >\r\n    <view class=\"picker\">  \r\n        {{region[indexCity].cityName}}\r\n    </view>  \r\n</picker>picker.js:page({\r\n   data:{\r\n       region:[\r\n           {\"cityName\":\"北京市\",\"cityId\":\"12345\"},\r\n           {\"cityName\":\"上海市\",\"cityId\":\"67890\"},\r\n           {\"cityName\":\"武汉市\",\"cityId\":\"54321\"},\r\n       ]\r\n   },\r\n   chooseCity(e){\r\n     var value = e.detail.value;  // index下标\r\n   }\r\n})属性介绍：mode(string)：选择器类型；mode 的合法值：selector：普通选择器；multiSelector：多列选择器；time：时间选择器；date:日期选择器;region:省市区选择器滑动组件scroll-view介绍： scroll-view:可滚动视图区域。使用竖向滚动时，需要给scroll-view一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。详细文档：请参考；效果如图：使用方法如下：<scroll-view scroll-x=\"true\"></scroll-view>注意：1.scroll-view的scroll-x失效的解决办法给scroll-view加上white-space: nowrap; 给scroll-view的子元素box加上display:inline-block即可。代码如下：.scroll-box {\r\n   white-space: nowrap;\r\n}\r\n.scroll-box .box{\r\n   display:inline-block\r\n}2.文本数据默认显示2行，超出部分用\"...\"代替：样式代码如下：line-height: 40rpx;\r\nwhite-space:pre-line;\r\ndisplay:-webkit-box;\r\n-webkit-box-orient:vertical;\r\n-webkit-line-clamp:2;\r\noverflow:hidden;视图容器cover-image和cover-view使用背景：在微信小程序经常会用到一些原生组件，比如map、video、canvas、camera，这些原生组件想让其他元素覆盖在其上，必须使用cover-view或者cover-image组件。cover-view介绍： 覆盖在原生组件之上的文本视图。可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher。只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。注意： 只支持基本的定位、布局、文本样式。不支持设置单边的border、background-image、shadow、overflow: visible等。1、支持background-color，不支持background-image，如果你发现你的素材在真机出不来，而且你又设置了背景图片的话，那你可以把这些元素全部替换成cover-image。2、不支持overflow: visible也是有点坑，这样的话，你想超出依然显示，就需要设置一个同级元素并提升层级才能达到效果了。效果如图：示例代码如下：video.wxml:<video id=\"myVideo\" src=\"http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400\" controls=\"{{false}}\" event-model=\"bubble\">\r\n  <cover-view class=\"controls\">\r\n    <cover-view class=\"play\" bindtap=\"play\">\r\n      <cover-image class=\"img\" src=\"/path/to/icon_play\" />\r\n    </cover-view>\r\n    <cover-view class=\"pause\" bindtap=\"pause\">\r\n      <cover-image class=\"img\" src=\"/path/to/icon_pause\" />\r\n    </cover-view>\r\n    <cover-view class=\"time\">00:00</cover-view>\r\n  </cover-view>\r\n</video>video.wxss:.controls {\r\n  position: relative;\r\n  top: 50%;\r\n  height: 50px;\r\n  margin-top: -25px;\r\n  display: flex;\r\n}\r\n.play,.pause,.time {\r\n  flex: 1;\r\n  height: 100%;\r\n}\r\n.time {\r\n  text-align: center;\r\n  background-color: rgba(0, 0, 0, .5);\r\n  color: white;\r\n  line-height: 50px;\r\n}\r\n.img {\r\n  width: 40px;\r\n  height: 40px;\r\n  margin: 5px auto;\r\n}video.jsPage({\r\n  onReady() {\r\n    this.videoCtx = wx.createVideoContext('myVideo')\r\n  },\r\n  play() {\r\n    this.videoCtx.play()\r\n  },\r\n  pause() {\r\n    this.videoCtx.pause()\r\n  }\r\n})cover-image介绍： 覆盖在原生组件之上的图片视图，可覆盖的原生组件同cover-view，只支持嵌套在cover-view里。cover-image发现了两个问题：1、虽说和image组件基本一样，但是设置mode属性也就是图片裁剪、缩放的模式无效2、宽度固定，高度auto，时，按照正常效果应该是图片按比例伸缩展示，但是发现该组件高度一直为0，只能根据应用场景寻找其他替代方案了。视图容器swiper介绍： 滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为。效果如图：代码如下：swiper.wxml:<view class=\"area\">\r\n   <view class=\"fuTitle\">swiper</view>\r\n   <view class=\"intro\"> \r\n      <text class=\"one-title\">介绍：</text>\r\n      <text>滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为。</text>\r\n   </view>\r\n   <view class=\"item\">\r\n      <swiper \r\n        indicator-dots=\"{{indicatorDots}}\"\r\n        indicator-color=\"{{indicatorColor}}\"\r\n        indicator-active-color=\"{{indicatorActiveColor}}\"\r\n        previous-margin=\"{{previousMargin}}\"\r\n        next-margin=\"{{nextMargin}}\"\r\n        display-multiple-items=\"{{itemsNum}}\"\r\n        autoplay=\"{{autoplay}}\" \r\n        interval=\"{{interval}}\" \r\n        duration=\"{{duration}}\"\r\n        bindchange=\"bindchange\"\r\n        easing-function=\"{{easing}}\"\r\n        >\r\n        <block wx:for=\"{{imgUrls}}\" wx:key=\"{{index}}\">\r\n          <swiper-item item-id=\"{{index}}\">\r\n            <image src=\"{{item}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>\r\n          </swiper-item>\r\n        </block>\r\n      </swiper>\r\n   </view>\r\n</view>swiper.jsPage({\r\n    data: {\r\n         imgUrls:[\r\n           \"../../images/bo1.jpg\",\r\n           \"../../images/bo2.jpg\",\r\n           \"../../images/bo3.jpg\",\r\n           \"../../images/bo4.jpg\"\r\n         ],\r\n         indicatorDots: true,    // 是否显示滚动圆点图标\r\n        indicatorColor: \"#07c160\", // 指示点颜色\r\n        indicatorActiveColor: \"#28d3ee\", // 当前选中的指示点颜色\r\n        previousMargin: \"10rpx\", // 前边距，可用于露出前一项的一小部分，接受 px 和 rpx 值\r\n        nextMargin: \"10rpx\",     // 后边距，可用于露出后一项的一小部分，接受 px 和 rpx 值\r\n        itemsNum:1,              // 同时显示的滑块数量\r\n        easing: \"default\",       // 指定 swiper 切换缓动动画类型\r\n        autoplay: true,         // 是否自动播放\r\n        interval: 5000,         // 自动切换时间间隔\r\n        duration: 1000          // 滑动的动画时长\r\n    }\r\n})rich-text实现富文本解析介绍： 富文本。主要用来解析服务端传递过来的富文本html格式的数据，进行展示在页面上。类似于vue的v-html指令；效果如图：代码如下：richText.wxml:<view class=\"rich-area\">\r\n      <rich-text nodes=\"{{article_content}}\" bindtap=\"tapRichText\"></rich-text>\r\n</view>richText.js:Page({\r\n   data: {\r\n     article_content: '<p>自我介绍1</p><p><img src=\"https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1\" width=\"100\" height=\"100\"/></p><p>自我介绍2</p><p><img src=\"https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1\" width=\"100\" height=\"100\"/></p><p>自我介绍3</p><p><img src=\"https://mirror-gold-cdn.xitu.io/168e088859e325b9d85?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1\" width=\"100\" height=\"100\"/></p>',\r\n   }\r\n});小程序中运用高德地图绘制静态图功能背景在小程序的页面中，需要显示某个位置的具体地理坐标并做好标记；如果直接使用map组件，无法满足功能需求，同时会存在页面层级重叠的问题；所有就选择了高德地图微信小程序sdk,绘制静态图来呈现。效果如图：开发步骤1.获取高德Key点我获取Key>>点我查看申请高德Key的方法>>2.绘制静态图简介：由于微信内无法运行第三方地图，高德对广大开发者提供了静态地图功能，可快速生成一张地图图片，可以指定显示的地图区域、图片大小、以及在地图上添加覆盖物，如标签、标注、折线、多边形。 可用于快速生成一张个性化涂鸦的静态地图用于查看和分享。静态图上绘制点1、在页面的 js 文件中，实例化 AMapWX 对象，请求显示静态地图。首先，引入 amap-wx.js 文件（amap-wx.js 从相关下载页面下载的 zip 文件解压后得到）。xinxi.js:var amapFile = require('path/to/amap-wx.js');//如：..­/..­/libs/amap-wx.js然后，构造 AMapWX 对象，并调用 getStaticmap 方法。其中，注意： 把百度地图坐标转换成高德，腾讯地图坐标var zuobiaoArr = network.bMapTransQQMap(lng,lat)Page({\r\n  data: {\r\n    pointObj:{\r\n      lng:'您的坐标经度值',\r\n      lat:'您的坐标纬度值'\r\n    },\r\n    src: ''\r\n  },\r\n  onLoad: function() {\r\n    var that = this;\r\n    var myAmapFun = new amapFile.AMapWX({key:\"您的Key\"});\r\n    wx.getSystemInfo({\r\n      success: function(data){\r\n        var height = data.windowHeight;\r\n        var width = data.windowWidth;\r\n        var size = width + \"*\" + height;\r\n        myAmapFun.getStaticmap({\r\n          zoom: 8,\r\n          size: size,\r\n          scale: 2,\r\n          markers: \"mid,0xFF0000,A:\"+pointObj.lng+\",\"+pointObj.lat\",\r\n          success: function(data){\r\n            that.setData({\r\n              src: data.url\r\n            })\r\n          },\r\n          fail: function(info){\r\n            wx.showModal({title:info.errMsg})\r\n          }\r\n        })\r\n      }\r\n    })\r\n  }\r\n})注意：data.windowHeight，data.windowWidth获取的是整个窗口的高度和宽度，这里可以根据需求自己设定地图要显示的宽高。markers: \"mid,0xFF0000,A:\"+pointObj.lng+\";\"+pointObj.lat\",用于设置地图上要显示的标记坐标；如果要显示多个标记，格式为：markers: \"mid,0xFF0000,A:116.37359,39.92437;116.47359,39.92437\"; // 多个坐标点以\";\"分割;2、编写页面的 wxml 文件，搭建页面结构。xinxi.wxml:<view class=\"img_box\">\r\n  <img src=\"{{src}}\">\r\n</view>3、编写页面的 wxss 文件，设置页面样式。xinxi.wxss:.img_box{\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n}\r\n.img_box image{\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n……4.注意细节：如果你提供的 pointObj:{lng:'您的坐标经度值',lat:'您的坐标纬度值'}数据对象为百度地图的坐标值，我们需要将其转换为高德地图坐标值(它们的坐标计算方式不同)；转换方法如下：//百度地图坐标转为高德，腾讯地图坐标\r\nfunction bMapTransQQMap(lng, lat) {\r\n    let x_pi = 3.14159265358979324 * 3000.0 / 180.0;\r\n    let x = lng - 0.0065;\r\n    let y = lat - 0.006;\r\n    let z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);\r\n    let theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);\r\n    let lngs = z * Math.cos(theta);\r\n    let lats = z * Math.sin(theta);\r\n    return {\r\n        lng: lngs,\r\n        lat: lats\r\n    }\r\n}\r\nlet pointObj = bMapTransQQMap(lng,lat); // 转换之后的坐标值；结束："}
{"title": "小程序·云开发实战 - 迷你微博 ", "author": "Rolan", "pub_time": "2019-7-25 00:42", "content": "0. 前言\r\n本文将手把手教你如何写出迷你版微博的一行行代码，迷你版微博包含以下功能：\r\n\r\nFeed 流：关注动态、所有动态\r\n发送图文动态\r\n搜索用户\r\n关注系统\r\n点赞动态\r\n个人主页\r\n\r\n使用到的云开发能力：\r\n\r\n云数据库\r\n云存储\r\n云函数\r\n云调用\r\n\r\n没错，几乎是所有的云开发能力。也就是说，读完这篇实战，你就相当于完全入门了云开发！\r\n咳咳，当然，实际上这里只是介绍核心逻辑和重点代码片段，完整代码建议下载查看。\r\n1. 取得授权\r\n作为一个社交平台，首先要做的肯定是经过用户授权，获取用户信息，小程序提供了很方便的接口：\r\n<button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n  进入小圈圈\r\n</button>\r\n复制代码这个 button 有个 open-type 属性，这个属性是专门用来使用小程序的开放能力的，而 getUserInfo 则表示 获取用户信息，可以从bindgetuserinfo回调中获取到用户信息。\r\n于是我们可以在 wxml 里放入这个 button 后，在相应的 js 里写如下代码：\r\nPage({\r\n  ...\r\n\r\n  getUserInfo: function(e) {\r\n    wx.navigateTo({\r\n      url: \"/pages/circle/circle\"\r\n    })\r\n  },\r\n\r\n  ...\r\n})\r\n复制代码这样在成功获取到用户信息后，我们就能跳转到迷你微博页面了。\r\n需要注意，不能使用 wx.authorize({scope: \"scope.userInfo\"}) 来获取读取用户信息的权限，因为它不会跳出授权弹窗。目前只能使用上面所述的方式实现。\r\n2. 主页设计\r\n社交平台的主页大同小异，主要由三个部分组成：\r\n\r\nFeed 流\r\n消息\r\n个人信息\r\n\r\n那么很容易就能想到这样的布局（注意新建一个 Page 哦，路径：pages/circle/circle.wxml）：\r\n<view class=\"circle-container\">\r\n  <view\r\n    style=\"display:{{currentPage === 'main' ? 'block' : 'none'}}\"\r\n    class=\"main-area\"\r\n  >\r\n  </view>\r\n\r\n  <view\r\n    style=\"display:{{currentPage === 'msg' ? 'flex' : 'none'}}\"\r\n    class=\"msg-area\"\r\n  >\r\n  </view>\r\n\r\n  <view\r\n    style=\"display:{{currentPage === 'me' ? 'flex' : 'none'}}\"\r\n    class=\"me-area\"\r\n  >\r\n  </view>\r\n\r\n  <view class=\"footer\">\r\n    <view class=\"footer-item\">\r\n      <button\r\n        class=\"footer-btn\"\r\n        bindtap=\"onPageMainTap\"\r\n        style=\"background: {{currentPage === 'main' ? '#111' : 'rgba(0,0,0,0)'}}; color: {{currentPage === 'main' ? '#fff' : '#000'}}\"\r\n      >\r\n        首页\r\n      </button>\r\n    </view>\r\n    <view class=\"footer-item\">\r\n      <button\r\n        class=\"footer-btn\"\r\n        bindtap=\"onPageMsgTap\"\r\n        style=\"background: {{currentPage === 'msg' ? '#111' : 'rgba(0,0,0,0)'}}; color: {{currentPage === 'msg' ? '#fff' : '#000'}}\"\r\n      >\r\n        消息\r\n      </button>\r\n    </view>\r\n    <view class=\"footer-item\">\r\n      <button\r\n        class=\"footer-btn\"\r\n        bindtap=\"onPageMeTap\"\r\n        style=\"background: {{currentPage === 'me' ? '#111' : 'rgba(0,0,0,0)'}}; color: {{currentPage === 'me' ? '#fff' : '#000'}}\"\r\n      >\r\n        个人\r\n      </button>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码很好理解，画面主要被分为上下两个部分：上面的部分是主要内容，下面的部分是三个 Tab 组成的 Footer。重点 WXSS 实现（完整的 WXSS 可以下载源码查看）：\r\n.footer {\r\n  box-shadow: 0 0 15rpx #ccc;\r\n  display: flex;\r\n  position: fixed;\r\n  height: 120rpx;\r\n  bottom: 0;\r\n  width: 100%;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n  z-index: 100;\r\n  background: #fff;\r\n}\r\n\r\n.footer-item {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  height: 100%;\r\n  width: 33.33%;\r\n  color: #333;\r\n}\r\n\r\n.footer-item:nth-child(2) {\r\n  border-left: 3rpx solid #aaa;\r\n  border-right: 3rpx solid #aaa;\r\n  flex-grow: 1;\r\n}\r\n\r\n.footer-btn {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  border-radius: 0;\r\n  font-size: 30rpx;\r\n}\r\n复制代码核心逻辑是通过 position: fixed 来让 Footer 一直在下方。\r\n读者会发现有一个 currentPage 的 data ，这个 data 的作用其实很直观：通过判断它的值是 main/msg/me 中的哪一个来决定主要内容。同时，为了让首次使用的用户知道自己在哪个 Tab，Footer 中相应的 button 也会从白底黑字黑底白字，与另外两个 Tab 形成对比。\r\n现在我们来看看 main 部分的代码（在上面代码的基础上扩充）:\r\n...\r\n<view\r\n  class=\"main-header\"\r\n  style=\"display:{{currentPage === 'main' ? 'flex' : 'none'}};max-height:{{mainHeaderMaxHeight}}\"\r\n>\r\n  <view class=\"group-picker-wrapper\">\r\n    <picker\r\n      bindchange=\"bindGroupPickerChange\"\r\n      value=\"{{groupArrayIndex}}\"\r\n      range=\"{{groupArray}}\"\r\n      class=\"group-picker\"\r\n    >\r\n      <button class=\"group-picker-inner\">\r\n        {{groupArray[groupArrayIndex]}}\r\n      </button>\r\n    </picker>\r\n  </view>\r\n  <view class=\"search-btn-wrapper\">\r\n    <button class=\"search-btn\" bindtap=\"onSearchTap\">搜索用户</button>\r\n  </view>\r\n</view>\r\n<view\r\n  class=\"main-area\"\r\n  style=\"display:{{currentPage === 'main' ? 'block' : 'none'}};height: {{mainAreaHeight}};margin-top:{{mainAreaMarginTop}}\"\r\n>\r\n  <scroll-view scroll-y class=\"main-area-scroll\" bindscroll=\"onMainPageScroll\">\r\n    <block\r\n      wx:for=\"{{pageMainData}}\"\r\n      wx:for-index=\"idx\"\r\n      wx:for-item=\"itemName\"\r\n      wx:key=\"_id\"\r\n    >\r\n      <post-item is=\"post-item\" data=\"{{itemName}}\" class=\"post-item-wrapper\" />\r\n    </block>\r\n    <view wx:if=\"{{pageMainData.length === 0}}\" class=\"item-placeholder\"\r\n      >无数据</view\r\n    >\r\n  </scroll-view>\r\n  <button\r\n    class=\"add-poster-btn\"\r\n    bindtap=\"onAddPosterTap\"\r\n    hover-class=\"add-poster-btn-hover\"\r\n    style=\"bottom:{{addPosterBtnBottom}}\"\r\n  >\r\n    +\r\n  </button>\r\n</view>\r\n...\r\n复制代码这里用到了 列表渲染 和 条件渲染，还不清楚的可以点击进去学习一下。\r\n可以看到，相比之前的代码，我添加一个 header，同时 main-area 的内部也新增了一个 scroll-view（用于展示 Feed 流） 和一个 button（用于编辑新迷你微博）。header 的功能很简单：左侧区域是一个 picker，可以选择查看的动态类型（目前有 关注动态 和 所有动态 两种）；右侧区域是一个按钮，点击后可以跳转到搜索页面，这两个功能我们先放一下，先继续看 main-area 的新增内容。\r\nmain-area 里的 scroll-view 是一个可监听滚动事件的列表，其中监听事件的实现：\r\ndata: {\r\n  ...\r\n  addPosterBtnBottom: \"190rpx\",\r\n  mainHeaderMaxHeight: \"80rpx\",\r\n  mainAreaHeight: \"calc(100vh - 200rpx)\",\r\n  mainAreaMarginTop: \"80rpx\",\r\n},\r\nonMainPageScroll: function(e) {\r\n  if (e.detail.deltaY < 0) {\r\n    this.setData({\r\n      addPosterBtnBottom: \"-190rpx\",\r\n      mainHeaderMaxHeight: \"0\",\r\n      mainAreaHeight: \"calc(100vh - 120rpx)\",\r\n      mainAreaMarginTop: \"0rpx\"\r\n    })\r\n  } else {\r\n    this.setData({\r\n      addPosterBtnBottom: \"190rpx\",\r\n      mainHeaderMaxHeight: \"80rpx\",\r\n      mainAreaHeight: \"calc(100vh - 200rpx)\",\r\n      mainAreaMarginTop: \"80rpx\"\r\n    })\r\n  }\r\n},\r\n...\r\n复制代码结合 wxml 可以知道，当页面向下滑动 （deltaY < 0） 时，header 和 button 会 “突然消失”，反之它们则会 “突然出现”。为了视觉上有更好地过渡，我们可以在 WXSS 中使用 transition ：\r\n...\r\n.main-area {\r\n  position: relative;\r\n  flex-grow: 1;\r\n  overflow: auto;\r\n  z-index: 1;\r\n  transition: height 0.3s, margin-top 0.3s;\r\n}\r\n.main-header {\r\n  position: fixed;\r\n  width: 100%;\r\n  height: 80rpx;\r\n  background: #fff;\r\n  top: 0;\r\n  left: 0;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-items: center;\r\n  z-index: 100;\r\n  border-bottom: 3rpx solid #aaa;\r\n  transition: max-height 0.3s;\r\n  overflow: hidden;\r\n}\r\n.add-poster-btn {\r\n  position: fixed;\r\n  right: 60rpx;\r\n  box-shadow: 5rpx 5rpx 10rpx #aaa;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  color: #333;\r\n  padding-bottom: 10rpx;\r\n  text-align: center;\r\n  border-radius: 50%;\r\n  font-size: 60rpx;\r\n  width: 100rpx;\r\n  height: 100rpx;\r\n  transition: bottom 0.3s;\r\n  background: #fff;\r\n  z-index: 1;\r\n}\r\n...\r\n复制代码3. Feed 流\r\n3.1 post-item\r\n前面提到，scroll-view 的内容是 Feed 流，那么首先就要想到使用 列表渲染。而且，为了方便在个人主页复用，列表渲染中的每一个 item 都要抽象出来。这时就要使用小程序中的 Custom-Component 功能了。\r\n新建一个名为 post-item 的 Component，其中 wxml 的实现（路径：pages/circle/component/post-item/post-item.js）：\r\n<view\r\n  class=\"post-item\"\r\n  hover-class=\"post-item-hover\"\r\n  bindlongpress=\"onItemLongTap\"\r\n  bindtap=\"onItemTap\"\r\n>\r\n  <view class=\"post-title\">\r\n    <view class=\"author\" hover-class=\"author-hover\" catchtap=\"onAuthorTap\"\r\n      >{{data.author}}</view\r\n    >\r\n    <view class=\"date\">{{data.formatDate}}</view>\r\n  </view>\r\n  <view class=\"msg-wrapper\">\r\n    <text class=\"msg\">{{data.msg}}</text>\r\n  </view>\r\n  <view class=\"image-outer\" wx:if=\"{{data.photoId !== ''}}\" catchtap=\"onImgTap\">\r\n    <image-wrapper is=\"image-wrapper\" src=\"{{data.photoId}}\" />\r\n  </view>\r\n</view>\r\n复制代码可见，一个 poster-item 最主要有以下信息：\r\n\r\n作者名\r\n发送时间\r\n文本内容\r\n图片内容\r\n\r\n其中，图片内容因为是可选的，所以使用了 条件渲染，这会在没有图片信息时不让图片显示区域占用屏幕空间。另外，图片内容主要是由 image-wrapper 组成，它也是一个 Custom-Component，主要功能是：\r\n\r\n强制长宽 1:1 裁剪显示图片\r\n点击查看大图\r\n未加载完成时显示 加载中\r\n\r\n具体代码这里就不展示了，比较简单，读者可以在 component/image-wrapper 里找到。\r\n回过头看 main-area 的其他新增部分，细心的读者会发现有这么一句：\r\n<view wx:if=\"{{pageMainData.length === 0}}\" class=\"item-placeholder\"\r\n  >无数据</view\r\n>\r\n复制代码这会在 Feed 流暂时没有获取到数据时给用户一个提示。\r\n3.2 collections: poster、poster_users\r\n展示 Feed 流的部分已经编写完毕，现在就差实际数据了。根据上一小节 poster-item 的主要信息，我们可以初步推断出一条迷你微博在 云数据库 的 collection poster 里是这样存储的：\r\n{\r\n  \"username\": \"Tester\",\r\n  \"date\": \"2019-07-22 12:00:00\",\r\n  \"text\": \"Ceshiwenben\",\r\n  \"photo\": \"xxx\"\r\n}\r\n复制代码先来看 username。由于社交平台一般不会限制用户的昵称，所以如果每条迷你微博都存储昵称，那将来每次用户修改一次昵称，就要遍历数据库把所有迷你微博项都改一遍，相当耗费时间，所以我们不如存储一个 userId，并另外把 id 和 昵称 的对应关系存在另一个叫 poster_users 的 collection 里。\r\n{\r\n  \"userId\": \"xxx\",\r\n  \"name\": \"Tester\",\r\n  ...（其他用户信息）\r\n}\r\n复制代码userId 从哪里拿呢？当然是通过之前已经授权的获取用户信息接口拿到了，详细操作之后会说到。\r\n接下来是 date，这里最好是服务器时间（因为客户端传过来的时间可能会有误差），而云开发文档里也有提供相应的接口：serverDate。这个数据可以直接被 new Date() 使用，可以理解为一个 UTC 时间。\r\ntext 即文本信息，直接存储即可。\r\nphoto 则表示附图数据，但是限于小程序 image 元素的实现，想要显示一张图片，要么提供该图片的 url，要么提供该图片在 云存储 的 id，所以这里最佳的实践是：先把图片上传到云存储里，然后把回调里的文件 id 作为数据存储。\r\n综上所述，最后 poster 每一项的数据结构如下：\r\n{\r\n  \"authorId\": \"xxx\",\r\n  \"date\": \"utc-format-date\",\r\n  \"text\": \"Ceshiwenben\",\r\n  \"photoId\": \"yyy\"\r\n}\r\n复制代码确定数据结构后，我们就可以开始往 collection 添加数据了。但是，在此之前，我们还缺少一个重要步骤。\r\n3.3 用户信息录入 与 云数据库\r\n没错，我们还没有在 poster_users 里添加一条新用户的信息。这个步骤一般在 pages/circle/circle 页面首次加载时判断即可：\r\ngetUserId: function(cb) {\r\n  let that = this\r\n  var value = this.data.userId || wx.getStorageSync(\"userId\")\r\n  if (value) {\r\n    if (cb) {\r\n      cb(value)\r\n    }\r\n    return value\r\n  }\r\n  wx.getSetting({\r\n    success(res) {\r\n      if (res.authSetting[\"scope.userInfo\"]) {\r\n        wx.getUserInfo({\r\n          withCredentials: true,\r\n          success: function(userData) {\r\n            wx.setStorageSync(\"userId\", userData.signature)\r\n            that.setData({\r\n              userId: userData.signature\r\n            })\r\n            db.collection(\"poster_users\")\r\n              .where({\r\n                userId: userData.signature\r\n              })\r\n              .get()\r\n              .then(searchResult => {\r\n                if (searchResult.data.length === 0) {\r\n                  wx.showToast({\r\n                    title: \"新用户录入中\"\r\n                  })\r\n                  db.collection(\"poster_users\")\r\n                    .add({\r\n                      data: {\r\n                        userId: userData.signature,\r\n                        date: db.serverDate(),\r\n                        name: userData.userInfo.nickName,\r\n                        gender: userData.userInfo.gender\r\n                      }\r\n                    })\r\n                    .then(res => {\r\n                      console.log(res)\r\n                      if (res.errMsg === \"collection.add:ok\") {\r\n                        wx.showToast({\r\n                          title: \"录入完成\"\r\n                        })\r\n                        if (cb) cb()\r\n                      }\r\n                    })\r\n                    .catch(err => {\r\n                      wx.showToast({\r\n                        title: \"录入失败，请稍后重试\",\r\n                        image: \"/images/error.png\"\r\n                      })\r\n                      wx.navigateTo({\r\n                        url: \"/pages/index/index\"\r\n                      })\r\n                    })\r\n                } else {\r\n                  if (cb) cb()\r\n                }\r\n              })\r\n          }\r\n        })\r\n      } else {\r\n        wx.showToast({\r\n          title: \"登陆失效，请重新授权登陆\",\r\n          image: \"/images/error.png\"\r\n        })\r\n        wx.navigateTo({\r\n          url: \"/pages/index/index\"\r\n        })\r\n      }\r\n    }\r\n  })\r\n}\r\n复制代码代码实现比较复杂，整体思路是这样的：\r\n\r\n判断是否已存储了 userId，如果有直接返回并调用回调函数，如果没有继续 2\r\n通过 wx.getSetting 获取当前设置信息\r\n如果返回里有 res.authSetting[\"scope.userInfo\"] 说明已经授权读取用户信息，继续 3，没有授权的话就跳转回首页重新授权\r\n调用 wx.getUserInfo 获取用户信息，成功后提取出 signature（这是每个微信用户的唯一签名），并调用 wx.setStorageSync 将其缓存\r\n调用 db.collection().where().get() ，判断返回的数据是否是空数组，如果不是说明该用户已经录入（注意 where() 中的筛选条件），如果是说明该用户是新用户，继续 5\r\n提示新用户录入中，同时调用 db.collection().add() 来添加用户信息，最后通过回调判断是否录入成功，并提示用户\r\n\r\n不知不觉我们就使用了云开发中的 云数据库 功能，紧接着我们就要开始使用 云存储 和 云函数了！\r\n3.4 addPoster 与 云存储\r\n发送新的迷你微博，需要一个编辑新迷你微博的界面，路径我定为 pages/circle/add-poster/add-poster：\r\n<view class=\"app-poster-container\">\r\n  <view class=\"body\">\r\n    <view class=\"text-area-wrapper\">\r\n      <textarea bindinput=\"bindTextInput\" placeholder=\"在此填写\" value=\"{{text}}\" auto-focus=\"true\" />\r\n      <view class=\"text-area-footer\">\r\n        <text>{{remainLen}}/140</text>\r\n      </view>\r\n    </view>\r\n    <view bindtap=\"onImageTap\" class=\"image-area\">\r\n      <view class=\"image-outer\">\r\n        <image-wrapper is=\"image-wrapper\" src=\"{{imageSrc}}\" placeholder=\"选择图片上传\" />\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"footer\">\r\n    <button class=\"footer-btn\" bindtap=\"onSendTap\">发送</button>\r\n  </view>\r\n</view>\r\n复制代码wxml 的代码很好理解：textarea 显示编辑文本，image-wrapper 显示需要上传的图片，最下面是一个发送的 button。其中，图片编辑区域的 bindtap 事件实现：\r\nonImageTap: function() {\r\n  let that = this\r\n  wx.chooseImage({\r\n    count: 1,\r\n    success: function(res) {\r\n      const tempFilePaths = res.tempFilePaths\r\n      that.setData({\r\n        imageSrc: tempFilePaths[0]\r\n      })\r\n    }\r\n  })\r\n}\r\n复制代码直接通过 wx.chooseImage 官方 API 获取本地图片的临时路径即可。而当发送按钮点击后，会有如下代码被执行：\r\nonSendTap: function() {\r\n  if (this.data.text === \"\" && this.data.imageSrc === \"\") {\r\n    wx.showModal({\r\n      title: \"错误\",\r\n      content: \"不能发送空内容\",\r\n      showCancel: false,\r\n      confirmText: \"好的\"\r\n    })\r\n    return\r\n  }\r\n  const that = this\r\n  wx.showLoading({\r\n    title: \"发送中\",\r\n    mask: true\r\n  })\r\n  const imageSrc = this.data.imageSrc\r\n  if (imageSrc !== \"\") {\r\n    const finalPath = imageSrc.replace(\"//\", \"/\").replace(\":\", \"\")\r\n    wx.cloud\r\n      .uploadFile({\r\n        cloudPath: finalPath,\r\n        filePath: imageSrc // 文件路径\r\n      })\r\n      .then(res => {\r\n        that.sendToDb(res.fileID)\r\n      })\r\n      .catch(error => {\r\n        that.onSendFail()\r\n      })\r\n  } else {\r\n    that.sendToDb()\r\n  }\r\n},\r\nsendToDb: function(fileId = \"\") {\r\n  const that = this\r\n  const posterData = {\r\n    authorId: that.data.userId,\r\n    msg: that.data.text,\r\n    photoId: fileId,\r\n    date: db.serverDate()\r\n  }\r\n  db.collection(\"poster\")\r\n    .add({\r\n      data: {\r\n        ...posterData\r\n      }\r\n    })\r\n    .then(res => {\r\n      wx.showToast({\r\n        title: \"发送成功\"\r\n      })\r\n      wx.navigateBack({\r\n        delta: 1\r\n      })\r\n    })\r\n    .catch(error => {\r\n      that.onSendFail()\r\n    })\r\n    .finally(wx.hideLoading())\r\n}\r\n复制代码\r\n首先判断文本和图片内容是否都为空，如果是则不执行发送，如果不是继续 2\r\n提示发送中，上传图片到云存储，注意需要将图片中的临时 url 的一些特殊字符组合替换一下，原因见 文件名命名限制\r\n上传成功后，调用 db.collection().add()，发送成功后退回上一页（即首页），如果失败则执行 onSendFail 函数，后者见源码，逻辑较简单这里不赘述\r\n\r\n于是，我们就这样创建了第一条迷你微博。接下来就让它在 Feed 流中显示吧！\r\n3.5 云函数 getMainPageData\r\n这个函数的主要作用如前所述，就是通过处理云数据库中的数据，将最终数据返回给客户端，后者将数据可视化给用户。我们先做一个初步版本，因为现在 poster_users 中只有一条数据，所以仅先展示自己的迷你微博。getMainPageData 云函数代码如下：\r\n// 云函数入口文件\r\nconst cloud = require(\"wx-server-sdk\")\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context, cb) => {\r\n  // 通过 event 获取入参\r\n  const userId = event.userId\r\n  let followingResult\r\n  let users\r\n  // idNameMap 负责存储 userId 和 name 的映射关系\r\n  let idNameMap = {}\r\n  let followingIds = []\r\n  // 获取用户信息\r\n  followingResult = await db\r\n      .collection(\"poster_users\")\r\n      .where({\r\n        userId: userId\r\n      })\r\n      .get()\r\n    users = followingResult.data\r\n    followingIds = users.map(u => {\r\n      return u.userId\r\n    })\r\n  users.map(u => {\r\n    idNameMap[u.userId] = u.name\r\n  })\r\n  // 获取动态\r\n  const postResult = await db\r\n    .collection(\"poster\")\r\n    .orderBy(\"date\", \"desc\")\r\n    .where({\r\n      // 通过高级筛选功能筛选出符合条件的 userId\r\n      authorId: db.command.in(followingIds)\r\n    })\r\n    .get()\r\n  const postData = postResult.data\r\n  // 向返回的数据添加 存储用户昵称的 author 属性、存储格式化后的时间的 formatDate 属性\r\n  postData.map(p => {\r\n    p.author = idNameMap[p.authorId]\r\n    p.formatDate = new Date(p.date).toLocaleDateString(\"zh-Hans\", options)\r\n  })\r\n  return postData\r\n}\r\n复制代码最后在 pages/circle/circle.js 里补充云调用：\r\ngetMainPageData: function(userId) {\r\n  const that = this\r\n  wx.cloud\r\n    .callFunction({\r\n      name: \"getMainPageData\",\r\n      data: {\r\n        userId: userId,\r\n        isEveryOne: that.data.groupArrayIndex === 0 ? false : true\r\n      }\r\n    })\r\n    .then(res => {\r\n      that.setData({\r\n        pageMainData: res.result,\r\n        pageMainLoaded: true\r\n      })\r\n    })\r\n    .catch(err => {\r\n      wx.showToast({\r\n        title: \"获取动态失败\",\r\n        image: \"/images/error.png\"\r\n      })\r\n      wx.hideLoading()\r\n    })\r\n}\r\n复制代码即可展示 Feed 流数据给用户。\r\n之后，getMainPageData 还会根据使用场景的不同，新增了查询所有用户动态、查询关注用户动态的功能，但是原理是一样的，看源码可以轻易理解，后续就不再说明。\r\n4. 关注系统\r\n上一节中我们一口气把云开发中的大部分主要功能：云数据库、云存储、云函数、云调用都用了一遍，接下来其他功能的实现也基本都依赖它们。\r\n4.1 poster_user_follows\r\n首先我们需要建一个新的 collection poster_user_follows，其中的每一项数据的数据结构如下：\r\n{\r\n  \"followerId\": \"xxx\",\r\n  \"followingId\": \"xxx\"\r\n}\r\n复制代码很简单，followerId 表示关注人，followingId 表示被关注人。\r\n4.2 user-data 页面\r\n关注或者取消关注需要进入他人的个人主页操作，我们在 pages/circle/user-data/user-data.wxml 中放一个 user-info 的自定义组件，然后新建该组件编辑：\r\n<view class=\"user-info\">\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\">用户名: {{userName}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" bindtap=\"onPosterCountTap\">动态数: {{posterCount}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" bindtap=\"onFollowingCountTap\">关注数: {{followingCount}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" bindtap=\"onFollowerCountTap\">粉丝数: {{followerCount}}</view>\r\n  <view class=\"info-item\" hover-class=\"info-item-hover\" wx:if=\"{{originId && originId !== '' && originId !== userId}}\"><button bindtap=\"onFollowTap\">{{followText}}</button></view>\r\n</view>\r\n复制代码这里注意条件渲染的 button：如果当前访问个人主页的用户 id （originId） 和 被访问的用户 id （userId）的值是相等的话，这个按钮就不会被渲染（自己不能关注/取消关注自己）。\r\n我们重点看下 onFollowTap 的实现：\r\nonFollowTap: function() {\r\n  const that = this\r\n  // 判断当前关注状态\r\n  if (this.data.isFollow) {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    wx.cloud\r\n      .callFunction({\r\n        name: \"cancelFollowing\",\r\n        data: {\r\n          followerId: this.properties.originId,\r\n          followingId: this.properties.userId\r\n        }\r\n      })\r\n      .then(res => {\r\n        wx.showToast({\r\n          title: \"取消关注成功\"\r\n        })\r\n        that.setData({\r\n          isFollow: false,\r\n          followText: \"关注\"\r\n        })\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"取消关注失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n  } else if (this.data.isFollow !== undefined) {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    const data = {\r\n      followerId: this.properties.originId,\r\n      followingId: this.properties.userId\r\n    }\r\n    db.collection(\"poster_user_follows\")\r\n      .add({\r\n        data: {\r\n          ...data\r\n        }\r\n      })\r\n      .then(res => {\r\n        wx.showToast({\r\n          title: \"关注成功\"\r\n        })\r\n        that.setData({\r\n          isFollow: true,\r\n          followText: \"取消关注\"\r\n        })\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"关注失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n    }\r\n  }\r\n}\r\n复制代码这里读者可能会有疑问：为什么关注的时候直接调用 db.collection().add() 即可，而取消关注却要调用云函数呢？这里涉及到云数据库的设计问题：删除多个数据的操作，或者说删除使用 where 筛选的数据，只能在服务端执行。如果确实想在客户端删除，则在查询用户关系时，将唯一标识数据的 _id 用 setData 存下来，之后再使用 db.collection().doc(_id).delete() 删除即可。这两种实现方式读者可自行选择。当然，还有一种实现是不实际删除数据，只是加个 isDelete 字段标记一下。\r\n查询用户关系的实现很简单，云函数的实现方式如下：\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  const followingResult = await db.collection(\"poster_user_follows\")\r\n    .where({\r\n      followingId: event.followingId,\r\n      followerId: event.followerId\r\n    }).get()\r\n  return followingResult\r\n}\r\n复制代码客户端只要检查返回的数据长度是否大于 0 即可。\r\n另外附上 user-data 页面其他数据的获取云函数实现：\r\n// 云函数入口文件\r\nconst cloud = require(\"wx-server-sdk\")\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\nasync function getPosterCount(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster\").where({\r\n      authorId: userId\r\n    }).count()).total,\r\n    key: \"posterCount\"\r\n  }\r\n}\r\n\r\nasync function getFollowingCount(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster_user_follows\").where({\r\n      followerId: userId\r\n    }).count()).total,\r\n    key: \"followingCount\"\r\n  }\r\n}\r\n\r\nasync function getFollowerCount(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster_user_follows\").where({\r\n      followingId: userId\r\n    }).count()).total,\r\n    key: \"followerCount\"\r\n  }\r\n}\r\n\r\n\r\nasync function getUserName(userId) {\r\n  return {\r\n    value: (await db.collection(\"poster_users\").where({\r\n      userId: userId\r\n    }).get()).data[0].name,\r\n    key: \"userName\"\r\n  }\r\n}\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const userId = event.userId\r\n  const tasks = []\r\n  tasks.push(getPosterCount(userId))\r\n  tasks.push(getFollowerCount(userId))\r\n  tasks.push(getFollowingCount(userId))\r\n  tasks.push(getUserName(userId))\r\n  const allData = await Promise.all(tasks)\r\n  const finalData = {}\r\n  allData.map(d => {\r\n    finalData[d.key] = d.value\r\n  })\r\n  return finalData\r\n}\r\n复制代码很好理解，客户端获取返回后直接使用即可。\r\n5. 搜索页面\r\n这部分其实很好实现。关键的搜索函数实现如下：\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\nconst MAX_LIMIT = 100\r\nasync function getDbData(dbName, whereObj) {\r\n  const totalCountsData = await db.collection(dbName).where(whereObj).count()\r\n  const total = totalCountsData.total\r\n  const batch = Math.ceil(total / 100)\r\n  const tasks = []\r\n  for (let i = 0; i < batch; i++) {\r\n    const promise = db\r\n      .collection(dbName)\r\n      .where(whereObj)\r\n      .skip(i * MAX_LIMIT)\r\n      .limit(MAX_LIMIT)\r\n      .get()\r\n    tasks.push(promise)\r\n  }\r\n  const rrr = await Promise.all(tasks)\r\n  if (rrr.length !== 0) {\r\n    return rrr.reduce((acc, cur) => {\r\n      return {\r\n        data: acc.data.concat(cur.data),\r\n        errMsg: acc.errMsg\r\n      }\r\n    })\r\n  } else {\r\n    return {\r\n      data: [],\r\n      errMsg: \"empty\"\r\n    }\r\n  }\r\n}\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const text = event.text\r\n  const data = await getDbData(\"poster_users\", {\r\n    name: {\r\n      $regex: text\r\n    }\r\n  })\r\n  return data\r\n}\r\n复制代码这里参考了官网所推荐的分页检索数据库数据的实现（因为搜索结果可能有很多），筛选条件则是正则模糊匹配关键字。\r\n搜索页面的源码路径是 pages/circle/search-user/search-user，实现了点击搜索结果项跳转到对应项的用户的 user-data 页面，建议直接阅读源码理解。\r\n6. 其他扩展\r\n6.1 poster_likes 与 点赞\r\n由于转发、评论、点赞的原理基本相同，所以这里只介绍点赞功能如何编写，另外两个功能读者可以自行实现。\r\n毫无疑问我们需要新建一个 collection poster_likes，其中每一项的数据结构如下：\r\n{\r\n  \"posterId\": \"xxx\",\r\n  \"likeId\": \"xxx\"\r\n}\r\n复制代码这里的 posterId 就是 poster collection 里每条记录的 _id 值，likeId 就是 poster_users 里的 userId 了。\r\n然后我们扩展一下 poster-item 的实现：\r\n<view class=\"post-item\" hover-class=\"post-item-hover\" bindlongpress=\"onItemLongTap\" bindtap=\"onItemTap\">\r\n  ...\r\n  <view class=\"interact-area\">\r\n    <view class=\"interact-item\">\r\n      <button class=\"interact-btn\" catchtap=\"onLikeTap\" style=\"color:{{liked ? '#55aaff' : '#000'}}\">赞 {{likeCount}}</button>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码即，新增一个 interact-area，其中 onLikeTap 实现如下：\r\nonLikeTap: function() {\r\n  if (!this.properties.originId) return\r\n  const that = this\r\n  if (this.data.liked) {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    wx.cloud\r\n      .callFunction({\r\n        name: \"cancelLiked\",\r\n        data: {\r\n          posterId: this.properties.data._id,\r\n          likeId: this.properties.originId\r\n        }\r\n      })\r\n      .then(res => {\r\n        wx.showToast({\r\n          title: \"取消成功\"\r\n        })\r\n        that.refreshLike()\r\n        that.triggerEvent('likeEvent');\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"取消失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n  } else {\r\n    wx.showLoading({\r\n      title: \"操作中\",\r\n      mask: true\r\n    })\r\n    db.collection(\"poster_likes\").add({\r\n        data: {\r\n          posterId: this.properties.data._id,\r\n          likeId: this.properties.originId\r\n        }\r\n      }).then(res => {\r\n        wx.showToast({\r\n          title: \"已赞\"\r\n        })\r\n        that.refreshLike()\r\n        that.triggerEvent('likeEvent');\r\n      })\r\n      .catch(error => {\r\n        wx.showToast({\r\n          title: \"赞失败\",\r\n          image: \"/images/error.png\"\r\n        })\r\n      })\r\n      .finally(wx.hideLoading())\r\n  }\r\n\r\n}\r\n复制代码细心的读者会发现这和关注功能原理几乎是一样的。\r\n6.2 数据刷新\r\n我们可以使用很多方式让主页面刷新数据：\r\nonShow: function() {\r\n  wx.showLoading({\r\n    title: \"加载中\",\r\n    mask: true\r\n  })\r\n  const that = this\r\n  function cb(userId) {\r\n    that.refreshMainPageData(userId)\r\n    that.refreshMePageData(userId)\r\n  }\r\n  this.getUserId(cb)\r\n}\r\n复制代码第一种是利用 onShow 方法：它会在页面每次从后台转到前台展示时调用，这个时候我们就能刷新页面数据（包括 Feed 流和个人信息）。但是这个时候用户信息可能会丢失，所以我们需要在 getUserId 里判断，并将刷新数据的函数们整合起来，作为回调函数。\r\n第二种是让用户手动刷新：\r\nonPageMainTap: function() {\r\n  if (this.data.currentPage === \"main\") {\r\n    this.refreshMainPageData()\r\n  }\r\n  this.setData({\r\n    currentPage: \"main\"\r\n  })\r\n}\r\n复制代码如图所示，当目前页面是 Feed 流时，如果再次点击 首页 Tab，就会强制刷新数据。\r\n第三种是关联数据变更触发刷新，比如动态类型选择、删除了一条动态以后触发数据的刷新。这种可以直接看源码学习。\r\n6.3 首次加载等待\r\n当用户第一次进入主页面时，我们如果想在 Feed 流和个人信息都加载好了再允许用户操作，应该如何实现？\r\n如果是类似 Vue 或者 React 的框架，我们很容易就能想到属性监控，如 watch、useEffect 等等，但是小程序目前 Page 并没有提供属性监控功能，怎么办？\r\n除了自己实现，还有一个方法就是利用 Component 的 observers，它和上面提到的属性监控功能差不多。虽然官网文档对其说明比较少，但摸索了一番还是能用来监控的。\r\n首先我们来新建一个 Component 叫 abstract-load，具体实现如下：\r\n// pages/circle/component/abstract-load.js\r\nComponent({\r\n  properties: {\r\n    pageMainLoaded: {\r\n      type: Boolean,\r\n      value: false\r\n    },\r\n    pageMeLoaded: {\r\n      type: Boolean,\r\n      value: false\r\n    }\r\n  },\r\n  observers: {\r\n    \"pageMainLoaded, pageMeLoaded\": function (pageMainLoaded, pageMeLoaded) {\r\n      if (pageMainLoaded && pageMeLoaded) {\r\n        this.triggerEvent(\"allLoadEvent\")\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码然后在 pages/circle/circle.wxml 中添加一行：\r\n<abstract-load is=\"abstract-load\" pageMainLoaded=\"{{pageMainLoaded}}\" pageMeLoaded=\"{{pageMeLoaded}}\" bind:allLoadEvent=\"onAllLoad\" />\r\n复制代码最后实现 onAllLoad 函数即可。\r\n另外，像这种没有实际展示数据的 Component，建议在项目中都用 abstract 开头来命名。\r\n6.4 scroll-view 在 iOS 的 bug\r\n如果读者使用 iOS 系统调试这个小程序，可能会发现 Feed 流比较短的时候，滚动 scroll-view header 和 button 会有鬼畜的上下抖动现象，这是因为 iOS 自己实现的 WebView 对于滚动视图有回弹的效果，而该效果也会触发滚动事件。\r\n对于这个 bug，官方人员也表示暂时无法修复，只能先忍一忍了。\r\n6.5 关于消息 Tab\r\n读者可能会疑惑我为什么没有讲解消息 Tab 以及消息提醒的实现。首先是因为源码没有这个实现，其次是我觉得目前云开发所提供的能力实现主动提醒比较麻烦（除了轮询想不到其他办法）。\r\n希望未来云开发可以提供 数据库长连接监控 的功能，这样通过订阅者模式可以很轻松地获取到数据更新的状态，主动提醒也就更容易实现了。到那时我可能会再更新相关源码。\r\n6.6 关于云函数耗时\r\n读者可能会发现我有一个叫 benchmark 的云函数，这个函数只是做了个查询数据库的操作，目的在于计算查询耗时。\r\n诡异的是，我前天在调试的时候，发现查询一次需要1秒钟，而写这篇文章时却不到100ms。建议在一些需要多次操作数据库的函数配置里，把超时时间设置长一点吧。目前云函数的性能不太稳定。\r\n7. 结语\r\n那么关于迷你版微博开发实战介绍就到此为止了，更多资料可以直接下载源码查看哦。\r\n源码链接\r\ngithub.com/TencentClou…"}
{"title": "微信小程序动画：高度渐变，left渐变 ", "author": "Rolan", "pub_time": "2019-8-9 00:32", "content": "今天在测试微信小程序动画的时候遇到了坑，需求是这样的点击时子元素从外部滑动回来，父元素的高度跟随子元素的高度改变。 　　实现子元素left为0并不复杂，但是改变父元素box的高度的时候却遇到了坑，因为是需要跟随子元素right的高度来改变父元素box的高度的，并且子元素right的高度不确定，我们需要先获取子元素的高度。　　在改变高度的时候出错了，高度未改变。在测试时发现12345678910var box = wx.createAnimation(option); // 创建动画var obj = wx.createSelectorQuery();obj.select('.anr').boundingClientRect(function (rect) {//获取子元素高度  box.height(rect.height).step();//改变父元素高度  console.log(1);}).exec();console.log(2);that.setData({  box: box.export()});　　先打印的竟然是2，原来是一个异步操作，这就可以理解为什么执行无效了。改成这样1234567obj.select('.anr').boundingClientRect(function (rect) {//获取子元素高度  var box = wx.createAnimation(option); // 创建动画  box.height(rect.height).step();//改变父元素高度  that.setData({    box: box.export()  });}).exec();　　想着应该没问题了，但是遇到了另外一个坑，父元素的高度一下子变成了预设的效果，并没有Animation的渐变效果。本身父元素的高度是由left这个子元素撑起来的，给父元素预设一个高度这个问题就解决了。渐变效果就实现了。 　　源码解析wxml123456<view class=\"box\" animation=\"{{box}}\">  <view class=\"anl\">left</view>  <view class=\"anr\" animation=\"{{anr}}\">right</view></view><button bindtap=\"add\" wx:if=\"{{down}}\">goDown</button><button bindtap=\"goback\" wx:else>goBack</button>　wxss12345678910111213141516171819202122232425/* pages/userinfo/index.wxss */.box{  position: relative;  height: 200rpx;  overflow: hidden;  text-align: center;  color: white;  font-size: 120rpx;}.anl{  height: 200rpx;  background-color: red;}.anr{  background-color: green;  height: 400rpx;  width: 100%;  position: absolute;  left: 100%;  top: 0;}.add{  background-color: yellow;  height: 100rpx;}　　js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// pages/userinfo/index.jsPage({   /**   * 页面的初始数据   */  data: {    box: {},    anr: {},    down:true  },  add: function () {    this.setData({      down: false    });    var that = this;    let option = {      duration: 1000, // 动画执行时间      timingFunction: 'ease-in' // 动画执行效果    };    var anr = wx.createAnimation(option);// 创建动画    this.anr=anr;    anr.left(0).step();    that.setData({      anr: anr.export()    });    var obj = wx.createSelectorQuery();    obj.select('.anr').boundingClientRect(function (rect) {//获取子元素高度      var box = wx.createAnimation(option); // 创建动画      that.box=box;      box.height(rect.height).step();//改变父元素高度      that.setData({        box: box.export()      });    }).exec();  },  goback:function(){    this.setData({      down:true    });    this.box.height('200rpx').step();    this.setData({      box:this.box.export()    });    this.anr.left('750rpx').step();    this.setData({      anr:this.anr.export()    })  }})"}
{"title": "微信小程序常用样式汇总 ", "author": "Rolan", "pub_time": "2019-6-17 00:13", "content": "小程序特点：用完即走、低频使用、性能要求低，不支持webview；以iphone6尺寸（750*1334）为视觉稿进行设计；iphone6下1px=1rpx=0.5pt     iphone6 plux下1px=0.6rpx；使用rpx，小程序会自动在不同的分辨率下进行转换，而使用px为单位不会；1.设置全局字体样式app.wxss：text{\r\nfont-family:MicroSoft yahei;\r\n}2.设置弹性盒子模型：.container{\r\n/*弹性模型*/\r\ndisplay:flex;\r\n/*垂直方向 列方向 排布*/\r\nflex-direction:column;\r\n/*居中*/\r\nalign-items:center;\r\n/*要从整体解决排布的问题是最好的方案*/\r\n}3.设置页面全屏样式及背景色：page{\r\nheight:100%;\r\nbackground:#b3d4db;\r\n}4.全局设置导航条颜色app.json：\"window\": {\r\n\"navigationBarBackgroundColor\": \"#405f80\"\r\n}5.页面设置导航条颜色和标题*.json:{\r\n\"navigationBarBackgroundColor\": \"#405f80\",\r\n\"navigationBarTitleText\":\"文与字\"\r\n}6.设置字体属性：.user-name{\r\nfont-size:32rpx;\r\nfont-weight:bold;\r\n}7.创建圆角矩形边框：.moto-container{\r\nborder:1px solid #405f80;\r\nwidth:200rpx;\r\nheight:80rpx;\r\nborder-radius:5rpx;\r\ntext-align:center;\r\n}8.外边距设置：margin-top:20rpx;\r\nmargin-bottom:40rpx;9.内边距设置：padding-bottom:20rpx;10.上、下边线设置：border-bottom:1px solid #ededed;\r\nborder-top:1px solid #ededed;11.文字间距设置：letter-spacing:2rpx;12.垂直居中（此元素放置在父元素的中部）：vertical-align: middle; 13.设置子元素Image样式：.circle-img image{\r\n    width:90rpx;\r\n    height: 90rpx\r\n}14.最底层垂直居中横线样式：.horizon{\r\n    width:660rpx;\r\n    height: 2rpx;\r\n    background-color: #e5e5e5;\r\n    vertical-align: middle;\r\n    position:relative;\r\n    top:46rpx;\r\n    margin: 0 auto;\r\n    z-index: -99\r\n}15.图片居中覆盖:.audio{\r\n    width:102rpx;\r\n    height:110rpx;\r\n    position: absolute;\r\n    left: 50%;\r\n    margin-left: -51rpx;//经典水平居中方式\r\n    top:180rpx;\r\n    margin-top: 20rpx;\r\n    opacity:0.6;//透明度\r\n}"}
{"title": "小程序登录数据解密 ", "author": "Rolan", "pub_time": "2019-6-19 00:13", "content": "小程序开发中，需要用户授权登陆并获取用户的数据，快速对接用户系统。openId与unionid的区别openId : 用户在当前小程序的唯一标识 unionId : 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionId是相同的。详情登录微信开放平台(open.weixin.qq.com) 。GET  https://api.weixin.qq.com/sns/jscode2session?appid=xx&secret=xx&js_code=xx&grant_type=authorization_code\r\n\r\n属性类型默认值必填说明\r\nappid    string    是    小程序 appId    \r\nsecret    string    是    小程序 appSecret    \r\njs_code    string    是    登录时获取的 code    \r\ngrant_type    string    是    授权类型，此处只需填写 authorization_code    \r\n\r\n\r\nObject\r\n返回的 JSON 数据包\r\n属性类型说明\r\nopenid    string    用户唯一标识    \r\nsession_key    string    会话密钥    \r\nunionid    string    用户在开放平台的唯一标识符，在满足 UnionID 下发条件的情况下会返回，详见 UnionID 机制说明。    \r\nerrcode    number    错误码    \r\nerrmsg    string    错误信息解密类class WxBizDataCrypt\r\n{\r\n    private $appid;\r\n    private $sessionKey;\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param $sessionKey string 用户在小程序登录后获取的会话密钥\r\n     * @param $appid string 小程序的appid\r\n     */\r\n    public function __construct( $appid, $sessionKey)\r\n    {\r\n        $this->sessionKey = $sessionKey;\r\n        $this->appid = $appid;\r\n    }\r\n\r\n\r\n    /**\r\n     * 检验数据的真实性，并且获取解密后的明文.\r\n     * @param $encryptedData string 加密的用户数据\r\n     * @param $iv string 与用户数据一同返回的初始向量\r\n     * @param $data string 解密后的原文\r\n     *\r\n     * @return int 成功0，失败返回对应的错误码\r\n     */\r\n    public function decryptData( $encryptedData, $iv, &$data )\r\n    {\r\n        if (strlen($this->sessionKey) != 24) {\r\n            return ErrorCode::$IllegalAesKey;\r\n        }\r\n        $aesKey=base64_decode($this->sessionKey);\r\n\r\n\r\n        if (strlen($iv) != 24) {\r\n            return ErrorCode::$IllegalIv;\r\n        }\r\n        $aesIV=base64_decode($iv);\r\n\r\n        $aesCipher=base64_decode($encryptedData);\r\n\r\n        $result=openssl_decrypt( $aesCipher, \"AES-128-CBC\", $aesKey, 1, $aesIV);\r\n\r\n        $dataObj=json_decode( $result );\r\n        if( $dataObj  == NULL )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        if( $dataObj->watermark->appid != $this->appid )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        $data = $result;\r\n        return ErrorCode::$OK;\r\n    }\r\n}代码如下仅供参考转载时请注明出处及相应链接，本文永久地址：https://blog.yayuanzi.com/25402.html"}
{"title": "一种让小程序支持JSX语法的新思路 ", "author": "Rolan", "pub_time": "2019-6-17 00:01", "content": "React 社区一直在探寻使用 React 语法开发小程序的方式，其中比较著名的项目有 Taro ， nanachi 。而使用 React 语法开发小程序的难点主要就是在 JSX 语法上， JSX 本质上是 JS ，相比于小程序静态模版来说太灵活。本文所说的新思路就是在处理 JSX 语法上的新思路，这是一种更加动态的处理思路，相比于现有方案，基本上不会限制任何 JSX 的写法，让你以 真正的React方式 处理小程序，希望这个新思路可以给任何有志于用 React 开发小程序的人带来启发。现有思路的局限在介绍新的思路之前，我们先来看下 Taro（最新版1.3） ， nanachi 是怎么在小程序端处理 JSX 语法的。简单来说，主要是通过在 编译阶段 把 JSX 转化为等效的小程序 wxml 来把 React代码运行在小程序端的。举个例子，比如 React 逻辑表达式：xx && <Text>Hello</Text>将会被转化为等效的小程序wx:if指令：<Text wx:if=\"{{xx}}\">Hello</Text>这种方式把对 JSX 的处理，主要放在了 编译阶段 ，他依赖于 编译阶段 的 信息 收集，以上面为例，它必须识别出逻辑表达式，然后做对应的 wx:if 转换处理。那 编译阶段 有什么问题和局限呢？我们以下面的例子说明：class App extends React.Component {\r\n    render () {\r\n        const a = <Text>Hello</Text>\r\n        const b = a\r\n\r\n        return (\r\n            <View>\r\n                {b}\r\n            </View>\r\n        )\r\n    }\r\n}首先我们声明 const a = <Text>Hello</Text> ，然后把 a 赋值给了 b ，我们看下最新版本 Taro 1.3 的转换，如下图：这个例子不是特别复杂，却报错了。要想理解上面的代码为什么报错，我们首先要理解 编译阶段 。本质上来说在编译阶段，代码其实就是‘字符串’，而 编译阶段 处理方案，就需要从这个‘字符串’中分析出必要的信息（通过 AST，正则等方式）然后做对应的等效转换处理。而对于上面的例子，需要做什么等效处理呢？需要我们在 编译阶段 分析出 b 是 JSX 片段： b = a = <Text>Hello</Text> ，然后把 <View>{b}</View> 中的 {b} 等效替换为 <Text>Hello</Text> 。然而在 编译阶段 要想确定 b 的值是很困难的，有人说可以往前追溯来确定b的值，也不是不可以，但是考虑一下 由于 b = a ，那么就先要确定 a 的值，这个 a 的值怎么确定呢？需要在 b 可以访问到的作用域链中确定 a ，然而 a 可能又是由其他变量赋值而来，循环往复，期间一旦出现不是简单赋值的情况，比如函数调用，三元判断等运行时信息，追溯就宣告失败，要是 a 本身就是挂在全局对象上的变量，追溯就更加无从谈起。所以在 编译阶段 是无法简单确定 b 的值的。我们再仔细看下上图的报错信息： a is not defined 。为什么说 a 未定义呢？这是涉及到另外一个问题，我们知道 <Text>Hello</Text> ，其实等效于 React.createElement(Text, null, 'Hello') ，而 React.createElement 方法的返回值就是一个普通 JS 对象，形如// ReactElement对象\r\n{\r\n   tag: Text,\r\n   props: null,\r\n   children: 'Hello'\r\n   ...\r\n}所以上面那一段代码在 JS 环境真正运行的时候，大概等效如下：class App extends React.Component {\r\n    render () {\r\n        const a = {\r\n            tag: Text,\r\n            props: null,\r\n            children: 'Hello'\r\n            ...\r\n        }\r\n        const b = a\r\n\r\n        return {\r\n            tag: View,\r\n            props: null,\r\n            children: b\r\n            ...\r\n        }\r\n    }\r\n}但是，我们刚说了编译阶段需要对 JSX 做等效处理，需要把 JSX 转换为 wxml ，所以 <Text>Hello</Text> 这个 JSX 片段被特殊处理了， a 不再是一个普通 js 对象，这里我们看到 a 变量甚至丢失了，这里暴露了一个很严重的问题： 代码语义被破坏了 ，也就是说由于编译时方案对 JSX 的特殊处理，真正运行在小程序上的代码语义并不是你的预期。这个是比较头疼。新的思路正因为 编译时 方案，有如上的限制，在使用的时候常常让你有“我还是在写 React 吗？”这种感觉。下面我们介绍一种全新的处理思路，这种思路在小程序运行期间和真正的 React 几无区别，不会改变任何代码语义， JSX 表达式只会被处理为 React.createElement 方法调用，实际运行的时候就是普通 js 对象，最终通过其他方式渲染出小程序视图。下面我们仔细说明一下这个思路的具体内容。第一步：给每个独立的 JSX 片段打上唯一标识 uuid ，假定我们有如下代码：const a = <Text uuid=\"000001\">Hello</Text>\r\n\r\nconst y = <View uuid=\"000002\">\r\n    <Image/>\r\n    <Text/>\r\n</View>我们给 a 片段， y 片段 添加了 uuid 属性第二步：把 React 代码通过 babel 转义为小程序可以识别的代码，例如 JSX 片段用等效的 React.createElement 替换等const a = React.createElement(Text, {\r\n  uuid: \"000001\"\r\n}, \"Hello\");第三步：提取每个独立的 JSX 片段，用小程序 template 包裹，生成 wxml 文件<template name=\"000001\">\r\n    <Text>Hello</Text>\r\n</template>\r\n\r\n<template name=\"000002\">\r\n    <View uuid=\"000002\">\r\n        <Image/>\r\n        <Text/>\r\n    </View>\r\n</template>\r\n\r\n\r\n<!--占位template-->\r\n<template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/>注意这里每一个 template 的 name 标识和 JSX 片段的唯一标识 uuid 是一样的。最后，需要在结尾生成一个占位模版： <template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/> 。第四步：修改 ReactDOM.render 的递归（ React 16.x 之后，不在是递归的方式）过程，递归执行阶段，聚合 JSX 片段的 uuid 属性，生成并返回 uiDes 数据结构。第五步：把第四步生成的 uiDes ，传递给小程序环境，小程序把 uiDes 设置给占位模版 <template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/> ，渲染出最终的视图。我们以上面的 App 组件的例子来说明整个过程，首先 js 代码会被转义为：class App extends React.Component {\r\n    render () {\r\n        const a = React.createElement(Text, {uuid: \"000001\"}, \"Hello\");\r\n        const b = a\r\n        \r\n        return (\r\n          React.createElement(View, {uuid: \"000002\"} , b);\r\n        )\r\n      }\r\n}同时生成 wxml 文件：<template name=\"000001\">\r\n    <Text>Hello</Text>\r\n</template>\r\n\r\n<template name=\"000002\">\r\n    <View>\r\n        <template is=\"{{child0001.name}}\" data=\"{{...child0001}}\"/>\r\n    </View>\r\n</template>\r\n\r\n<!--占位template-->\r\n<template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/>使用我们定制之后 render 执行 ReactDOM.render(<App/>, parent) 。在 render 的递归过程中，除了会执行常规的创建组件实例，执行生命周期之外，还会额外的收集执行过程中组件的 uuid 标识，最终生成 uiDes 对象const uiDes = {\r\n    name: \"000002\",\r\n    \r\n    child0001: {\r\n           name: 000001,\r\n           ...\r\n   }\r\n   \r\n   ...\r\n}小程序获取到这个 uiDes ，设置给占位模版 <template is=\"{{uiDes.name}}\" data=\"{{...uiDes}}\"/> 。 最终渲染出小程序视图。在这整个过程中，你的所有 JS 代码都是运行在 React过程 中的， 语义完全一致 ， JSX 片段也不会被任何特殊处理，只是简单的 React.createElement 调用，另外由于这里的 React过程 只是纯 js 运算，执行是非常迅速的，通常只有几ms。最终会输出一个 uiDes 数据到小程序，小程序通过这个 uiDes 渲染出视图。现在我们在看之前的赋值 const b = a ，就不会有任何问题了，因为 a 不过是普通对象。另外对于常见的 编译时方案的限制 ，比如任意函数返回 JSX 片段，动态生成 JSX 片段， for 循环使用 JSX 片段等等，都可以完全解除了，因为 JSX 片段只是 js 对象，你可以做任何操作，最终 ReactDOM.render 会搜集所有 执行结果的片段 的 uuid 标识，生成 uiDes ，而小程序会根据这个 uiDes 数据结构渲染出最终视图。可以看出这种新的思路和以前 编译时 方案还是有很大的区别的，对 JSX 片段的处理是动态的，你可以在任何地方，任何函数出现任何 JSX 片段, 最终执行结果会确定渲染哪一个片段，只有执行结果的片段的 uuid 会被写入 uiDes 。这和 编译时 方案的静态识别有着本质的区别。结语\"Talk is cheap. Show me your code！\" 这仅仅是一个思路？还是已经有落地完整的实现呢？是有完整的实现的， alita 项目在处理 JSX 语法的时候，采用的就是这个思路，这也是 alita 基本不限制写法却可以转化整个React Native项目的原因，另外 alita 在这个思路上做了很多优化。如果对这个思路的具体实现有兴趣，可以去研读一下 alita 源码，它完全是开源的 https://github.com/areslabs/alita 。当然，你也可以基于这个思路，构造出自己的 React小程序开发方案 。"}
{"title": "小程序多图上传并压缩,带预览删除功能 ", "author": "Rolan", "pub_time": "2019-6-17 00:42", "content": "<view class=\"upload_view\">　　<block wx:for=\"{{pics}}\" wx:key=\"*this\">\r\n　　　　<view class=\"q_image_wrap\">\r\n　　　　　　<!-- 图片缩略图  -->\r\n　　　　　　<image class=\"q_image\" src=\"{{item}}\" mode=\"aspectFill\" data-idx=\"{{index}}\" bindtap=\"handleImagePreview\"></image>\r\n　　　　　　<!-- 移除图片的按钮  -->\r\n　　　　　　<view class=\"q_image_remover\" data-idx=\"{{index}}\" bindtap=\"removeImage\">\r\n　　　　　　　　<i-icon type=\"close\" size=\"14\" class=\"icon\" />\r\n　　　　　　</view>\r\n　　　　</view>　　</block>\r\n　　<view class='uploadImg_btn' bindtap=\"chooseImage\" wx:if=\"{{pics.length < 9}}\">\r\n　　　　<image src=\"../../img/upload.png\"></image>\r\n　　</view>\r\n</view> //选择图片\r\n    chooseImage(e) {\r\n        console.log(e)\r\n        var that = this;\r\n        var pics = this.data.pics;\r\n        //---------------------多张上传----------------------------------------------------------------------------------------\r\n        wx.chooseImage({\r\n            count: 9 - pics.length, // 最多可以选择的图片张数，默认9\r\n            sizeType: ['original', 'compressed'], // original 原图，compressed 压缩图，默认二者都有\r\n            sourceType: ['album', 'camera'], // album 从相册选图，camera 使用相机，默认二者都有\r\n            success: function (photo) {\r\n                //图片大小，限制10M以内\r\n                for (var i = 0; i < photo.tempFiles.length; i++) {\r\n                    if (photo.tempFiles[i].size >= 10 * 1024 * 1024) {\r\n                        console.log('请上传10M以内的图片');\r\n                        return;\r\n                    }\r\n                }\r\n                var imgsrc = photo.tempFilePaths;\r\n                //页面上展示的是原图片========pics数组\r\n                pics = pics.concat(imgsrc);\r\n                that.setData({\r\n                    pics: pics\r\n                });\r\n                console.log(that.data.pics)\r\n                that.getCanvasImg(0, 0, photo.tempFilePaths);  //进行压缩\r\n            },\r\n            fail: function () {\r\n                // fail\r\n            },\r\n            complete: function () {\r\n                // complete\r\n            }\r\n        })\r\n    }, //压缩并获取图片，这里用了递归的方法来解决canvas的draw方法延时的问题\r\n    getCanvasImg: function (index, failNum, tempFilePaths) {\r\n        var that = this;\r\n        let imagesPress = that.data.imagesPress;\r\n        if (index < tempFilePaths.length) {\r\n            wx.getImageInfo({\r\n                src: tempFilePaths[index],\r\n                success: function (res) {\r\n                    //---------利用canvas压缩图片--------------\r\n                    var ratio = 2;\r\n                    var canvasWidth = res.width //图片原始长宽\r\n                    var canvasHeight = res.height\r\n                    while (canvasWidth > 400 || canvasHeight > 400) {// 保证宽高在400以内\r\n                        canvasWidth = Math.trunc(res.width / ratio)\r\n                        canvasHeight = Math.trunc(res.height / ratio)\r\n                        ratio++;\r\n                    }\r\n                    that.setData({\r\n                        canvasWidth: canvasWidth,\r\n                        canvasHeight: canvasHeight,\r\n                    })\r\n                    const ctx = wx.createCanvasContext('photo_canvas');\r\n                    ctx.drawImage(tempFilePaths[index], 0, 0, canvasWidth, canvasHeight);\r\n                    ctx.draw(false, function () {\r\n                        index = index + 1;//上传成功的数量，上传成功则加1\r\n                        wx.canvasToTempFilePath({\r\n                            canvasId: 'photo_canvas',\r\n                            success: function success(res) {\r\n                                console.log('最终图片路径' + res.tempFilePath)//最终图片路径\r\n                                imagesPress.push(res.tempFilePath);\r\n                                console.log(that.data.imagesPress)\r\n                                that.setData({\r\n                                    imagesPress: imagesPress\r\n                                })\r\n                                that.uploadCanvasImg(res.tempFilePath);\r\n                                that.getCanvasImg(index, failNum, tempFilePaths);\r\n                            }, fail: function (e) {\r\n                                failNum += 1;//失败数量，可以用来提示用户\r\n                                that.getCanvasImg(inedx, failNum, tempFilePaths);\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            })\r\n\r\n        }\r\n    },//上传图片\r\n    uploadCanvasImg: function (canvasImg) {\r\n        const {$Toast} = require('../../dist/base/index');\r\n        var that = this;\r\n        let attachmentId = that.data.attachmentId\r\n        var tempImg = canvasImg;\r\n        wx.showLoading({\r\n            title: '上传中...',\r\n        });\r\n        wx.uploadFile({\r\n            url: app.globalData.baseUrl + '/api/upload',//文件服务器的地址\r\n            filePath: tempImg,\r\n            header: {\r\n                'Content-type': 'multipart/form-data',\r\n                'token': wx.getStorageSync('token')\r\n            },\r\n            // formData: {\r\n            // },\r\n            name: 'file',\r\n            success: function (res) {\r\n                wx.hideLoading()\r\n                $Toast({\r\n                    content: '上传成功！'\r\n                });\r\n                console.log(res)\r\n            }\r\n        })\r\n    },//删除图片\r\n    removeImage(e) {\r\n        var that = this;\r\n        var pics = that.data.pics;\r\n        var imagesPress = that.data.imagesPress;\r\n        // 获取要删除的第几张图片的下标\r\n        const idx = e.currentTarget.dataset.idx\r\n        // splice  第一个参数是下表值  第二个参数是删除的数量\r\n        pics.splice(idx, 1)\r\n        imagesPress.splice(idx, 1)\r\n        this.setData({\r\n            pics: pics,\r\n            imagesPress: imagesPress\r\n        })\r\n        console.log(that.data.imagesPress)\r\n    },\r\n    //预览图片\r\n    handleImagePreview(e) {\r\n        const idx = e.target.dataset.idx\r\n        const pics = this.data.pics\r\n        wx.previewImage({\r\n            current: pics[idx],  //当前预览的图片\r\n            urls: pics,  //所有要预览的图片\r\n        })\r\n    },"}
{"title": "基于uni-app的缓存器 ", "author": "Rolan", "pub_time": "2019-6-19 00:34", "content": "在前端开发应用程序中，性能一直都是被大家所重视的一点，然而判断一个应用程序的性能最直观的就是看页面打开的速度。其中提高页页面反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短页面请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。前端常用缓存技术在这里我就不再描述，下面基于Storage对其进行增强，采用Map 基本相同的api。阅读以下内容时遇到不懂的，请先科普阮一峰老师的ECMAScript 6 入门下面是基本代码，会在此基础上进行增强class MinCache {\r\n  // 将数据存储在本地缓存中指定的 name 中\r\n  set (name, data) {\r\n    try {\r\n      uni.setStorageSync(name, data)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  // 从本地缓存中获取指定 name 对应的内容\r\n  get (name) {\r\n    let data\r\n    try {\r\n      data = uni.getStorageSync(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return data\r\n  }\r\n  // 从本地缓存中移除指定 key\r\n  delete (name) {\r\n    try {\r\n      uni.removeStorageSync(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  // 返回一个布尔值，表示 name 是否在本地缓存之中\r\n  has (name) {\r\n    const value\r\n    try {\r\n      const res = uni.getStorageInfoSync()\r\n      value = res.keys.includes(name)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return value\r\n  }\r\n  // 清理本地数据缓存\r\n  clear () {\r\n    try {\r\n      uni.clearStorageSync()\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n}\r\n\r\nexport default MinCache复制代码我们知道缓存往往是有危害的，那么我们最好规定个时间来去除数据。class CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    // 设置超时时间，单位秒\r\n    this.timeout = timeout\r\n    // 对象创建时候的时间\r\n    this.createTime = Date.now()\r\n  }\r\n}复制代码set (name, data, timeout = 1200) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    try {\r\n      uni.setStorageSync(name, cachecell)\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n  get (name) {\r\n    let data = null\r\n    try {\r\n      data = uni.getStorageSync(name)\r\n      if (!data) return null\r\n      const currentTime = Date.now()\r\n      const overTime = (currentTime - data.createTime) / 1000\r\n      if (overTime > data.timeout) {\r\n        try {\r\n          uni.removeStorageSync(name)\r\n          data = null\r\n        } catch (e) {\r\n          console.log(e)\r\n        }\r\n      }\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return data\r\n  }复制代码使用了过期时间进行缓存的方式，已经可以满足绝大部分的业务场景。uni-app的Storage在不同端的实现不同：H5端为localStorage，浏览器限制5M大小，是缓存概念，可能会被清理App端为原生的plus.storage，无大小限制，不是缓存，持久化各个小程序端为其自带的storage api，数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。微信小程序单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。支付宝小程序单条数据转换成字符串后，字符串长度最大200*1024。同一个支付宝用户，同一个小程序缓存总上限为10MB。百度、头条小程序文档未说明大小限制除此之外，H5端还支持websql、indexedDB、sessionStorage；App端还支持SQLite、IO文件等本地存储方案。我们可以看出来Storage在一些端中是有大小限制的，其实我们的数据只是想要缓存，不一定要持久化。也就是说在应用程序生命周期内使用就行，而且直接操作Storage也不是很好。我们知道ES6中有Map可以做缓存下面代码时基于Map封装的let cacheMap =  new Map()\r\nlet instance = null\r\nlet timeoutDefault = 1200\r\n\r\nfunction isTimeout (name) {\r\n  const data = cacheMap.get(name)\r\n  if (!data) return true\r\n  if (data.timeout === 0) return false\r\n  const currentTime = Date.now()\r\n  const overTime = (currentTime - data.createTime) / 1000\r\n  if (overTime > data.timeout) {\r\n    cacheMap.delete(name)\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nclass CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    this.timeout = timeout\r\n    this.createTime = Date.now()\r\n  }\r\n}\r\n\r\nclass Cache {\r\n  set (name, data, timeout = timeoutDefault) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    return cacheMap.set(name, cachecell)\r\n  }\r\n  get (name) {\r\n    return isTimeout(name) ? null : cacheMap.get(name).data\r\n  }\r\n  delete (name) {\r\n    return cacheMap.delete(name)\r\n  }\r\n  has (name) {\r\n    return !isTimeout(name)\r\n  }\r\n  clear () {\r\n    return cacheMap.clear()\r\n  }\r\n  setTimeoutDefault (num) {\r\n    if (timeoutDefault === 1200) {\r\n      return timeoutDefault = num\r\n    }\r\n    throw Error('缓存器只能设置一次默认过期时间')\r\n  }\r\n}\r\n\r\nclass ProxyCache {\r\n  constructor () {\r\n    return instance || (instance = new Cache())\r\n  }\r\n}\r\n\r\nexport default ProxyCache复制代码对Storage和Map封装的缓存进行整合我们来分析一下Storage和Map共用一套api在命名上解决以下划线_开头命名的缓存到Storage，并且Map也有副本尽量不操作Storage(读取速度慢)那就必须在应用程序初始化的时候把Storage加载进Map像Vue插件一样使用let cacheMap =  new Map()\r\nlet timeoutDefault = 1200\r\n\r\nfunction isTimeout (name) {\r\n  const data = cacheMap.get(name)\r\n  if (!data) return true\r\n  if (data.timeout === 0) return false \r\n  const currentTime = Date.now()\r\n  const overTime = (currentTime - data.createTime) / 1000\r\n  if (overTime > data.timeout) {\r\n    cacheMap.delete(name)\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.removeStorageSync(name)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    }\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\nclass CacheCell {\r\n  constructor (data, timeout) {\r\n    this.data = data\r\n    this.timeout = timeout\r\n    this.createTime = Date.now()\r\n  }\r\n}\r\n\r\nclass MinCache {\r\n  constructor (timeout) {\r\n    try {\r\n      const res = uni.getStorageInfoSync()\r\n      res.keys.forEach(name => {\r\n        try {\r\n          const value = uni.getStorageSync(name)\r\n          cacheMap.set(name, value)\r\n        } catch (e) {\r\n          console.log(e)\r\n        }\r\n      })\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    timeoutDefault = timeout\r\n  }\r\n  set (name, data, timeout = timeoutDefault) {\r\n    const cachecell = new CacheCell(data, timeout)\r\n    let cache = null\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.setStorageSync(name, cachecell)\r\n        cache = cacheMap.set(name, cachecell)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    } else {\r\n      cache = cacheMap.set(name, cachecell)\r\n    }\r\n    return cache\r\n  }\r\n  get (name) {\r\n    return isTimeout(name) ? null : cacheMap.get(name).data\r\n  }\r\n  delete (name) {\r\n    let value = false\r\n    if (name.startsWith('_')) {\r\n      try {\r\n        uni.removeStorageSync(name)\r\n        value = cacheMap.delete(name)\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    } else {\r\n      value = cacheMap.delete(name)\r\n    }\r\n    return value\r\n  }\r\n  has (name) {\r\n    return !isTimeout(name)\r\n  }\r\n  clear () {\r\n    let value = false\r\n    try {\r\n      uni.clearStorageSync()\r\n      cacheMap.clear()\r\n      value = true\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n    return value\r\n  }\r\n}\r\n\r\nMinCache.install = function (Vue, {timeout = 1200} = {}) {\r\n  Vue.prototype.$cache = new MinCache(timeout)\r\n}\r\n\r\nexport default MinCache复制代码使用方法name以下划线_开头命名的缓存到Storage，并且Map也有副本事件名参数说明返回值setname缓存的key,data缓存的数据,timeout(必须数字单位s)缓存时间，默认缓存1200s, timeout设置为0表示永久缓存设置缓存数据Map集合getname缓存的key获取数据(缓存过期将返回null)返回缓存的数据datahasname缓存的key检查值true/falsedeletename缓存的key删除数据true/falseclear-清空Storage和Map缓存数据true/false// 注册缓存器\r\nVue.use(MinCache)\r\n// 设置默认缓存时间\r\n// Vue.use(MinCache, {timeout: 600})复制代码// 'name'不是以下划线开头的表示会缓存到Map中，在程序生命周期内有并且在有效时间内有效\r\nthis.$cache.set('name', 'MinCache')\r\n\r\n// 过期时间设置为0表示不会过期\r\n// 注意：'test'并不是以下划线命名表示在程序生命周期永久缓存\r\nthis.$cache.set('test', 'testdemo', 0)\r\n\r\n// 过期时间设置为0表示不会过期\r\n// 注意：'_imgURL'是以下划线命名表示永久缓存到Storage\r\nthis.$cache.set('_imgURL', 'data', 0)复制代码// 获取缓存的数据\r\nthis.imgURL = this.$cache.get('_imgURL')\r\nthis.name = this.$cache.get('name')\r\nthis.test = this.$cache.get('test')复制代码具体使用方法可以参考\tgithubuni-app路由的封装"}
{"title": "通过json用canvas生成分享海报,支持微信小程序和web ", "author": "Rolan", "pub_time": "2019-6-19 00:39", "content": "需求在项目里写过几个canvas生成分享海报页面后,觉得这是个重复且冗余的工作.于是就想有没有能通过类似json直接生成海报的库.然后就在github找到到两个项目:wxa-plugin-canvas ,不太喜欢配置文件的写法.就没多去了解mp_canvas_drawer ,使用方式就比较符合直觉,不过可惜功能有点少.然后就想着能不能自己再造个轮子.于是就有了这个项目 json2canvas ,你可以简单的理解为是mp_canvas_drawer的增强版吧.json2canvas canvas绘制海报,写个json就够了.项目的canvas绘制是基于 cax 实现的.所以天然的带来一个好处,json2canvas同时支持小程序和web功能支持缩放. 如果设计稿是750,而画布只有375时.你不需要任何换算,只需要将scale设置为0.5即可.支持图片圆角支持圆型,矩形,矩形圆角(背景色支持线性渐变)长文本自动换行(感谢 coolzjy@v2ex 提供的正则 https://regexr.com/4f12l ,优化了换行的计算方式(不会粗暴的折断单词))支持分组(cax里很好用的一个功能)同时支持小程序和web示例demo-web 界面左边的json,可以进行编辑,直接看效果哟~小程序demogit clone https://github.com/willnewii/json2canvas.git\r\n微信开发者工具导入项目 example/weapp/小程序安装npm i json2canvas\r\n微信开发者工具->工具->构建npm在需要使用的界面引入Component{\r\n  \"usingComponents\": {\r\n    \"json2canvas\":\"/miniprogram_npm/json2canvas/index\"\r\n  }\r\n}举个例子想要生成一个这样的海报,需要怎么做？(红框是图片元素,蓝框是文字元素,其余的是一张背景图。)简单,一个json搞定.具体支持的元素和参数,请查看项目 readme{\r\n        \"width\": 750,\r\n        \"height\": 1334,\r\n        \"scale\": 0.5,\r\n        \"children\": [\r\n            {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/bg_concerts_1.jpg\",\r\n                \"width\": 750,\r\n                \"height\": 1334\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\",\r\n                \"width\": 100,\r\n                \"x\": 48,\r\n                \"y\": 44,\r\n                \"isCircular\": true,\r\n            }, {\r\n                \"type\": \"circle\",\r\n                \"r\": 50,\r\n                \"lineWidth\": 5,\r\n                \"strokeStyle\": \"#CCCCCC\",\r\n                \"x\": 48,\r\n                \"y\": 44,\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"歌词本\",\r\n                \"font\": \"30px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": 168,\r\n                \"y\": 75,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/medal_concerts_1.png\",\r\n                \"width\": 300,\r\n                \"x\": \"center\",\r\n                \"y\": 361\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"一生活一场 五月天\",\r\n                \"font\": \"38px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": \"center\",\r\n                \"y\": 838,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"北京6场，郑州2场，登船，上班，听到你想听的歌了吗？\",\r\n                \"font\": \"24px Arial\",\r\n                \"color\": \"#FFFFFF\",\r\n                \"x\": \"center\",\r\n                \"y\": 888,\r\n                \"shadow\": {\r\n                    \"color\": \"#000\",\r\n                    \"offsetX\": 2,\r\n                    \"offsetY\": 2,\r\n                    \"blur\": 2\r\n                }\r\n            }, {\r\n                \"type\": \"rect\",\r\n                \"width\": 750,\r\n                \"height\": 193,\r\n                \"fillStyle\": \"#FFFFFF\",\r\n                \"x\": 0,\r\n                \"y\": \"bottom\"\r\n            }, {\r\n                \"type\": \"image\",\r\n                \"url\": \"http://res.mayday5.me/wxapp/wxavatar/tmp/wxapp_code.jpg\",\r\n                \"width\": 117,\r\n                \"height\": 117,\r\n                \"x\": 47,\r\n                \"y\": 1180\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"长按识别小程序二维码\",\r\n                \"font\": \"26px Arial\",\r\n                \"color\": \"#858687\",\r\n                \"x\": 192,\r\n                \"y\": 1202\r\n            }, {\r\n                \"type\": \"text\",\r\n                \"text\": \"加入五月天 永远不会太迟\",\r\n                \"font\": \"18px Arial\",\r\n                \"color\": \"#A4A5A6\",\r\n                \"x\": 192,\r\n                \"y\": 1249\r\n            }]\r\n    }问题反馈有什么问题可以直接 提issue"}
{"title": "[填坑手册]小程序目录结构和组件化使用心得 ", "author": "Rolan", "pub_time": "2019-6-20 00:14", "content": "小程序目录结构关于小程序的目录结构，可以说一开始大家都有各自的开发习惯和命名规则，但一旦项目变得复杂庞大的时候，你就发现管理起来和后期维护变得很麻烦，如果是 协同开发 的话，更容易出现 “互坑” 的情况。智库君在一年多的小程序开发中也跳过不少的坑，总结了一套还算好维护的目录结构跟大家分享（仅供 参考 ，觉得好拿去，觉得不好欢迎提出意见），以下是实战项目中的结构示例：├─  app.js    --- 小程序加载时优先加载的入口JS\r\n├─  app.json   ---入口文件和公共配置\r\n├─  app.wxss     ---公共样式表\r\n├─  project.config.json     ---小程序全局配置文件\r\n├─  sitemap.json     ---允许微信索引文件\r\n│  \r\n├─cloud-functions     ---云函数\r\n│  └─setCrypto      ---数据加密模块，用户加密一些数据\r\n│          index.js\r\n│          package.json\r\n│          ...\r\n│          ...\r\n│          \r\n├─components      ---小程序自定义组件\r\n│  ├─plugins      --- （重点）可独立运行的大型模块，可以打包成plugins\r\n│  │  ├─comment         ---评论模块\r\n│  │  │  │  index.js\r\n│  │  │  │  index.json\r\n│  │  │  │  index.wxml\r\n│  │  │  │  index.wxss\r\n│  │  │  │  services.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n│  │  │  │      \r\n│  │  │  └─submit    ---评论模块子模块：提交评论\r\n│  │  │          index.js\r\n│  │  │          index.json\r\n│  │  │          index.wxml\r\n│  │  │          index.wxss\r\n│  │  │      \r\n│  │  └─canvasPoster     ---canvas海报生成模块\r\n│  │          index.js\r\n│  │          index.json\r\n│  │          index.wxml\r\n│  │          index.wxss\r\n│  │          services.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n│  │     ...\r\n│  │     ...\r\n│  │          \r\n│  └─templates   ---（重点）模板，通过外部传参的容器，不做过多的数据处理\r\n│      │      \r\n│      ├─slideshow     ---滚屏切换模板\r\n│      │      index.js\r\n│      │      index.json\r\n│      │      index.wxml\r\n│      │      index.wxss\r\n│      │      service.js    ---（重点）用来处理和清洗数据的service.js，配套模板和插件\r\n│      │      \r\n│      └─works       ---作品模板\r\n│          │  index.js\r\n│          │  index.json\r\n│          │  index.wxml\r\n│          │  index.wxss\r\n│          │  service.js\r\n│          │  \r\n│          ├─articlePlugin    ---作品模板中的文章类型\r\n│          │      index.js\r\n│          │      index.json\r\n│          │      index.wxml\r\n│          │      index.wxss\r\n│          │      \r\n│          ├─galleryPlugin    ---作品模板中的九宫格类型\r\n│          │      index.js\r\n│          │      index.json\r\n│          │      index.wxml\r\n│          │      index.wxss\r\n│          │      \r\n│          └─videoPlugin     ---作品模板中的视频类型\r\n│                  index.js\r\n│                  index.json\r\n│                  index.wxml\r\n│                  index.wxss\r\n│                  ...\r\n│                  ...\r\n│                  \r\n├─config     ---自定义配置文件\r\n│      config.js    ---存放基础配置\r\n│      constants.js   ---存储常量\r\n│      weui.wxss   ---第三方文件wxss，js等\r\n│      ...\r\n│      ...\r\n│      \r\n├─pages     ---小程序页面\r\n│  ├─user      ---用户页面\r\n│  │      index.js\r\n│  │      index.json\r\n│  │      index.wxml\r\n│  │      index.wxss\r\n│  ├─news      ---新闻页面\r\n│  │      index.js\r\n│  │      index.json\r\n│  │      index.wxml\r\n│  │      index.wxss\r\n│  │      \r\n│  └─home      ---首页\r\n│         index.js\r\n│         index.json\r\n│         index.wxml\r\n│         index.wxss\r\n│         ...   \r\n│         ...   \r\n│          \r\n├─request      ---https请求管理（根据switch tab分类会比较好）\r\n│      common.js    ---一些公共请求获取，如兑换openId,unionId 等\r\n│      news.js\r\n│      uri.js     --- （重点）总的URI请求管理，方便切换和配置DEV,QA,PROD环境\r\n│      user.js\r\n│      ...\r\n│      ...\r\n│      \r\n└─utils       ---功能组件\r\n        logger.js    ---日志管理\r\n        util.js       ---公共小组件库\r\n        ...\r\n        ...\r\n        \r\n复制代码例如微信自己的wepy的官方文档，现在也添加了目录结构说明：为什么一定要写这个目录结构呢？不知道大家有没有发现，在以往的老项目交接和多人协同开发中，容易遇到别人写的模块，变量命名不准确，或者资料缺损，一次十来个方法/组件间的互相调用，直接把接（盘）手的人整懵逼了，所以智库君觉得，无论是独立开发，还是协同开发，留一份完整的目录说明文档是很有必要的， 勿坑他人 OR 未来的自己~~~component使用心得大家在开发过程中肯定会去看官方文档，但不可能全看完才开始写代码，大多数情况都是用到了再看，本人也是，所以下面抽一些开发中遇到的重点来讲：一、引用组件模板页面的自定义组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。 在组件模板中可以提供一个 节点，用于承载组件引用时提供的子节点。<!-- 组件模板 -->\r\n<view class=\"wrapper\">\r\n  <view>这里是组件的内部节点</view>\r\n  <slot></slot>\r\n</view>\r\n复制代码<!-- page页/父页面引用组件的页面模板 -->\r\n<view>\r\n  <component-tag-name>\r\n    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->\r\n    <view>这里是插入到组件slot中的内容</view>\r\n    <view>在加载组件的页面里自定义内容，将没有复用性的内容写在这里</view>\r\n  </component-tag-name>\r\n</view>\r\n复制代码页面自定义部分默认是加载在组件 上方 。为什么要在引用组件的页面添加这些内容呢？因为组件其中一个重要的特点是 复用性 ，但是有的时候可能要根据不同场景做一些 自定义 ，如果在组件中写大量的场景/逻辑判断，会增加组件的冗余，而且这些方法只是被 复用一次 的话，完全可以不写到组件里。二、“一键换肤”根据不同场景给组件引入外部样式<!-- 外部引用组件的页面传入样式 -->\r\n<WorkComponent extra-class=\"style1\" j-data=\"{{workData}}\"></WorkComponent>\r\n复制代码//组件中js\r\nComponent({\r\n    /**\r\n    * 引入外部样式，可传多个class\r\n    */\r\n    externalClasses: ['extra-class','extra-class2'],\r\n})\r\n复制代码extra-class从外部引入父级css，可用根据不同场景配置不同的样式方案，这样使得组件自定义能力更强。三、数据清洗与容错//service.js  思路示例\r\nmodule.exports = {\r\n    /**\r\n     * 功能：处理作者列表\r\n     * @param list\r\n     * @returns {Array}\r\n     */\r\n    authorList: function (list = []) {\r\n        let result = [];\r\n        list.forEach(item => {\r\n            result.push({\r\n                guid: item.recommend_obj_id || '',\r\n                type: item.recommend_type || '',\r\n                logo: (item.theme_pic || '').trim() || '',\r\n                title: item.title || ''\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n};\r\n复制代码如果外部传入的数据要分别导入多个组件中，可以在组件中建立一个对应的service.js，有2个作用：清洗数据，避免setData()的时有过多的脏数据错误数据的兼容，添加数据缺省值，增加代码健壮性四、canvas在component组件中无法选中的问题//这里只需要在后面 添加this对象\r\n    let ctx = wx.createCanvasContext('myCanvas', this);\r\n复制代码其他一些默认组件，遇到类似的问题，一般只要引用时传入this对象即可解决。五、组件之间的通讯在实际生产环境中，我们常常需要控制各个组件之间的互相通信/传参，下面介绍下具体的用法：WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。事件：用于子组件向父组件传递数据，可以传递任意数据。如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。设置监听事件：<!-- wxml 中 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->\r\n<component-tag-name bindmyevent=\"setMyEvent\" />\r\n<!-- 或者可以写成 -->\r\n<component-tag-name bind:myevent=\"setMyEvent\" />\r\n复制代码// index.js 父页面中\r\nPage({\r\n  setMyEvent: function(e){\r\n    let self = this;\r\n    if (e.detail) { // 自定义组件触发事件时提供的detail对象\r\n      switch (e.detail) {\r\n        case \"hidden\":  //隐藏 悬浮框上的评论\r\n          this.setData({\r\n            isFixCommentShow: false\r\n          });\r\n          break;\r\n        case \"fixRefresh\":   //刷新悬浮框\r\n          this.setData({\r\n            fixRefresh: true\r\n          });\r\n          break;\r\n        case \"commentRefresh\":  //刷新评论\r\n          this.setData({\r\n            commentRefresh: Math.random()\r\n          });\r\n          break;\r\n        case \"createPoster\":  //生成海报组件\r\n          self.setPosterSave();\r\n          break;\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码父页面引用子组件，子组件发送的信息，可以通过bind的方法监听到，来获取到具体的传参值。触发事件自定义组件触发事件时，需要使用 triggerEvent方法，指定事件名、detail对象和事件选项：<!-- 页面 page.wxml -->\r\n<another-component bindcustomevent=\"pageEventListener1\">\r\n   <my-component bindcustomevent=\"pageEventListener2\"></my-component>\r\n</another-component>\r\n<!-- 组件 another-component.wxml -->\r\n<view bindcustomevent=\"anotherEventListener\">\r\n   <slot />\r\n</view>\r\n<!-- 组件 my-component.wxml -->\r\n<view bindcustomevent=\"myEventListener\">\r\n  <slot />\r\n</view>\r\n复制代码//组件中js\r\nComponent({\r\n  properties: {},\r\n  methods: {\r\n    onTap: function(){\r\n        var myEventDetail = {} // detail对象，提供给事件监听函数\r\n        var myEventOption = {} // 触发事件的选项\r\n        this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n        //myEventOption的一些配置：\r\n        this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1\r\n        this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1\r\n    }\r\n  }\r\n});\r\n复制代码myEventOption 的配置：bubbles（Boolean）：事件是否冒泡composed（Boolean）：事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部capturePhase（Boolean）：事件是否拥有捕获阶段需要强调一点：建议大家不要在组件上bind太多的监听，一方面以后管理起来会比较麻烦，另一方面首次加载如果调用过多方法会引起数据渲染的卡顿。Component官方文档： developers.weixin.qq.com/miniprogram…往期回顾：[填坑手册]小程序Canvas生成海报（一）[拆弹时刻]小程序Canvas生成海报（二）"}
{"title": "在小程序中实现 Mixins 方案 ", "author": "Rolan", "pub_time": "2019-6-20 00:20", "content": "原文来自我的博客：jrainlau.github.io/#/article?n…\r\n\r\n\r\n在原生开发小程序的过程中，发现有多个页面都使用了几乎完全一样的逻辑。由于小程序官方并没有提供 Mixins 这种代码复用机制，所以只能采用非常不优雅的复制粘贴的方式去“复用”代码。随着功能越来越复杂，靠复制粘贴来维护代码显然不科学，于是便寻思着如何在小程序里面实现 Mixins。\r\n什么是 Mixins\r\nMixins 直译过来是“混入”的意思，顾名思义就是把可复用的代码混入当前的代码里面。熟悉 VueJS 的同学应该清楚，它提供了更强大了代码复用能力，解耦了重复的模块，让系统维护更加方便优雅。\r\n先看看在 VueJS 中是怎么使用 Mixins 的。\r\n// define a mixin object\r\nvar myMixin = {\r\n  created: function () {\r\n    this.hello()\r\n  },\r\n  methods: {\r\n    hello: function () {\r\n      console.log('hello from mixin!')\r\n    }\r\n  }\r\n}\r\n\r\n// define a component that uses this mixin\r\nvar Component = Vue.extend({\r\n  mixins: [myMixin]\r\n})\r\n\r\nvar component = new Component() // => \"hello from mixin!\"\r\n复制代码在上述的代码中，首先定义了一个名为 myMixin 的对象，里面定义了一些生命周期函数和方法。接着在一个新建的组件里面直接通过 mixins: [myMixin] 的方式注入，此时新建的组件便获得了来自 myMixin 的方法了。\r\n明白了什么是 Mixins 以后，便可开始着手在小程序里面实现了。\r\nMixins 的机制\r\nMixins 也有一些小小的细节需要注意的，就是关于生命周期事件的执行顺序。在上一节的例子中，我们在 myMixin 里定义了一个 created() 方法，这是 VueJS 里面的一个生命周期事件。如果我们在新建组件 Component 里面也定义一个 created() 方法，那么执行结果会是如何呢？\r\nvar Component = Vue.extend({\r\n  mixins: [myMixin],\r\n  created: function () {\r\n    console.log('hello from Component!')\r\n  }\r\n})\r\n\r\nvar component = new Component()\r\n\r\n// =>\r\n// Hello from mixin!\r\n// Hello from Component!\r\n复制代码可以看运行结果是先输出了来自 Mixin 的 log，再输出来自组件的 log。\r\n除了生命周期函数以外，再看看对象属性的混入结果：\r\n// define a mixin object\r\nconst myMixin = {\r\n  data () {\r\n    return {\r\n      mixinData: 'data from mixin'\r\n    }\r\n  }\r\n}\r\n\r\n// define a component that uses this mixin\r\nvar Component = Vue.extend({\r\n  mixins: [myMixin],\r\n  data () {\r\n    return {\r\n      componentData: 'data from component'\r\n    }\r\n  },\r\n  mounted () {\r\n    console.log(this.$data)\r\n  }\r\n})\r\n\r\nvar component = new Component()\r\n复制代码\r\n在 VueJS 中，会把来自 Mixins 和组件的对象属性当中的内容（如 data, methods等）混合，以确保两边的数据都同时存在。\r\n经过上述的验证，我们可以得到 VueJS 中关于 Mixins 运行机制的结论：\r\n\r\n生命周期属性，会优先执行来自 Mixins 当中的，后执行来自组件当中的。\r\n对象类型属性，来自 Mixins 和来自组件中的会共存。\r\n\r\n但是在小程序中，这套机制会和 VueJS 的有一点区别。在小程序中，自定义的方法是直接定义在 Page 的属性当中的，既不属于生命周期类型属性，也不属于对象类型属性。为了不引入奇怪的问题，我们为小程序的 Mixins 运行机制多加一条：\r\n\r\n小程序中的自定义方法，优先级为 Page > Mixins，即 Page 中的自定义方法会覆盖 Mixins 当中的。\r\n\r\n代码实现\r\n在小程序中，每个页面都由 Page(options) 函数定义，而 Mixins 则作用于这个函数当中的 options 对象。因此我们实现 Mixins 的思路就有了——劫持并改写 Page 函数，最后再重新把它释放出来。\r\n新建一个 mixins.js 文件：\r\n// 保存原生的 Page 函数\r\nconst originPage = Page\r\n\r\nPage = (options) => {\r\n  const mixins = options.mixins\r\n  // mixins 必须为数组\r\n  if (Array.isArray(mixins)) {\r\n    delete options.mixins\r\n    // mixins 注入并执行相应逻辑\r\n    merge(mixins, options)\r\n  }\r\n  // 释放原生 Page 函数\r\n  originPage(options)\r\n}\r\n复制代码原理很简单，关键的地方在于 merge() 函数。merge 函数即为小程序 Mixins 运行机制的具体实现，完全按照上一节总结的三条结论来进行。\r\n// 定义小程序内置的属性/方法\r\nconst originProperties = ['data', 'properties', 'options']\r\nconst originMethods = ['onLoad', 'onReady', 'onShow', 'onHide', 'onUnload', 'onPullDownRefresh', 'onReachBottom', 'onShareAppMessage', 'onPageScroll', 'onTabItemTap']\r\n\r\nfunction merge (mixins, options) {\r\n  mixins.forEach((mixin) => {\r\n    if (Object.prototype.toString.call(mixin) !== '[object Object]') {\r\n      throw new Error('mixin 类型必须为对象！')\r\n    }\r\n    // 遍历 mixin 里面的所有属性\r\n    for (let [key, value] of Object.entries(mixin)) {\r\n      if (originProperties.includes(key)) {\r\n        // 内置对象属性混入\r\n        options[key] = { ...value, ...options[key] }\r\n      } else if (originMethods.includes(key)) {\r\n        // 内置方法属性混入，优先执行混入的部分\r\n        const originFunc = options[key]\r\n        options[key] = function (...args) {\r\n          value.call(this, ...args)\r\n          return originFunc && originFunc.call(this, ...args)\r\n        }\r\n      } else {\r\n        // 自定义方法混入\r\n        options = { ...mixin, ...options }\r\n      }\r\n    }\r\n  })\r\n}\r\n复制代码Mixins 使用\r\n\r\n在小程序的 app.js 里引入 mixins.js\r\n\r\nrequire('./mixins.js')\r\n复制代码\r\n撰写一个 myMixin.js\r\n\r\nmodule.exports = {\r\n  data: { someData: 'myMixin' },\r\n  onShow () { console.log('Log from mixin!') }\r\n}\r\n复制代码\r\n在  page/index/index.js 中使用\r\n\r\nPage({\r\n  mixins: [require('../../myMixin.js')]\r\n})\r\n复制代码\r\n大功告成！此时小程序已经具备 Mixins 的能力，对于代码解耦与复用来说将会更加方便。作者：Jrain链接：https://juejin.im/post/5d0a07eb6fb9a07eba2c4142来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "mpVue + 云开发微信小程序之旅 ", "author": "Rolan", "pub_time": "2019-6-20 00:46", "content": "本文是使用mpVue + 小程序云开发构建的mini型的微信小程序，小程序加载过程会稍微比较慢，如存在问题望各路大神指教。 小程序分为三个部分：1. 首页主要是展示发布的内容；2. 写日记是提供添加数据的项；3. 详情页是浏览内容正文的具体详情喜欢的小伙伴动动您的小手给个小星星哦，谢谢！！ 小程序源码小程序二维码首页先看首页效果图，顶部是一个轮播 此轮播是获取预览人数排名第一个的发布的图片 ，中间部分是内容展示区 全部，最新，我的 。直接上代码吧// index.vue\r\nmethods： {\r\n    // 跳转详情\r\n    navigateTo (id) {\r\n      wx.navigateTo({\r\n        url: '../diaryDetail/main?id=' + id\r\n      })\r\n    },\r\n    // 切换 全部， 最新， 我的\r\n    switechNav (index) {\r\n      this.isActive = index\r\n      if (index === 0) {\r\n        this.getDiaryList()\r\n      }\r\n      if (index === 1) {\r\n        this.getNewList()\r\n      }\r\n      if (index === 2) {\r\n        this.getOpenId()\r\n      }\r\n    },\r\n    // 最近发布的，按时间排序前10条\r\n    getNewList () {\r\n      const that = this\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      wx.cloud.callFunction({\r\n        name: 'diaryList'\r\n      }).then(res => {\r\n        let infoList = res.result.data.reverse()\r\n        setTimeout(function () {\r\n          wx.hideLoading()\r\n        }, 2000)\r\n        that.diaryList = infoList.slice(0, 10)\r\n      })\r\n    },\r\n    // 获取自己发布的\r\n    getMyList () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const diary = db.collection('diary')\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      diary.where({\r\n        _openid: that.openId\r\n      }).get({\r\n        success: function (res) {\r\n          setTimeout(function () {\r\n            wx.hideLoading()\r\n          }, 2000)\r\n          if (res.data.length === 0) {\r\n            toast('您暂时没有发布文章日记', 'none')\r\n          }\r\n          that.diaryList = res.data.reverse()\r\n        }\r\n      })\r\n    },\r\n    // 通过云函数获取日记的list\r\n    getDiaryList () {\r\n      const that = this\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      wx.cloud.callFunction({\r\n        name: 'diaryList'\r\n      }).then(res => {\r\n        setTimeout(function () {\r\n          wx.hideLoading()\r\n        }, 2000)\r\n        let infoList = res.result.data\r\n        that.diaryList = infoList.sort(function (a, b) {\r\n          return b.preview - a.preview\r\n        })\r\n        that.imgUrls = that.diaryList[0].imagesList\r\n      })\r\n    }，\r\n    // 获取openid\r\n    getOpenId () {\r\n      const that = this\r\n      wx.cloud.callFunction({\r\n        name: 'user'\r\n      }).then(res => {\r\n        that.openId = res.result.OPENID\r\n        that.getMyList()\r\n      })\r\n    }\r\n}\r\n复制代码工具函数工具函数在 utils/index.js，做时间格式化和弹出提示function addZero (n) {\r\n  return n > 10 ? n : '0' + n\r\n}\r\n// toast 弹出提示\r\nexport function toast (title = '成功', icon = 'success', duration = 2000) {\r\n  wx.showToast({\r\n    title: title,\r\n    icon: icon,\r\n    duration: duration\r\n  })\r\n}\r\n// 时间格式化\r\nexport function getNowFormatDate () {\r\n  const now = new Date()\r\n  const year = now.getFullYear()\r\n  const month = addZero(now.getMonth() + 1)\r\n  const day = addZero(now.getDate())\r\n  const hh = addZero(now.getHours())\r\n  const mm = addZero(now.getMinutes())\r\n  const ss = addZero(now.getSeconds())\r\n  const timer = year + '-' + month + '-' + day + ' ' + hh + ':' + mm + ':' + ss\r\n  return timer\r\n}\r\n\r\nexport default {\r\n  toast,\r\n  getNowFormatDate\r\n}\r\n复制代码详情页展示内容详情，顶部轮播是作者上传的图片，可以点击查看原图，有为日记点赞，以及评论功能// diaryDetail.vue\r\nmethods: {\r\n    // id 是文章id通过首页跳转传过来 page页面可以用 this.$root.$mp.query.id 获取\r\n    getDiaryDetail (id) {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const diary = db.collection('diary')\r\n      diary.doc(id).get().then(res => {\r\n        that.detailInfo = res.data\r\n        that.detailImgs = res.data.imagesList\r\n      })\r\n    },\r\n  // 点赞\r\n    dianZan () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const _id = this.$root.$mp.query.id\r\n      const dianzan = db.collection('dianzan')\r\n      dianzan.where({\r\n        textId: _id,\r\n        _openid: that.openId\r\n      }).get({\r\n        success: function (res) {\r\n          if (res.data.length === 0) {\r\n            that.addDZ()\r\n            return false\r\n          }\r\n          toast('不能重复点赞哦！', 'none')\r\n        }\r\n      })\r\n    },\r\n    // 添加点赞人，以便可以判断是否重复点赞\r\n    addDZ () {\r\n      const that = this\r\n      const _id = this.$root.$mp.query.id\r\n      const db = wx.cloud.database()\r\n      const dianzan = db.collection('dianzan')\r\n      dianzan.add({\r\n        data: {\r\n          textId: _id, // 文字id\r\n          isZan: 1 // 1 为点赞\r\n        }\r\n      }).then(res => {\r\n        that.isAnimate = true\r\n        that.changeDZCount(_id)\r\n      })\r\n    },\r\n    // 调用点赞云函数，自增点赞数\r\n    changeDZCount (id) {\r\n      const that = this\r\n      wx.cloud.callFunction({\r\n        name: 'dianzan',\r\n        data: {\r\n          _id: id\r\n        }\r\n      }).then(res => {\r\n        toast('谢谢您的认可哦！', 'none')\r\n        that.getDiaryDetail(id)\r\n      })\r\n    },\r\n    // 判断阅读的人是否对这篇文章已经点过赞，如果点过赞进入页面心直接变红\r\n    getZan () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const _id = this.$root.$mp.query.id\r\n      const dianzan = db.collection('dianzan')\r\n      dianzan.where({\r\n        textId: _id,\r\n        _openid: that.openId\r\n      }).get({\r\n        success: function (res) {\r\n          if (res.data.length) {\r\n            that.isAnimate = true\r\n          }\r\n        }\r\n      })\r\n    },\r\n    // 获取评论\r\n    getComment (id) {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const comment = db.collection('comment')\r\n      comment.where({\r\n        textId: id\r\n      }).get({\r\n        success: function (res) {\r\n          that.commentList = res.data.reverse()\r\n        }\r\n      })\r\n    },\r\n    // 添加评论\r\n    addComment () {\r\n      if (this.content === '') {\r\n        toast('请输入评论内容', 'none')\r\n        return false\r\n      }\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const comment = db.collection('comment')\r\n      comment.add({\r\n        data: {\r\n          textId: this.$root.$mp.query.id, // 正文id\r\n          user: that.userInfo, // 用户信息\r\n          content: that.content, // 评论内容\r\n          time: getNowFormatDate() // 评论时间\r\n        }\r\n      }).then(res => {\r\n        that.contentCount = 0\r\n        that.getComment(this.$root.$mp.query.id)\r\n      })\r\n    },\r\n    // 判断用户是否发表过评论\r\n    getIsComment () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const comment = db.collection('comment')\r\n      comment.where({\r\n        _openid: that.openId,\r\n        textId: this.$root.$mp.query.id\r\n      }).get().then(res => {\r\n        if (res.data.length === 0) {\r\n          that.addComment()\r\n          toast('发表成功')\r\n          that.content = ''\r\n          return false\r\n        }\r\n        toast('不能重复发表评论哦！', 'none')\r\n      })\r\n    },\r\n    // 绑定评论字数\r\n    handleContentInput (e) {\r\n      this.contentCount = e.target.value.length\r\n    },\r\n    // 发表评论\r\n    onGotUserInfo (e) {\r\n      this.userInfo = e.target.userInfo\r\n      this.getIsComment()\r\n    },\r\n    // 轮播图 全屏预览图片 调用微信API wx.previewImage\r\n    handleImagePreview (e) {\r\n      let idx = e.target.dataset.idx\r\n      let images = this.detailImgs\r\n      wx.previewImage({\r\n        current: images[idx],\r\n        urls: images\r\n      })\r\n    }\r\n}\r\n复制代码写日记将 wx.chooseImage() 生成的临时图片保存到微信云存储，主要掉用 wx.cloud.uploadFile()方法// write.vue\r\nmethods: {\r\n    // 上传图片，并将临时图片保存到云存储中\r\n    chooseImage () {\r\n      const that = this\r\n      wx.chooseImage({\r\n        count: 9,\r\n        sizeType: ['original', 'compressed'],\r\n        sourceType: ['album', 'camera'],\r\n        success: function (res) {\r\n          // 将选择的图片上传到云存储\r\n          for (let i = 0; i < res.tempFilePaths.length; i++) {\r\n            const filePath = res.tempFilePaths[i]\r\n            const name = Math.random() * 1000000\r\n            const cloudPath = name + filePath.match(/\\.[^.]+?$/)[0]\r\n            wx.cloud.uploadFile({\r\n              cloudPath,\r\n              filePath,\r\n              success: res => {\r\n                let images = that.imagesList.concat(res.fileID)\r\n                that.imagesList = images.length <= 9 ? images : images.slice(0, 9)\r\n              }\r\n            })\r\n          }\r\n        }\r\n      })\r\n    },\r\n    // 限制标题字数\r\n    handleTitleInput (e) {\r\n      this.titleCount = e.target.value.length\r\n    },\r\n    // 限制标题字数\r\n    handleContentInput (e) {\r\n      this.contentCount = e.target.value.length\r\n    },\r\n    // 全屏预览图片\r\n    handleImagePreview (e) {\r\n      console.log(e)\r\n      let idx = e.target.dataset.idx\r\n      let images = this.imagesList\r\n      wx.previewImage({\r\n        current: images[idx], // 当前预览的图片索引\r\n        urls: images // 所有要预览的图片\r\n      })\r\n    },\r\n    // 移除不想要的图\r\n    removeImage (e) {\r\n      const that = this\r\n      const idx = e.target.dataset.idx // 当前需要移除的图片索引\r\n      wx.showModal({\r\n        title: '提示',\r\n        content: '您确定删除这张照片吗？',\r\n        success (res) {\r\n          if (res.confirm) {\r\n            that.imagesList.splice(idx, 1)\r\n            toast('删除成功')\r\n          } else if (res.cancel) {\r\n            console.log('用户点击取消')\r\n          }\r\n        }\r\n      })\r\n    },\r\n    // 发布文章\r\n    onGotUserInfo (e) {\r\n      if (this.title === '') {\r\n        toast('请输入文章标题', 'none')\r\n        return false\r\n      }\r\n      if (this.content === '') {\r\n        toast('请输入文章内容', 'none')\r\n        return false\r\n      }\r\n      if (this.imagesList.length === 0) {\r\n        toast('您还没上传图片', 'none')\r\n        return false\r\n      }\r\n      this.userInfo = e.target.userInfo\r\n      this.getOpenId()\r\n    },\r\n    // 往数据库里写数据\r\n    sendMessage () {\r\n      const that = this\r\n      const db = wx.cloud.database()\r\n      const diary = db.collection('diary')\r\n      diary.add({\r\n        data: {\r\n          title: that.title, // 正文标题\r\n          content: that.content, // 正文内容\r\n          imagesList: that.imagesList, // 上传图片 list\r\n          avatarUrl: that.userInfo.avatarUrl, // 头像\r\n          nickname: that.userInfo.nickName, // 名字\r\n          preview: 0, // 预览数\r\n          fabulous: 0, // 点赞数\r\n          creatTime: getNowFormatDate()\r\n        }\r\n      }).then(res => {\r\n        toast('发布成功')\r\n        that.title = that.content = ''\r\n        that.titleCount = that.contentCount = 0\r\n        that.imagesList = []\r\n      })\r\n    },\r\n}\r\n复制代码末尾在使用云开发中需要将如下代码放到根目录的 src/main.js中wx.cloud.init({\r\n  env: '云开发环境ID'\r\n})\r\n复制代码app.json 文件下添加 \"cloud\": true 告诉小程序使用云开发, project.config.json文件下添加 \"cloudfunctionRoot\": \"static/functions/\", 指定存放云函数的目录"}
{"title": "玩玩微信小程序（多图预警） ", "author": "Rolan", "pub_time": "2019-6-21 00:21", "content": "趁着最近下班比较早，还是有时间看下其他知识点。于是，自己屁颠屁颠的玩了下微信小程序。环境安装我使用的是 mac 电脑来开发，那我简单说下我自己的准备工作吧～首先，你需要一个良好的编辑器工具，我这里下载了 sublime、vscode和微信开发者工具 。我选择使用 微信开发者工具 进行开发，因为对开发者友好。有说vscode比较友好的，需要配置些东西，这就要百度一下了。然后，如果你的小程序要上线或需要使用里面比较完整的功能，你需要注册一个微信小程序，获取 appId 。我这里是学习而已，所以只是用微信提供的测试 appId ，这个测试 appId 在使用 微信开发者工具 新建项目的时候有得选择。嗯～就是这么简单，惊喜不～意外不:hushed:项目结构当你使用 微信开发者工具 新建项目的时候，它会自动帮你新建一个规范的项目目录结构。当然，我们也可以从零开始进行搭建啦。我下面简单罗列下我项目中的结构(截止2019年06月21日)：- app.js\r\n- app.json\r\n- assets\r\n  - tabbar\r\n\t- home_active.png\r\n\t- home.png\r\n\t- profile_active.png\r\n\t- profile.png\r\n- pages\r\n  - home\r\n\t- home.js\r\n\t- home.json\r\n\t- home.wxml\r\n\t- home.wxss\r\n  - profile\r\n\t- profile.js\r\n\t- profile.json\r\n\t- profile.wxml\r\n\t- profile.wxss\r\n- page.wxss\r\n- project.config.json\r\n- README.md\r\n复制代码也许你已经注意到了文件后缀名 js, json, wxml, wxss 。那么它们具体是干什么用的呢？js后缀名的文件是你写 javascript 的地方了，项目的一些逻辑代码。json后缀名的文件是你写页面的配置的地方， app.json 是应用的整体配置， home.json 是 home 页面的配置， profile.json 是 profile 页面的配置。wxml后缀名的文件是你写页面骨架的地方，类似我们的 html 。wxss后缀名的文件是你写页面样式的地方，类似我们的 css 。练手项目在看了文档，百度了些资料，就开始想一个练手的项目 -- github信息展示 。首先，我们搭建好项目的目录，之后就是根据文档啥的进行我们的项目构思的实现了。具体的过程我这里就不赘述了，毕竟在文章后面会配上项目代码的github地址啦:dog:～我们来看下效果吧："}
{"title": "小程序生成海报代码分享 ", "author": "Rolan", "pub_time": "2019-6-24 00:26", "content": "今天下午花了一下午时间把之前项目添加了对海报生成的支持,本代码已提交到微信，已通过审核，已发布，已经过本人验收，以下功能可用需要的同学可以移步下面链接https://gitee.com/jgl1210/eas...本代码实现功能1、海报上添加图片2、海报上添加文字3、海报下载4、海报保存到本地"}
{"title": "基于Proxy的小程序状态管理 ", "author": "Rolan", "pub_time": "2019-6-21 00:34", "content": "作者：wwayne原文： 基于Proxy的小程序状态管理Fundebug经授权转载，版权归原作者所有。微信小程序的市场在进一步的扩大，而背后的技术社区仍在摸索着最好的实践方案。我在帮助Nike，沃尔玛以及一些创业公司开发小程序后，依旧认为使用小程序原生框架是一个更高效，稳定的选择，而使用原生框架唯独缺少一个好的状态管理库，如果不引入状态管理则会让我们在模块化，项目结构以及单元测试上都有些捉襟见肘。目前相对比较稳健的做法是针对redux或者mobx做一个adaptor应用到小程序中，但这样需要自己想办法打包引入外部库，还要想怎么去写这个adaptor，总显得有些麻烦。于是我迸发出一个想法去写一个专用于小程序的状态管理库，它使用起来足够简单并且可以通过小程序自己的npm机制安装。目前我已经用这个开源库开发了两个电商小程序，在提高我开发效率的同时亦保证了程序的性能，所以接下来我想谈谈这背后的理念以启发更多开发者尝试新的解决方案。基于Proxy的状态管理实现Proxy在小程序中已经得到了足够好的支持，目前并没有发现在任何iPhone或者Android上不能使用Proxy的情况。而基于Proxy的状态管理其实也就是订阅监听的模式，一方面监听数据的变化，另一方面将这些变化传达给订阅的小程序页面。举一个比较常见的例子，当一个用户从自己的主页进入用户编辑页面，然后更改了自己的用户名点击保存后，用户主页和用户编辑页上的用户名这时候都应该被更新。这背后的程序逻辑则是：更新这个行为将触发Proxy去通知状态管理库，然后状态管理库负责检查此时还在页面栈中的所有页面，更新订阅了用户名这个数据的页面，如下图：Part1: 监听数据变化监听数据变化其实就是监听各个Store的属性变化，实现上就是在各个Store前面加了一层Proxy，用更直观的图片来表示就是这样：当一个Store被观察以后，它的属性就都变成了Proxy实例，当这个属性值是Object或者Array的时候，它内部的值也会被包装成Proxy实例，这样无论多深层的数据变动都能被监听到。而在Proxy的后面，Store的属性其实是被另一套数据(紫色部分)所维护，这套数据不负责监听，它就是纯数据，针对属性的任何变动最后都会应用到这套数据上来，它的作用是维护和返回最新的数据。实现细节： https://github.com/wwayne/min…Part2: 页面数据绑定因为小程序每个页面的js都是向Page中传递一个对象，这就让我们有机会包装这个对象，从而实现：进入页面后，将页面保存在页面栈中将来自状态管理库的数据映射到这个页面的data上来页面退出时，将页面从页面栈中移除实现细节： https://github.com/wwayne/min…Part3： 页面订阅更新当数据被监听到变化后，我们需要依次做两件事，先是找到所有存储在页面栈里的页面，然后根据各个页面订阅的数据来检查变化，如果有变化就通知这些页面，从而让它们去触发setData更新页面。实现细节： https://github.com/wwayne/min…使用状态管理的例子有了状态管理库，现在我们就来实现一开始举例的更新用户信息的操作，我们的文件路径如下：stores/\r\n  user.js\r\npages/\r\n  userEdit/\r\n     index.js\r\n     index.wxml\r\n1. 首先我们创建一个Store保存用户的信息，并且监听它的变化：// stores/user.js\r\nimport { observe } from 'minii'\r\n\r\nClass UserStore {\r\n  constructor () {\r\n     this.name = 'bob'\r\n  }\r\n\r\n  changeName (name) {\r\n     this.name = name\r\n  }\r\n}\r\n\r\nexport default observe(new UserStore(), 'user')\r\n2. 接着在我们的小程序页面订阅Store的信息// pages/userEdit/index.js\r\nimport { mapToData } from 'minii'\r\nimport userStore from '../../stores/user'\r\n\r\nconst connect = mapToData(state => (({\r\n  myName: state.user.name\r\n}))\r\nPage(connect({\r\n  updateNameToJames () {\r\n    userStore. changeName('james')\r\n  }\r\n}))\r\n3. 完成，现在可以在页面中使用和更新数据了// pages/userEdit/index.wxml\r\n<text>{{ myName }}</text>\r\n<button bindtap=\"updateNameToJames\">update name to James</button>\r\n最后小程序因为有体积的限制，所以我希望在代码量上也尽量做到轻量和便捷，所以目前这个状态管理库并没有太多很复杂的功能，在小程序打包后所占用的体积也不到1kb，颇有点够用就好的意思。我也已经用它开发了两款小程序，在经历了一段时间的用户使用后，我也更有信心说这个方案在小程序中是可行的。如果你有任何想法和建议，都欢迎告诉我。项目Github: https://github.com/wwayne/minii关于作者Hi, 我是wwayne，是一名居住在上海的独立软件工程师，我正在开发我的新产品 talk-to-kim , 你可以在 Github 或者专栏 一个人写代码 找到我"}
{"title": "小程序框架原理综合分析和 fard 的新思路 ", "author": "Rolan", "pub_time": "2019-6-24 00:07", "content": "halo，大家好，我是 132 ，好久不贱~今天给大家带来的是一个 fre 转小程序的新框架，叫 fard，它使用了非常精彩的思路，将 fre 代码跑到小程序环境里背景当下国内前端环境中，几乎每一个框架作者最终都会研究小程序，如 nerv 和 taro，anu 和 nanachi加上前阵子某人发微博说出 “hooks 无法用于别处，想用就得重新实现” 这种膝盖言论我急迫的想要给 fre 一个归宿，寻找适用于 fre 的小程序方案现有方案在做 fard 之前，我看了几乎所有的小程序框架，以下：编译型封装型tarowepynanachimpxmpvueuniappchameleon以上列举的只是常见的，还有很多小众的没有写出，小程序框架比小程序还多::>_<::编译型对于编译型框架，基本上就是 AST 转译，写 react/vue 的语法，编译出小程序的语法这样做的好处是理论上无所不能，啥都能转，甚至使用 parcel 的策略能让编译速度很快但是致命缺陷是，全程写的不是真的 react，react 内部的遍历过程根本没走，而且还需要制定足够严格的语法约定我认为，这个方向是走投无路的方向封装型封装型框架，基本就是对小程序的 API 进行封装，使其长得像 vue优点是能够最大程度的接近原生，缺点是没有足够的抽象层，无法跨端跨端了解完两种类型的框架，我们来探讨一下“跨端”跨端一直是很多人乐此不疲的事情，跨端的关键点在于寻找一个【抽象中间层】比如 taro 等使用 AST 作为抽象中间层flutter 使用各个端都支持的渲染引擎作为抽象中间层RN 自己搞了个 bridge，把桥作为抽象中间层weex 利用 v8 搞了个 runtime 作为抽象中间层(以上仅仅是举例，不要深究他们的原理)所以，fard 只需要寻找一个中间层，就完事了Fard 原理好吧，通篇，就这段是重点 ::>_<::首先，fard 是 fre 转小程序的框架，fre 是 react like 框架，它包含了整个 reconcilerreconciler 全程都是 js 的遍历行为，能够跑在任何 js 环境中，小程序也不例外所以最终 fard 的方案，就和 RN 类似，在小程序端跑 fre reconciler 过程，跑完再通过某个【桥】反馈给小程序视图好吧，上图如图，首先，在小程序里，跑 fre reconciler 的所有逻辑，hooks 就位于这个阶段，所以 hooks 所有逻辑，都是在 fre 中跑完的跑完后就好说了，我们拿到了一个 vdom (也可以说 fiber，但是我们只需要子集 vdom )拿到这个 vdom 后，就去 setData，附加给 Page好的，到这里，可以说全程 js 逻辑，该拿到的都拿到了，就差怎么反馈给视图了小程序自身也是 vdom 机制的，如果说它默认提供 vdom 的接口的话，我们直接将 vdom 附加过去即可但是并没有，小程序开放的唯一的修改视图的方法就是 template所以我们需要根据 vdom 改造 template，使其成为桥梁这个也非常简单，比如 vdom 长这个样子：let vdom = {\r\n    name:'@2',\r\n    type:'view',\r\n    children:[\r\n        {\r\n            name:'@1',\r\n            type:'text'\r\n        }\r\n    ]\r\n}\r\n复制代码我们完全可以通过 template 模拟出来<template is=\"@2\">\r\n    <view>\r\n        <block wx:for=\"{{props.children}}\" wx:key=\"\">\r\n            <template is=\"{{item.name}}\"></template>\r\n      </block>\r\n    </view>\r\n</template>\r\n\r\n<template is=\"@1\">\r\n    <text></text>\r\n</template>\r\n\r\n复制代码我们可以通过 template 模拟出整个 vdom，很好，bridge 就这么搞定了其实到这里，fard 就搞定了剩下的就是，增加更多的 case，封装更多的通用 API，提高性能了综合分析我们看到 fard 是类似 RN 的原理，我们高度抽象 fre 的 reconciler 层和小程序的 template bridge，使得整个设计非常的简单却精彩而且它能够完美的支持 jsx 和 hooks API，不存在任何约定任何限制任何规范毕竟，这才是 jsx 真正的意义同样的，hooks API 自出现以来，关于它内部的黑魔法也一直令人津津乐道，我用实际行动证明，hooks API 完全可以用到任何端，也包括 webgl前提是要有设计精巧的抽象中间层"}
{"title": "微信小程序 禁止弹框底部内容滑动 ", "author": "Rolan", "pub_time": "2019-7-29 00:11", "content": "我们需要解决的问题：当弹框显示的时候，弹框下面的内容不能滚动小程序的弹框特别多,像下面这样，弹框的底部是一个可以下拉的页面，但是当弹框出现的时候，需要禁止底部的滚动，那么怎么做呢？直接给出答案吧：给 view 加上 catchtouchmove='true' 就可以.比如下面这种：<view catchtouchmove='true' ></view>至于加到哪个view上边，自然是最外边包含整个屏幕的view了。如果你实在不知道哪一个，你试一下也成。网友们的方法网友们有人使用的方式是给 catchtouchmove 绑定一个空方法。这也是一个解决方法。<view catchtouchmove='prevent' ></view>\r\n\r\nprevent(){\r\n    return ;\r\n}友情提醒：关于不能滚动的这个效果需要在真机上面查看，在编辑器上面看不到效果。至此，完成。"}
{"title": "微信小程序通过云函数进行微信支付 ", "author": "Rolan", "pub_time": "2019-7-29 00:12", "content": "微信小程序微信支付官方流程图链接我简化的流程：本地发起下单请求调用云函数并传送数据云函数处理数据并返回5个参数本地接受5个参数，发起支付请求交易结束主要代码：//第一步，本地发起下单请求并传送数据。这一步，在你的wxml中的某个元素\r\n//中绑定事件<button bindtap='pay'></button>。通过这个pay函数，\r\n//触发云函数并传递一些数据\r\npay: function(){\r\n\t//需要上传给云函数的数据\r\n\tlet uploadData = {\r\n\t\t//此次需要支付的金额，单位是分。例如¥1.80=180\r\n\t\t\"total_fee\": \"180\",\r\n\t\t//用户端的ip地址\r\n\t\t\"spbill_create_ip\": \"123.123.123.123\"\r\n\t}\r\n\t//调用云函数\r\n\twx.cloud.callFunction({\r\n\t\t//云函数的名字，这里我定义为payment\r\n\t\tname: \"payment\",\r\n\t\t//需要上传的数据\r\n\t\tdata: uploadData\r\n\t}).then(res => {\r\n\t\t//这个res就是云函数返回的5个参数\r\n\t\t//通过wx.requestPayment发起支付\r\n\t\twx.requestPayment({\r\n\t\t\ttimeStamp: res.result.data.timeStamp,\r\n\t\t\tnonceStr: res.result.data.nonceStr,\r\n\t\t\tpackage: res.result.data.package,\r\n\t\t\tsignType: res.result.data.signType,\r\n\t\t\tpaySign: res.result.data.paySign,\r\n\t\t\tsuccess: res => {\r\n\t\t\t\t//支付成功\r\n\t\t\t},\r\n\t\t\tfail: err => {\r\n\t\t\t\t//支付失败\r\n\t\t\t}\r\n\t})\r\n}\r\n\r\n\r\n复制代码以上就是本地端的全部代码，接下来我们只需要搞定云函数的代码就完成全部的工作了。云函数的内容是：调用小程序登陆API -> Openid生成商户订单调用统一下单API -> prepay_id将组合数据再次签名,返回5个参数我创建的云函数命名为payment，此时云函数结构应该为payment\r\n|__index.js\r\n|__package.json\r\n复制代码##每一步的详细做法1. 调用小程序登陆API -> Openid这一步目的是获取用户的Openid在云函数的index.js中加上以下代码//获取云实例\r\nconst cloud = require('wx-server-sdk')\r\n//云初始化\r\ncloud.init()\r\n//获取微信调用上下文信息，其中包括Openid，Appid等\r\nconst wxContext = cloud.getWXContext()\r\n//获取用户openid\r\nconst openid = wxContext.OPENID\r\n复制代码到这里我们已经达成我们第一步的目的了。2. 生成商户订单微信支付开发文档-统一下单这一步的目的是为了 生成调用支付统一下单API的订单 。根据官方文档，我们需要以下数据：appid（小程序ID）openid（用户OPENID）mch_id（商户号）nonce_str（随机字符串）body（商品描述）out_trade_no（商户订单号）total_fee（标价金额）spbill_create_ip（终端IP）notify_url（通知地址）trade_type（交易类型）key（密钥）sign（签名）我们一个一个解决。1. appid小程序管理员进入公众平台、使用小程序帐户登录后，点击左侧菜单中的「设置」，在「开发设置」一项，就可以查询到小程序的AppID。示例值 wxd678efh567hg6787在云函数的index.js中加上以下代码：const appid='wxwxd678efh567hg6787'\r\n复制代码2. openid第一步已经获得。示例值 oUpF8uMuAJO_M2pxb1Q9zNjWeS6o3. mch_id登陆微信支付商户平台pay.weixin.qq.com,点击上方「账户中心」，在「个人信息」中的「登陆账号」就是mch_id。示例值 1230000109在云函数的index.js中加上以下代码：const mch_id='1230000109'\r\n复制代码4. nonce_str任意生成的随机数，不超过32位。你可以自己写个函数。示例值 5K8264ILTKCH16CQ2502SI8ZNMTM67VS我在云函数中创建了一个新的JS文件(random.js)来保存这个函数，此时云函数的结构如下payment\r\n|__index.js\r\n|__package.json\r\n|__random.js\r\n复制代码其中random.js的内容为:function random(){\r\n  var result = ''\r\n  const wordList = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\r\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',\r\n  '3', '4', '5', '6', '7', '8', '9', '0']\r\n  for(let i=0;i<31;i++){\r\n    result += wordList[Math.round(Math.random()*36)]\r\n  }\r\n  return result\r\n}\r\n\r\nmodule.exports = random()\r\n\r\n复制代码然后在云函数index.js中加上以下代码:const random = require(\"random.js\")\r\n复制代码5. body格式为：商家名称-销售商品类目示例值 腾讯-游戏在云函数index.js中加上以下代码:const body = \"腾讯-游戏\"\r\n复制代码6. out_trade_no商户系统内部订单号，要求32个字符内，只能是数字、大小写字母_-|*且 在同一个商户号下唯一 。由自己定义，推荐用当下时间+商品编号组成。示例值 20150806125346在云函数index.js中的exports.main函数中加上以下代码://这里我只使用了当下时间。只要这个数字不是重复的就可以。\r\nconst out_trade_no = Date.parse(new Date()).toString()\r\n复制代码7. total_fee订单总金额，单位为分。比如当前需支付¥6.80，则total_fee为680。示例值 88这里需要用到我们上传过来的值，先不管8. spbill_create_ip支持IPV4和IPV6两种格式的IP地址。调用微信支付API的机器IP。示例值 123.12.12.123这里需要用到我们上传过来的值，先不管9. notify_url异步接收微信支付结果通知的回调地址，通知url必须为外网可访问的url，不能携带参数。在这里可以填上你自己服务器的url。示例值 http://www.weixin.qq.com/wxpay/pay.php在云函数index.js中加上以下代码://随便填写个服务器就行，我在使用中没有遇到什么问题\r\nconst notify_url = 'http://www.weixin.qq.com/wxpay/pay.php'\r\n复制代码10. trade_type小程序的trade_type为JSAPI。示例值 JSAPI在云函数index.js中加上以下代码:const trade_type = 'JSAPI'\r\n复制代码11. keykey为商户平台设置的密钥key，是由你自己设置的。key设置路径：微信商户平台(pay.weixin.qq.com)-->账户设置-->API安全-->密钥设置。示例值 1a79a4d60de6718e8e5b326e338ae533在云函数index.js中加上以下代码:const key = '1a79a4d60de6718e8e5b326e338ae533'\r\n复制代码12. sign将以上除key外所有信息按照参数名ASCII码从大到小拼接成字符串，用&分割，将key放在最后。字符串示例值:appid=wxd678efh567hg6787&body=微信-游戏&mch_\r\nid=1230000109&nonce_str=5K8264ILTKCH16CQ2502SI8ZNMTM6\r\n7VS&notify_url=http://www.weixin.qq.com/wxpay/pay.php&\r\nopenid=oUpF8uMuAJO_M2pxb1Q9zNjWeS6o&out_trade_no=2015080\r\n6125346&spbill_create_ip=123.12.12.123&total_fee=88&trad\r\ne_type=JSAPI&key=1a79a4d60de6718e8e5b326e338ae533\r\n复制代码此字符串的MD5码的大写就是sign。因为上面的total_fee与spbill_create_ip我们还没处理，所以这个数据放到下面再处理。MD5码示例值 C380BEC2BFD727A4B6845133519F3AD6到此为止你的云函数结构应该为:payment\r\n|__index.js\r\n|__package.json\r\n|__random.js\r\n复制代码其中index.js的内容应该为://云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst openid = cloud.getWXContext().OPENID\r\nconst appid = 'wxwxd678efh567hg6787'\r\nconst mch_id = '1230000109'\r\nconst random = require('random.js')\r\nconst body = \"腾讯-游戏\"\r\nconst notify_url = 'http://www.weixin.qq.com/wxpay/pay.php'\r\nconst trade_type = 'JSAPI'\r\nconst key = '1a79a4d60de6718e8e5b326e338ae533'\r\n\r\n//云函数入口函数\r\nexports.main = async (event, content) => {\r\n\tconst out_trade_no = Date.parse(new Date()).toString()\r\n}\r\n复制代码接下来我们处理上面没有处理的total_fee与spbill_create_ip，以及sign。 其中total_fee和spbill_create_ip是由客户端上传的，这两个数据就在云函数入口函数的参数event中，所以我们在云函数入口函数里面加上以下代码const total_fee = event.total_fee\r\nconst spbill_create_ip = event.spbill_create_ip\r\n复制代码最后，我们需要处理sign，按照12.sign提到的规则，在云函数入口函数里面加上以下代码let stringA = `appid=${appid}&body=${body}&\r\nmch_id=${mch_id}&nonce_str=${random}&\r\nnotify_url=${notify_url}&openid=${openid}&\r\nout_trade_no=${out_trade_no}&\r\nspbill_create_ip=${spbill_create_ip}&\r\ntotal_fee=${total_fee}™_type=${trade_type}&\r\nkey=1a79a4d60de6718e8e5b326e338ae533`\r\n复制代码我们现在需要将这个字符串进行MD5码加密，所以需要安装一个npm包来完成这个任务。右键点击云函数pyament，选择「在终端打开」，输入下面的命令：npm install --save crypto\r\n复制代码完成后在云函数入口文件处加上以下代码const crypto = require(\"crypto\")\r\n复制代码这样我们就成功地将crypto这个加密工具包引入我们的云函数里了。然后我们需要在云函数入口函数里使用它对刚刚的stringA进行MD5加密。所以我们在 let stringA = ... 这行代码下面添加以下代码var sign = crypto.createHash('md5').update(stringA).digest('hex').toUpperCase()\r\n复制代码以上除key的11个信息就是我们调用统一下单API所需要的全部数据了我们现在需要将这些数据转成xml格式,例如：<xml>\r\n<appid>wxd930ea5d5a258f4f</appid>\r\n<mch_id>10000100</mch_id>\r\n<device_info>1000</device_info>\r\n<body>test</body>\r\n<nonce_str>ibuaiVcKdpRxkhJA</nonce_str>\r\n<sign>9A0A8659F005D6984697E2CA0A9CF3B7</sign>\r\n...\r\n</xml>\r\n复制代码在云函数中新建一个requestData.js，写下如下函数，用来完成将数据转成xml的任务function requestData(\r\n  appid,\r\n  mch_id,\r\n  nonce_str,\r\n  sign,\r\n  body,\r\n  out_trade_no,\r\n  total_fee,\r\n  spbill_create_ip,\r\n  notify_url,\r\n  trade_type,\r\n  openid\r\n){\r\n  let data = \"<xml>\"\r\n  data += \"<appid>\"+appid+\"</appid>\"\r\n  data += \"<mch_id>\"+mch_id+\"</mch_id>\"\r\n  data += \"<nonce_str>\"+nonce_str+\"</nonce_str>\"\r\n  data += \"<sign>\"+sign+\"</sign>\"\r\n  data += \"<body>\"+body+\"</body>\"\r\n  data += \"<out_trade_no>\"+out_trade_no+\"</out_trade_no>\"\r\n  data += \"<total_fee>\"+total_fee+\"</total_fee>\"\r\n  data += \"<spbill_create_ip>\"+spbill_create_ip+\"</spbill_create_ip>\"\r\n  data += \"<notify_url>\"+notify_url+\"</notify_url>\"\r\n  data += \"<trade_type>\"+trade_type+\"</trade_type>\"\r\n  data += \"<openid>\"+openid+\"</openid>\"\r\n  data += \"</xml>\"\r\n  return data\r\n}\r\n\r\nmodule.exports = requestData\r\n复制代码此时云函数的结构为payment\r\n|__index.js\r\n|__package.json\r\n|__package-lock.json //由npm install产生的文件\r\n|__random.js\r\n|__requestData.js\r\n复制代码我们需要将requestData.js文件导入到我们的项目。在云函数入口文件那里添加以下代码const requestData = require(\"requestData.js\")\r\n复制代码现在，我们可以生成调用支付统一下单API的订单了,这个dataBody就是订单。let dataBody = reqData(\r\n    appid,\r\n    mch_id,\r\n    random,\r\n    sign,\r\n    body,\r\n    out_trade_no,\r\n    total_fee,\r\n    spbill_create_ip,\r\n    notify_url,\r\n    trade_type,\r\n    openid\r\n  )\r\n复制代码到这里我们已经达成我们第二部的目的了。3.调用统一下单API -> prepay_id官方文档我们需要对官方提供的链接 https://api.mch.weixin.qq.com/pay/unifiedorder 发起统一下单，所以这里我们需要一个npm包来帮我们完成request请求，并且由于发起请求后的返回值是xml格式的，所以我们还需要一个npm包来帮助我们解析xml格式文件。故右键点击云函数payment，选择「在终端打开」，输入下面命令：npm install --save request\r\nnpm install --save xmlreader\r\n复制代码在云函数入口文件中引入上面两个包：const request = require(\"request\")\r\nconst xmlreader = require(\"xmlreader\")\r\n复制代码然后就可以在云函数入口函数中发起对统一下单API的request请求了，由于request是异步请求，所以我们需要返回一个Promise。return new Promise(reslove => {\r\n\trequest({\r\n\t\t//官方统一下单api的url\r\n\t\turl: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\r\n\t\t//请求方法，post\r\n\t\tmethod: \"POST\",\r\n\t\t//需要传送的订单，就是刚刚我们生成的dataBody\r\n\t\tbody: dataBody\r\n\t}, body => {\r\n\t\t//body就是我们收到的数据，我们需要得到其中的prepay_id\r\n\t\t//使用xmlreader解析body，获得其中的prepay_id\r\n\t\txmlreader.read(body, res => {\r\n\t\t\t//此时我们已经完成第三步的目的了\r\n\t\t\tlet prepay_id = res.xml.prepay_id.text()\r\n\t\t}\r\n\t}\r\n}\r\n复制代码第三步目的完成4.将组合数据再次签名，返回5个参数已知wx.requestPayment()需要五个参数，分别是timeStampnonceStrpackagesignTypepaySign其中，timeStamp为时间戳，可由 Date.parse(new Date()).toString() 取得。 nonceStr为随机字符串，可由我们的随机函数取得。 package就是上一步获得的prepay_id， signType是签名类型，我们选择的是MD5。所以我们现在只剩下paySign未知，得到paySign的方法为paySign = MD5(appId=wxd678efh567hg6787&nonceStr=5K826\r\n4ILTKCH16CQ2502SI8ZNMTM67VS&package=prepay_id=wx20170\r\n33010242291fcfe0db70013231072&signType=MD5&timeStamp=\r\n1490840662&key=qazwsxedcrfvtgbyhnujmikolp111111) = 22D\r\n9B4E54AB1950F51E0649E8810ACD6\r\n复制代码所以我们在上一步的代码中接着写return new Promise(reslove => {\r\n\trequest({\r\n\t\turl: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\r\n\t\tmethod: \"POST\",\r\n\t\tbody: dataBody\r\n\t}, body => {\r\n\t\txmlreader.read(body, res => {\r\n\t\t\tlet prepay_id = res.xml.prepay_id.text()\r\n\t\t\tlet timeStamp = Date.parse(new Date()).toString()\r\n\t\t\tlet str = `appId=${appid}&nonceStr=${random}&package=prepay_id=${prepay_id}&signType=MD5&timeStamp=${timeStamp}&key=1a79a4d60de6718e8e5b326e338ae533`\r\n\t\t\tlet paySign = crypto.createHash('md5').update(str).digest('hex')\r\n\t\t\t//返回上面的五个参数\r\n\t\t\treslove({\r\n\t\t\t\tdata: {\r\n\t\t\t\t\ttimeStamp: timeStamp,\r\n            \t\tnonceStr: random,\r\n            \t\tpackage: `prepay_id=${prepay_id}`,\r\n            \t\tsignType: 'MD5',\r\n            \t\tpaySign: paySign\r\n            \t}\r\n            })\r\n\t\t}\r\n\t}\r\n}\r\n复制代码至此，微信小程序支付流程结束。此时云函数结构为：payment\r\n|__index.js\r\n|__package.json\r\n|__package-lock.json\r\n|__random.js\r\n|__requestData.js\r\n复制代码index.js://云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst openid = cloud.getWXContext().OPENID\r\nconst appid = 'wxwxd678efh567hg6787'\r\nconst mch_id = '1230000109'\r\nconst random = require('random.js')\r\nconst body = \"腾讯-游戏\"\r\nconst notify_url = 'http://www.weixin.qq.com/wxpay/pay.php'\r\nconst trade_type = 'JSAPI'\r\nconst key = '1a79a4d60de6718e8e5b326e338ae533'\r\nconst crypto = require(\"crypto\")\r\nconst requestData = require(\"requestData\")\r\nconst request = require(\"request\")\r\nconst xmlreader = require(\"xmlreader\")\r\n\r\n//云函数入口函数\r\nexports.main = async (event, content) => {\r\n    const out_trade_no = Date.parse(new Date()).toString()\r\n    const total_fee = event.total_fee\r\n    const spbill_create_ip = event.spbill_create_ip\r\n    let stringA = `appid=${appid}&body=${body}&mch_id=${mch_id}&nonce_str=${random}&notify_url=${notify_url}&openid=${openid}&out_trade_no=${out_trade_no}&spbill_create_ip=${spbill_create_ip}&total_fee=${total_fee}™_type=${trade_type}&key=1a79a4d60de6718e8e5b326e338ae533`\r\n    var sign = crypto.createHash('md5').update(stringA).digest('hex').toUpperCase()\r\n    let dataBody = reqData(\r\n\t    appid,\r\n\t    mch_id,\r\n\t    random,\r\n\t    sign,\r\n\t    body,\r\n\t    out_trade_no,\r\n\t    total_fee,\r\n\t    spbill_create_ip,\r\n\t    notify_url,\r\n\t    trade_type,\r\n\t    openid\r\n\t  )\r\n\treturn new Promise(reslove => {\r\n\t    request({\r\n\t        url: 'https://api.mch.weixin.qq.com/pay/unifiedorder',\r\n\t        method: \"POST\",\r\n\t        body: dataBody\r\n\t    }, body => {\r\n\t        xmlreader.read(body, res => {\r\n\t            let prepay_id = res.xml.prepay_id.text()\r\n\t            let timeStamp = Date.parse(new Date()).toString()\r\n\t            let str = `appId=${appid}&nonceStr=${random}&package=prepay_id=${prepay_id}&signType=MD5&timeStamp=${timeStamp}&key=1a79a4d60de6718e8e5b326e338ae533`\r\n\t            let paySign = crypto.createHash('md5').update(str).digest('hex')\r\n\t            //返回上面的五个参数\r\n\t            reslove({\r\n\t                data: {\r\n\t                    timeStamp: timeStamp,\r\n\t                    nonceStr: random,\r\n\t                    package: `prepay_id=${prepay_id}`,\r\n\t                    signType: 'MD5',\r\n\t                    paySign: paySign\r\n\t                }\r\n\t            })\r\n\t        }\r\n\t    }\r\n}\r\n复制代码random.js:function random(){\r\n  var result = ''\r\n  const wordList = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\r\n  'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '1', '2',\r\n  '3', '4', '5', '6', '7', '8', '9', '0']\r\n  for(let i=0;i<31;i++){\r\n    result += wordList[Math.round(Math.random()*36)]\r\n  }\r\n  return result\r\n}\r\n\r\nmodule.exports = random()\r\n复制代码requestData.js:function requestData(\r\n  appid,\r\n  mch_id,\r\n  nonce_str,\r\n  sign,\r\n  body,\r\n  out_trade_no,\r\n  total_fee,\r\n  spbill_create_ip,\r\n  notify_url,\r\n  trade_type,\r\n  openid\r\n){\r\n  let data = \"<xml>\"\r\n  data += \"<appid>\"+appid+\"</appid>\"\r\n  data += \"<mch_id>\"+mch_id+\"</mch_id>\"\r\n  data += \"<nonce_str>\"+nonce_str+\"</nonce_str>\"\r\n  data += \"<sign>\"+sign+\"</sign>\"\r\n  data += \"<body>\"+body+\"</body>\"\r\n  data += \"<out_trade_no>\"+out_trade_no+\"</out_trade_no>\"\r\n  data += \"<total_fee>\"+total_fee+\"</total_fee>\"\r\n  data += \"<spbill_create_ip>\"+spbill_create_ip+\"</spbill_create_ip>\"\r\n  data += \"<notify_url>\"+notify_url+\"</notify_url>\"\r\n  data += \"<trade_type>\"+trade_type+\"</trade_type>\"\r\n  data += \"<openid>\"+openid+\"</openid>\"\r\n  data += \"</xml>\"\r\n  return data\r\n}\r\n\r\nmodule.exports = requestData\r\n复制代码"}
{"title": "手把手从零开始小程序单元测试(附避坑指南以及源码跟踪) ", "author": "Rolan", "pub_time": "2019-7-29 00:15", "content": "单元测试是一个老生常谈的话题，基于Web/NodeJs环境的测试框架、测试教程数不胜数，也趋于成熟了。但是对于微信小程序的单元测试，目前还是处于起步状态，这两天在研究微信小程序的测试，也遇到了一些坑，在这里记录一下，希望给看到本文的小伙伴带来一点帮助，少走一些弯路。本文内容有点多，但是干货满满，不明白的小伙伴可以给我留言demo地址https://github.com/xialeistudio/miniprogram-unit-test-demo关键依赖版本本文写作时相关依赖版本如下(版本不同，源码行数可能不同)：miniprogram-simulate: 1.0.7j-component: 1.1.6miniprogram-exparser: 0.0.6测试流程初始化小程序项目，编写待测试组件安装jest,miniprogram-simulate测试环境编写测试用例执行测试初始化小程序项目使用小程序开发者工具初始化新项目，APPID选择 测试号 即可，语言选择 Javascript 。使用小程序开发者工具新建 /components/user 组件components/user.js// components/user.js\r\nComponent({\r\n    data: {\r\n        nickname: ''\r\n    },\r\n    methods: {\r\n        handleUserInfo: function(e){\r\n            this.setData({ nickname: e.detail.userInfo.nickName })\r\n        }\r\n    }\r\n})\r\ncomponents/user.wxml<textclass=\"nickname\">{{nickname}}</text>\r\n<buttonclass=\"button\"open-type=\"getUserInfo\"bindgetuserinfo=\"handleUserInfo\">Oauth</button>\r\npages/index/index.jsPage({\r\n    data:{}\r\n})\r\npages/index/index.wxml<viewclass=\"container\">\r\n    <user></user>\r\n</view>\r\n打开小程序开发者工具，可以看到有一个 Oauth 按钮，点击之后会在上面显示昵称。由此可以得到测试用例 点击授权按钮时上方显示为授权用户的昵称安装jest/miniprogram-simulate测试环境由于JS项目的小程序根目录没有 package.json ，需要手动生成一下打开终端，在项目根目录执行 npm init -y 生成 package.json安装测试工具集 npm install jest miniprogram-simulate --save-dev编辑 package.json ，在 scripts 新建 test 命令{\r\n    \"name\": \"unit-test-demo\",\r\n    \"version\": \"1.0.0\",\r\n    \"description\": \"\",\r\n    \"main\": \"app.js\",\r\n    \"scripts\": {\r\n        \"test\": \"jest\"\r\n    },\r\n    \"keywords\": [],\r\n    \"author\": \"\",\r\n    \"license\": \"ISC\",\r\n    \"devDependencies\": {\r\n        \"jest\": \"^24.8.0\",\r\n        \"miniprogram-simulate\": \"^1.0.7\"\r\n    }\r\n}\r\n编写测试用例在项目根目录新建 tests/components/user.spec.js 文件(目录需要手动创建)代码如下(参考微信官方单元测试文档编写):const simulate = require('miniprogram-simulate');\r\nconst path = require('path');\r\n\r\ntest('components/user', (done) => { // 定义测试名称,传入done表示当前测试是异步测试，需要回调函数来告诉jest，我测试执行完毕\r\nconst id = simulate.load(path.join(__dirname, '../../components/user')); // 加载组件\r\nconst component = simulate.render(id); // 渲染组件\r\n\r\nconst text = component.querySelector('.nickname'); // 获取nickname节点\r\nconst button = component.querySelector('.button'); // 获取button节点\r\nbutton.dispatchEvent('getuserinfo', { // 模拟触发事件\r\n    detail: {   // 传递事件参数\r\n        userInfo: {\r\n            nickName: 'hello',\r\n        },\r\n    },\r\n});\r\nsetTimeout(()=> { // 异步断言\r\n    expect(text.dom.innerHTML).toBe('hello'); // 检测text节点的innerHTML等于模拟授权获取的昵称\r\n    done();\r\n}, 1000);\r\n});\r\n执行测试npm run test ，等待一秒后发现， 不出意外的话，测试肯定过不去部分出错日志：Expected: \"hello\"\r\nReceived: \"\"\r\n     at toBe (/Users/xialeistudio/WeChatProjects/unit-test-demo/tests/components/user.spec.js:18:32)\r\n     at Timeout.callback [as _onTimeout] (/Users/xialeistudio/WeChatProjects/unit-test-demo/node_modules/jsdom/lib/jsdom/browser/Window.js:678:19)\r\n     at listOnTimeout (internal/timers.js:535:17)\r\n     at processTimers (internal/timers.js:479:7)\r\n可以推测一下原因：dispatchEvent的事件触发有问题，导致handleUserInfo未触发[1]dispatchEvent的事件触发成功，但是触发参数有问题[2]错误分析(源码跟踪过程)针对第1点原因，可以写一下测试代码( components/user.js )Component({\r\n    data: {\r\n        nickname: ''\r\n    },\r\n    methods: {\r\n        handleUserInfo: function(e){\r\n            console.log(e);\r\n        }\r\n    }\r\n})\r\nnpm run test ，可以看到事件还是成功触发了，不过 detail 是 {} console.log components/user.js:21\r\n{ type: 'getuserinfo',\r\n  timeStamp: 948,\r\n  target: { id: '', offsetLeft: 0, offsetTop: 0, dataset: {} },\r\n  currentTarget: { id: '', offsetLeft: 0, offsetTop: 0, dataset: {} },\r\n  detail: {},\r\n  touches: {},\r\n  changedTouches: {} }\r\n原因1排除，查原因2dispatchEvent 方法是 被测试组件的子组件 ， 被测试组件 由 simulate.render 函数返回浏览 node_modules/miniprogram-simulate/src/index.js ，看到 render函数(152行) ，可以看到返回的组件由 jComponent.create 提供浏览 node_modules/j-component/src/index.js 的 create 函数，可以看到其返回了 RootComponent 实例，而 RootComponent 是由 ./render/component.js 提供浏览 node_modules/j-component/src/render/component.js 的 dispatchEvent 函数，在这里可以打下日志测试(本文就不打了，结果是这里的options就是 user.spec.js dispatchEvent函数的 第二个参数 ， detail 是有值的)继续跟踪源码，由于咱们的是 自定义事件 ，所以会走到 91行 的代码，该代码块如下：// 自定义事件\r\n  const customEvent = new CustomEvent(eventName, options);\r\n\r\n  // 模拟异步情况\r\n  setTimeout(()=> {\r\n    dom.dispatchEvent(customEvent);\r\n\r\n    exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, {}, {\r\n      originalEvent: customEvent,\r\n      bubbles: true,\r\n      capturePhase: true,\r\n      composed: true,\r\n      extraFields: {\r\n        touches: options.touches || {},\r\n        changedTouches: options.changedTouches || {},\r\n      },\r\n    }));\r\n  }, 0);\r\n可以看到调用了 exparser.Event.dispatchEvent 函数，该函数的 第二个参数 调用了 exparser.Event.create 对自定义事件进行了包装，这里还没到最底层，需要继续跟踪exparser 对象是 miniprogram-exparser模块 提供的，浏览 node_modules/miniprogram-exparser/exparser.min.js ，发现该文件被混淆了，不过没关系 混淆后的代码逻辑是不变的，只不过变量名变得无意义，可读性变差使用webstorm格式化该文件，这里我传了一份格式化好的到github wxparser.js，可在线观看需要在源码中搜索 三个参数 的 create 函数( Object.create不算 )，需要有耐心，经过排查后发现 168行 代码应该是目标代码i.create = function(e, t, r){\r\n    r = r || {};\r\n    var n = r.originalEvent, o = r.extraFields || {}, a = Date.now() - l, s = new i;\r\n    s.currentTarget = null, s.type = e, s.timeStamp = a, s.mark = null, s.detail = t, s.bubbles = !!r.bubbles, s.composed = !!r.composed, s.__originalEvent = n, s.__hasCapture = !!r.capturePhase, s.__stopped = !1, s.__dispatched = !1;\r\n    for (var u in o) s[u] = o[u];\r\n    return s;\r\n}\r\n可以看到 s.detail = t 这个赋值， t 是 create 的 第二个参数 ，由 node_modules/j-component/render/component.js 的 wxparser.Event.create 传入，但是传入的 第二个参数写死了{}，所以咱们的组件获取 detail 的时候 永远为{} ，将其修改为 options.detail||{} 即可，修改后代码如下：exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, options.detail||{}, xxxxxx\r\n重新测试   PASS  tests/components/user.spec.js\r\n✓ components/user (1099ms)\r\n\r\n  Test Suites: 1 passed, 1 total\r\n  Tests:       1 passed, 1 total\r\n  Snapshots:   0 total\r\n  Time:        3.622s\r\n  Ran all test suites.\r\n避坑指南querySelector 用法同HTML，但是需要在 组件 执行，而不是 组件.dom ，HTML中实在 DOMNode 执行的dispatchEvent 是触发事件，需要在 组件 执行，上述代码中是触发 button组件 的 自定义事件dispatchEvent 事件名规范: 去掉前导bind剩余的字符串为事件名 ，示例代码中 bindgetuserinfo ，触发时就是 getuserinfo ，如果是 bindtap ，那触发时就是 tapdispatchEvent 底层是 j-component 这个 npm模块实现 的，跟踪源码发现执行是异步的(代码文件 node_modules/j-component/src/render/component.js ，函数名 dispatchEvent )// 自定义事件\r\n  const customEvent = new CustomEvent(eventName, options);\r\n\r\n  // 模拟异步情况\r\n  setTimeout(()=> {\r\n    dom.dispatchEvent(customEvent);\r\n\r\n    exparser.Event.dispatchEvent(customEvent.target, exparser.Event.create(eventName, {}, {\r\n      originalEvent: customEvent,\r\n      bubbles: true,\r\n      capturePhase: true,\r\n      composed: true,\r\n      extraFields: {\r\n        touches: options.touches || {},\r\n        changedTouches: options.changedTouches || {},\r\n      },\r\n    }));\r\n  }, 0);\r\n由于 setTimeout 的存在，触发事件为异步，所以写断言时需要加定时器结语小程序单元测试基本是没什么经验扩借鉴，但是基于官网提供的工具，以及 开源 ，咱们遇到问题时细心排查然后修改一下，还是可以解决问题的。对单元测试有疑问的小伙伴可以扫码加我进行交流。"}
{"title": "小程序 随机读取数据并生成分享图片 上手笔记 ", "author": "Rolan", "pub_time": "2019-7-29 00:25", "content": "效果图如下，用户每次点击分享图片的时候，从内容库中随机抽出一条数据，渲染在图片上，并且加上用户昵称和头像，用户可以保存到本地。功能不难，但是有一些小细节，还是列出来记录下吧。根据开发的顺序写一下吧，先要确定rpx单位，读取数据（昵称 头像、文字），再渲染圆角头像和本地的二维码图片，判断保存权限，关闭后再次点击再渲染。目录自适应rpx单位读取用户昵称和头像随机获取文字内容promisify.js的封装使用渲染网络图片和本图片圆角图片保存权限多次渲染清空1. 自适应rpx单位起初自己在 css 里用的 px 单位给 canvas 设置的样式，在模拟器里切换机型后不能自适应，又换成 rpx 单位。canvas 里渲染图片和文字也需要单位，需要把 px 转成 rpx ， 1rpx = 窗口宽度px/750 。<!--rpx2px函数-->\r\nfunction createRpx2px() {\r\n  const { windowWidth } = wx.getSystemInfoSync()\r\n  return function(rpx) {\r\n    return windowWidth / 750 * rpx\r\n  }\r\n}\r\n\r\n<!--使用rpx2px-->\r\nconst rpx2px = createRpx2px()\r\nctx.setFontSize(rpx2px(28))\r\nctx.fillText('长按左侧二维码', rpx2px(220), rpx2px(640))\r\n复制代码2. 读取用户昵称和头像根据微信的api文档，需要使用 open-type=\"getUserInfo\" 属性的按钮获取用户授权，授权成功后调用 wx.getUserInfo 方法获取用户详情。<button class=\"button\" open-type=\"getUserInfo\" bindtap=\"share\" >分享到朋友圈</button>\r\n复制代码封装获取用户详情的 Promise ，并且返回昵称和图片地址。<!--获取用户详情-->\r\ngetInfo(){\r\n    return new Promise((resolve, reject) => {\r\n      wx.getUserInfo({\r\n        success: function(res) {\r\n          let { nickName , avatarUrl } = res.userInfo\r\n          resolve({ nickName , avatarUrl })\r\n        }\r\n      })\r\n    })\r\n  }\r\n复制代码3. 随机获取文字内容云数据库可以使用类 mongo 的 sample 方法随机抽取数据，具体可见官方网文档。size 为指定数量。封装 Promise 返回数据getMsg(){\r\n    const db = wx.cloud.database()\r\n    return new Promise((resolve, reject) => {\r\n      db.collection('shareMsg').aggregate().sample({ size: 1 }).end().then(res=>{ \r\n        resolve(res.list[0])\r\n      });\r\n    })\r\n  },\r\n复制代码4. promisify.js的封装使用Nodejs 8 有一个工具函数 util.promisify()。将一个接收回调函数参数的函数转换成一个返回Promise的函数。js的编程中有很多需要异步的场景，刚才我们获取昵称和随机数据都用到了 Promise ，这样写很麻烦，微信的api都遵循一样的规范，网上有封装好的代码，拿来主义。promisify.jsconst promisify = (api) => {\r\n    return (options, ...params) => {\r\n        return new Promise((resolve, reject) => {\r\n            api(Object.assign({}, options, { success: resolve, fail: reject }), ...params);\r\n        });\r\n    }\r\n}\r\nexport default promisify\r\n复制代码使用示例import promisify from '../../lib/promisify.js'; \r\n\r\nlet userInfo = promisify(wx.getUserInfo);\r\nuserInfo().then(res => {\r\n  console.log(res)\r\n})\r\n复制代码5. 渲染网络图片和本图片读取网络图片要在公众平台设置合法域名。接口返回的头像图片域名为 https://wx.qlogo.cn，添加上就可以了。渲染网络图片需要使用 wx.getImageInfo 方法把网络图片变成本地图片再渲染，本地图片直接放入图片路径即可。this.getInfo().then(userInfo => {\r\n \r\n    Promise.all([\r\n        wxGetImageInfo({\r\n            src: userInfo.avatarUrl\r\n        })\r\n    ]).then(res => {\r\n     \r\n        ctx = wx.createCanvasContext('shareCanvas')\r\n            \r\n        <!--网络图片-->\r\n        ctx.drawImage(res[0].path, rpx2px(40), rpx2px(60), rpx2px(60), rpx2px(60)); \r\n    \r\n        <!--本地图片-->\r\n        ctx.drawImage('../../images/qrcode.jpeg', rpx2px(20), rpx2px(580), rpx2px(160),rpx2px(160));\r\n\r\n\r\n    })\r\n})\r\n复制代码6. 圆角头像ctx.save(); \r\nctx.beginPath(); \r\nctx.arc(rpx2px(70), rpx2px(90), rpx2px(30), 0, Math.PI * 2, false);\r\nctx.clip();\r\nctx.drawImage(res[0].path, rpx2px(40), rpx2px(60), rpx2px(60), rpx2px(60)); \r\nctx.restore(); \r\n复制代码7. 保存权限第一步使用 wx.canvasToTempFilePath 从 canvas 导出图片，第二步使用 wx.saveImageToPhotosAlbum 要把导出的图片的图片保存到相册。保存到相册是需要用户授权的，用户授权拒绝后七天之内是不会在出现的授权框的，所以需要增加判断，如果无权限，显示设置按钮，跳转到权限设置页面。<!--保存按钮-->\r\nsaveImg(){\r\n    const wxCanvasToTempFilePath = promisify(wx.canvasToTempFilePath)\r\n    const wxSaveImageToPhotosAlbum = promisify(wx.saveImageToPhotosAlbum)\r\n\r\n    wxCanvasToTempFilePath({\r\n        canvasId: 'shareCanvas'\r\n    }, this).then(res => {\r\n        return wxSaveImageToPhotosAlbum({\r\n            filePath: res.tempFilePath\r\n        })\r\n    }).then(res => {\r\n        wx.showToast({\r\n            title: '已保存到相册'\r\n        })\r\n    }).catch(err => {\r\n      wx.showToast({\r\n          icon: 'none',\r\n          title: '授权失败'\r\n        })\r\n      <!--显示授权按钮-->\r\n      this.setData({setPage:true})\r\n    })\r\n  }\r\n复制代码<button hidden=\"{{!setPage}}\" open-type=\"openSetting\" >设置权限</button>\r\n复制代码8. 多次渲染清空对 canvas 不是特别熟悉，从翻api说画一个图形，然后在清除图片范围内的内容。ctx.fillRect(0,0,rpx2px(500),rpx2px(760))\r\nctx.clearRect(0,0,rpx2px(500),rpx2px(760))\r\nctx.draw()\r\n复制代码ctx 对象要多次操作，需要提取为全局变量，另外创建时要保证DOM渲染完毕。let ctx = wx.createCanvasContext('shareCanvas')\r\n复制代码不过在模拟器中多次渲染会出现空白的情况，但是手机实测是正常的。好了，这个是在 【小程序 + 云开发】体重记录小程序 上手笔记 发表后继续新增的功能，下次希望云函数新增定时任务和推送的内容。"}
{"title": "基于 Vue 的小程序开发框架性能优化实践---去除 VNode ", "author": "Rolan", "pub_time": "2019-7-30 00:41", "content": "为了提高小程序的开发效率，我们团队开发了Mars 框架，可以使用 Vue 语法开发小程序，同时支持编译到 H5。近期我们进行了 Mars 框架的性能升级（0.3.x 版本），极大简化了 Vue 的 render 过程，去掉了 VNode 构建，省略了 patch 过程，从而获得了性能提升。\r\n\r\nMars 框架原理简介，为什么要去除 VNode？\r\n为了方便大家理解，这里简单说一下 Mars 框架的原理，目前基于 Vue 的小程序开发框架原理差异不大。\r\n\r\n详细的原理大家可以看这篇文章：Mars - 又双叒叕一个多端开发框架？这次是 Vue 驱动，能完美适配 H5\r\n\r\nMars 的原理如下图所示：\r\n\r\n上图中，左半部分表示小程序的执行部分。粉红色区域代表小程序视图，蓝色部分代表小程序的逻辑执行部分，视图与逻辑之间交换的是数据和事件。右边绿色部分是我们在小程序逻辑之外，单独创建的 Vue 实例。小程序逻辑（蓝色部分）与 Vue 实例（绿色部分）是以如下方式工作的：\r\n\r\n在小程序的 Page 创建时，我们会同步 new 一个 Vue 实例。\r\n在 Vue 实例的 .$mp.scope 变量中绑定小程序实例，小程序实例中也会使用 .$vue 变量来绑定 Vue 实例，用于后续的数据传递。\r\n使用 handleProxy 方法代理小程序中的事件，当小程序事件发生时，对应执行 Vue 实例中相应的 Method。\r\n页面中的逻辑执行在 Vue 部分，每当 Vue 的视图更新时，在 Updated 阶段将数据的变化使用 setData 方法同步给小程序实例，触发小程序视图的刷新。\r\n\r\n可以看到优化前我们基本保留了 Vue 的所有渲染过程，只是删除了 Vue 中的 DOM 操作部分。由于 Vue 实例与小程序之间交换的只有数据，因此 Vue 中的视图层其实是没有用到的。\r\n我们需要的只是执行 Vue 中的逻辑，判断数据修改是否会造成视图更新，视图更新时把变化的数据同步给小程序。而 Vue 视图层相关的内容，VNode、render、patch 这些很多是没有必要的，我们的想法是通过精简不必要的操作来提升性能。\r\n优化前 render 和 patch 过程所起的作用\r\n想要精简 render 和 patch，我们就需要先搞清楚 render 和 patch 在 Vue 中起到了什么作用：\r\n\r\n在 Vue 中，当数据发生变化时，会通知视图渲染依赖这一数据的所有实例，依次执行这些实例的 render 函数，这次 render 函数执行过程中又会重新收集依赖，用于下一次数据发生变化时的依赖追踪。\r\nrender 函数执行后会返回一个该实例对应的 VNode 树，render 过程中并不会创建子组件实例，仅仅是生成了一个占位符。这个 VNode 树随后会传递给 patch 过程。\r\npatch 过程会将当前 VNode 树与旧 VNode 树进行 diff，之后根据 diff 创建、销毁子组件实例，修改 DOM 完成渲染。\r\n\r\n在小程序框架这个情境下，我们需要的是 数据依赖追踪 和 组件实例创建、销毁，其他部分的内容则可以进行删减。\r\n我们可以精简哪些内容？\r\n\r\nrender 函数部分，我们只需要进行必要的依赖追踪，不需要创建 VNode 节点。\r\npatch 部分，由于没有 VNode 了，我们也不需要进行耗时的 diff 操作了！\r\n\r\n但是等一下，没有了 VNode 树，如何创建组件实例呢？我们将子组件的 Vue 实例创建改到了小程序子组件的生命周期中，也就是说单个 Vue 实例只会创建它自己，不会在继续创建子组件实例。\r\n之前的结构为小程序实例树和 Vue 实例树，组件实例间互相绑定。现在的结构变为只有小程序实例树，每个小程序实例节点单独对应一个 Vue 实例。\r\n开始实践！\r\n下面介绍一下我们具体做了哪些内容。\r\ncreateComponent 中创建 Vue 实例\r\n由于把 patch 过程干掉了，因此我们需要手动创建子组件的 Vue 实例，同 Page 一样，我们在 Component 的生命周期函数中 new 一个 Vue 实例，并与当前小程序实例绑定：\r\nthis.$vue = new VueComponent(options);\r\nthis.$vue.$mp = {\r\n    scope: this\r\n};\r\n复制代码在组件中创建 Vue 实例时，之前 Vue 中的父子关系没有了，维护这一关系需要解决以下问题：父元素绑定、properties 传递。\r\n父元素绑定\r\n在 patch 过程中，Vue 创建子组件时会传递以下三个参数：\r\nconst options: InternalComponentOptions = {\r\n    _isComponent: true,\r\n    _parentVnode: vnode,\r\n    parent\r\n}\r\n复制代码\r\n_isComponent 用于优化 options 的合并，我们可以直接设置成 true。\r\n_parentVnode 用于在 render 过程中获取父元素信息，例如 scope-slot 等，由于我们已经把 VNode 删掉了，因此不再需要了。\r\nparent 用于获取根元素、绑定 $children 等操作，Vue 就是通过这个参数来维护实例间的父子关系的。\r\n\r\n我们需要找到当前 Vue 实例的父实例，作为 parent 参数，从而完成父元素绑定过程。\r\n小程序当前没有机制来直接获取父元素，需要我们自己想办法来查找。在之前开发 Mars 过程中，为了进行小程序组件实例和 Vue 组件实例间的匹配，对小程序实例树和 Vue 实例树中的组件节点都进行了标记，现在不需要进行实例间匹配查找了，但是我们可以通过这个标记来查找父元素。\r\n\r\n由于 Page 元素可能在同一时间不唯一（由于页面切换），因此每创建一个 Page 实例，都需要绑定一个唯一的 rootUID，我们将其存储在了getApp().__pages__中。rootUID 会逐层传给每个小程序自定义组件实例。\r\n每次有小程序自定义组件实例创建，我们都将该实例以标记的 id 为 key 存储在 getApp().__pages__[rootUID].__vms__中。\r\n根据 rootUID 找到根元素，进而找到 page 中的 __vms__。\r\n根据 compId 算出父实例的 compId。\r\n根据父实例的 compid从__vms__中找到父元素，作为 parent。\r\n\r\nproperties 传递\r\n除了需要设置的初始化属性外，我们还需要传递子组件的 properties，否则父元素的数据没办法传递给子组件。\r\n\r\n\r\n数据初始化：可以在 Vue 创建时传入 propsData 来作为 props 的初始数据。\r\n由于小程序自定义组件的参数和 Vue 子组件实例的参数是相同的，因此我们可以直接将程序自定义组件的参数作为propsData在 new Vue 时传入：\r\nconst options = {\r\n    mpType: 'component',\r\n    mpInstance: this,\r\n    propsData: properties,\r\n    parent\r\n};\r\n\r\n// 初始化 vue 实例\r\nthis.$vue = new VueComponent(options);\r\n复制代码\r\n\r\n数据更新：仿照 Vue 给子组件传参数的机制，每次 render 时，将 props 重新给子组件赋值一遍。\r\n\r\n\r\n\r\n只需要更新第一层，因为 properties 如果是对象，那么它在父元素中已经做过变化追踪了。\r\n\r\n事件传递\r\n对于 template 上绑定的事件，由于我们本身已经使用了 handleProxy 来处理，因此不会受到影响。\r\n需要处理的是 .$emit、.$on 方法。\r\n\r\n对于 .$emit，我们利用小程序机制，使用 triggerEvent 在小程序层面给父元素传递事件。\r\n对于 .$on，使用 Vue 现成的机制就好，不需要做额外工作，不过这也造成 Vue 的事件机制不能删除。\r\n\r\n\r\n这里有个小坑：triggerEvent 方法传递的参数，需要从 event.detail 中获取，Mars 兼容了这个 diff。\r\n\r\nrender 函数精简\r\nrender 函数目前我们不能完全删除，因为需要以下两个功能：依赖收集、复杂表达式和filter 计算。\r\n依赖收集\r\nVue 在初始化时会对实例上的 data 进行响应式处理，设置 set 和 get 方法。组件执行 render 函数时，会读取变量触发 get 方法，从而在 get 方法中将当前实例收集为这个数据的依赖。下次数据更新时 Vue 会通知依赖进行更新。\r\n为了收集依赖，我们需要在 render 函数中读取一遍数据。这里我们将 VNode 树编译为数组树的形式，只留下数据，剩下的内容都可以删除。\r\n比如这样的一个 template:\r\n<template>\r\n    <view class=\"hello\">\r\n        <view @tap=\"tapHandler\">\r\n            <text>https://github.com/max-team/Mars</text>\r\n        </view>\r\n        <view>{{ aaa }}</view>\r\n        <view>{{ ccc }}</view>\r\n        <name :name=\"nameOutter\"></name>\r\n        <view>{{ aaaComp }}</view>\r\n    </view>\r\n</template>\r\n复制代码Vue 产出的 render 函数是这样的：\r\n// 修改前的 render 函数\r\n_c('view',{staticClass:\"hello\"},[_c('view',{on:{\"tap\":_vm.tapHandler}},[_c('text',[_vm._v(\"https://github.com/max-team/Mars\")])]),_c('view',[_vm._v(_vm._s(_vm.aaa))]),_c('view',[_vm._v(_vm._s(_vm.ccc))]),_c('name',{attrs:{\"name\":_vm.nameOutter,\"compId\":(_vm.compId ? _vm.compId : '$root') + ',0'}}),_c('view',[_vm._v(_vm._s(_vm.aaaComp))])],1)\r\n复制代码精简后我们得到的 render 函数是这样的：\r\n// 修改后的 render 函数\r\n[,[,,[(_vm.aaa)],,[(_vm.ccc)],,[[_vm.nameOutter,(_vm.compId ? _vm.compId : '$root') + ',0']],,[(_vm.aaaComp)]]]\r\n复制代码可以看到 Vue 中的大量 render helper 掉用，例如 _c、_v、_s 等都可以省略了。\r\n\r\n有些 render helper 还是不能去掉，例如 v-for 循环，我们还是保留了 _l 函数，因为 v-for 循环的对象可能为数组、字符串、数字等多种情况。\r\n\r\n复杂表达式和filter 计算。\r\n在 Vue 的 template 中，是可以像 js 一样执行很多计算的，比如可以执行定义好的 method：\r\n<div :prop=\"someMethod(data)\"></div>\r\n复制代码或者执行一个 filter\r\n<div :prop=\"someMethod | someFilter\"></div>\r\n复制代码这部分的计算之前是在 render 中随着 VNode 构建执行的，计算结果存储在了 VNode 节点中。现在我们没有 VNode 了，计算出的值怎么办呢？\r\n\r\n计算复杂表达式和 filter 的过程还在 render 过程中保留。\r\n计算出的值使用 _ff 方法包裹。每个计算值产生一个唯一的 id，_ff 方法将这些值按照 id 存储下来 setData 给小程序，小程序直接使用这些计算结果来进行渲染。\r\n\r\npatch 过程\r\npatch 过程已经完全不需要了，我们将这一过程完全删除。\r\n顺带解决的一个坑\r\n在之前的方案中，从 Page 开始创建的小程序组件实例树，与 Vue 组件实例树是相互独立的。为了让小程序组件实例与 Vue 组件实例之间能够对应上（否则无法在组件级别 setData），我们需要对每个组件实例进行标记，通过标记来寻找对应关系。这在一些特殊情景下是会有问题的，例如组件快速生成又销毁等，造成实例间不匹配。\r\n修改后的方案由于 Vue 实例是以组件级别创建的了，因此不再会出现实例无法匹配的情况。\r\n结果和总结\r\n我们使用了线上业务进行验证，渲染时间 -16%。此外，由于我们精简了 Vue 的功能，删除了这部分功能的代码，框架整体的体积也减少了 11%。"}
{"title": "微信小程序渲染性能调优 ", "author": "Rolan", "pub_time": "2019-7-30 00:12", "content": "网页的性能优化是前端开发老生常谈的热门话题，其中微信小程序因其页面双线程架构设计，所以性能优化的手段跟传统的 H5 应用不太一样。今天主要介绍一下微信小程序页面双线程架构的特性给页面渲染带来的一些影响，以及应对的一些渲染性能调优策略。为了叙述方便，下文会把微信小程序简称为小程序。小程序的双线程架构与传统的浏览器Web页面最大区别在于，小程序的是基于 双线程 模型的，在这种架构中，小程序的渲染层使用 WebView 作为渲染载体，而逻辑层则由独立的 JsCore 线程运行 JS 脚本，双方并不具备数据直接共享的通道，因此渲染层和逻辑层的通信要由 Native 的 JSBrigde 做中转。小程序更新视图数据的通信流程每当小程序视图数据需要更新时，逻辑层会调用小程序宿主环境提供的 setData 方法将数据从逻辑层传递到视图层，经过一系列渲染步骤之后完成UI视图更新。完整的通信流程如下：小程序逻辑层调用宿主环境的 setData 方法。逻辑层执行 JSON.stringify 将待传输数据转换成字符串并拼接到特定的JS脚本，并通过 evaluateJavascript 执行脚本将数据传输到渲染层。渲染层接收到后， WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列等待 WebView 线程空闲时进行页面渲染。WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在WXML片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到UI视图。同时，将新的节点树替换旧节点树，用于下一次重渲染。引发渲染性能问题的一些原因在上述通信流程中，一些不恰当的操作可能会影响到页面渲染的性能：setData传递大量的新数据数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程。下图是我们做的一组测试统计：在相同网络环境下，各个机型分别对大小为 1KB 、 2KB 、 3KB 的数据执行 setData 操作所消耗的时间。从图中可以看出， setData 数据传输量越大，数据传输所消耗的时间越大。频繁的执行setData操作频繁的执行 setData 会让 WebView JS 线程一直忙碌于脚本的编译、节点树的对比计算和页面渲染。导致的结果是：WebView JS\r\n过多的页面节点数页面初始渲染时，渲染树的构建、计算节点几何信息以及绘制节点到屏幕的时间开销都跟页面节点数量成正相关关系，页面节点数量越多，渲染耗时越长。每次执行 setData 更新视图， WebView JS 线程都要遍历节点树计算新旧节点数差异部分。当页面节点数量越多，计算的时间开销越大，减少节点树节点数量可以有效降低重渲染的时间开销。渲染性能优化基于引发渲染性能问题的原因，我们可以制定一些优化策略来避免性能问题的发生。setData优化setData 作为逻辑层与视图层通信的媒介，是最容易造成渲染性能瓶颈的 API 。我们在使用 setData 时应该遵循一些规则来尽可能避免性能问题的发生：减少 setData 数据传输量仅传输视图层使用到的数据，其他 JS 环境用到的数据存放到 data 对象外。合理利用局部更新。 setData 是支持使用 数据路径 的方式对对象的局部字段进行更新，我们可能会遇到这样的场景： list 列表是从后台获取的数据，并展示在页面上，当 list 列表的第一项数据的 src 字段需要更新时，一般情况下我们会从后台获取新的 list 列表，执行 setData 更新整个 list 列表。// 后台获取列表数据\r\n  const list = requestSync(); \r\n\r\n  // 更新整个列表\r\n  this.setData({ list });  \r\n复制代码实际上，只有个别字段需要更新时，我们可以这么写来避免整个 list 列表更新:// 后台获取列表数据\r\n  const list = requestSync(); \r\n\r\n  // 局部更新列表\r\n  this.setData({ \r\n      'list[0].src': list[0].src\r\n  });  \r\n复制代码降低 setData 执行频率在不影响业务流程的前提下，将多个 setData 调用合并执行，减少线程间通信频次。当需要在频繁触发的用户事件（如 PageScroll 、 Resize 事件）中调用 setData ，合理的利用 函数防抖（debounce） 和 函数节流（throttle） 可以减少 setData 执行次数。函数防抖（debounce） ：函数在触发n秒后才执行一次，如果在n秒内重复触发函数，则重新计算时间。函数节流（throttle） ：单位时间内，只会触发一次函数，如果同一个单位时间内触发多次函数，只会有一次生效。除了让开发者自觉遵循规则来减少 setData 数据传输量和执行频率之外，我们还可以自己设计一个 diff 算法，重新对 setData 进行封装，使得在 setData 执行之前，让待更新的数据与原 data 数据做 diff 对比，计算出数据差异 patch 对象，判断 patch 对象是否为空，如果为空则跳过执行更新，否则再将 patch 对象执行 setData 操作，从而达到减少数据传输量和降低执行 setData 频率的目的。// setData重新封装成新的方法，使得数据更新前先对新旧数据做diff对比，再执行setData方法\r\nthis.update = (data) => {\r\n    return new Promise((resolve, reject) => {\r\n        const result = diff(data, this.data);\r\n        if (!Object.keys(result).length) {\r\n            resolve(null);\r\n            return;\r\n        } \r\n        this.setData(result, () => {\r\n            resolve(result);\r\n        });\r\n    });\r\n}\r\n复制代码当然，可以直接引用 这里 的现成 高性能小程序 setData diff算法具体流程如下图：善用自定义组件小程序自定义组件的实现是由小程序官方设计的 Exparser 框架所支持，框架实现的自定义组件的组件模型与 Web Components 标准的 Shadow DOM 相似：在页面引用自定义组件后，当初始化页面时， Exparser 会在创建页面实例的同时，也会根据自定义组件的注册信息进行组件实例化，然后根据组件自带的 data 数据和组件WXML，构造出独立的 Shadow Tree ，并追加到页面 Composed Tree 。创建出来的 Shadow Tree 拥有着自己独立的逻辑空间、数据、样式环境及setData调用：基于自定义组件的 Shadow DOM 模型设计，我们可以将页面中一些需要高频执行 setData 更新的功能模块（如倒计时、进度条等）封装成自定义组件嵌入到页面中。当这些自定义组件视图需要更新时，执行的是组件自己的 setData ，新旧节点树的对比计算和渲染树的更新都只限于组件内有限的节点数量，有效降低渲染时间开销。下图是我们在微保小程序WeDrive首页中，将倒计时模块抽取自定义组件前后的setData更新耗时对比：从图中可以看出，使用自定义组件后，倒计时模块 setData 平均渲染耗时有了非常明显的下降，实际在低端安卓机中体验会感觉明显的更流畅。当然，并不是使用自定义组件越多会越好，页面每新增一个自定义组件， Exparser 需要多管理一个组件实例，内存消耗会更大，当内存占用上升到一定程度，有可能导致 iOS 将部分 WKWebView 回收，安卓机体验会变得更加卡顿。因此要合理的使用自定义组件，同时页面设计也要注意不滥用标签。"}
{"title": "电视剧看多了，就想仿个爱奇艺小程序 ", "author": "Rolan", "pub_time": "2019-8-1 00:33", "content": "听说讲正文前，都喜欢先唠会嗑，咱们先聊个五毛钱的，不知道大家最近有没有看啥电视剧，比如，emmmmm，《亲爱的，热爱的》(斜眼笑)(好的假装你们看过了，咱们可以接着聊了)。哇，杨紫小猴子超甜的有没有，老夫的少女心，比吃了蜜还甜，李现大概或许可能maybe比我帅那么一丢丢，就一丢丢(是在下不要脸了，请忽略上面这句话谢谢！！！)。用爱奇艺看多了，就想仿个爱奇艺小程序来练练手(那是因为爱奇艺APP那玩意儿暂时还仿不出来)，虽说自己比较菜，写的不怎么样，但是咱们搞技术的，总得折腾一下嘛，有兴趣的东西就应该撸一个出来。好了五毛钱的聊完了，该讲正题了，还想聊天的再加五毛，一块也行，在座的各位都是大佬，多多指点一下下哈!蟹蟹蟹蟹。\r\n效果展示\r\n\r\n\r\n\r\n项目前准备\r\n\r\nVS Code\r\n微信web开发者工具以及它的云开发\r\n微信开放文档\r\neasymock\r\nVant Weapp\r\niconfont\r\n还有就是数据，有点伤感难过，数据自己在爱奇艺官网一个个找的，所以小程序里面的数据有一(da)部分是重复的，咱也不敢说，咱也不敢问(等我学会了爬虫，再去爬你几千条数据解解气)\r\n\r\n项目界面\r\n首页\r\n\r\n首页长成这个样子，一眼看过去还是挺好写的，布局什么的都比较有规律，对于小白来说还是很友善的，没有花里胡哨的排列。头部用的是小程序官方的swiper组件,炒鸡好用。不过有一点就是，轮播图的指示点一般都是在中间靠下面一点，而正好这里有文字，会重叠，没有绿色的指示点(爱奇艺偏爱环保健康的green)又不好看，脑壳疼，咋办？加几行css就行了。\r\n.wx-swiper-dots {\r\n  position: relative;\r\n  left: unset !important;\r\n  right: -40rpx;\r\n}\r\n.wx-swiper-dots.wx-swiper-dots-horizontal {\r\n  margin-bottom: -5rpx;\r\n}\r\n复制代码left不是可继承的样式，unset了之后，就相当于重置掉了，就可以开开心心的把指示点的位置换掉了。\r\n下面基本上就是一个  wx:for能解决的事情，对于这样的布局，用flex是再好不过的了，简单方便又快捷，顺便给大家推荐一篇详细讲解flex的文章，看了说不定你也会收获一些东西。\r\n\r\nwxml\r\n<!-- miniprogram/pages/homepage/homepage.wxml -->\r\n<view class=\"homePage\">\r\n  <view class=\"head\">\r\n    <swiper indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\" indicator-color=\"{{indicatorColor}}\" indicator-active-color=\"{{indicatorActiveColor}}\" circular=\"{{circular}}\">\r\n      <block wx:for=\"{{imgUrl}}\" wx:key=\"{{index}}\">\r\n        <view bindtap=\"navigate\" data-set=\"{{item}}\">\r\n          <swiper-item>\r\n            <image src=\"{{item.img}}\" mode=\"aspectFill\" class=\"slide-image\"></image>\r\n            <view class=\"desc\">{{item.desc}}</view>\r\n          </swiper-item>\r\n        </view>\r\n      </block>\r\n    </swiper>\r\n    <view class=\"header\">\r\n      <image class=\"iqiyi\" src=\"{{iqiyi}}\" mode=\"widthFix\" />\r\n      <view class=\"name\">{{headerName}}</view>\r\n      <view class=\"searchBox\" bindtap=\"toSearch\">\r\n        <icon class=\"iconSearch\" type=\"search\" size=\"15\" color=\"rgb(47,244,44)\"></icon>\r\n        <view class=\"searchName\">{{searchName}}</view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"content\">\r\n    <view class=\"contentVideoes\" wx:for=\"{{videoes}}\" wx:key=\"index\">\r\n      <!-- 板块标题 -->\r\n      <view class=\"title\">{{item.listTitle}}</view>\r\n      <!-- 板块内容，四个内容 -->\r\n      <view class=\"contain\">\r\n        <view class=\"video\" wx:for=\"{{item.videoList}}\" wx:key=\"index\" bindtap=\"navigate\" data-set=\"{{item}}\">\r\n          <view class=\"topPart\">\r\n            <image class=\"img\" src=\"{{item.img}}\" mode=\"widthFix\" />\r\n            <view class=\"count\">{{item.count}}</view>\r\n            <view class=\"vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n          </view>\r\n          <view class=\"downPart\">\r\n            <view class=\"videoTitle\">{{item.title}}</view>\r\n            <view class=\"videoDesc\">{{item.desc}}</view>\r\n          </view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码wxss\r\n/* miniprogram/pages/homepage/homepage.wxss */\r\n.homePage {\r\n  width: 100%;\r\n}\r\n.homePage .head {\r\n  position: relative;\r\n  width: 100%;\r\n}\r\n.homePage .head .slide-image {\r\n  width: 100%;\r\n}\r\n.homePage .head .desc {\r\n  position: absolute;\r\n  left: 20rpx;\r\n  bottom: 30rpx;\r\n  font-weight: bold;\r\n  font-size: 35rpx;\r\n  color: #ffffff\r\n}\r\n.homePage .head .header {\r\n  width: 100%;\r\n  position: absolute;\r\n  top: 10rpx;\r\n  left: 10rpx;\r\n  display: flex\r\n}\r\n.homePage .head .header .iqiyi {\r\n  width: 75rpx;\r\n  display: inline-block;\r\n  top: 20rpx;\r\n  left: 10rpx;\r\n  margin: auto\r\n}\r\n.homePage .head .header .name {\r\n  font-size: 30rpx;\r\n  color: #2BFA39;\r\n  font-weight: bold;\r\n  display: inline-block;\r\n  margin: auto\r\n}\r\n.homePage .head .header .searchBox {\r\n  flex: 1;\r\n  background-color: rgba(255,255,255,0.5);\r\n  border-radius: 42rpx;\r\n  margin: auto 30rpx;\r\n  height: 60rpx;\r\n  position: relative;\r\n}\r\n.homePage .head .header .searchBox .iconSearch {\r\n  margin: auto 20rpx;\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 20%;\r\n  transform: translate(-50%,-50%)\r\n}\r\n.homePage .head .header .searchBox .searchName {\r\n  display: inline-block;\r\n  font-size: 30rpx;\r\n  color: #ffffff;\r\n  margin-left: 50%;\r\n  transform: translate(-50%,0)\r\n}\r\n\r\n\r\n.homePage .content {\r\n  width: 100%;\r\n}\r\n.homePage .content .contentVideoes {\r\n  padding-right: 15rpx;\r\n}\r\n.homePage .content .contentVideoes .title {\r\n  font-size: 35rpx;\r\n  font-weight: bold;\r\n  margin: 25rpx 0 25rpx 25rpx;\r\n}\r\n.homePage .content .contentVideoes .contain {\r\n  width: 100%;\r\n}\r\n.homePage .content .contentVideoes .contain .video {\r\n  display: inline-block;\r\n  width: 50%;\r\n  margin-bottom: 10px;\r\n  padding-left: 15rpx;\r\n  box-sizing: border-box\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart {\r\n  position: relative;\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .img {\r\n  display: block;\r\n  width: 100%; \r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .count {\r\n  position: absolute;\r\n  right: 15rpx;\r\n  bottom: 15rpx;\r\n  font-size: 25rpx;\r\n  color: #fff;\r\n}\r\n.homePage .content .contentVideoes .contain .video .topPart .vip {\r\n  position: absolute;\r\n  top: 0rpx;\r\n  right: 20rpx;\r\n  font-size: 25rpx;\r\n  background-color: #E1B876;\r\n  color: #FFF;\r\n  padding: 0rpx 10rpx 5rpx;\r\n  border-radius: 0 0 10rpx 10rpx;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart {\r\n  padding-right: 10rpx;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart .videoTitle {\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n  margin-bottom: 15rpx;\r\n  overflow:hidden;\r\n  text-overflow:ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.homePage .content .contentVideoes .contain .video .downPart .videoDesc {\r\n  font-size: 25rpx;\r\n  margin-bottom: 20rpx;\r\n  color: #999;\r\n  overflow: hidden;\r\n  text-overflow:ellipsis;\r\n  white-space: nowrap;\r\n}\r\n.wx-swiper-dots {\r\n  position: relative;\r\n  left: unset !important;\r\n  right: -40rpx;\r\n}\r\n\r\n.wx-swiper-dots.wx-swiper-dots-horizontal {\r\n  margin-bottom: -5rpx;\r\n}\r\n复制代码热点页\r\n\r\n小程序家的video组件，瞄一分钟文档，就能上手了。暖暖的，很贴心。\r\n<video src=\"{{ item.video}}\" duration=\"{{item.duration }}\" object-fit=\"cover\" id=\"{{ item.id}}\"  bindtap=\"handleVideoPlay\" data-vid=\"{{item.id}}\" ></video>\r\n复制代码小红心的切换则是根据从云数据库中取得的数据,动态切换。\r\n<image src='{{item.isLike ? likeStar : star}}' class='littleStar' mode='aspectFit'></image>\r\n复制代码视频下面的布局就让万能的flex来解决叭。所以我决定送flex一朵花花。\r\n\r\nwxml\r\n<!-- miniprogram/pages/hot/hot.wxml -->\r\n<view class='hotVideo'>\r\n  <view class='video' wx:for=\"{{entities}}\" wx:key=\"id\" data-index=\"{{index}}\">\r\n    <video src=\"{{ item.video}}\" duration=\"{{item.duration }}\" object-fit=\"cover\" id=\"{{ item.id}}\"  bindtap=\"handleVideoPlay\" data-vid=\"{{item.id}}\" ></video>\r\n    <view class='title'>{{item.description}}</view>\r\n    <!-- 视频下面的用户信息以及视频热度和分享按钮,用一个盒子来包裹这些信息 -->\r\n    <view class='infor'>\r\n      <view class=\"infor-left\">\r\n        <image src='{{item.userAvatar}}' class='userAvatar' mode=\"aspectFit\"></image>\r\n        <view class='userNickName'>{{item.userNickName}}</view>\r\n      </view>\r\n      <view class=\"infor-right\">\r\n        <view class='star' bindtap=\"wxLike\" data-index=\"{{index}}\" >\r\n          <image src='{{item.isLike ? likeStar : star}}' class='littleStar' mode='aspectFit'></image>\r\n          <view class='hotStar'>{{item.star}}</view>\r\n        </view>\r\n        <view class='share' bindtap=\"wxShare\">\r\n          <image src='{{weixin}}' class='wxLogo' mode='aspectFit'></image>\r\n          <view class='wxshare'>分享</view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <van-notify id=\"van-notify\" />\r\n  <van-toast id=\"van-toast\" />\r\n</view>\r\n复制代码wxss\r\n/* miniprogram/pages/hot/hot.wxss */\r\n.hotVideo {\r\n  width: 100%;\r\n}\r\n.hotVideo .video {\r\n  position: relative;\r\n}\r\n.hotVideo .video video{\r\n  width: 100%;\r\n  z-index: 5;\r\n}\r\n.hotVideo .video .title {\r\n  position: absolute;\r\n  top: 20rpx;\r\n  left: 20rpx;\r\n  z-index: 10;\r\n  color: #fff;\r\n  font-size: 36rpx;\r\n  font-weight: bold;\r\n}\r\n.hotVideo .video .infor{\r\n  height: 125rpx;\r\n  position: relative;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-left {\r\n  height: 100%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-left .userAvatar {\r\n  width: 75rpx;\r\n  height: 75rpx;\r\n  margin: 20rpx 15px 30rpx 30rpx;\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n}\r\n.hotVideo .video .infor .infor-left .userNickName {\r\n  display: inline-block;\r\n  line-height: 125rpx;\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n}\r\n.hotVideo .video .infor .infor-right {\r\n  flex: 1;\r\n  height: 100%;\r\n}\r\n.hotVideo .video .infor .infor-right .star {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  right: 30%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-right .star .littleStar {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .infor-right .star .hotStar {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n.hotVideo .video .infor .infor-right .share {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  right: 5%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .infor-right .share .wxLogo {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .infor-right .share .wxshare {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n/* .hotVideo .video .infor{\r\n  height: 125rpx;\r\n  position: relative\r\n}\r\n.hotVideo .video .userAvatar {\r\n  width: 75rpx;\r\n  height: 75rpx;\r\n  float: left;\r\n  margin: 20rpx 15px 40rpx 30rpx;\r\n  border-radius: 50%;\r\n}\r\n.hotVideo .video .userNickName {\r\n  line-height: 125rpx;\r\n  font-size: 27rpx;\r\n  display: inline-block;\r\n}\r\n.hotVideo .video .infor .star {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  margin-left: 50%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .star .littleStar {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .star .hotStar {\r\n  line-height: 60rpx;\r\n  font-size: 30rpx;\r\n}\r\n.hotVideo .video .infor .share {\r\n  width: 150rpx;\r\n  height: 60rpx;\r\n  border: 1px solid #DDD;\r\n  border-radius: 42rpx;\r\n  position: absolute;\r\n  top: 0;\r\n  bottom: 0;\r\n  margin: auto;\r\n  margin-left: 75%;\r\n  display: flex;\r\n}\r\n.hotVideo .video .infor .share .weixin {\r\n  width: 40rpx;\r\n  height: 60rpx;\r\n  margin: auto 15rpx 20rpx;\r\n  float: left;\r\n  align-items: center\r\n}\r\n.hotVideo .video .infor .share .wxshare {\r\n   line-height: 60rpx;\r\n   font-size: 30rpx;\r\n} */\r\n复制代码风云榜\r\n\r\n头部的横向滚动，在scroll-view标签上设置scroll-x为true，并且加上white-space:nowrap;就能实现横向滚动了。标签页用的是vant的tab标签页，就省下自己写原生标签页的功夫可以去写别的了，不过小白白可以有空手动写一个，不算很难的。\r\n\r\nwxml\r\n<!-- miniprogram/pages/ranking/ranking.wxml -->\r\n<view class=\"ranking\">\r\n  <!-- 风云榜头部的分类 -->\r\n  <view class=\"ranking-header\">\r\n    <!-- 滑动的部分 -->\r\n    <scroll-view class=\"header\" scroll-x=\"{{true}}\" scroll-left=\"{{scrollLeft}}\">\r\n      <view wx:for=\"{{headerList}}\" wx:key=\"index\" class=\"headerList {{currentIndex === index?'selected': ''}}\" data-index=\"{{index}}\" bindtap=\"selected\">\r\n        {{item}}\r\n      </view>\r\n    </scroll-view>\r\n    <!-- 箭头部分 -->\r\n    <view class=\"header-arrow\" bindtap='showAllSort'>\r\n      <view class=\" {{isShow ? 'down-arrow up-arrow': 'down-arrow'}} \"></view>\r\n    </view>\r\n    <!-- 导航栏部分 -->\r\n    <view wx:if=\"{{isShow}}\" class=\"{{isShow ? 'header-sort opacity' : ''}}\">\r\n      <van-transition name=\"fade-down\">\r\n        <view wx:for=\"{{headerList}}\" wx:key=\"index\" class='headerSort' data-index=\"{{index}}\" bindtap=\"selected\">\r\n          {{item}}\r\n        </view>\r\n      </van-transition>\r\n    </view>\r\n  </view>\r\n  <!-- 下面的排行榜部分 -->\r\n  <view class=\"ranking-container\">\r\n    <van-tabs active=\"{{ active }}\" animated>\r\n      <!-- 热度榜 -->\r\n      <van-tab title=\"热度榜\">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=\"ranking-content\" wx:for=\"{{programs}}\" wx:key=\"{{index}}\">\r\n          <view class=\"ranking-list\" data-set=\"{{item}}\" bindtap=\"navigate\">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=\"list-left\">\r\n              <image src=\"{{item.img}}\" mode='aspectFill' class='image' />\r\n              <view class=\"list-number\">{{index + 1}}</view>\r\n              <view class=\"list-vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n              <view class=\"list-count\">{{item.count}}</view>\r\n            </view>\r\n            <view class=\"list-right\">\r\n              <view class=\"list-title\">{{item.title}}</view>\r\n              <view class=\"list-desc\">{{item.desc}}</view>\r\n              <view class=\"list-hot\">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n      <!-- 飙升榜 -->\r\n      <van-tab title=\"飙升榜\">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=\"ranking-content\" wx:for=\"{{programs}}\" wx:key=\"{{index}}\">\r\n          <view class=\"ranking-list\" data-set=\"{{item}}\" bindtap=\"navigate\">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=\"list-left\">\r\n              <image src=\"{{item.img}}\" mode='aspectFill' class='image' />\r\n              <view class=\"list-number\">{{index + 1}}</view>\r\n              <view class=\"list-vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n              <view class=\"list-count\">{{item.count}}</view>\r\n            </view>\r\n            <view class=\"list-right\">\r\n              <view class=\"list-title\">{{item.title}}</view>\r\n              <view class=\"list-desc\">{{item.desc}}</view>\r\n              <view class=\"list-hot\">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n      <!-- 播放指数榜 -->\r\n      <van-tab title=\"播放指数榜\">\r\n        <!-- 包裹着一个影视信息的小盒子 -->\r\n        <view class=\"ranking-content\" wx:for=\"{{programs}}\" wx:key=\"{{index}}\">\r\n          <view class=\"ranking-list\" data-set=\"{{item}}\" bindtap=\"navigate\">\r\n            <!-- 左边的图片部分 -->\r\n            <view class=\"list-left\">\r\n              <image src=\"{{item.img}}\" mode='aspectFill' class='image' />\r\n              <view class=\"list-number\">{{index + 1}}</view>\r\n              <view class=\"list-vip\" wx:if=\"{{item.vip}}\">VIP</view>\r\n              <view class=\"list-count\">{{item.count}}</view>\r\n            </view>\r\n            <view class=\"list-right\">\r\n              <view class=\"list-title\">{{item.title}}</view>\r\n              <view class=\"list-desc\">{{item.desc}}</view>\r\n              <view class=\"list-hot\">热度 {{item.hot}}</view>\r\n            </view>\r\n          </view>\r\n        </view>\r\n      </van-tab>\r\n    </van-tabs>\r\n  </view>\r\n</view>\r\n复制代码wxss\r\n/* miniprogram/pages/ranking/ranking.wxss */\r\n.ranking {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n  left: 0;\r\n}\r\n.ranking .ranking-header {\r\n  width: 100%;\r\n  height: 80rpx;\r\n  background-color: #F6F6F6;\r\n  border-bottom: 2rpx solid #E3E3E3;\r\n}\r\n.ranking .ranking-header .header {\r\n  width: 90%;\r\n  height: 100%;\r\n  white-space: nowrap;\r\n  overflow-x: auto;\r\n}\r\n/* .header::-webkit-scrollbar {\r\n  display: none;\r\n} */\r\n.ranking .ranking-header .header .headerList {\r\n  display: inline-block;\r\n  margin: 0rpx 25rpx;\r\n  text-align: center;\r\n  line-height: 80rpx;\r\n  \r\n}\r\n.ranking .ranking-header .header .headerList.selected {\r\n  color: green;\r\n}\r\n.ranking .ranking-header .header-arrow {\r\n  position: absolute;\r\n  right:0;\r\n  top:0;\r\n  overflow: hidden;\r\n  width: 80rpx;\r\n  height: 80rpx;\r\n  background-color: #F6F6F6;\r\n  border-left: 1px solid #E3E3E3\r\n}\r\n.ranking .ranking-header .header-arrow .down-arrow {\r\n  width: 25rpx;\r\n  height: 25rpx;\r\n  border-bottom: 2px solid #999;\r\n  border-right: 2px solid #999;\r\n  margin: 40rpx auto 0rpx;\r\n  transform: rotateZ(45deg) translate(-50%,-50%);\r\n  transition: transform 0.5s;\r\n}\r\n.ranking .ranking-header .header-arrow .down-arrow.up-arrow {\r\n  transform: rotateZ(-135deg) translate(25%,25%);\r\n}\r\n.ranking .ranking-header .header-sort {\r\n  width: 100%;\r\n  border-bottom: 1px solid #EFEFEF;\r\n  background-color: rgba(255, 255, 255,0.8);\r\n  position: absolute;\r\n  z-index: 5;\r\n  transition: opacity 3s;\r\n}\r\n\r\n.ranking .ranking-header .header-sort .headerSort {\r\n  width: 20%;\r\n  display: inline-block;\r\n  font-size: 25rpx;\r\n  text-align: center;\r\n  margin: 17rpx auto;\r\n  opacity: 0.8;\r\n}\r\n.ranking .ranking-container {\r\n  width: 100%;\r\n}\r\n.ranking .ranking-container .ranking-content {\r\n  width: 100%;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list {\r\n  display: flex;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left {\r\n  display: inline-block;\r\n  margin: 20rpx;\r\n  position: relative;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .image {\r\n  width: 270rpx;\r\n  height: 150rpx;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-number {\r\n  position: absolute;\r\n  left: 0rpx;\r\n  top: 0rpx;\r\n  font-size: 35rpx;\r\n  background-color: #FC2932;\r\n  width: 45rpx;\r\n  height: 45rpx;\r\n  padding-right: 10rpx;\r\n  text-align: center;\r\n  border-radius: 0 5rpx 45rpx 0;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-vip {\r\n  position: absolute;\r\n  top: 0rpx;\r\n  right: 5rpx;\r\n  font-size: 25rpx;\r\n  background-color: #E1B876;\r\n  color: #FFF;\r\n  padding: 0rpx 10rpx 5rpx;\r\n  border-radius: 0 0 10rpx 10rpx;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-left .list-count {\r\n  position: absolute;\r\n  right: 20rpx;\r\n  bottom: 20rpx;\r\n  font-size: 20rpx;\r\n  color: #fff;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right {\r\n  display: inline-block;\r\n  position: relative;\r\n  top: 15rpx;\r\n  padding: 10rpx;\r\n  white-space: nowrap;\r\n  text-overflow: ellipsis;\r\n  overflow: hidden;\r\n  flex: 1;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-title {\r\n  font-size: 30rpx;\r\n  font-weight: bold;\r\n  margin-bottom: 15rpx;\r\n  overflow:hidden;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-desc {\r\n  font-size: 30rpx;\r\n  margin-bottom: 20rpx;\r\n  color: #999;\r\n  overflow: hidden;\r\n  text-overflow:ellipsis;\r\n}\r\n.ranking .ranking-container .ranking-content .ranking-list .list-right .list-hot {\r\n  font-size: 25rpx;\r\n  color: #999\r\n}\r\n复制代码还有几个页面比较简单，就不介绍了。\r\n\r\n功能的实现\r\n高亮模糊查询\r\n\r\n这里我只是实现了一个简单版的模糊查询，也参考了一下网上的思路(好吧是我太菜了)，毕竟有问题就找度娘嘛。实时获取到输入框中的文字value，用filter和include方法筛选出包含value的名字，放入filter_list数组中,再遍历filter_list数组，将其中的字段切分为三段，然后就是这样的\r\n\r\n当value和其中的一项相等时，就改变颜色，怎么样，是不是还挺简单的\r\nonChange(event) {\r\n    const list = this.data.allName;//这里是所有的名字\r\n    const value = event.detail; //实时获取输入框中的文字\r\n    const result = [] \r\n    if (event.detail !== '') {//当输入框中有文字的话，就筛选出含有value的名字\r\n      let filter_list = [...new Set(//用Set是因为我的数据中有重复的字段\r\n        list.filter(item => {\r\n          return item.includes(value)\r\n        })\r\n      )]\r\n      filter_list.forEach(item => {//遍历\r\n      // 将名字切割成三段放入数组中，和value一样的字段的就换个颜色\r\n        let index1 = item.indexOf(value)\r\n        let index2 = value.length\r\n        let string1 = item.slice(0, index1)\r\n        let string2 = item.slice(index1, index1 + index2)\r\n        let string3 = item.slice(index1 + index2)\r\n        console.log([string1, string2, string3])\r\n        result.push([string1,string2,string3])\r\n      })\r\n      this.setData({\r\n        value,\r\n        result\r\n      })\r\n    } else {\r\n      this.setData({\r\n        result: null\r\n      })\r\n    }\r\n  },\r\n复制代码<!-- 这里是搜索到的结果 -->\r\n  <view class=\"results\">\r\n    <view class=\"result\" wx:for=\"{{result}}\" wx:key=\"index\" bindtap=\"navigate\" data-name='{{item}}'>\r\n      <text  wx:for=\"{{item}}\" class=\"{{item == value ? 'highlight' : 'normal' }}\" wx:key=\"index\">{{item}}</text>  \r\n    </view>\r\n  </view>\r\n复制代码页面的带参跳转\r\n我给每个需要跳转的元素都绑定了设置了自定义属性data-*和用bind-tap绑定了navigate点击事件，方便在js中获取当前需要的信息,在跳转的时候用路由传参的形式将信息携带过去，JSON.stringify()方法可以将对象或者数组转换为一个 JSON字符串\r\n navigate(e) {\r\n    const dataSet = e.currentTarget.dataset.set;\r\n    const item = JSON.stringify(dataSet);\r\n    wx.navigateTo({\r\n      url: '../show/show?item=' + item\r\n    })\r\n  },\r\n复制代码然后在接收的时候使用JSON.parse()方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作).就可以在该显示的界面获取到信息了\r\nonLoad: function (options) {\r\n    const item = JSON.parse(options.item);\r\n    this.setData({\r\n      entities : item\r\n    })\r\n  },\r\n复制代码\r\n云数据库的增删改查\r\n这里大概是最让我崩溃的一个环节了，其中的辛酸苦辣(抹眼泪)，就是有句mmp不知当讲不当讲，同样的操作，上午不能执行成功，然后检查代码查bug翻文档，下午就能执行成功了，回头一看，我又没改代码，怎么就成功了呢，咋的，觉着我好欺负？\r\n\r\n添加数据和删除数据\r\nexports.main = async (event, context) => {\r\n  if(event.isAdd) {//idAdd是传过来的参数，为true时，往wxlike集合中添加字段\r\n    return db.collection('wxlike').add({\r\n      data: {\r\n        id: event.index,\r\n        Videoes:event.entity\r\n      }\r\n    })\r\n      .then(res => {\r\n        console.log(res)\r\n      })\r\n  } else {//isAdd为false时，根据id查到这个字段，然后删除\r\n    return db.collection('wxlike').where({\r\n      id: event.index\r\n    }).remove();\r\n  }\r\n}\r\n复制代码在iqiyi这个集合中根据name属性找到相应的字段并且获取id，再根据id去更新字段。\r\nexports.main = async (event, context) => {\r\n  let entities = await db.collection('iqiyi').where({\r\n    name: event.name\r\n  })\r\n  .get();\r\n  let id = entities._id;\r\n  return await db.collection('iqiyi').doc(id).update({\r\n    data: {\r\n      hotspot: {\r\n        videoes:event.entities\r\n      }\r\n    }\r\n  }).then(res => {\r\n  })\r\n}\r\n复制代码根据传过来的name属性从集合中查找数据\r\nexports.main = async (event, context) => {\r\n  \r\n  let entities = await db.collection('iqiyi').where({\r\n    name: event.name\r\n  })\r\n  .get()\r\n  return entities\r\n}\r\n复制代码看，数据库增删查改就这么几行代码就能搞定，真是幸福感爆棚。\r\n只能同时播放一个的视频\r\n在热点页，视频都是以单个video的形式存在,\r\n<video src=\"{{ item.video}}\" duration=\"{{item.duration }}\" object-fit=\"cover\" id=\"{{ item.id}}\"  bindtap=\"handleVideoPlay\" data-vid=\"{{item.id}}\" ></video>\r\n复制代码emmmmmm,这一段好像上面看过了，没事那就在看一遍吧。\r\n我们需要控制它不能同时播放两个视频，点击下一个视频时，上一个视频需要暂停掉，不然同时两个视频的声音播放，我觉得脑壳可能会炸掉。我们给每个video标签都绑定handleVideoPlay方法，并且设置自定义属性data-vid=\"{{item.id}}\"方便来获取他们的id来分别控制和播放\r\nhandleVideoPlay(e) {\r\n    if (this.data.currentVideo) {//currentVideo是当前播放的视频，初始值为null\r\n      this.data.currentVideo.pause();//如果存在currentVideo则停掉\r\n    }\r\n    const Vid = e.target.id;//获取点击的视频的id\r\n    if (Vid) {\r\n      // 创建 video 上下文 VideoContext 对象。\r\n      const currentVideo = wx.createVideoContext(`${Vid}`);\r\n      this.setData({\r\n        currentVideo\r\n      })\r\n      currentVideo.play();\r\n    }\r\n  },\r\n复制代码结语\r\n总体来看吧，这个demo主要是就是切页面，云数据库的操作和数据渲染了，呐呐呐，这是github地址,虽然页面和功能不多，在写的时候还是磕磕绊绊的遇到了各种各样的问题，不过最终还算是完成了。以后再接再厉鸭！！！最后祝看文章的小姐姐都能有杨紫小猴子辣么漂酿，，小哥哥都比李现现还帅，单身的程序猿都能找到像佟年和韩商言一般的好对象，蟹蟹蟹蟹啦，，留下个赞再走叭！！！"}
{"title": "Taro+dva+Typescript 搭建微信小程序架构 ", "author": "Rolan", "pub_time": "2019-7-30 00:15", "content": "原文链接个人博客-欢迎访问效果预览图：微信小程序的开发目前是很热的一个领域，有很多的开发模式，找到一种属于自己的方法才会使得开发顺心顺利。此架构是使用 Taro + dva + typescript 构建前端开发京东凹凸实验室的React框架Taro很成熟，又是大厂在维护更新迭代，不用担心没人维护的问题，他有自己的UI还有物料社区，比起原生小程序方便很多，支持多端，一处代码，多处运行，微信小程序、H5、百度小程序、支付宝小程序、字节跳动小程序、QQ轻应用、快应用、ReactNative；数据管理是Redux集成的dva框架，是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架；TypeScript就是所谓的JavaScript超集。它不是JavaScript的替代品，也不会为JavaScript代码添加任何新功能。相反，TypeScript允许程序员在其代码中使用面向对象的构造，然后将其转换为JavaScript。它还包括类型安全和编译时类型检查等便利功能。资料Taro官网地址：https://taro.aotu.io/dva官网地址：https://dvajs.com/guide/开始前期工作准备cli 工具安装:# 使用 npm 安装 cli\r\n$ npm install -g @tarojs/cli\r\n\r\n# OR 使用 yarn 安装 cli\r\n$ yarn global add @tarojs/cli\r\n\r\n# OR 安装了 cnpm，使用 cnpm 安装 cli\r\n$ cnpm install -g @tarojs/cli\r\n\r\n\r\n复制代码使用命令创建模板项目:$ taro init Taro_dva_Typescript\r\n\r\n复制代码安装配置文件安装dvacnpm install --save dva-core dva-loadingdva-core\r\ndva-loading\r\n安装@tarojs/reduxcnpm install --save redux @tarojs/redux @tarojs/redux-h5 redux-thunk redux-logger配置项目文件去除不需要的文件，添加实际需要的一些文件，先删除 ./ssrc/page 下的index文件夹，后期使用命令行生成完整结构的文件夹。在``/src`目录下根据自己的实际需求进行一下配置：assets\r\nconfig\r\ncomponents\r\ntypes\r\nmodels\r\nutils\r\n项目一些具体配置操作1、在 ./src/config 下创建index.ts，添加项目配置信息/** \r\n * 这里为了方便测试使用 Easy Mock 模拟接口数据\r\n * \r\n * https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist\r\n*/\r\n\r\nexport const ONLINEHOST = 'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist';\r\n\r\n/** \r\n * mock 接口\r\n * */ \r\nexport const MOCKHOST = 'https://www.easy-mock.com/mock/5d38269ffb233553ab0d10ad/getlist';\r\n\r\n/** \r\n * 是否mock\r\n*/\r\n\r\nexport const ISMOCK = true;\r\n\r\n\r\n/**\r\n * 这是一个全局的分享信息 不用每一个都去写\r\n */\r\nexport const SHAREINFO = {\r\n    'title': '分享标题',\r\n    'path': '路径',\r\n    'imageUrl': '图片'\r\n  }\r\n\r\n\r\n复制代码2、在 ./src/utils 下创建dva.ts，配置dvaimport { create } from \"dva-core\";\r\nimport { createLogger } from \"redux-logger\";\r\nimport  createLoading  from \"dva-loading\";\r\n\r\n\r\n\r\nlet app\r\nlet store\r\nlet dispatch\r\nlet registered\r\n\r\nfunction createApp(opt) {\r\n    // redux 的日志\r\n    opt.onAction = [createLogger()]\r\n    app = create(opt)\r\n    app.use(createLoading({}))\r\n\r\n    if (!registered) {\r\n        opt.models.forEach(model => app.model(model));\r\n    }\r\n    registered = true;\r\n    app.start()\r\n\r\n    store = app._store;\r\n    app.getStore = () => store;\r\n    app.use({\r\n        onError(err){\r\n            console.log(err);\r\n        }\r\n    })\r\n\r\n    dispatch = store.dispatch;\r\n    app.dispatch = dispatch;\r\n    return app;\r\n}\r\n\r\nexport default{\r\n    createApp,\r\n    getDispatch(){\r\n        return app.dispatch\r\n    }\r\n}\r\n\r\n复制代码3、在 ./src/utils 下创建tips.ts，整合封装微信原生弹窗import Taro from \"@tarojs/taro\";\r\nimport { node } from \"_@types_prop-types@15.7.1@@types/prop-types\";\r\n\r\n/** \r\n * 整合封装微信的原生弹窗\r\n * 提示、加载、工具类\r\n*/\r\n\r\nexport default class Tips {\r\n\tstatic isLoading = false;\r\n\r\n\t/** \r\n\t * 提示信息\r\n\t*/\r\n\tstatic toast(title: string, onHide?: () => void) {\r\n\t\tTaro.showToast({\r\n\t\t\ttitle: title,\r\n\t\t\ticon: 'node',\r\n\t\t\tmask: true,\r\n\t\t\tduration: 1500\r\n\t\t});\r\n\t\t// 去除结束回调函数\r\n\t\tif (onHide) {\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tonHide();\r\n\t\t\t}, 500);\r\n\t\t}\r\n\t}\r\n\r\n\t/** \r\n\t * 加载提示弹窗\r\n\t*/\r\n\r\n\tstatic loding(title:'加载中',force = false){\r\n\t\tif (this.isLoading && !force) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.isLoading = true;\r\n\t\tif (Taro.showLoading) {\r\n\t\t\tTaro.showLoading({\r\n\t\t\t\ttitle:title,\r\n\t\t\t\tmask:true\r\n\t\t\t})\r\n\t\t}else{\r\n\t\t\tTaro.showNavigationBarLoading() //导航条加载动画\r\n\t\t}\r\n\t}\r\n\r\n\t/** \r\n\t * 加载完成\r\n\t*/\r\n\tstatic loaded(){\r\n\t\tlet duration = 0;\r\n\t\tif (this.isLoading) {\r\n\t\t\tthis.isLoading = false;\r\n\t\t\tif (Taro.hideLoading) {\r\n\t\t\t\tTaro.hideLoading()\r\n\t\t\t} else {\r\n\t\t\t\tTaro.hideNavigationBarLoading(); //导航条加载动画\r\n\t\t\t}\r\n\t\t\tduration = 500;\r\n\t\t}\r\n\t\t// 设定隐藏的动画时长为500ms,防止直接toast时出现问题\r\n\t\treturn new Promise(resolve => setTimeout(resolve,duration))\r\n\t}\r\n\r\n\t/** \r\n\t * 弹出提示框\r\n\t*/\r\n\r\n\tstatic success(title,duration = 1500){\r\n\t\tTaro.showToast({\r\n\t\t\ttitle: title,\r\n\t\t\ticon: 'success',\r\n\t\t\tduration: duration,\r\n\t\t\tmask:true\r\n\t\t})\r\n\t\tif (duration > 0) {\r\n\t\t\treturn new Promise(resolve => setTimeout(resolve,duration))\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n复制代码4、在 ./src/config 下创建requestConfig.ts，统一配置请求接口/** \r\n * 请求公共参数\r\n*/\r\n\r\nexport const commonParame = {}\r\n\r\n/** \r\n * 请求的映射文件\r\n*/\r\n\r\nexport const requestConfig = {\r\n    loginUrl:'/api/user/wechat-auth' // 微信的登陆接口\r\n}\r\n\r\n\r\n复制代码5、在 ./src/utils 下创建common.ts，共用函数/** \r\n * 共用函数\r\n*/\r\n\r\nexport const repeat = (str = '0', times) => (new Array(times + 1)).join(str);\r\n// 时间前面 +0 \r\nexport const pad = (num, maxLength = 2) => repeat('0', maxLength - num.toString().length) + num;\r\n\r\n// 全局的公共变量\r\nexport let globalData: any = {\r\n\r\n}\r\n\r\n// 时间格式装换函数\r\n\r\nexport const formatTime = time => {\r\n    `${pad(time.getHours())}:${pad(time.getMinutes())}:${pad(time.getSeconds())}.${pad(time.getMilliseconds(), 3)}`\r\n}\r\n\r\n复制代码6、在 ./src/utils 下创建logger.ts，封装log函数/** \r\n * 封装logo函数\r\n*/\r\n\r\nimport { formatTime } from './common';\r\n\r\nconst defaults = {\r\n\tlevel: 'log',\r\n\tlogger: console,\r\n\tlogErrors: true,\r\n\tcolors: {\r\n\t\ttitle:'logger',\r\n\t\treq:'#9e9e9e',\r\n\t\tres:'#4caf50',\r\n\t\terror:'#f20404',\r\n\t}\r\n}\r\n\r\nfunction printBuffer(logEntry, options){\r\n\tconst {logger,colors} = options;\r\n\tlet {title,started,req,res} = logEntry;\r\n\t\r\n\t// Message\r\n\tconst headerCSS = ['color:gray; font-weight:lighter;']\r\n\tconst styles = s => `color ${s}; font-weight: bold`;\r\n\r\n\t// render\r\n\tlogger.group(`%c ${title} @${formatTime(started)}`, ...headerCSS);\r\n\tlogger.log('%c req', styles(colors.req), req)\r\n\tlogger.log('%c res', styles(colors.res), res)\r\n\tlogger.groupEnd()\r\n\r\n}\r\n\r\ninterface LogEntry{\r\n\tstarted ? : object  // 触发时间\r\n}\r\n\r\nfunction createLogger(options: LogEntry = {}){\r\n\tconst loggerOptions = Object.assign({}, defaults, options)\r\n\tconst logEntry = options\r\n\tlogEntry.started = new Date();\r\n\tprintBuffer(logEntry, Object.assign({}, loggerOptions))\r\n}\r\n\r\nexport {\r\n\tdefaults,\r\n\tcreateLogger,\r\n}\r\n\r\n复制代码7、在 ./src/utils 下创建request.ts，封装http请求import Taro,{ Component } from \"@tarojs/taro\";\r\nimport { ISMOCK,MAINHOST } from \"../config\";\r\nimport { commonParame,requestConfig } from \"../config/requestConfig\";\r\nimport Tips from \"./tips\";\r\n\r\n\r\n// 封装请求\r\n\r\n\r\ndeclare type Methohs = \"GET\" | \"OPTIONS\" | \"HEAD\" | \"PUT\" | \"DELETE\" | \"TRACE\" | \"CONNECT\";\r\ndeclare type Headers = { [key :string]:string};\r\ndeclare type Datas = {method : Methohs; [key: string] : any;};\r\ninterface Options{\r\n    url: string;\r\n    host?: string;\r\n    method?: Methohs;\r\n    data?: Datas;\r\n    header?: Headers;\r\n}\r\n\r\nexport class Request {\r\n    // 登陆时的promise\r\n    static loginReadyPromise: Promise<any> = Promise.resolve()\r\n\r\n    // 正在登陆\r\n    static isLoading: boolean = false\r\n\r\n    // 导出的API对象\r\n    static apiLists: { [key: string]: () => any;} = {}\r\n\r\n    // token\r\n    static token: string = ''\r\n\r\n    // 开始处理options\r\n    static conbineOptions(opts, data: Datas, method: Methohs): Options {\r\n        typeof opts ===  'string' && (opts = {url: opts})\r\n        return {\r\n            data: { ...commonParame, ...opts.data, ...data },\r\n            method: opts.method || data.method || method || 'GET',\r\n            url: `${opts.host || MAINHOST}${opts.url}`\r\n        }\r\n    }\r\n\r\n    static getToken(){\r\n        !this.token && (this.token = Taro.getStorageSync('token'))\r\n        return this.token\r\n    }\r\n\r\n\r\n    // 登陆\r\n    static login(){\r\n        if (!this.isLoading) {\r\n            this.loginReadyPromise = this.onLogining()\r\n        }\r\n        return this.loginReadyPromise\r\n    }\r\n\r\n    static onLogining(){\r\n        this.isLoading = true;\r\n        return new Promise(async (resolve, reject) => {\r\n            // 获取code\r\n            const { code } = await Taro.login();\r\n\r\n            const { data } = await Taro.request({\r\n                url: `${MAINHOST}${requestConfig.loginUrl}`,\r\n                data:{code: code}\r\n            })\r\n\r\n            if (data.code !== 0 || !data.data || !data.data.token) {\r\n                reject()\r\n                return\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    /** \r\n     * 基于 Taro.request 的 request 请求\r\n     * \r\n     * */ \r\n    static async request(opts: Options) {\r\n        \r\n        // Taro.request 请求\r\n        const res = await Taro.request(opts);\r\n\r\n        // 是否mock\r\n        if(ISMOCK) return res.data;\r\n\r\n        // 请求失败\r\n        if (res.data.code === 99999) {\r\n            await this.login();\r\n            return this.request(opts)\r\n        }\r\n\r\n        // 请求成功\r\n        if (res.data) {\r\n            return res.data\r\n        }\r\n\r\n        // 请求错误\r\n        const edata = { ...res.data, err : (res.data && res.data.msg) || '网络错误 ~'}\r\n        Tips.toast(edata.err)\r\n        throw new Error(edata.err)\r\n\r\n    }\r\n\r\n\r\n    /** \r\n     * 创建请求函数\r\n    */\r\n   static creatRequests(opts: Options | string) : () => {} {\r\n       console.log('opts==>',opts);\r\n       return async (data={}, method: Methods = \"GET\") => {\r\n           const _opts = this.conbineOptions(opts, data, method)\r\n           const res = await this.request(_opts)\r\n            return res;\r\n        }\r\n   }\r\n\r\n   /** \r\n    * 抛出API方法\r\n   */\r\n\r\n   static getApiList(requestConfig){\r\n        if (!Object.keys(requestConfig).length) {\r\n            return {}\r\n        }\r\n        Object.keys(requestConfig).forEach((key)=>{\r\n            this.apiLists[key] = this.creatRequests(requestConfig[key])\r\n        })\r\n        return this.apiLists\r\n   }\r\n\r\n\r\n}\r\n\r\nconst Api = Request.getApiList(requestConfig)\r\nComponent.prototype.$api = Api\r\nexport default Api as any\r\n\r\n\r\n复制代码注：在这里tslint会报这样的错： 类型“Component<any, any>”上不存在属性“$api” 。，因为没有添加声明，需在./src目录下创建 app-shim.d.ts/** \r\n * 添加taro等自定义类型\r\n*/\r\n\r\nimport Taro,{ Component } from '@tarojs/taro'\r\n\r\n// 在Component上定义自定义方法类型\r\ndeclare module '@tarojs/taro' {\r\n    interface Component {\r\n        $api: any\r\n    }\r\n}\r\n\r\n// 声明\r\ndeclare let require: any;\r\ndeclare let dispatch: any\r\n\r\n复制代码8、在 ./src/config 下创建taroConfig.ts，封装taro小程序的一些方法import Taro,{ Component } from '@tarojs/taro'\r\nimport { SHAREINFO } from '../config/index'\r\n\r\n\r\n\r\n/** \r\n * 封装taro小程序的一些方法\r\n *  - 方法改写\r\n *  - utils 挂载\r\n*/\r\n\r\n\r\n// navigateTo 超过8次后，强行进行redirectTo,避免页面卡顿\r\n\r\n const nav = Taro.navigateTo\r\n Taro.navigateTo = (data) => {\r\n     if (Taro.getCurrentPages().length > 8) {\r\n         return Taro.redirectTo(data)\r\n     }\r\n     return nav(data)\r\n }\r\n\r\n\r\n// 挂载分享方法 Component\r\n\r\nComponent.prototype.onShareAppMessage = function () {\r\n    return SHAREINFO\r\n}\r\n\r\n\r\n复制代码配置文件生成脚本1、在根目录下创建scripts文件夹，添加 ./scripts/template.js/** \r\n *  pages 页面快速生成脚本\r\n *  \r\n *  npm run tem '文件名‘\r\n*/\r\n\r\nconst fs = require('fs')\r\nconst dirName = process.argv[2]\r\nconst capPirName = dirName.substring(0, 1).toUpperCase() + dirName.substring(1);\r\n\r\nif (!dirName) {\r\n    console.log('文件名不能为空');\r\n    console.log('用法：npm run tem test');\r\n    process.exit(0);\r\n}\r\n\r\n// 页面模板构建\r\n\r\nconst indexTep = `\r\n    import Taro, { Component, Config } from '@tarojs/taro'\r\n    import { View } from '@tarojs/components'\r\n    // import { connect } from '@tarojs/redux'\r\n    // import Api from '../../utils/request'\r\n    // import Tips from '../../utils/tips'\r\n    import { ${capPirName}Props, ${capPirName}State } from './${dirName}.interface'\r\n    import './${dirName}.scss'\r\n    // import {  } from '../../components'\r\n\r\n    // @connect(({ ${dirName} }) => ({\r\n    //     ...${dirName},\r\n    // }))\r\n\r\n    class ${capPirName} extends Component<${capPirName}Props,${capPirName}State > {\r\n    config:Config = {\r\n        navigationBarTitleText: '页面标题'\r\n    }\r\n    constructor(props: ${capPirName}Props) {\r\n        super(props)\r\n        this.state = {}\r\n    }\r\n\r\n    componentDidMount() {\r\n        \r\n    }\r\n\r\n    render() {\r\n        return (\r\n        <View className='fx-${dirName}-wrap'>\r\n            页面内容\r\n        </View>\r\n        )\r\n    }\r\n    }\r\n    export default ${capPirName}\r\n`\r\n\r\n// scss 文件模板\r\n\r\nconst scssTep = `\r\n    @import \"../../assets/scss/variables\";\r\n    .#{$prefix} {\r\n        &-${dirName}-wrap {\r\n            width: 100%;\r\n            min-height: 100Vh;\r\n        }\r\n    }\r\n`\r\n\r\n// config 接口地址配置模板\r\n\r\nconst configTep =`\r\n    export default {\r\n        test:'/wechat/perfect-info',  //XX接口\r\n    }\r\n`\r\n\r\n// 接口请求模板\r\n\r\nconst serviceTep =`\r\n    import Api from '../../utils/request'\r\n    export const testApi = data => Api.test(\r\n        data\r\n    )\r\n`\r\n\r\n// model 模板\r\n\r\nconst modelTep = `\r\n    // import Taro from '@tarojs/taro';\r\n    // import * as ${dirName}Api from './service';\r\n    export default {\r\n        namespace: '${dirName}',\r\n        state: {\r\n        },\r\n        \r\n        effects: {},\r\n        \r\n        reducers: {}\r\n    \r\n    }\r\n\r\n`\r\n\r\nconst interfaceTep = `\r\n/**\r\n * ${dirName}.state 参数类型\r\n *\r\n * @export\r\n * @interface ${capPirName}State\r\n */\r\nexport interface ${capPirName}State {}\r\n\r\n/**\r\n * ${dirName}.props 参数类型\r\n *\r\n * @export\r\n * @interface ${capPirName}Props\r\n */\r\nexport interface ${capPirName}Props {}\r\n`\r\n\r\nfs.mkdirSync(`./src/pages/${dirName}`); // mkdir $1\r\nprocess.chdir(`./src/pages/${dirName}`); // cd $1\r\n\r\nfs.writeFileSync(`${dirName}.tsx`, indexTep); //tsx\r\nfs.writeFileSync(`${dirName}.scss`, scssTep); // scss\r\nfs.writeFileSync('config.ts', configTep); // config\r\nfs.writeFileSync('service.ts', serviceTep); // service\r\nfs.writeFileSync('model.ts', modelTep); // model\r\nfs.writeFileSync(`${dirName}.interface.ts`, interfaceTep); // interface\r\nprocess.exit(0);\r\n\r\n\r\n\r\n复制代码最后在根目录的 package.json 的scripts里加上对应的命令\"scripts\": {\r\n  ...\r\n  \"tep\": \"node scripts/template\",\r\n  \"com\": \"node scripts/component\"\r\n}\r\n\r\n复制代码2、自动生成脚本文件夹cnpm run tep indexpage文件夹下生成了一个index的文件夹，里面包含config.tsindex.interface.tsindex.scssindex.tsxmodel.tsservice.ts配置业务代码1、先在 src 目录下创建 models 文件夹，集合项目里的 model 关系。import index from '../pages/index/model';\r\n\r\n\r\nexport default[\r\n    index\r\n]\r\n\r\n复制代码项目目前只有 index 页面， export default 这里的数组就只有 index ，需要注意这里是 []数组。2、修改非常主要的文件 app.tsximport Taro, { Component, Config } from '@tarojs/taro'\r\nimport \"@tarojs/async-await\";\r\nimport { Provider } from \"@tarojs/redux\";\r\nimport dva from './utils/dva';\r\nimport './utils/request';\r\nimport { globalData } from './utils/common';\r\n\r\nimport models from './models'\r\nimport Index from './pages/index'\r\nimport './app.scss'\r\n\r\n// 如果需要在 h5 环境中开启 React Devtools\r\n// 取消以下注释：\r\n// if (process.env.NODE_ENV !== 'production' && process.env.TARO_ENV === 'h5')  {\r\n//   require('nerv-devtools')\r\n// }\r\n\r\n\r\nconst dvaApp = dva.createApp({\r\n  initialState:{},\r\n  models:  models,\r\n})\r\n\r\nconst store = dvaApp.getStore();\r\n\r\nclass App extends Component {\r\n\r\n  /**\r\n   * 指定config的类型声明为: Taro.Config\r\n   *\r\n   * 由于 typescript 对于 object 类型推导只能推出 Key 的基本类型\r\n   * 对于像 navigationBarTextStyle: 'black' 这样的推导出的类型是 string\r\n   * 提示和声明 navigationBarTextStyle: 'black' | 'white' 类型冲突, 需要显示声明类型\r\n   */\r\n  config: Config = {\r\n    pages: [\r\n      'pages/index/index'\r\n    ],\r\n    window: {\r\n      backgroundTextStyle: 'light',\r\n      navigationBarBackgroundColor: '#fff',\r\n      navigationBarTitleText: 'WeChat',\r\n      navigationBarTextStyle: 'black'\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   *  1.小程序打开的参数 globalData.extraData.xx\r\n   *  2.从二维码进入的参数 globalData.extraData.xx\r\n   *  3.获取小程序的设备信息 globalData.systemInfo\r\n   */\r\n  async componentDidMount () {\r\n    // 获取参数\r\n    const referrerInfo = this.$router.params.referrerInfo\r\n    const query = this.$router.params.query\r\n    !globalData.extraData && (globalData.extraData = {})\r\n    if (referrerInfo && referrerInfo.extraData) {\r\n      globalData.extraData = referrerInfo.extraData\r\n    }\r\n    if (query) {\r\n      globalData.extraData = {\r\n        ...globalData.extraData,\r\n        ...query\r\n      }\r\n    }\r\n\r\n    // 获取设备信息\r\n    const sys = await Taro.getSystemInfo()\r\n    sys && (globalData.systemInfo = sys)\r\n  }\r\n\r\n  componentDidShow () {}\r\n\r\n  componentDidHide () {}\r\n\r\n  componentDidCatchError () {}\r\n\r\n  render () {\r\n    return (\r\n      <Provider store={store}>\r\n        <Index />\r\n      </Provider>\r\n    )\r\n  }\r\n}\r\n\r\nTaro.render(<App />, document.getElementById('app'))\r\n\r\n\r\n复制代码3、修改接口请求 ./src/pages/index/config.ts 文件一个获取列表数据接口export default {\r\n  getList: '/getlist', //getlist接口\r\n}\r\n\r\n复制代码4、修改 ./src/config/requestConfig.ts 文件的映射关系引入 index 页面的刚刚创建的 config 文件import index from \"../pages/index/config\"; // index的接口\r\n\r\n\r\n\r\n/** \r\n * 请求公共参数\r\n*/\r\nexport const commonParame = {}\r\n\r\n/** \r\n * 请求的映射文件\r\n*/\r\n\r\nexport const requestConfig = {\r\n    loginUrl:'/api/user/wechat-auth', // 微信的登陆接口\r\n    ...index\r\n}\r\n\r\n\r\n复制代码5、修改 ./src/pages/index/service.ts 里的接口请求还是依据之前的 getlist 接口import Api from '../../utils/request'\r\n\r\nexport const getList = (data) => {\r\n\r\n  return Api.getList(data)\r\n\r\n}\r\n  \r\n\r\n复制代码6、修改 ./src/pages/index/index.interface.ts 里的参数类型根据项目具体的参数，自行进行配置/**\r\n * index.state 参数类型\r\n * @interface IndexState\r\n */\r\nexport interface IndexState {\r\n\r\n}\r\n\r\n/**\r\n * index.props 参数类型\r\n *\r\n * @export\r\n * @interface IndexProps\r\n */\r\nexport interface IndexProps {\r\n    dispatch?: any,\r\n    data?: Array<DataInterface>\r\n}\r\n\r\nexport interface DataInterface {\r\n    des:string,\r\n    lunar:string,\r\n    thumbnail_pic_s:string,\r\n    title:string,\r\n    _id:string\r\n}\r\n\r\n复制代码7、修改 ./src/pages/index/model.ts 里 effects 函数在这里创建页面需要请求的接口，链接 service 里的接口发起数据请求,这里以 getList 为例。// import Taro from '@tarojs/taro';\r\nimport * as indexApi from './service';\r\n\r\nexport default {\r\n  namespace: 'index',\r\n  state: {\r\n    data:[],\r\n    v:'1.0',\r\n  },\r\n\r\n  effects: {\r\n    *getList({ payload },{select, call, put}){\r\n      const { error, result} = yield call(indexApi.getList,{\r\n        ...payload\r\n      })\r\n      console.log('数据接口返回',result);\r\n      \r\n      if (!error) {\r\n        yield put({\r\n          type: 'save',\r\n          payload: {\r\n            data:result.data\r\n          },\r\n        })\r\n      }\r\n    }\r\n  },\r\n\r\n  reducers: {\r\n    save(state, { payload }) {\r\n      return { ...state, ...payload };\r\n    },\r\n  }\r\n\r\n}\r\n\r\n复制代码8、修改 ./src/pages/index/index.tsx 里页面结构这里简单的实现列表新闻页面。import Taro, { Component, Config } from '@tarojs/taro'\r\nimport { View, Text} from '@tarojs/components'\r\nimport { connect } from '@tarojs/redux'\r\n// import Api from '../../utils/request'\r\n// import Tips from '../../utils/tips'\r\nimport { IndexProps, IndexState } from './index.interface'\r\nimport './index.scss'\r\n// import {  } from '../../components'\r\n\r\n@connect(({ index }) => ({\r\n    ...index,\r\n}))\r\n\r\nclass Index extends Component<IndexProps,IndexState > {\r\n  config:Config = {\r\n    navigationBarTitleText: 'taro_dva_typescript'\r\n  }\r\n  constructor(props: IndexProps) {\r\n    super(props)\r\n    this.state = {}\r\n  }\r\n\r\n  async getList() {\r\n    await this.props.dispatch({\r\n      type: 'index/getList',\r\n      payload: {}\r\n    })\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.getList()\r\n  }\r\n\r\n  render() {\r\n    const { data } = this.props\r\n    console.log('this.props===>>',data);\r\n    \r\n    return (\r\n      <View className='fx-index-wrap'>\r\n          <View className='index-topbar'>New资讯</View>\r\n          <View className='index-data'>\r\n            {\r\n              data && data.map((item,index) => {\r\n                return (\r\n                  <View className='index-list' key={index}>\r\n                    <View className='index-title'>{item.title}</View>\r\n                    <View className='index-img' style={`background-image: url(${item.thumbnail_pic_s})`}></View>\r\n                  </View>\r\n                )\r\n              })\r\n            }\r\n          </View>\r\n      </View>\r\n    )\r\n  }\r\n}\r\n\r\nexport default Index\r\n\r\n\r\n复制代码9、修改 ./src/pages/index/index.scss 首页的样式这里的写法是 sass 的语法糖@import \"../../assets/scss/variables\";\r\n\r\n.#{$prefix} {\r\n\r\n  &-index-wrap {\r\n    width: 100%;\r\n    min-height: 100vh;\r\n    .index {\r\n      &-topbar {\r\n        padding: 10rpx 50rpx;\r\n        text-align: center;\r\n        font-weight: bold;\r\n        color: #333;\r\n        font-size: 30rpx;\r\n      }\r\n  \r\n      // &-data {\r\n      // }\r\n       \r\n      &-title {\r\n        font-size: 28rpx;\r\n        color: #666;\r\n        width: 100%;\r\n        font-weight: bold;\r\n      }\r\n      &-list{\r\n        border-bottom: 1rpx solid #eee;\r\n        padding-bottom: 20rpx;\r\n        margin: 20rpx 24rpx;\r\n        display: flex;\r\n        flex-direction: row;\r\n        justify-content: space-between;\r\n        align-items: center\r\n      }\r\n  \r\n      &-img {\r\n        width: 70%;\r\n        height: 200rpx;\r\n        background-repeat: no-repeat;\r\n        background-size: contain;\r\n        background-position: right center;\r\n      }\r\n    }\r\n  }\r\n \r\n}\r\n\r\n\r\n复制代码项目启动运行小程序编译命令cnpm run dev:weapp等待项目编译完成，会在项目根目录下生成一个 dist ,打开微信小程序开发者根据，导入本地刚刚生成的 dist 文件，就成功启动了项目。效果预览图：如有啥问题欢迎讨论，共同学习。项目示例Github地址： github.com/Duanruilong…"}
{"title": "小程序跨平台开发解决方案探索 ", "author": "Rolan", "pub_time": "2019-8-2 00:15", "content": "原文地址： ant-move.github.io/website/blo…继微信正式推出微信小程序后，各个大厂陆续发布了各自的小程序平台 —— 支付宝小程序、百度小程序、头条小程序，跨小程序平台开发也成为了众多小程序开发者要面临的问题。Antmove - 小程序跨平台解决方案小程序开发血泪史小程序发展初期框架不稳定更新频繁bug 众多随着微信小程序的发展，微信小程序以基本不存在上述的问题，而其它新兴的小程序厂商则还在此阶段，对于小程序开发者来说，如果要接入微信小程序之外的平台，以上的问题是技术方案评估环境必须要衡量的问题。小程序发展中期开发体验提升组件式开发需求与 web 开发技术生态的融合在这个阶段，小程序开发者追求的是开发体验，在 web 框架蓬勃发展，开发工具生态飞速完善的环境下，槽糕的小程序开发体验是用户不能忍受的，这个阶段也出现了许多的小程序框架极力的解决这个问题，如 wepy、mpvue、taro 等。小程序发展成熟期多平台支持需求包体积性能到今年以来，除微信小程序平台外，其它厂商小程序平台也得到了极大的推动发展，这时小程序跨平台能力就显得尤为重要，同时与之相对的包体积控制小程序性能也成为关注点，这也是目前众多企业和开发者面临的问题。小程序跨平台开发解决方案探索小程序跨平台开发，简单来说就是通过一套解决方案实现开发一次，上线到多个小程序平台。解决方案为满足多小程序平台的需求，简单来说可以有以下的解决方案：各平台单独开发人力成本高开发某一个平台小程序，通过技术实现到其它平台的转换技术实现成本高，小团队难以支撑使用支持跨平台的小程序框架开发，依赖于框架的跨平台能力，实现跨平台引入框架成本对于第三种方案来说，目前社区中比较热门的小程序跨平台开发解决方案有 mpvue、taro、uni-app 等。这些框架不同程度的解决了小程序跨平台开发的问题，但他们都存在一个饱受诟病的问题，那就是框架之痛。在前端开发的发展过程中，从前端框架出现到百花争鸣，到现在的三足鼎立（Angular、React、Vue）时代，开发者依然会因如下的 问题而头疼：是否应该在项目中引入框架？应该选择什么样的框架，更好？更适合？在性能面前，应该选择框架还是采用原生开发？团队开发技术栈统一之争？老项目维护问题，技术升级之痛？该框架的未来发展是怎样的？作为小程序的开发者，依然会面临这样的问题，而且会更加严重， 小程序本身就是一个框架（而且小程序框架发展很快，功能也在不断完善，开发体验也越来越好） ，在小程序之上又包一层框架，整个开发流程多了一环，无疑会增加项目的风险。而且小程序框架本身还在不断的发展，以微信小程序为例，新特性、能力、规范不断的更新，框架如何短时间的更新适配就成为一个难题。而依赖框架之后，开发者与原生小程序隔离开来，不得不依赖框架方提供解决方案。除了框架能力的支持适配，引入框架还会使得项目本身变得臃肿、缓慢、约束。解决方案之 Antmove在高德小程序开发团队（阿里系小程序的一员【支付宝小程序、淘宝应用、钉钉应用、天猫精灵等】）的工作中，我们遇到了许多想将微信小程序应用上线到阿里系小程序平台的客户，而重新开发一个新平台的小程序对他们来说又比较耗成本，为了解决这个问题，蚂蚁搬家工具应运而生，我们的出发点很简单，希望能够通过技术手段将一个微信小程序应用上线到阿里系小程序平台上。随着这个过程的进行，我们发现用户除了有对阿里系平台的需求外，还有对其它小程序平台支持的需求，所以又有了其它厂商小程序平台的支持。多小程序平台支持目前百度智能小程序、头条小程序的支持还在内测，即将可以体验。从最初的客户服务案例到现在的 antmove 开源项目，我们整个团队考虑过很多，作为一个非 KPI 项目，我们会持续的将它做好，希望能帮助更多的小程序开发者解决他们遇到的问题。Antmove 不是一个框架，而是一个转换工具，比如将微信小程序项目转换为支付宝小程序项目，它更多的还是希望开发者能使用原生的小程序语法去开发小程序，更小、更快、更简洁。到目前为止，Antmove 工具已经帮助了众多的内部用户和外部小程序开发者实现小程序的转换迁徙，现在也希望它能够帮助你解决跨平台开发的难题。"}
{"title": "小程序Request的另类用法 ", "author": "Rolan", "pub_time": "2019-8-2 00:18", "content": "小程序中唯一能发送网络请求接口数据的是wx.request接口，当然这个接口存在诸多的限制，例如：10个并发请求限制，https限制（当然在开发阶段是可以关闭此限制），除了wx.request还有其他方法可以实现类型的功能吗？当然是有的,这个思路也源于我之前看到的一篇文章，随便笔记下来\r\n思路\r\n使用云开发来发送网络请求并把数据返回给小程序端。还不了解的云开发的同学请速度移步到官方【云开发】\r\n新建一个http的云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst axios = require('axios')\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext()\r\n  const { method, url, data } = event;\r\n  const res = await axios.request({\r\n    method: method,\r\n    url: url,\r\n    data: data\r\n  });\r\n\r\n  return { code: 1, data: res.data } || {code: -1, msg: 'error', data: null}\r\n}\r\n复制代码小程序端二次封装云函数调用\r\nasync http(options = {}) {\r\n\treturn wx.cloud.callFunction({\r\n\t\tname: 'http',\r\n\t\tdata: {\r\n\t\t\tmethod: options.method || 'GET',\r\n\t\t\turl: options.url || '',\r\n\t\t\tdata: options.data || {}\r\n\t\t}\r\n\t}).then(res => {\r\n\t\treturn res.result\r\n\t})\r\n},\r\n复制代码小程序端使用\r\nasync onLoad() {\r\n    this.http({\r\n      method: 'GET',\r\n      url: 'https://www.baidu.com'\r\n    }).then(res => {\r\n      console.log(res)\r\n    })\r\n  },\r\n复制代码总结\r\n这种方法可以很好绕过https的限制，当然这只是提供一个简单的思路，我们可以进一步细一点封装，包括配置header proxy 等等功能，其实原理就是借助云函数做了二次转发，性能上肯定比不上原生的request\r\n注意\r\nasync 和 await 语法糖在最新的开发工具中已经实现了，开启增强编译即可使用，具体更新内容请移步官方社区 微信小程序社区"}
{"title": "[UI组件] 来做一个可配置的滑块进度条吧 ", "author": "Rolan", "pub_time": "2019-5-7 00:32", "content": "在一些需要用户填写资料的业务场景中，有时会让用户选择某个业务的范围，这时就需要用到滑块进度条。然后你们最爱的产品经理会说，给我整一个颜色可控，滑块按钮可大可小，滑块边框也要可大可小的滑动条来..emmm，一看这样的设计需求就意味着小程序原生的slider组件就不能用了。因为这玩意在样式上就不能自由的配置，只好来手动实现一个。结构设计行吧，那说干就干。首先滑动条可以从俯视图角度来看，分为三层。分别是底部滑轨区域，进度条区域以及供用户操作的滑块本身。在结构设计中，可以将底部滑轨区域，进度条区域分为一块，这样进度条区域可以根据随着滑动条的高度变化而变化, 宽度则由js控制。除此之外还需要暴露一些参数给外部，让它自己定义长粗宽。Component({\r\n    /**\r\n     * 组件的属性列表\r\n     */\r\n    properties: {\r\n        // 滑块大小\r\n        blockSize: {\r\n            type: Number,\r\n            value: 32,\r\n        },\r\n\r\n        // 滑块宽度\r\n        blockBorderWidth: {\r\n            type: Number,\r\n            value: 3\r\n        },\r\n\r\n        // 滑轨高度\r\n        height: {\r\n            type: Number,\r\n            value: 2\r\n        },\r\n\r\n        // 滑轨进度\r\n        step: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n\r\n        // 进度值小数位\r\n        digits: {\r\n            type: Number,\r\n            value: 0,\r\n        },\r\n    },\r\n});<view id=\"slider-wrap\" class=\"slider-wrap\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view  class=\"silder-bg-inner\"></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>.slider-wrap {\r\n    position: relative;\r\n    display: flex;\r\n    align-items: center;\r\n    width: 100%;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner,\r\n.silder-block {\r\n    position: absolute;\r\n    left: 0;\r\n}\r\n\r\n.silder-bg,\r\n.silder-bg-inner {\r\n    width: 100%;\r\n    height: 2rpx;\r\n    flex: 1;\r\n}\r\n\r\n.silder-bg {\r\n    overflow: hidden;\r\n    background-color: #eeeeee;\r\n    border-radius: 8rpx;\r\n    z-index: 0;\r\n}\r\n\r\n.silder-bg-inner {\r\n    height: 100%;\r\n    background-color: #66a6ff;\r\n    /* border-radius: 8rpx; */\r\n    z-index: 1;\r\n    border-bottom-left-radius: 8rpx;\r\n    border-top-left-radius: 8rpx;\r\n}\r\n\r\n.silder-block {\r\n    width: 32rpx;\r\n    height: 32rpx;\r\n    background-color: #ffffff;\r\n    border: solid 3rpx #66a6ff;\r\n    z-index: 2;\r\n    border-radius: 50%;\r\n    box-sizing: border-box;\r\n}\r\n点击行为事件滑块进度条的滑块是一个听话的小朋友，就是说我们叫它去哪它就听话的过去。所以就不要抓它去煲汤了~在组件外部容器中绑定一个点击事件，我们必须得要知道用户点击位置，在bind:tap事件中取到clientX属性。除此之外还需要取到进度条的位置信息。得到两个关键数据后，将用户点击的位置ClintX与进度条组件的偏移量offset相减，得出相对于组件内的进度progress.再用组件的宽度width减去progress乘于100得到目前进度的百分比percentage。同时为了防止进度条超出进度条如下图所示：((191 - 36) / 301) * 100 ≈ 52<view class=\"slider-wrap\" bindtap=\"tappingSlider\">\r\n    <!-- ...other -->\r\n</view>Component({\r\n    // ...\r\n\r\n    /**\r\n     * 组件的初始数据\r\n     */\r\n    data: {\r\n        containerInfo: null,\r\n        percentage: 0,\r\n    },\r\n\r\n    ready() {\r\n        // 取到滑块进度条的位置信息\r\n        wx.createSelectorQuery().in(this)\r\n            .select('.slider-wrap')\r\n            .boundingClientRect((rect) => {\r\n                if (!rect) return;\r\n\r\n                this.data.container = rect;\r\n                this._initBloackPos();\r\n            }).exec()\r\n    },\r\n\r\n    // 点击进度条\r\n    tappingSlider(evt) {\r\n        const { containerInfo } = this.data;\r\n        if (!containerInfo) return;\r\n\r\n        const { clientX } = evt.changedTouches[0];\r\n        const { digits, _maxDistance } = this.data;\r\n\r\n        // 需要做边界处理\r\n        const perc = this._computeOffset(clientX, containerInfo.left, 100);\r\n        const percentage = this._boundaryHandler(perc);\r\n\r\n        this.setData({ percentage });\r\n        this.triggerEvent('change', {\r\n              value: percentage.toFixed(digits) * 1\r\n          });\r\n    },\r\n\r\n    /**\r\n     * 计算相对容器的偏移距离\r\n     *\r\n     * @param { Number } x - X 坐标\r\n     * @param { Number } offset - 偏移量\r\n     * @param { Number } maxVal - 在 maxVal 范围内求百分比\r\n     */\r\n    _computeOffset(x, offset, maxVal) {\r\n        const { width } = this.data.containerInfo;\r\n\r\n        // 底层保证一定精度\r\n        return (((x - offset) / width) * maxVal).toFixed(4) * 1;\r\n    },\r\n\r\n    /**\r\n     * 边界处理\r\n     * @param { Number } num - 待处理的最值\r\n     * @param { Number } maxNum - num 最大值\r\n     * @param { Number } minNum - num 最小值\r\n     */\r\n    _boundaryHandler(num, maxNum = 100, minNum = 0) {\r\n        return num > maxNum ? maxNum : (num < minNum ? minNum : num);\r\n    },\r\n});<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{percentage}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>虽然实现了点击滑动到指定位置的功能，但仔细一看还是有一些瑕疵的~ 当我们点击到百分百时，滑块超出原先设定的容器宽度。超出的原因是因为在布局上，我们使用绝对定位absolute，通过设置滑块left属性来控制滑块位置的。偏移量中还包含了滑块自身的宽度，因此还需要对滑块的偏移量做一定的处理，去掉自身宽度再获取百分比。在文章开头我们已经暴露了一个blockSize的属性，利用该属性可以计算滑块的最大偏移量：Component({\r\n    // ...\r\n    data: {\r\n        // other data...\r\n\r\n        _blockOffset: 0,\r\n        _maxDistance: 100,\r\n    },\r\n\r\n    methods: {\r\n        // 点击进度条\r\n        tappingSlider(evt) {\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n\r\n})<!-- other code -->\r\n<view\r\n    class=\"silder-block\"\r\n    style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n></view>如此，该事件就完成啦~滑动事件完成点击事件后，我们还得让它能进行自由的滑动。进度条组件的拖动的流程大致是：点击滑块 -> 拖动滑块 -> 释放滑块这三个步骤。因此跟H5的思路一样，我们只需监听touchmove、touchstatr、touchend三个事件。首先先监听touchmove，用户点击滑块后，记录当前的clientX属性, 随后还需要记录当前进度和滑块的偏移量；touchmove事件则由外层容器相关联，并更新滑动的距离。由于touchmove里针对拖动事件逻辑不能被随便触发，因此需要加一个标识的锁；在touchend事件触发后释放锁即可：Component({\r\n    methods: {\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = this.data._blockOffset;\r\n            this.data.originPercentage = this.data.percentage;\r\n\r\n            this.data._startTouchX = evt.changedTouches[0].clientX;\r\n        },\r\n\r\n        // 滑块移动\r\n        onTouchMove(evt) {\r\n            const { moving, containerInfo } = this.data;\r\n            if (!moving || !containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const {\r\n                digits,\r\n                originPos,\r\n                originPercentage,\r\n                _startTouchX,\r\n                _maxDistance\r\n            } = this.data;\r\n\r\n            // 计算偏移量\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, _startTouchX, maxVal);\r\n            }\r\n\r\n            // 实际百分比\r\n            const perc = originPercentage + computeOffset(100);\r\n            const percentage = this._boundaryHandler(perc);\r\n\r\n            // 滑块偏移度\r\n            const offset = originPos + computeOffset(_maxDistance);\r\n            const _blockOffset = this._boundaryHandler(offset, _maxDistance);\r\n\r\n            this.setData({ percentage, _blockOffset });\r\n            this.triggerEvent('change', {\r\n                value: percentage.toFixed(digits) * 1\r\n            });\r\n        },\r\n\r\n        onTouchEnd(evt) {\r\n            this.data.moving = false;\r\n        },\r\n    }\r\n})<view class=\"slider-wrap\" bindtap=\"tappingSlider\" bindtouchmove=\"onTouchMove\">\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n        bindtouchstart=\"onTouchStart\"\r\n        bindtouchend=\"onTouchEnd\"\r\n    ></view>\r\n</view>总结以上就是滑块进度条组件的实现~ 实际上该组件还有更多可供配置的地方，如颜色值，背景控制等这些比较基础的东西就不继续展开讲啦~本文是以小程序进行示例。但思路是共通的，也可以使用同样思路在H5实现，只不过是 API 的差异罢了~微信代码片段, 可以直接拿来就用。2019/05/04 更新：后面又重新看了一遍，发现该组件还是有可优化的空间：操作不必局限于滑块上，可以将bindtap事件废弃，其余的所有事件都代理到最外部的节点中。touchstar的同时就渲染位置信息，还允许它自由的滑动:<view class=\"slider-wrap\"\r\n    bindtouchstart=\"onTouchStart\"\r\n    bindtouchmove=\"onTouchMove\"\r\n    bindtouchend=\"onTouchEnd\"\r\n>\r\n    <view class=\"silder-bg\" style=\"height: {{height}}rpx;\">\r\n        <view\r\n            class=\"silder-bg-inner\"\r\n            style=\"width: {{percentage}}%; height: {{height}}rpx;\"\r\n        ></view>\r\n    </view>\r\n    <view\r\n        class=\"silder-block\"\r\n        style=\"left: {{_blockOffset}}%;width: {{blockSize}}rpx;height: {{blockSize}}rpx; border-width: {{blockBorderWidth}}rpx;\"\r\n    ></view>\r\n</view>Component({\r\n    // other options ...\r\n\r\n    methods: {\r\n        // other method ...\r\n        onTouchStart(evt) {\r\n            this.data.moving = true;\r\n\r\n            const { containerInfo } = this.data;\r\n            if (!containerInfo) return;\r\n\r\n            const { clientX } = evt.changedTouches[0];\r\n            const { digits, _maxDistance } = this.data;\r\n            const computeOffset = (maxVal) => {\r\n                return this._computeOffset(clientX, containerInfo.left, maxVal);\r\n            }\r\n\r\n            // 滑块偏移度\r\n            const _blockOffset = this._boundaryHandler(\r\n                computeOffset(_maxDistance), _maxDistance\r\n            );\r\n\r\n            // 实际百分比\r\n            const percentage = this._boundaryHandler(computeOffset(100));\r\n\r\n            // 记录原始坐标\r\n            this.data.originPos = _blockOffset;\r\n            this.data.originPercentage = percentage;\r\n\r\n            this.data._startTouchX = clientX;\r\n\r\n            this.setData({ _blockOffset, percentage });\r\n            this.triggerEvent('change', { value: percentage.toFixed(digits) * 1 });\r\n        },\r\n    }\r\n});微信代码片段 v0.0.2"}
{"title": "微信小程序之数据访问 ", "author": "Rolan", "pub_time": "2019-5-7 00:56", "content": "先简单说一下，小程序的结构如图所示1、每个视图(.wxml)只需要添加对应名字的脚本（.js）和样式（.wxss）就可以了，不需要引用，page下面的脚本以及样式都是继承至最外面的app.js , app.wxcss2、脚本也就是.js文件，他有固定格式：page，是用于获取数据的3、utils是用来放置数据接口的--------------------------------------------华丽的分割线--------------------------------------------------------数据访问，如果懂点ajax，都不是问题，没啥好讲的微信小程序，因为IDE太烂了，如果代码再写得难以阅读，整个项目就很难维护了。因为没有写过app，不知道在app中数据访问是怎么封装的作为一个有3天工作经验的小程序码农，觉得如果每个页面的数据都是自己去访问数据接口，那就太不OOP了然后想到了linq to sql，只取了其中的两个方法，原本打算用singelordefault，firstordefault的，想想也麻烦，就用了getbyparams,getbyid，根据条件查找出所有数据，或者根据id获取一条数据直接看方法吧，有点啰嗦了const API_URL = 'http://localhost:4424/api/'function getApi(url,params){  return new Promise((res,rej)=>{    wx.request({      url:API_URL+'/'+url,      data:Object.assign({},params),      header:{'Content-Type': 'application/json'},      success:res,      fail:rej    })  })}module.exports = {  GetByParams(url,page=1,pageSize=20,search = ''){    const params = { start: (page - 1) * pageSize, pageSize: pageSize }    return getApi(url, search ? Object.assign(params, { q: search }) : params)      .then(res => res.data)  },  GetById(url,id){    return getApi(url, id)      .then(res => res.data)  }}module.exports = {}是固定写法，里面写一个一个的方法，每个方法用,隔开。 我设置了一个url参数，因为不可能把所有的接口都放在一个conntroller里面，所以url的格式是“conntroller/action”看一个调用的栗子吧，就明白怎么用了const req = require('../../utils/util.js')Page({  data: {    imgUrls: [],    indicatorDots: true,    autoplay: true,    interval: 2000,    duration: 2000  },  onLoad(){    req.GetByParams('home/homebanner')//看这里   看这里   看这里    .then(d=>this.setData({imgUrls:d,loading:false}))    .catch(e=>{      this.setData({imgUrls:[],loading:false})    })  }})这是index的获取banner图的方法，req.GetByParams('home/homebanner')，这里也可以带参数，也可以空着最终的页面是这样的在右边的红色框里面，我们可以看到请求返回的数据，也可以在右边修改数据，界面会跟随着变化，这是关于调试的事情了，容后再议。"}
{"title": "微信小程序--发表评价满意度 ", "author": "Rolan", "pub_time": "2019-5-7 00:46", "content": "话不多说，我们来看一下效果图：要实现的效果：点击到第几颗星，就要显示到第几颗星,接下来直接查看源码：<view class=\"l-evalbox row\">    <text class=\"l-evaltxt\">满意度：</text>    <view class=\"l-evalist flex-1\" bindtap=\"chooseicon\">        <icon class=\"{{tabArr.curHdIndex >'0'? 'cur icon' : 'icon'}}\" data-id=\"1\"></icon>        <icon class=\"{{tabArr.curHdIndex >'1'? 'cur icon' : 'icon'}}\" data-id=\"2\"></icon>        <icon class=\"{{tabArr.curHdIndex >'2'? 'cur icon' : 'icon'}}\" data-id=\"3\"></icon>        <icon class=\"{{tabArr.curHdIndex >'3'? 'cur icon' : 'icon'}}\" data-id=\"4\"></icon>        <icon class=\"{{tabArr.curHdIndex >'4'? 'cur icon' : 'icon'}}\" data-id=\"5\"></icon>    </view></view>css如下：.l-evalbox{    height: 100rpx;    padding: 0 3%;    margin-top: 10rpx;    background: #FFF;    line-height: 100rpx;}.l-evaltxt{    width: 120rpx;    display: block;    font-size: 26rpx;    color: #666666;}.l-evalist .icon{    background-position:  -77rpx -246rpx;    width: 40rpx;    height: 43rpx;    margin-right: 30rpx;}.l-evalist .cur{    background-position:  -128rpx -246rpx;}.l-evalist .icon:last-child{    margin: 0;}js代码如下：chooseicon:function(e){    var strnumber=e.target.dataset.id;       var _obj={};        _obj.curHdIndex=strnumber;         this.setData({           tabArr: _obj        });  },这样效果显示如下："}
{"title": "小程序开发前的准备工作之【深入封装Component】 ", "author": "Rolan", "pub_time": "2019-5-14 00:50", "content": "在上一篇内容中主要总结了如何扩展小程序中的Page与Component函数，在开发过程中减少包的引入，这一篇则深入总结小程序自定义组件Component函数还有哪些可以进一步扩展的地方【demo地址】。优化点：优化组件定义默认值时声明的写法自定义watch函数监听全部参数变化编写小程序自定义组件时 你是否是这样？Component({\r\n  properties: {\r\n    num: {\r\n        type: Number,\r\n        value: 2\r\n    },\r\n    name: {\r\n        type: String,\r\n        value: \"abcdef...\"\r\n    },\r\n    test: Object // 即使没有默认值也要写上数据类型\r\n  },\r\n  methods: {\r\n    //...\r\n  }\r\n})\r\n复制代码我还是比较喜欢像【data】对象初始化时的写法:arrow_heading_down:Component({\r\n  props: {\r\n    num: 2,\r\n    name: 'abcdef...',\r\n    test: {}\r\n  },\r\n  methods: {\r\n    //...\r\n  }\r\n})\r\n复制代码开始改造properties：既然我们已经可以重写Component函数了，那就有办法把这个数据【转换】成我们要的那种结构格式，打开Init.js Component函数部分实现的步骤大概是：取到参数内名为props的对象 -> 获取每一个数据类型 -> 还原成小程序原来的数据格式 -> 重新赋值给properties// 优化 properties 传入方式\r\nlet originComponent = Component;\r\nComponent = (opt) => {\r\n  let { props = {} } = opt;\r\n  let properties = {};\r\n  // 获取自定义关键字【props】中的每一项\r\n  Object.keys(props).forEach(item => {\r\n    // 重新还原成原有数据格式\r\n    properties[item] = {\r\n      type: getValueType(props[item]), // 获取数据格式\r\n      value: props[item]\r\n    }\r\n  });\r\n  opt.properties = properties; // 还给properties...\r\n  //...\r\n  return originComponent(opt)\r\n}\r\n\r\n\r\n/**\r\n * 获取数据类型\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction getValueType(value) {\r\n  if (typeof value === 'number') return Number;\r\n  if (typeof value === 'string') return String;\r\n  if (typeof value === 'boolean') return Boolean;\r\n\r\n  if (value instanceof Object && !value instanceof Array) return Object;\r\n  if (value instanceof Array) return Array;\r\n\r\n  return null;\r\n}\r\n复制代码组件声明默认数据格式的修改就弄好了，其实这个东西并没有对开发上起到多么明显的优化，无非就是少写几个字而已，但是以此demo 还可以扩展出更多功能。监听组件传入参数变化小程序自定义组件的传入数据上可以声明observer监听器属性，用来监听数据变化:arrow_heading_down:Component({\r\n  properties: {\r\n    num: {\r\n        type: Number,\r\n        value: 2,\r\n        observer (newVal, oldVal, changedPath) {\r\n            //...\r\n        }\r\n    },\r\n  },\r\n  methods: {\r\n    //...\r\n  }\r\n})\r\n复制代码其中observer接收的参数分别是newVal[改变的参数]、oldVal[改变之前的参数]、changedPath[具体改变的参数的key]默认要监听某个参数的时候，都是需要写在具体参数的对象内的，并且每个要监听的数据都要声明observer函数，通过改造后 可以统一监听数据变动:arrow_heading_down:Component({\r\n  props: {\r\n    num: 2,\r\n    name: 'abcdefg....',\r\n  },\r\n  methods: {\r\n    // 自定义添加的监听方法\r\n    $watch(newVal, oldVal, changedPath) {\r\n        if (changedPath == 'num' && newVal == 5) {\r\n            this.data.name = 'five';\r\n            return this.triggerEvent(\"isFive\")\r\n        }\r\n        //...\r\n    }\r\n  }\r\n})\r\n复制代码相比每个参数都要监听 这种写法可以减少代码。实现$watch：实现步骤：获取自定义props对象 -> 还原成properties格式 -> 每一个数据内都添加observer函数 -> 函数在触发时 调用自身$watch函数// 优化 properties 传入方式\r\nlet originComponent = Component;\r\nComponent = (opt) => {\r\n  let { props = {} } = opt;\r\n  let properties = {};\r\n  // 获取自定义关键字【props】中的每一项\r\n  Object.keys(props).forEach(item => {\r\n    // 重新还原成原有数据格式\r\n    properties[item] = {\r\n      type: _util.getValueType(props[item]),\r\n      value: props[item],\r\n      // 每一个数据都添加observer方法监听\r\n      observer: function (newVal, oldVal, changedPath) {\r\n        const changeEvent = {\r\n          event: item,\r\n          newVal, oldVal, changedPath\r\n        };\r\n        // 传入属性可通过组件内定义的$watch方法统一监听变化\r\n        this.$watch && this.$watch(changeEvent);\r\n      }\r\n    }\r\n  });\r\n  opt.properties = properties; // 还给properties...\r\n  //...\r\n  return originComponent(opt)\r\n}\r\n\r\n\r\n/**\r\n * 获取数据类型\r\n * @param value\r\n * @returns {*}\r\n */\r\nfunction getValueType(value) {\r\n  if (typeof value === 'number') return Number;\r\n  if (typeof value === 'string') return String;\r\n  if (typeof value === 'boolean') return Boolean;\r\n\r\n  if (value instanceof Object && !value instanceof Array) return Object;\r\n  if (value instanceof Array) return Array;\r\n\r\n  return null;\r\n}\r\n复制代码这样就可以实现$watch方法啦！【demo地址】"}
{"title": "微信小程序全屏模式（自定义导航栏） ", "author": "Rolan", "pub_time": "2019-5-6 00:53", "content": "导航栏背景图要自定义导航栏，首先需要在app.json里设置：{\"window\": {        \"navigationStyle\": \"custom\"    }}设置之后进入小程序就只剩下右上角的胶囊了。 在设置导航栏样式时需要知道它的高度，在app.json的onLaunch里获取状态栏高度：App({    onLaunch: function(options) {        wx.getSystemInfo({            success: (res) => {                this.globalData.statusBarHeight = res.statusBarHeight                this.globalData.navBarHeight = 44 + res.statusBarHeight            }        })    },    globalData: {        statusBarHeight: 0,        screenHeight: 0    }})44是导航栏除去状态栏的高度，单位px。 因为导航栏每个页面都会用到，所以我们用组件会方便使用一些，这里创建一个叫nav的组件： 首先在组件js里设置statusBarHeight和一个可以通过外部设置状态栏颜色的backgroundColor的属性，默认透明。 nav.js:const app = getApp()Component({    options: {        multipleSlots: true    },    properties: {        backgroundColor:{            type: String,            value: 'rgba(0,0,0,0)'        }    },    data: {},    ready() {        let {            statusBarHeight,            navBarHeight        } = app.globalData;        this.setData({            statusBarHeight,            navBarHeight        })    },    methods: {        back() {            wx.navigateBack({                delta:1            })        }    }})content里放置内容，返回按钮固定在左边。 nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <slot name=\"content\"></slot>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:.nav-wrap {    position: fixed;    top: 0;    left: 0;    width: 750rpx;    z-index: 1;}.content {    position: relative;    width: 100%;    height: 44px;}.back {    position: absolute;    left: 0;    top: 0;    width: 88px;    height: 44px;    background: pink;}在页面中使用：<nav bgColor=\"black\">    <view slot=\"content\">        <view class='txt'>Nav title</view>    </view></nav><view>page content</view>效果图：效果图这里txt里的样式、内容都是可以自定义的，如果想要使用通用样式，可以写在组件里。 比如把导航栏title放在组件里，通过外部传值设置： nav.js:Component({    // ...    properties: {        title:{            type: String,            value: ''        }    },    // ...})nav.wxml:<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view>nav.wxss:/* ... */.title {    color: white;    text-align: center;    line-height: 44px;    font-weight: 500;}/* ... */调用就可以了。 在第一次使用nav组件的页面代码中，page content是看不见的，因为是直接从状态栏开始显示的，被nav挡住了。 这里可以加一个高度为导航栏高度的view当做顶部padding： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class=\"title\">{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>这里在properties里设置了一个hastop，用来控制是否有顶部padding。 页面中：<nav bgColor=\"black\" title=\"Nav title\" hastop></nav><view>page content</view>这样就可以显示出来了：导航栏背景图 还可以做导航栏背景图，添加一个image，绝对定位放置在nav-wrap底部： nav.wxml<view class='nav-wrap' style=\"background-color:{{bgColor}};\">    <image class='bgimg' wx:if=\"{{bgsrc}}\" src='{{bgsrc}}' mode='aspectFill'></image>    <view style=\"height:{{statusBarHeight}}px;\"></view>    <view class='content'>        <view class='title'>{{title}}</view>        <view class='back' bindtap='back'></view>    </view></view><view wx:if=\"{{hastop}}\" class='padding' style=\"width:100;height:{{navBarHeight}}px;\"></view>nav.wxss.bgimg {    position: absolute;    left: 0;    top: 0;    width: 100%;    height: 100%;}页面：<nav bgColor=\"black\" title=\"Nav title\" hastop bgsrc=\"/images/bg.jpeg\"></nav><view>page content</view>导航栏背景图全屏背景 将bgColor、hastop、bgsrc都去掉，在页面中放置一个position: fixed;，并且铺满全屏的图片。<nav title=\"Nav title\"></nav><image class='pagebg' src='/images/bg.jpeg' mode='aspectFill'></image>全屏背景back的内容自定义就行了，我这里只是简单放置了一个色框。注意事项 官方文档中的注意事项：注1：HexColor（十六进制颜色值），如\"#ff00ff\" 注2：关于navigationStyle客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 客户端 6.7.2 版本开始，navigationStyle: custom 对 组件无效 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉"}
{"title": "小程序绑定用户方案 优化 ", "author": "Rolan", "pub_time": "2019-5-15 00:16", "content": "在做过一系列小程序之后，对小程序的登陆鉴权的流程也有一定的理解，类似于 B 端小程序自不必说，要用户信息手机号地址可以一把梭，做一个引导页面进行判断然后要求用户给与绑定，用户自然不会多说什么，毕竟这是企业级别应用。但是当涉及到 C 端小程序时候。想让用户进行绑定，就势必要给与用户便利。这里我列出一些我觉得较为不错的小程序应用方案以供参考。预先绑定类该类小程序在使用之前就需要绑定用户信息。常见于线下门店类功能性小程序。线下操作时有大量的优惠活动来支持小程序的流量。功能介绍例如 便利蜂。之前在上海经常使用，价格和优惠都非常不错，这类小程序属于线下功能类小程序，内部有抽奖，付款等一系列功能。该小程序第一次打开就先用户直接要求用户绑定信息和地址，考虑到线下门店都会有一定的店员辅助。所以该小程序的绑定操作实际上用户都是可以接受的。图片如下所示。技术要点技术1： 使用自定义导航栏让头部可以配置全局配置\"window\": {\r\n  \"navigationStyle\": \"custom\"\r\n}如果微信 app 的版本在 7.0.0之上，我们就可以使用页面级别的配置了。{\r\n  \"usingComponents\": {},\r\n  \"navigationStyle\": \"custom\"\r\n}该配置默认时default，当使用custom时候可以自定义导航，可以在头部配置 loading。第二种这个需要 app 版本，所以如果是想简化，反而在全局下定义，再使用微信官方的组件 avigation-bar 即可。技术2：使用小程序骨架屏骨架屏方案在后端不能很快给与前端数据时候采用这种方案，亦或者前端可以使用 Service Worker 把上次缓存数据返回到前端，等到从后端获取数据之后刷新页面也是一种方案，但是因为这是第一次打开小程序，所以采用骨架屏是一个很好的方法。采用 小程序骨架屏 组件，如果不需要骨架屏动画效果，可以试试直接加载图片作为骨架屏。惰性绑定类该类小程序在展示时无需绑定用户信息，但是当用户进行操作时在询问绑定。常用于线上商城等一系列无需专人引导的用户项目。功能介绍基本上线上大部分 c 端小程序都采用此做法，功能上倒是没什么可以介绍的，但是实践上却有不同做法。实践方式方式 1: 页面跳转 (京东购物)在每个需要绑定的按钮上添加跳转逻辑，如果当前小程序没有绑定，可以跳转到另外一个页面上确认授权。方式2: 按钮控制 (华为商城+)在每个需要绑定按钮上添加 open-type='getuserinfo'，后续可以根据状态变化，切换掉按钮(也可以不切换，因为第二次绑定数据不会跳出组件)。方式3: 遮罩层拦截 (抽奖助手)在需要绑定的页面添加一个 透明模态框，增加以整个页面大小的button。用fixed布局，还可以向下滚动。无论在当前页面点击任何地方都会出现需要绑定选项。组件代码：// wxml\r\n<view style=\"z-index: {{zIndex}}\" class=\"mask\">\r\n  <button open-type=\"{{ openType }}\"\r\n          bindtap=\"onClick\"\r\n          bindgetuserinfo=\"bindGetUserInfo\"\r\n          bindgetphonenumber=\"bindGetPhoneNumber\"\r\n          bindopensetting=\"bindOpenSetting\"\r\n          binderror=\"bindError\"\r\n          class=\"mask\"/>\r\n</view>\r\n\r\n// wxss\r\n.mask{\r\n  position: fixed;\r\n  top: 0;\r\n  bottom:0;\r\n  left:0;\r\n  right:0;\r\n  background-color: inherit;\r\n  opacity: 0;\r\n}然后在绑定后令 mask 消失。该方案初看起来不是那么的合适，但是仔细想想却也没什么问题，因为用户99%可能点击所需求的按钮，就算点击到按钮之间的空隙之处跳出要求绑定也没有什么问题。上面方式实际上都没有太大的问题，需要在不同场景下做最合适的选择。结语人机交互功能是决定计算机系统“友善性”的一个重要因素。读书学习时候要先把书读厚，再把书读薄，做程序也是一样，如何把系统做的复杂而更加复杂，如何让用户的体验简单而更为简单都不是那么容易的一件事。"}
{"title": "小程序setData()使用和注意事项 ", "author": "Rolan", "pub_time": "2019-6-3 00:24", "content": "注意：\r\n\r\n直接修改this.data，而不调用this.setData()，是无法改变当前页面的状态的，会导致数据不一致\r\n仅支持可以JSON化的数据\r\n单次设置的数据不能超过1024KB，尽量避免一次设置过多的数据\r\n不要把data中的任何一项的value设为undefined，否则这一项将不能被设置，可能会有潜在的问题\r\n\r\n代码示例：\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n data: {\r\n    value:\"初始值\"    //定义一个变量value，赋值为：“初始化”\r\n\r\n  },\r\n   /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  }\r\n  })复制代码直接在wx:request()的success回调函数中使用this.setData()会报这样一个错误：因为这里的this是相对于wx:request()的当前对象解决：因为这里的wx:rewuest()是在页面加载时调用，所以我们可以在onLoad（）中定义一个变量that ，将this赋值给that，那么此时的that代表相对于onLoad（）的当前对象，然后在success回调函数中直接使用that.setData()即可。如果是获取实例方式：var that; 全局定义that变量\r\n\r\nvar option = {    data: { }};\r\n\r\nvar requestCallback =function (err, data) {    if (err) {          ************************    } else {\r\n\r\n        that.setData({          cosImage: data.headers.Location        })\r\n    }};\r\n\r\noption.simpleUpload = function () {  that = this;  //这里定义 this \r\n\r\n    // 选择文件    wx.chooseImage({        count: 1, // 默认9        success: function (res) {            **********************************            }, requestCallback);        }    })};\r\n//获取应用实例Page(option);\r\n\r\n复制代码还有一个需要注意到地方就是：如果在onReady（）函数中调用setData（）方法，那么通过这个方法设置的值只能刷新一次，若需要再次刷新，需要清除缓存。data: {\r\n    isChecked: [true, true, true, true, true, true, true, true, true, true, true]\r\n}\r\n复制代码\r\n如上，如果我想动态修改isChecked里面指定某个下标的值怎么办？\r\n下面我来说怎么动态修改一个对象的某元素的值。上面这个是索引下标，等会还有个key-value的例子。\r\n代码：\r\nclick: function (e) {    \r\n    var id = e.target.id//根据点击不同的view获取对应的id值\r\n    var str = \"isChecked[\" + id + \"]\"//重点在这里，组合出一个字符串\r\n    this.setData({\r\n      [str]: false//用中括号把str括起来即可\r\n    })\r\n}\r\n复制代码\r\n看注释。点击->触发对应事件->来到click函数这里，根据点击的view获取对应的id，修改指定下标的isChecked。\r\n上面这个isChecked的索引是从0到n的，即可以通过isChecked[0]、isChecked[1]来访问。可以在操作的过程中打印日志看一下数据类型。\r\n\r\n哦，对了，在wxml中如果要绑定isChecked中元素的值，可以这么：\r\n<view class=\"{{isChecked[2]?'main_view':'main_view_clicked'}}\" bindtap='click' bindlongpress='cancelclick' id='2' bindtap='click'></view>\r\n不要在意那个三目运算，反正类似于js中访问方式，也是isChecked[index]。同理，下面的key-value类型的就可以通过isChecked[index].key来绑定数据了。\r\n\r\n下面是key-value类型的：\r\ndata: {\r\n    isChecked: [\r\n      { \r\n        key: true \r\n      },\r\n      { \r\n        key: true \r\n      },\r\n      { \r\n        key: true\r\n      }\r\n    ]\r\n}\r\n复制代码\r\n直接写操作方式了（因为就跟上面只有一点点的区别）：\r\n    var str = \"isChecked[\" + id + \"].key\"\r\n    this.setData({\r\n      [str]: false\r\n    })复制代码结束~"}
{"title": "微信小程序性能,行为收集探针实现 ", "author": "Rolan", "pub_time": "2019-6-3 09:52", "content": "​小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。​网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。​网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的运行限制基于安全考虑，小程序中不支持动态执行 JS 代码，即：不支持使用 eval 执行 JS 代码 不支持使用 new Function 创建函数​网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。小程序运行机制小程序启动小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。 小程序没有重启的概念。前台/后台状态当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有直接销毁，而是进入了后台状态；当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。小程序销毁需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）小程序会被微信主动销毁。 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。 在 iOS 上，当微信客户端在一定时间间隔内（目前是 5 秒）连续收到两次及以上系统内存告警时，会主动进行小程序的销毁，并提示用户 「该小程序可能导致微信响应变慢被终止」。 建议小程序在必要时使用 wx.onMemoryWarning 监听内存告警事件，进行必要的内存清理。小程序更新机制未启动时更新开发者在管理后台发布新版本的小程序之后，如果某个用户本地有小程序的历史版本，此时打开的可能还是旧版本。微信客户端会有若干个时机去检查本地缓存的小程序有没有更新版本，如果有则会静默更新到新版本。总的来说，开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。用户下次打开时会先更新最新版本再打开。启动时更新小程序每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理。小程序探针开发难点与重点无法直接拦截/监听请求微信请求统一通过微信API完成 ，请求模块已被微信方封装，且小程序的运行环境不是浏览器对象，不像web应用那样重写封装很自如。三种运行环境的监控兼容性保证Android 上，js运行环境是 X5 内核iOS 上，js 运行环境是 JavaScriptCore开发工具上， j s运行环境是 nwjs（chrome内核）用户行为无法直接监听小程序逻辑层运行时无法获取DOM和BOM,无法像传统网页开发一样使用DOM事件API,无法全局监听事件.sdk需轻量小程序包大小有限制,单包最大为2M,分包情况下,不能超过8M,所以sdk需轻量数据收集量大，尽量减少性能损耗需要设计缓存池,制定上报策略不影响业务（基本需求）探针缓存池与上报策略探针收集到的数据主要分为两种,一种是基本数据,还有一种是事件特性数据.特性数据在下面关键事件中将会提到基础数据基本数据是每条上报日志都包含的数据。其中一部分,在初始化探针后就获取到，并且不会改变.这部分数据,业务相关的由用户配置,其余数据由探针内部生成或者调用wx.getSystemInfoSync API获取另一部分，随着用户行为，比如页面切换、登陆,或者环境变化,如网络变化时,将会改变.network数据通过 wx.getNetworkType 与 wx.onNetworkStatusChange获取 title部分在下面的关键事件有讲到事件特性数据![]( user-gold-cdn.xitu.io/2019/5/30/1…上报策略探针内部将会缓存对应日志,防止小程序Storage清空时,遗失数据.数据上报只要上报,就将缓存的日志清空,防止上报失败导致缓存的日志越积越多探针关键事件捕获关键事件类型改写App config对于App类主要改写config上的\"onShow\", \"onHide\", \"onError\", 'onLaunch'这几个生命周期缓存钩子函数给config上的方法挂上钩子,对config中未配置对应生命周期,加上默认生命周期回调对config包含了\"onShow\", \"onHide\", \"onError\",'onLaunch'生命周期函数,执行完原方法后再调用钩子函数启动事件(start)小程序启动,获取小程序启动场景值.重写App的config,通过onLaunch触发. 获取小程序启动场景值scene,页面路径path,页面search,通过页面路径与 __wxConfig对象获取页面title.退出到后台(pause)小程序切换到后台,重写App的config,通过onHide触发切回前台(resume)小程序从后台唤醒,获取切回小程序场景值scene.重写App的config,通过onShow触发(第一次触发onShow除外)异常捕获由于小程序的全局监听方法wx.onError只有2.1.2及以上才支持,为了兼容,需要重写App的config,通过onError触发.改写Page config这一部分与改写App config大同小异,主要看事件的获取页面停留(page_stay)onHide与onUnload时触发,获取用户在当前页面停留的时间.对于分享转发页面导致onHide触发的场景,不进行页面停留上报.页面切换(page)每次切换页面(onShow)时触发,获取当前页面路径,参数,title页面初次渲染时长页面首次打开或销毁后首次打开,页面渲染所花费的时间,重写Page的config,通过onReady触发.页面分享(share)用户分享转发页面时触发,通过重写Page的config,onShareAppMessage触发.由于页面分享会触发当前页面的onShow,onHide生命周期,为了数据准确,通过设置变量isPause来甄别.用户行为捕获由于用户行为总是与事件相关,对于事件,小程序无法直接监听dom事件,这里采取的方案是对App、Page、Component、Behavior的config进行改写,判断,判断config上的属性是否为函数,并且函数的形参是否为事件源,如果是事件源,说明该函数与用户行为现关联对于Component、Behavior只需对其config.method上的方法进行hook通过形参是否具有currentTarget属性判断当前是否为事件函数对于不存在自定义事件属性的点击事件,认定为点击事件,对于存在的,认定为自定义事件点击事件(click)由于小程序的逻辑层与渲染层是分开的,逻辑层运行在JSCore中,没有完整的浏览器对象,缺少dom与bom相关api,无法在body上设置全局的点击事件监听方法.为了实现事件的监听,探针通过改写Page 、Component和Behavior的config,对config上的所有属性进行区分,判断当前属性是否为函数,并且该函数触发时,形参上是否具有currentTargey属性来区分形参是否为事件对象,以此监听页面事件.对于tap与longpress事件,探针认定为点击事件.类型触发条件tap手指触摸后马上离开longpress手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发自定义事件(log)直接在事件函数内调用探针暴露的自定义事件上报方法会导致业务代码与探针耦合度过高.探针结合事件的监听通过在绑定了事件的小程序标签上添加自定义属性,来实现自定义事件的上报.由于事件触发时的事件源经微信内部封装过,自定义属性的获取目前只支持数据属性data-xxx的形式获取,所以在非手动调用时,可以在触发点击事件的小程序标签上增加data-event 与 data-log来添加低耦合的自定义事件代码.改写wx对象实现api事件捕获api事件(api)覆写wx对象,对wx.request方法的config进行重写,获取api(数据接口地址)、api_method(数据接口请求方式)、api_status(数据接口响应状态码)、api_response_time(数据接口响应时间(ms))、api_response_content_length (数据接口响应内容长度(byte))小程序的api基本都挂载在全局对象wx上,直接修改wx上面的属性,将会报错,直接赋值失败(小程序内部对此做出了限制)thirdScriptError \r\n sdk uncaught third Error \r\n Cannot set property request of #<Object> which has only a getter \r\n TypeError: Cannot set property request of #<Object> which has only a getter\r\n复制代码替代方案使用Object.getOwnPropertyDescriptors获取到wx对象的属性描述符,将微信对象重新赋值为空对象,循环属性描述符,判断当前描述符的键是否为request,并进行改造request属性描述符,其他情况使用Object.defineProperty方法定义属性由于for in循环获取不到Symbol类型的键,为了兼容wx对象将来引入Symbol作为wx对象键的情景,使用Object.getOwnPropertySymbols方法获取到属性描述符中的Symbol,再重新定义属性这一块代码太多了,不好截图,直接上代码吧// 重写wx.request\r\n  rewriteWxRequest() {\r\n    const that = this;\r\n    \r\n    // return \r\n    // 重写wx对象start\r\n    const descriptorObj = Object.getOwnPropertyDescriptors(wx);\r\n    let oldWx = this.oldWx = wx;\r\n    wx = {};\r\n    for (let i in descriptorObj) {\r\n      if (i === 'request') {\r\n        const desObj = descriptorObj[i];\r\n        let oldGet = desObj.get;\r\n        desObj.get = function(...args){\r\n          let oldRequest = oldGet.apply(this, args);\r\n          return function(params){\r\n            const {\r\n              url,\r\n              method = 'GET',\r\n              success = function(){},\r\n      \r\n            } = params;\r\n            // 检查API请求是否在忽略的url中\r\n            const ignoreUrls = that.conf.api_ignore_urls;\r\n            if (url && isIgnoreApi(url, ignoreUrls)) {\r\n              return oldRequest.call(this, params);\r\n            }\r\n            // 处理自定义 api url trim func\r\n            let apiTrimUrl = null;\r\n            if (that.conf.api_property_cb) {\r\n              try {\r\n                apiTrimUrl = that.conf.api_property_cb(url) || null;\r\n              } catch (e) {\r\n                apiTrimUrl = null;\r\n              }\r\n            }\r\n\r\n            const timeStamp = Date.now();\r\n            const apiData = {\r\n              api: apiTrimUrl || cutAPIUrl(url),\r\n              api_method: method.toUpperCase(),\r\n              api_status: undefined,\r\n              api_response_time: 0,\r\n              api_response_content_length: 0,\r\n            }\r\n            return oldRequest.call(this, {\r\n              ...params,\r\n              success (res) { // 成功回调\r\n                try {\r\n                  const {\r\n                    data,\r\n                    statusCode\r\n                  } = res\r\n                  apiData.api_status = statusCode;\r\n                  apiData.api_response_time = Date.now() - timeStamp;\r\n                  if (data) {\r\n                    let AB = {};\r\n                    if(typeof ArrayBuffer !== undefined) {\r\n                      AB = ArrayBuffer;\r\n                    }\r\n                    if (data instanceof AB && data.byteLength !== undefined) {\r\n                      apiData.api_response_content_length = data.byteLength;\r\n                    } else {\r\n                      if (typeof data === 'string') {\r\n                        apiData.api_response_content_length = data.length || 0;\r\n                      } else {\r\n                        apiData.api_response_content_length = JSON.stringify(data).length || 0;\r\n                      }\r\n                    }\r\n                  } else {\r\n                    apiData.api_response_content_length = 0;\r\n                  }\r\n                  that.reportApi(apiData)\r\n                } catch (e) {\r\n                  that.consoleErr(e);\r\n                }\r\n                success.call(this, res);\r\n              },\r\n            })\r\n          }\r\n        }\r\n        Object.defineProperty(wx, i, desObj)\r\n      } else {\r\n        Object.defineProperty(wx, i, descriptorObj[i])\r\n      }\r\n    }\r\n    // 对微信将来引入Symbol的情况进行兼容,防止丢失以Symbol为键的情况\r\n    if (Object.getOwnPropertySymbols && typeof Object.getOwnPropertySymbols === 'function') {\r\n      Object.getOwnPropertySymbols(descriptorObj).forEach(val => {\r\n        Object.defineProperty(wx, val, descriptorObj[val])\r\n      })\r\n    }\r\n    // 重写wx对象end\r\n  }\r\n复制代码待优化错误异常无法定位到源码目前只支持原生框架和mpvue框架,并且不能适用微信第三方插件自定义事件无法像web探针,在任意标签上添加"}
{"title": "利用watch在小程序中实现全局状态共享 ", "author": "Rolan", "pub_time": "2019-6-4 00:43", "content": "在之前开发微信小程序的时候，获取用户信息、openid还有地理位置这些信息的时候，都是采用 Promise 的方式异步获取，但是这样的话在页面和App.js中都获取就可能造成 请求重复 的问题。比如为了在每个页面都能获取到这些共享信息，都会选择在App.js中进行获取，然后在页面级进行获取，这两次获取的时间间隔较小时就可能导致前一个请求还未获取到数据，后一个请求就会再次进行获取，这样就产生了两次请求。还有一个问题就是书写麻烦(虽然也能通过async await简化)，比如onLoad() {\r\n    app.getUserInfo()\r\n    .then(userInfo => {\r\n        \r\n    }).catch(err => { /* 错误处理 */ });\r\n    \r\n    // 如果同时需要userInfo和openid，可能就是如下形式：\r\n    Promise.all([app.getUserInfo(), app.getOpenid()])\r\n    .then(res => {\r\n        \r\n    }).catch(err => { /* 错误处理 */ });\r\n}\r\n复制代码正好周末的时候突然想到了vue的watch语法，利用一些相关的知识，就可以解决这个麻烦的问题了。解决思路双向绑定vue的双向绑定原理，3.0将会采用Proxy监听数据变化，不过考虑到小程序这边的Proxy兼容性我不知道，所以采用了2.0的Object.defineProperty来监听数据的变化。主要还是拦截设置的操作，在进行赋值时，将新旧值通知至监听者。观察者模式在页面级的onLoad 监听 app.globalData 各个键名的事件 ，而在app.js的onLoad中则使用Object.defineProperty重新定义app.globalData，这样一旦app.globalData相应的键值发生了变化，就会通知监听的页面该值发生了变化。模块化的引用观察者模式导出的是一个对象（类实例），而不是一个类，所以在导入的时候这个对象是共享的，就可以通过这个对象将app.js和其他页面联系起来。至于模块加载的实质，ES6模块加载的机制，与CommonJS模块完全不同。感兴趣的可以去看看这个。封装Page小程序的Page函数本身是不支持watch，但是我们可以自定义一个函数，进行参数合并就可以了。在页面onLoad时先遍历watch属性，对app.globalData进行监听，可以参考vue的watch用法。页面onUnload时就会进行销毁，此时也应该取消监听，这些我都封装过了，不用手动处理了。有了这些思路，用不了多久，一个雏形就出来了，经过手动测试，感觉没什么问题，我就发布到npm了，大家感兴趣的可以安装体验一下。安装npm i wx-watch -S --production\r\n复制代码使用// app.js\r\nvar { watchData, } = require('/miniprogram_npm/wx-watch/index.js');\r\n\r\nApp({\r\n  onLaunch() {\r\n    this.watchData(); /* 监听this.globalData的变化，并触发事件，其他页面监听的值必须在globalData中预先定义，否则无法监听 */\r\n  },\r\n  watchData,\r\n  globalData: {\r\n    userInfo: null,\r\n  }\r\n});\r\n\r\n// 其他需要监听globalData的页面.js\r\nvar { getPage } = require('../../miniprogram_npm/wx-watch/index.js');\r\nconst app = getApp();\r\n\r\n/**\r\n * getPage(页面参数，app) app必传，因为封装的时候访问不到，就只能传参了\r\n*/\r\ngetPage({\r\n  watch: {\r\n    userInfo(userInfo, oldUserInfo) {\r\n      console.log(`来自app.glodalData的userInfo`);\r\n    }\r\n  },\r\n  // 其他参数\r\n}, app)\r\n复制代码github: github.com/ma125120/wx…要是用的还行，欢迎star。要是有问题，欢迎提交issue。"}
{"title": "微信小程序上传文件小结 ", "author": "Rolan", "pub_time": "2019-6-11 00:09", "content": "前言后端用的是\tRails ActiveStorage direct_upload 的处理方式, 前端被要求：MD5-Base64\r\nsigned_id\r\n相关知识因为目前开发任务重且紧，暂时略过此部分，只记录结论要点，后续有时间再补充相关知识要点小结3.0 上传文件（后端 Rails: activeStorage）Step 1: 计算文件MD5-Base64摘要小程序中前端无法获取文件的Binary格式 ，因此无法自行或使用第三方库来计算文件的\tMD5值，但幸运的是，小程序也提供了API来做这件事，请使用：\twx.getFileInfo将获得的\tMD5 值转为\tBase64 格式。可使用此项目中\tutils/base64.js 的\tencode 方法，该方法适用于转换字符串。也可使用\tCryptoJS 库，需要注意的是，\tCryptoJS.enc.Base64.stringify 需要的参数是\tWordArray 格式，不能直接传\tString ，要先用\tCryptoJS.enc.Utf8.parse 转换一下字符串Step 2: 上传文件到上一步返回的指定\tdirect_upload 地址小程序前端无法直接获得文件的\tBinary 格式传给后端，但可以通过\twx.uploadFile 上传文件，通过此接口发送请求，后端可获取到文件\tBinary 格式后端提供的上传文件接口需符合\twx.uploadFile 的要求，即\t请求方式为\tPOST , 并指定所需文件\tkey 名（而不是直接要求把\tBinary 文件丢在请求\tbody 中）"}
{"title": "小程序如何做全局重新加载 ", "author": "Rolan", "pub_time": "2019-6-4 00:44", "content": "背景：随着业务的增加，我们服务器需要计算大量的用户数据，导致用户跟客服反应页面不能正常展示。反馈给开发后，我们一看，是服务器异常的错误。So，产品想看下我们到底有多少用户页面不能正常展示？方案：后端人员直接在阿里云后台去查哪些接口异常 前端做一个服务器报错页，这样产品在小程序后台能看到这个页面的PV,UV技术方案因为业务庞大，所以我们不可能区在每个页面加上重新加载的逻辑。所以初步考虑使用全局重新加载。需要解决的问题都有哪些？1、首先我们要有网络请求失败的全局控制权（要不然就需要在每个页面处理失败的情况） 2、需要定义好网络失败后是如何跳转到重载页（R）的（用wx.redirectTo，wx.reLaunch还是其他） 3、点击错误页的“重新加载”，如何返回或跳转到出错页(E)（用wx.redirectTo，wx.reLaunch还是其他） 4、跳转到出错页后，如何重新加载数据（把所有请求都放在Page.onShow()里面?） 5、那如果从出错页的上个界面(P)传到出错页（E）options，那重载页（R）又将如何处理？ 6、点击重新加载跟返回，我们希望效果效果一样，又该如何操作？实践的方式如下1、第一个问题： 比较好解决，我们基于wx.request已经封装了为fetch（如果还在用wx.request的项目可以考虑封装下，好处多多）。基于fetch我们可以用res.statusCode来判断服务器是否出错。 2、第二个问题： 暂且先不说具体的跳转方式是怎样的，就跳转的url这个怎么定义也需要我们来讨论下。为什么这么说，因为我们的架构涉及到了分包。分包加载意味着我们的代码不仅仅是在pages下面，还放在了package下。 基于此，我们在跳转的时候，url能直接写成'../serverError/serverError'吗？在主包下面可以正常跳转，但是在分包下，路径是'package/serverError/serverError'，这样跳肯定不行。url应该是根目录下的路径，所以'/pages/serverError/serverError'。 路径确认后，我们可以跳转了。如果是wx.redirectTo（关闭当前页面，跳转到应用内的某个页面），想象下关闭E跳转到R，点击重新加载，再关闭R跳转到E，这么跳转路径复杂，用户体验不好，并且options的参数需要逐级传递。wx.reLaunch类似。我们用所以我们选择wx.navigateTo。 3、第三个问题： 综合问题二的解释，跳回到E，我们用wx.navigateBack。 4、第四个问题： 如果从R用wx.navigateBack回到E的话，肯定会触发E.onShow()方法。但是有些请求我们除了写在Page.onShow()里，还有些是写在Page.onLoad()里的，所以我们必须想办法调起E.onLoad()。 大家对于getCurrentPages()这个方法肯定不陌生，官方定义是来获取当前页面栈，我们一般用它来获取当前页面路径。其实在这个过程中，我们是能拿到当前页面的实例的，并且实例里面有route（页面路径）options（页面传递参数）data(页面初始参数)以及各种function()等等。 利用previousPageClass()我们可以拿到E的实例，也就可以拿到E.options，当然我们也可以调E.onLoad()。 util.js// 获取当前路径function currentPagePath() {  let pageData = getCurrentPages()  if (pageData.length >= 1) {    let len = pageData.length - 1    let data = pageData[len]    return data.route  } else {    return ''  }}// 获取上个界面的实例function previousPageClass() {  let pageData = getCurrentPages()  if (pageData.length >= 2) {    let len = pageData.length - 2    let preClass = pageData[len]    return preClass  } else {    return ''  }}module.exports = {  currentPagePath,  previousPageClass}第五个问题： 基于问题的四的方案，我们可以调E.onLoad(E.options)来将我们的参数回传回去。 第六个问题： 点击返回，相当于页面卸载，也就是执行了R.onUnload(),这个时候我们只需要执行E.onLoad(E.options)这个方法，把options传过去，以及调用起E.onLoad()就OK了。 但是点击重新加载，我们是调的wx.navigateBack()，这个方法也会走R.onUnload()。这是时候可能有些苦恼了，我们隐藏掉返回按钮？发现官方并没有提供此方法。禁用R.onUnload()，好像也不行。因为R.onUnload()是在点击重新加载后才执行的，所以我们可以记录下用户是否点击了重新加载的行为。然后我们通过记录的行为，即便用户点击了重新加载，然后触发了R.onUnload()，我们不去执行E.onLoad(E.options)就OK了。 // pages/serverError/serverError.jsimport { previousPageClass } from '../../utils/util.js'let isClickReload = falsePage({  onLoad: function (options) {    isClickReload = false  },  onUnload: function () {    if(!isClickReload) {      this.callbackParams()    }      },  /**   * 点击事件   */  clickReload: function (e) {    isClickReload = true    wx.navigateBack()    this.callbackParams()  },  // 点击返回，参数回传  callbackParams: function () {    let preOptions = previousPageClass().options    previousPageClass().onLoad(preOptions)  }})至此所有问题，基本都已解决。 Demo代码附上，欢迎参考。"}
{"title": "滴滴小程序框架Mpx支持小程序跨平台开发，可直接转换已有微信小程序 ... ", "author": "Rolan", "pub_time": "2019-6-4 00:49", "content": "Mpx是一款致力于提高小程序开发体验和效率的增强型小程序框架，目前在滴滴公司内部支撑了包括滴滴出行小程序，滴滴出行广场小程序，青桔单车，黑马电单车，小桔养车，小桔加油在内的小程序生态；自去年11月开源以来，Mpx也吸纳了众多外部开发者的加入，基于Mpx开发了开走吧，好免街，花忆等小程序。\r\n长期以来，Mpx优秀的开发体验和强大的稳定性得到了内外开发者的一致认可和好评，这非常符合Mpx的设计初衷。但是在各大厂商陆续推出自己的小程序平台，且各家的技术标准都不统一的今天，单纯地提高某一个平台的开发体验已经不能满足广大小程序开发者们的诉求，一套代码在多小程序平台运行已经成为一个现实上的刚需。为了解决这个小程序开发的痛点，Mpx发布了2.0版本，适配了目前业内已经发布的所有小程序平台(微信、支付宝、百度、头条、qq)，并且提供了直接将现有微信小程序编译输出到其他平台运行的能力。\r\nMpx2.0版本新增的主要特性主要包含：\r\n\r\n完整支持了目前业内已发布的所有小程序平台(微信，支付宝，百度，qq，头条)；\r\nMpx小程序跨平台开发，支持将已有的Mpx微信项目编译输出到其他已支持的小程序平台中运行，点击查看详情；\r\n小程序原生组件跨平台编译，支持将已有的微信原生组件编译输出到其他已支持的小程序平台中运行；\r\n深度分包优化，编译过程中进行精准分包资源判断，所有分包only的资源(组件、js、外部样式、外部模板、wxs，图像媒体等)都会精确输出到分包目录中；\r\nrender函数中完整支持wxs模块，关于render函数点击查看详情；\r\n支持了模板引入，内联wxs，自定义tabbar，独立分包，workers，云开发等原生能力，进一步完善原生兼容性。\r\n\r\n同业内主流的小程序跨端框架相比，Mpx更专注于小程序开发本身，在小程序开发中具备以下优势：\r\n\r\n基于小程序自身的技术标准进行增强，没有进行过重的DSL转换，开发时遇到的坑会更少；\r\n完全兼容原生小程序技术规范，0成本迁移原生小程序项目;\r\n跨平台开发以跨小程序平台为目标，大部分差异抹平工作在编译阶段进行，大大减少运行时适配层增加的包体积；\r\n支持业内微信小程序组件库(如vant、iView等)直接转换到其他小程序平台运行;\r\n非常重视小程序性能，提供了深度的setData和包体积优化。\r\n\r\n关于Mpx更详细的介绍可以查看官方文档和这篇文章。\r\nGithub：github.com/didi/mpx\r\n跨平台开发\r\n作为2.0版本的核心能力，Mpx的跨平台开发能力允许用户直接将已有小程序项目编译输出到其他已支持的小程序平台中运行。微信小程序作为小程序概念的提出者，有着最广泛的生态覆盖，因此我们优先支持了将微信小程序编译为其他平台小程序的能力。基于这个能力，用户不仅能跨平台编译微信Mpx项目，甚至能够将微信的原生自定义组件也编译到其他小程序平台进行运行，这意味着我们的跨平台项目能够直接使用一些社区内已有的UI组件库生态(如vant、iView等)，极大地提高了跨平台开发的适用范围。\r\n设计理念\r\nMpx框架的核心设计理念在于增强，增强是指在小程序已有的原生能力基础上做加法，拓展小程序的开发能力，提高小程序的开发体验和效率。这个设计理念使Mpx给开发者带来了更强的确定性和可预期性，更低的学习上手和调试成本。基于这个理念，Mpx在不同的小程序平台中进行了差异性的增强适配，并参考各个平台的模板指令风格提供了不同的增强模板指令集，让用户在各小程序平台中都可以以增强的方式去最大限度地使用平台自有的原生能力。\r\n我们在对Mpx提供跨平台能力的支持时也遵循了增强的核心设计理念。简单来讲，Mpx的跨平台能力是在多平台能力的基础上，在编译和运行时增加了一层转换层，将源平台的代码转换为目标平台的代码之后，再按照既有的目标平台的处理逻辑进行增强，同时我们也提供了一套完善的条件编译机制，让用户自行实现少数框架无法转换的部分。\r\n\r\nMpx跨平台开发流程示意图\r\nMpx跨平台能力设计思路明显区别于业内已有的其他小程序跨平台框架，主要差异在于：\r\n\r\nMpx以小程序本身的DSL作为基准，而没有使用web框架(React,Vue)的DSL；\r\nMpx主要通过编译和运行时转换的方式处理平台差异，没有提供额外的差异抹平层(基础组件库等)。\r\n\r\n之所以采用这种设计，主要基于以下原因：\r\n\r\nMpx主要以跨小程序平台为目标，目前各大小程序平台的技术规范具有一定相似性，绝大部分平台差异能够通过编译和运行时手段抹平，同时省去的差异抹平层也能够进一步减少框架运行时体积；\r\n使用小程序本身的DSL作为基准允许用户直接在已有项目中使用跨平台能力，对于原生小程序项目或组件也能够使用该能力进行跨平台输出；\r\n结合完善的条件编译支持，该方案能够在满足用户跨平台需求的同时仍然允许用户最大限度地使用各个小程序平台提供的能力，完全延续了Mpx增强的核心设计理念。\r\n\r\n使用方法\r\nMpx跨平台开发的使用方式非常简单，用户只需在MpxWebpackPlugin创建时传入mode和srcMode参数指定源平台和目标平台，当srcMode和mode不一致时，框架会读取相应的配置对项目进行编译和运行时转换。\r\n// 微信转支付宝\r\nnew MpxWebpackPlugin({\r\n  // mode指定目标平台，可选值有(wx|ali|swan|qq|tt)\r\n  mode: 'ali',\r\n  // srcMode指定源码平台，默认值同目标平台一致 \r\n  srcMode: 'wx' \r\n})\r\n复制代码差异抹平\r\n目前各大厂商的小程序技术规范在宏观层面上大致保持一致，但是技术细节方面存在很多差异，大致划分为以下几个部分：\r\n\r\n模板语法/基础组件差异\r\njson配置差异\r\nwxs语法差异\r\n页面/组件对象差异\r\napi调用差异\r\nwebview bridge差异\r\n\r\n其中，对于模板语法/基础组件、json配置和wxs中的静态差异，我们主要通过编译手段进行转换处理，对于这部分差异中无法转换的部分会在编译阶段报错指出；而对于页面/组件对象、api调用和webview bridge中js运行时的差异，我们主要通过运行时手段进行处理，对应的无法转换部分也会在运行时中报错指出。\r\n值得注意的是，我们在跨平台转换中做的工作不仅是对可转换的技术标准进行转换映射，对于一些目标平台中不存在的能力，我们也尽可能地通过编译和运行时手段提供了模拟和支持，最大限度地减少用户在跨平台开发中需要付出的额外工作量。以差异性最大但现实场景也最多的微信转支付宝为例，Mpx模拟提供了许多微信中支持但支付宝中未支持的能力：\r\n\r\n组件自定义事件\r\n组件间关系\r\n获取子组件实例\r\nobservers/property observer\r\n内联wxs\r\n外部样式类\r\n\r\n对于原生自定义组件的跨平台转换，我们会对其进行简单的运行时注入，使其能够使用Mpx框架提供的运行时转换能力。\r\n条件编译\r\n对于框架无法抹平的差异部分，会在编译和运行时报错指出，对于这部分错误，我们提供了完善的条件编译机制让用户能够自行编写目标平台的patch进行修复，该能力也能用于实现具有平台差异性的业务逻辑。\r\n上文中提到Mpx通过读取用户传入的mode和srcMode来决定是否以及如何对项目进行转换，mode和srcMode分别代表整个项目构建的目标平台和源平台，条件编译能够让用户在项目中创建声明了自身平台属性(localSrcMode)的文件和代码块。在项目构建中，框架会优先加载带有localSrcMode声明且localSrcMode与项目目标平台匹配(localSrcMode===mode)的文件和代码块，这部分文件和代码块需要完全依照自身声明的平台标准进行编写，Mpx不会对其进行任何编译和运行时的跨平台转换。\r\nMpx提供了三种维度的条件编译，分别是文件维度，区块维度和代码维度，用户可以根据平台差异的覆盖范围灵活选择使用。\r\n性能优化\r\nMpx框架专注于小程序开发，在性能优化方面我们做过很多尝试和努力，主要集中在两个方面：\r\n\r\n运行时的setData优化\r\n编译构建时的包体积优化\r\n\r\nsetData优化\r\n数据响应是Mpx运行时增强的核心能力，该能力让用户在小程序开发中能够像Vue中一样使用watch和computed特性，并且用直接赋值的方式操作数据驱动视图更新，而不需要手动调用setData方法，换言之框架接管了小程序中的setData调用。\r\n通过各大小程序平台的设计原理和性能优化建议可以得知，setData对于小程序的性能表现非常重要，而setData优化的两大方向在于：\r\n\r\n尽可能减少setData调用的频次\r\n尽可能减少单次setData传输的数据\r\n\r\n为了实现setData的优化，我们在模板编译过程中对于每个组件的模板都生成了一个渲染函数(render function)，该函数模拟模板的渲染逻辑，在每次执行时访问当次渲染所需的数据，并将当次访问过的数据路径记录下来作为函数返回值返回。\r\n在运行时，框架会在每个组件创建时创建一个render watcher，该watcher追踪渲染函数，当渲染依赖数据发生变更时异步执行渲染函数，在render watcher回调中得到渲染函数返回的数据路径，基于这些路径与上一次的缓存数据进行diff比对，过滤掉未发生变化的数据后得到最小必要数据，最后调用setData将最小必要数据发送到真实的小程序渲染层更新视图。\r\n基于这个机制，当数据发生变更时，只有当前渲染依赖的那部分数据发生变更才会异步地触发render watcher的执行，而每次执行后也只有实际发生变更的那部分数据会被setData发送到渲染层。这样用户就能自由地根据业务需求来操作数据，无需关注setData的调用优化，框架能够自动进行程序上最优的setData调用，在提升用户开发体验的同时也提升了程序性能。\r\n在1.x版本中，渲染函数内无法执行wxs的逻辑，对于含有wxs的组件有可能降级到全量设置数据的模式，在2.0版本中，我们将wxs模块转译处理为js可执行的代码后注入到js bundle中，含有wxs的渲染函数也能够正常访问并执行wxs逻辑。\r\n\r\nsetData优化示意图\r\n包体积优化\r\n类似于运行时对于setData的接管，Mpx在编译阶段接管了项目的资源管理。得益于webpack强大的插件机制，Mpx开发了一个深度定制的webpack插件，基于webpack完成小程序的打包构建工作。用户在使用Mpx开发小程序时可以不受限制地使用npm依赖、最新的es特性和css预处理器等现代web开发能力。与此同时，Mpx在包体积优化上也做了很多工作，让用户专注于业务开发而无需花费过多精力进行包体积管理，我们所做的优化工作如下：\r\n\r\n打包构建工作完全基于依赖分析，任何没有被引用的资源都不会出现在dist当中；\r\n对于npm组件和页面的构建也完全基于依赖分析按需打包，不会copy整个miniprogram_dist目录，也不需要执行构建npm，使用体验和包体积均优于微信小程序自身的npm支持方案；\r\n基于webpack提供的能力进行公共模块抽取和代码压缩等优化工作；\r\n完善的分包支持，对所有资源进行从属分析，将所有分包only的资源都输出到分包目录中。\r\n\r\n分包作为微信小程序中优化包体积的核心手段(类似于异步按需加载)，Mpx对其进行了完善的支持。为了精确地标记出分包only的资源，我们在构建时将主包和分包的依赖收集步骤拆分开来串行处理，先处理主包，再处理分包。在主包的处理过程中，将主包页面中引用的所有非js资源(组件、外部样式、外部模板、wxs，图像媒体等)都记录下来，在处理分包时，对分包内引用的非js资源都进行检查，如果被主包引用过则输出到主包中，否则标记为分包only的资源输出到分包目录下。\r\n对于js模块资源，我们在脚手架中生成的构建配置中提供了辅助函数，便于用户进行分包bundle的配置，经过该配置后，分包only的公用模块会被打入分包bundle输出到分包目录下，其余的公共模块会正常打入主bundle中。\r\n在跨平台开发中，我们建议用户使用Mpx提供的packages来定义分包，这样在转换到不支持分包的小程序平台时会自动降级为同步包进行处理。\r\n\r\n分包构建示意图\r\n渐进迁移\r\nMpx提供了良好的渐进迁移支持，对于使用原生或其他小程序框架的开发者来说，采用渐进迁移的方式逐步引入Mpx进行开发成本并不大。\r\n在2.0版本中我们进一步完善了Mpx的原生兼容性，跟进支持了各个小程序平台最新的技术能力，如自定义tabbar，独立分包，分包预加载，workers，云开发等能力，同时补齐了一些1.x版本遗漏的支持。得益于此，对于使用原生小程序开发的开发者来说，迁移Mpx的成本几乎为0，用户只需将对应页面组件的构造函数替换为Mpx提供的createPage/createCompnent，即可使用Mpx提供的各种增强能力。\r\n对于使用其他框架的开发者，Mpx也提供了局部构建的机制，允许用户将特定的页面和组件单独构建输出为原生组件，用户只需手动或者编写脚本输出的原生组件整合进原有项目中即可。\r\n未来规划\r\n作为滴滴公司内部小程序生态的基础设施，我们会对Mpx框架进行长期的维护更新，确保能在第一时间支持各个小程序平台最新的技术特性。与此同时，我们也会进一步完善框架的基础能力，目前已排上日程待支持能力包括：\r\n\r\ni18n\r\nts支持\r\n单元测试支持\r\n\r\n在跨平台能力方面，我们也会根据社区的反馈和建议，以及小程序的标准化进程，对其进行持续的完善与更新。\r\n最后，如果你专注小程序开发，关注开发体验和产品性能，那Mpx会是你最好的选择。"}
{"title": "微信小程序WebSocket实践 ", "author": "Rolan", "pub_time": "2019-6-5 00:23", "content": "微信基础库1.7.0之后的版本提供了新版的WebSocket API，考虑到兼容性问题，尝试整合新旧两种版本的API，进行简单的封装。从以下几个角度对微信小程序中所提供的WebSocket API封装API兼容性重连机制小程序WebSocket API旧版WebSocket API的使用创建 - wx.connectSocket发送消息 - sendSocketMessage监听事件 - onSocketOpenlet socketOpen = false\r\nconst socketMsgQueue = []\r\n// 连接socket\r\nwx.connectSocket({\r\n  url: 'test.php'\r\n})\r\n// 监听打开事件\r\nwx.onSocketOpen(function(res) {\r\n  socketOpen = true\r\n  for (let i = 0; i < socketMsgQueue.length; i++){\r\n    sendSocketMessage(socketMsgQueue[i])\r\n  }\r\n  socketMsgQueue = []\r\n})\r\n// 发送消息\r\nfunction sendSocketMessage(msg) {\r\n  if (socketOpen) {\r\n    wx.sendSocketMessage({\r\n      data:msg\r\n    })\r\n  } else {\r\n    socketMsgQueue.push(msg)\r\n  }\r\n}新版WebSocket API的使用支持1.7.0+，连接后会返回一个SocketTask对象，在该对象上监听该连接的各种事件与执行发送消息等操作。let socketTask = wx.connectSocket({\r\n  url: 'test.php'\r\n})\r\n// 监听打开事件\r\nsocketTask.onOpen(function(res) {\r\n  socketOpen = true\r\n  // 发送信息\r\n  socketTask.send({msg: \"hello world\"})\r\n})并发数1.7.0 及以上版本，最多可以同时存在\t5 个\tWebSocket 连接。1.7.0 以下版本，一个小程序同时只能有一个\tWebSocket 连接，如果当前已存在一个 WebSocket 连接，会自动关闭该连接，并重新创建一个\tWebSocket 连接。模块封装简单封装封装一个兼容新旧socketAPI的模块，仅考虑存在单个socket连接的情况创建与事件监听新版: 在socket连接时会返回一个socketTask对象，监听事件是在该对象的基础上进行旧版: 直接使用wx放进行创建与监听方法统一创建与添加监听函数init() {\r\n  let st = this.connect()\r\n  this.listen(st)\r\n  this.manualClose = false\r\n}创建连接connect() {\r\n  let st = wx.connectSocket(this.config.server)\r\n  return st\r\n}添加事件监听函数listen(st) {\r\n  if (st !== undefined) {\r\n    this.ws = st\r\n    this.ws.onOpen(() => this.openHandle())\r\n    this.ws.onError(() => this.errorHandle())\r\n    this.ws.onClose(() => this.closeHandle())\r\n    this.ws.onMessage(res => this.messageHandle(res))\r\n  } else {\r\n    wx.onSocketOpen(() => this.openHandle())\r\n    wx.onSocketError(() => this.errorHandle())\r\n    wx.onSocketClose(() => this.closeHandle())\r\n    wx.onSocketMessage(res => this.messageHandle(res))\r\n  }\r\n}重连机制预设标记位retryLock = false; // 避免多次同时重连\r\nsocketOpen = false; // 连接状态\r\nmanualClose = false; // 主动断开标记在连接关闭监听函数中执行重连closeHandle() {\r\n  console.info('WebSocket closed')\r\n  this.socketOpen = false\r\n  this.retryLock = false\r\n  // 不论是error还是close都会触发close事件，统一在这里进行重连\r\n  // 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)\r\n  this.retryTimes !== undefined && this.reconnect()\r\n}判断重连锁与是否主动断开进行重连reconnect() {\r\n  if (this.retryLock) return\r\n  this.retryLock = true\r\n  // 若manualClose为true，表明不是主动断开\r\n  if (!this.manualClose) {\r\n    // 开始重连\r\n    setTimeout(() => {\r\n      this.retry()\r\n    }, this.retryInterval)\r\n  }\r\n}重连函数，包含重连次数的限制retry() {\r\n  if (\r\n    this.socketOpen ||\r\n    (this.retryTimes > 0 && this.retryCount <= this.retryTimes)\r\n  ) {\r\n    console.warn(`reconnect ending. reconnect ${this.retryTimes} times`)\r\n    if (!this.socketOpen) {\r\n      this.config.closeCallback()\r\n    }\r\n    return\r\n  }\r\n  this.retryTimes += 1\r\n  console.warn(`[ ${this.retryTimes} ]th reconnect WebSocket...`)\r\n  this.init()\r\n}消息队列添加消息队列，当重连后自动发送缓存消息openHandle() {\r\n  this.retryTimes = 0\r\n  this.socketOpen = true\r\n  this.retryLock = false\r\n\r\n  this.messageQueue.map(e => this.send(e))\r\n  this.messageQueue = []\r\n}若发送时断开则先将消息缓存到消息队列中send(value) {\r\n  let data = this.msgWrapper(value)\r\n  data = JSON.stringify(data)\r\n  if (!this.socketOpen) {\r\n    this.messageQueue.push(data)\r\n  } else {\r\n    if (this.ws) {\r\n      this.ws.send({ data })\r\n    } else {\r\n      wx.sendSocketMessage({ data })\r\n    }\r\n  }\r\n}辅助函数添加一些包裹消息格式的工具函数messageIndex = 0;\r\nhelper = {\r\n  isPlainObject: val =>\r\n    Object.prototype.toString.call(val) === '[object Object]',\r\n  nextId: () => {\r\n    this.messageIndex += 1\r\n    return this.messageIndex\r\n  },\r\n  id: () => Date.now() + '.' + this.helper.nextId()\r\n};\r\nmsgWrapper(data) {\r\n  let msg = data\r\n  if (this.helper.isPlainObject(msg)) {\r\n    if (msg.type) {\r\n      return msg\r\n    } else {\r\n      return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n    }\r\n  } else {\r\n    return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n  }\r\n}完整代码export default class WXWebSocket {\r\n  messageQueue = []; // 消息队列\r\n  retryLock = false; // 避免多次同时重连\r\n  socketOpen = false;\r\n  manualClose = false; // 主动断开标记\r\n  constructor(config) {\r\n    this.config = config || {}\r\n    // 重连间隔\r\n    this.retryInterval =\r\n      this.config.retryInterval && this.config.retryInterval > 100\r\n        ? this.config.retryInterval\r\n        : 3000\r\n    // 重连次数\r\n    this.retryCount = this.config.retryCount || 5\r\n    this.init()\r\n  }\r\n  init() {\r\n    let st = this.connect()\r\n    this.listen(st)\r\n    this.manualClose = false\r\n  }\r\n  connect() {\r\n    let st = wx.connectSocket(this.config.server)\r\n    console.log('current socket: ', st)\r\n    return st\r\n  }\r\n  listen(st) {\r\n    // 添加监听事件\r\n    if (st !== undefined) {\r\n      // 若存在SocketTask，则要通过readyState判断状态\r\n      // CONNECTING: 0\r\n      // OPEN: 1\r\n      // CLOSING: 2\r\n      // CLOSE: 3\r\n      this.ws = st\r\n      this.ws.onOpen(() => this.openHandle())\r\n      this.ws.onError(() => this.errorHandle())\r\n      this.ws.onClose(() => this.closeHandle())\r\n      this.ws.onMessage(res => this.messageHandle(res))\r\n    } else {\r\n      wx.onSocketOpen(() => this.openHandle())\r\n      wx.onSocketError(() => this.errorHandle())\r\n      wx.onSocketClose(() => this.closeHandle())\r\n      wx.onSocketMessage(res => this.messageHandle(res))\r\n    }\r\n  }\r\n  close() {\r\n    this.manualClose = true\r\n    if (this.ws) {\r\n      this.ws.close()\r\n    } else {\r\n      wx.closeSocket()\r\n    }\r\n  }\r\n  send(value) {\r\n    console.log('send value: ', value)\r\n    let data = this.msgWrapper(value)\r\n    data = JSON.stringify(data)\r\n    if (!this.socketOpen) {\r\n      // add new message to queue\r\n      this.messageQueue.push(data)\r\n    } else {\r\n      if (this.ws) {\r\n        this.ws.send({ data })\r\n      } else {\r\n        wx.sendSocketMessage({ data })\r\n      }\r\n    }\r\n  }\r\n  openHandle() {\r\n    console.info('WebSocket connected')\r\n    this.retryTimes = 0\r\n    this.socketOpen = true\r\n    this.retryLock = false\r\n\r\n    this.messageQueue.map(e => this.send(e))\r\n    this.messageQueue = []\r\n  }\r\n  errorHandle() {\r\n    console.error('WebSocket error')\r\n    this.socketOpen = false\r\n  }\r\n  closeHandle() {\r\n    console.info('WebSocket closed')\r\n    this.socketOpen = false\r\n    this.retryLock = false\r\n    // 不论是error还是close都会触发close事件，统一在这里进行重连\r\n    // 初次连接失败不进行重连(失败不会进入到onOpen的监听事件中，那时未声明retryTimes变量)\r\n    this.retryTimes !== undefined && this.reconnect()\r\n  }\r\n  reconnect() {\r\n    if (this.retryLock) return\r\n    this.retryLock = true\r\n    // 若manualClose为true，表明不是主动断开\r\n    if (!this.manualClose) {\r\n      // 开始重连\r\n      setTimeout(() => {\r\n        this.retry()\r\n      }, this.retryInterval)\r\n    }\r\n  }\r\n  retry() {\r\n    if (\r\n      this.socketOpen ||\r\n      (this.retryTimes > 0 && this.retryCount <= this.retryTimes)\r\n    ) {\r\n      console.warn(`end reconnect. reconnect ${this.retryTimes} times`)\r\n      if (!this.socketOpen) {\r\n        this.config.closeCallback()\r\n      }\r\n      return\r\n    }\r\n    this.retryTimes += 1\r\n    console.warn(`[ ${this.retryTimes} ]th reconnect WebSocket...`)\r\n    this.init()\r\n  }\r\n  messageHandle(res) {\r\n    this.config.responseCallback(res)\r\n  }\r\n  msgWrapper(data) {\r\n    let msg = data\r\n    if (this.helper.isPlainObject(msg)) {\r\n      if (msg.type) {\r\n        return msg\r\n      } else {\r\n        return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n      }\r\n    } else {\r\n      return this.msgWrapper({ type: 'message', msg, id: this.helper.id() })\r\n    }\r\n  }\r\n  messageIndex = 0;\r\n  helper = {\r\n    isPlainObject: val =>\r\n      Object.prototype.toString.call(val) === '[object Object]',\r\n    nextId: () => {\r\n      this.messageIndex += 1\r\n      return this.messageIndex\r\n    },\r\n    id: () => Date.now() + '.' + this.helper.nextId()\r\n  };\r\n}使用创建连接let socketTask = new WXWebSocket({\r\n  server: this.wsServerOption,\r\n  responseCallback: e => {\r\n    let { data } = e\r\n    let { msg } = JSON.parse(data)\r\n    this.msgStack.push(msg)\r\n  },\r\n  closeCallback: () => {\r\n    this.socketTask = null\r\n  }\r\n})\r\nthis.socketTask = socketTask发送消息sendWSMessage(msg) {\r\n  this.msgStack.push(msg)\r\n  this.socketTask && this.socketTask.send(msg)\r\n},关闭连接closeWS() {\r\n  if (!this.socketTask) return\r\n  if (this.socketTask.socketOpen) {\r\n    this.socketTask.close()\r\n    this.socketTask = null\r\n  }\r\n}"}
{"title": "当微信小程序遇上TensorFlow - tensorflow.js篇 ", "author": "Rolan", "pub_time": "2019-6-11 00:24", "content": "在上一篇推送《 重磅好消息！TensorFlow开始支持微信小程序 》中，介绍了TensorFlow开始支持微信小程序平台，并计划将我之前开发的人工智能微信小程序 识狗君 使用tensorflow js改写。这个端午节，趁着放假，空余时间比较多，开始研究微信小程序中如何使用tensorflow.js。在写下上一篇推送后，我简单尝试过在微信小程序中使用tensorflow.js，发现直接使用还是存在一点问题，所以本次的目标是走通简单的流程：加载预训练模型mobilenet，可以用来识别图片所属分类。示例代码位于: https://github.com/mogoweb/aidog请切换到tfjs分支。运行起来，效果是这样的：嗯，示例是简单了一点，但所有使用tensorflow js的关键步骤都包括。下面就简要描述一下我所遇到的坑及解决之道：loadLayersModel无法加载模型使用tfjs定义模型，训练模型并进行预测都没问题，但是使用 loadLayersModel 加载预训练模型，却出现如下错误：Uncaught (in promise) Error: Unable to find the fetch() method. Please add your own fetch() function to the global namespace.为什么会出现这个问题呢，原来tfjs-core为了可移植性，平台相关的操作，由各平台自行实现。从网络上获取数据就是这样的平台相关操作，浏览器、Node各有自己的实现方法。浏览器的实现依赖于fetch API，而微信小程序上，非常遗憾的看到了一条更新日志：微信小程序中，网络请求可以通过 wx.request 实现，问题是如何实现全局的fetch函数呢？这可难倒了我。在网上搜索的时候，发现了一个项目：https://github.com/HunterXuan/wx-tfjs-core.git\r\n原来这哥们早就研究过将tfjs移植倒微信小程序平台，写了几篇博客，值得看一看。参考了他的修改，我也完成了tfjs-core的改造，参考我在GitHub上建的项目:https://github.com/mogoweb/wechat-tfjs-core.git\r\n我的修改有点不同，新定义了PlatformMP，主要是考虑到微信小程序和普通浏览器还有一些差异，以后存在差异的代码都放到PlatformMP里面实现。是不是还有更好的方法，比如不需要修改tfjs的代码，在微信小程序里面实现全局fetch函数？我不太确定，希望前端高手指点。预训练模型被墙由于一些众所周知的原因，访问Google的服务总是不顺畅。我长期挂VPN，这倒不是问题。关键是，如果在微信小程序中访问Google，这就有些麻烦，不可能期望用户能够个个玩转VPN。幸运的是，tfjs上有一个issue： Model accessibility issues in China #1375 。里面给出了临时解决方案，我们可以通过镜像：https://cnpmjs.org/mirrors/tfjs-models/ 获取模型。这个镜像能够存在多久还是个未知数，可能最靠谱的还是将模型同步下来，自己存储。这种方式还没有来得及研究，有时间再看看。获取图像数据在tfjs-examples中，是通过： tf.browser.fromPixels 接口获取图像数据，但在微信小程序中却行不通，因为微信小程序平台中移除掉了document对象。好在以前在开发 识狗君 微信小程序识研究过通过wx canvas获取图像数据，具体实现请参考源码。有一点需要注意，通过canvas获取到的图像数据是RGBA格式，而mobilenet模型接收的却是RGB，为此我写了一个转换函数：// RGBA to RGB\r\nvar rgbData = new Uint8Array(res.width * res.height * 3);\r\nlet idx = 0;\r\nfor (let i = 0; i < res.data.length; i +=4) {\r\n  rgbData[idx] = res.data[i];\r\n  rgbData[idx + 1] = res.data[i + 1];\r\n  rgbData[idx + 2] = res.data[i + 2];\r\n  idx += 3;\r\n}感觉这个函数实现得效率有些低，是否有更好的方法，还请高手指教。async / await作为一名浏览器内核开发人员，平常也接触一些js代码，但前端发展实在太迅猛了，好些新式的js代码已经完全看不懂。比如在 tfjs-examples 代码中，就有许多async / await等用法，模块导出也有好几种方式，Promise又是什么鬼？搞的我头晕脑胀，多亏了知识搜索能力还不错，遇到问题就Google，每次都能逢凶化吉。要在微信小程序中使用async / await，需要打开项目配置的增强编译开关：待完善问题模型每次都需要从网络加载，需要研究如何利用微信小程序的storage，这样模型可以缓存到本地，避免每次从网络加载。由于微信小程序包有大小限制，所以将模型打包到小程序不可能。将自己的模型转化为tfjs模型，并在微信小程序中使用。不修改tfjs-core，将平台相关代码放到微信小程序中实现。你还可以看：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现当微信小程序遇上TensorFlow：接收base64编码图像数据当微信小程序遇上TensorFlow：终章识狗君微信小程序的部署"}
{"title": "细数百度小程序踩的坑 ", "author": "Rolan", "pub_time": "2019-6-11 00:32", "content": "最近接触百度小程序挺多，开发了几个产品，都快被百度的小程序折磨死。真的是不想吐槽了，接下来我就讲讲我遇到的坑与一些经验。1. s-for这个for循环的写法为 s-for='arr' 或者 s-for = 'item,index in arr' 。这些到没什么，主要是s-for不能循环常数。。。这让我从微信小程序转到百度小程序不太习惯。。。官方回应说什么底层diff差异哦，后面会修复。不知道现在修复好没。2. 自定义组件之命名与路径引用组件的时候，在json文件中，usingComponents 选项里填入要引入的组件并自定义名称：\"my-radio\":\"/components/bd-radio/bd-radio\"。需要注意的是：这个组件的名称不支持驼峰和大写写法。路径支持绝对路径和相对路径。3. 自定义组件之组件通讯子组件 this.triggerEvent('getchange', idx); 触发事件，getchange是父组件需要接收的事件名，第二个参数是需要传回去的数据，最好是object，其它的参数，在2.0.3之前不支持。父组件 <my-radio bindgetchange='getSex'></my-radio> bindgetchange bind后面的就是子组件传过来的事件名，再后面一个(getSex)就是父组件中定义的函数，接收的时候e.detail，就是自组件传过来的数据4. 获取索引值如果要获取s-for中当前点击元素的索引值，只有在元素上添加 data-idx='{{index}}' 自定义属性，然后点击事件里面，通过：e.currentTarget.dataset.idx 获取。5. swan.request百度小程序的 swan.request 只支持 https协议。如果你不小心接口弄成了HTTP协议的url，在开发者工具上完全没问题，但是真机调试的话，如果你运气好，就没问题，运气不好在某些手机上就会出现接口无反应的情况，并且swan.request 的fail打印出： illegal request 非法请求。但是又没报错。所以，这个情况的提示也是不明显的，谁知道那个非法请求是接口还是url地址的错啊。还有就是百度好像并没有对这个接口中的url进行encodeURIComponent，所以如果有中文，那自己需要进行编码一次。6. swan.setStorageSyncswan.setStorageSync 这个同步的存储数据接口，官方文档说：参数支持String key, Object/String data。我第一次使用这个接口的时候，没注意看参数，结果传了一个布尔值进去，但是使用swan.getStorageSync获取的时候，始终获取不了，结果发现数据最外层包了一个data属性。即正常是xxx:true，实际上取出来是 data:{xxx:true} 也是醉了。。。不支持的至少给个错误提示啊。。。7. rich-text使用rich-text富文本组件的时候<rich-text node=\"{{a.b}}\"></rich-text>\r\n//如果a是后台取的，在js的data中初始化的时候，如果a设置为null，有可能会报错，导致页面复制相同的内容，即出现两个相同的内容连在一起。所以最好设置为 {} 空对象。而且如果遇到识别不了的标签会停止渲染，并且不会有错误提示。。。我遇到过几次出现两个相同的内容连在一起的情况，忘了截图的，具体怎样出现的也忘了。。。8. image 组件出现 image load faild如果遇到某些时候图片路径是正确的，但是出现 image load faild 这个错误，我也不知道怎么解决。官方回答说不影响开发就行。。。特别是从一个页面navgitor或者其它的跳转方式跳转到另外的页面，就有可能会出现这种情况。而且图片还是本地的。。。官方回复说：image图片地址只支持https协议，并且在小程序后台进行域名配置，或者百度域名的图片，不满足条件的话，图片将无法正常显示。不过有时候还是会出现上面的问题。9. H5支付 转到 百度支付 swan.requestPolymerPayment关于百度小程序支付：最开始我天真的以为，web-view嵌套一个已经完善的H5商城，支付的时候也可以直接使用自己对接的H5的支付。因为在本地预览时，不管安卓还是IOS，都可以支付成功，没问题。但是只要一发布上线，支付的时候就调不起微信或者支付宝的支付弹窗了。都不能跳转到支付弹窗的页面。安卓机全部不得行，IOS没问题。抓包发现结果返回正常，没有错误。我估计是百度官方屏蔽了。官方给出的回答是：为保护用户的资金安全，小程序的web-view不支持自行调用第三方支付服务。如有支付需求，建议接入百度收银台。。。但是，但是，但是。。。我看到苏宁易购的百度小程序就是使用的自己对接的第三方支付，并没有使用百度的支付接口。。。我就很奇怪了，为撒子苏宁易购就可以？？？10. web-view的src也可以使用localhostweb-view的src也可以弄成IP地址的情况。比如我本地使用vue-cli运行了一个项目，假设为http://localhost:8087/szxgcs/detail.html。这时我把localhost改成自己的IP地址，然后在web-view的src中：<web-view src='http://192.168.xxx.xxx:8087/szxgcs/detail.html'></web-view>\r\n//这样就能运行在本地的代码了 11. 使用未申明的变量，有可能会没错误提示有时候在某些接口中，或者request的data中，使用that.data.xxx的时候，由于我粗心，that没有声明。所以在运行的时候，发现调接口没反应。但是又没有提示哪里有错，就很懵逼。所以一定要检查某些变量是否声明的。不过现在好像改好了，不声明会报错了。12. swan.setPageInfo接入百度信息流接入百度信息流的申请，就是在页面配置swan.setPageInfo，如果小程序首页是web-view嵌套的页面，不是百度小程序原生开发的页面。那么就会申请不了。现在默认都是接入了百度信息流的，所以如果没配置，会出现让你配置的警告信息。建议代码写成swan.setPageInfo && swan.setPageInfo({配置内容}) ，如果不这样写，按照官方的写法，在真机调试中，会报错。13. 发布审核时设置基础库版本高一点。建议发布审核的时候，把开发者平台 --- 设置 --- 基本设置 --- 基础库最低版本设置 设置高一点。低版本出现了问题，如果是百度的问题，官方是不会给你修复的，这是官方技术人员回复我的原话。一般设置3.xxx以上就可以了，3.xxx以前的没多少用户了。这样也可以避免审核的时候测试人员在低版本测试，出现不清楚原因的bug。14. s-if不能和s-for一起用。有可能出现不可预知的错误。还有就是 s-if 一定要写在最前面，不然有可能也会出现一些小问题。。。.假如需要给组件传递内容，这个内容是异步获取的，那么在组件里，获取的时候，有可能会遇到获取不到传过来的内容，这个很正常。在H5的vue中，我使用v-if来避免获取不了的情况。类似：</ child :sendval='data' v-if='data' >\r\n//data初始化为false，这样，只有在data真实获取到内容的时候，才渲染组件。\r\n//但是，在百度小程序中，判断条件必须写在前面即：\r\n<child  s-if='data' :sendval='data' ></child>\r\n//不然，还是会出现获取不了内容的情况 15. swan.createSelectorQuery() 有时需要延时获取宽高等信息。swan.createSelectorQuery()这个获取dom元素的接口，如果获取的dom元素是动态添加的，那么，在调用boundingClientRect获取宽高等信息的时候，是需要延时获取的。这个在组件中更明显，就算组件加了s-if，在数据成功返回之后再渲染组件，但是渲染的过程也需要耗时，所以，不能及时地获取到元素的信息。就算使用swan.nextTick()也没作用，有时候也会获取不到。我设置setTimeout延时一般是150ms16. swan.nextTick()swan.nextTick()就是提供一个异步操作。从来就没用过，官方的描述也是云里雾里的。感觉和vue的nextTick不太一样。因为我试过相同情况下相同的代码，两个的表现不一样。17. 慎用sConsoleweb-view中的h5页面跳转到小程序会打开两次。这个情况是打开了SConsole调试面板的，关闭之后就不会出现这个情况。其它情况使用sConsole也有可能会出现某些小问题。。。18. getSwanIdgetSwanId在开发者工具上，返回的是SWAN-DEVELOP，而真机上是一段长度为几十个的字母和数字组成的字符串。19. css单位css单位基本都支持，不过如果是rpx这种，小程序会自动转换成vw或者vh，所以你会看到控制台里的单位都是vw或者vh20. getStoragegetStorage获取本地不存在的数据，默认进入success，不会进入fail回调21. 分享到贴吧这个功能，官方有说明： 这里是接入文档       这里是简单说明。在代码中配置好，并且上线小程序后，我以为这样就能申请分享白名单了。。。然而，按钮竟然没给我激活，点不动。。。搞不清楚原因。。。然后就放弃了 上面这些是真实遇到的情况，真的累，本来只花一天的时间搞得定的内容，一路踩坑结果多花了两三倍的时间。。。逐渐怀疑我是不是做程序员的料。。。后面还会继续开发百度小程序，估计又会折寿了。。。"}
{"title": "我写小程序像菜虚鲲—— 唱，跳，rap，篮球 ", "author": "Rolan", "pub_time": "2019-6-11 00:38", "content": "引言大家好，我是练习时长两年半的个人练习生菜虚鲲，我喜欢唱，跳，rap，篮球，Music！为了避免律师含，就不po鲲鲲的原图咯~在小作坊待久了，都忘记自己的本职工作当初进来是一枚Android开发了，写写下APP和py脚本，偶尔帮人修修电脑。感觉如果自己大只点，可能饮水机的水都要我来换了…因为一些原因，旧APP不再更新迭代了，新的APP没开始做，不想赔钱把我开掉，就把我晾着摸鱼。而我自己比较腊鸡，感觉出去会找不到好的工作（不想再去小作坊，一个人玩好累，感觉再这样下去，会废掉…）晾着摸鱼不做事，工资照发，管理肯定不愿意啊，要给我找点事做做咯：要不你学下前端吧，做下小程序，后面做APP了，你再回去做APP…我TM，说得好像学东西不用学习成本一样，特别是跨域，最怕最后四不像，啥也什么都学得半桶水，如果真转的话，我更想转后端，毕竟前端技术更新换代速度实在是太快了，是真的快，学不来学不来。唉，自己又不是大神，人在屋檐下，不得不低头，安慰自己：小程序外包的单子挺多的，毕竟开发一个小程序的成本比APP少太多，很多甲方爸爸动不动就要做一个小程序，学了小程序，以后可以接点外包苟活下…自己摸索着玩了一个多星期，有点意思：老规矩，记录下自己的学习过程，方便自己日后回顾，也方便后来者。看过网上很多《从零开始学习微信小程序开发》类型的教程，大都废话太多，或者不是真的零基础入门，学着学着者突然来些高深玩意，看得我头皮发麻读者一脸懵逼，笔者深知自学循序渐进的重要性。另外，之前群里有小火汁问我学东西为啥那么快，其实，我学东西还真不快，主要有几点：顺带分享下自己的学习姿势吧~① 兴趣驱动 ：「 你想学 」而非「 要你学 」，主动去探索而非被动接受。② 专注 ：心无旁骛，别一下折腾这个，一下子又折腾那个，三分钟热度。③ 反思总结 ：及时总结归纳，形成自己的知识脉络，同时反思学习过程中的一些问题。④ 去实践 ：你掌握多少知识，取决于你能调用多少，而非记忆了多少知识。⑤ 度 ：把握一个度，知道自己要学习到什么程度，不要去钻牛角尖，等等。大概就这些，笔者是前端小白，并不会深刨，只是希望初学者学完这个系列可以撸出一个简单基本的小程序。现学现卖，难免有错，还望海涵，欢迎前端大神指出。如无意外，一周1-2更。不要有太多期待，因为还在准备Android面试相关。废话就那么多，开始本系列教程。Tips：个人觉得学习小程序最佳的学习方式就是肝官方文档~微信小程序官网： developers.weixin.qq.com/miniprogram…0x1、你看这个面又长又宽（开发环境搭建）官网点击：「 指南 」-> 「 开始 」1、申请账号账号可以申请也可以不申请不是一定要申请账号，如果你只是想 自己瞎玩不发布 的话，可以跳过这一步。当然，你也可以申请，申请后会给你的小程序分配一个「 AppID 」，类似于身份标识。可以在小程序后台，依次点击「 设置 」->「 开发设置 」获取到这个「 AppID 」：2、下载安装微信开发者工具官网依次点击「 工具 」-> 「 下载 」，或者直接打开下述链接跳转下载：developers.weixin.qq.com/miniprogram…用哪个版本看个人喜欢，笔者用的是 开发版 ，你也可以使用稳定版，下载完以后，无脑下一步安装即可。安装完后，其实就可以直接进行小程序开发，只是微信开发者工具自带的IDE比较简陋，没有自带api智能提醒和语法高亮等，写起代码来不是很顺手，所以一般只是拿微信开发者工具来「 看下运行效果 」和「 调试 」，写代码的话用的看看 运行效果，调试 ，二用第三方的IDE来编写代码，常见的两款组合：VS Code + minapp插件Sublime Text 3 + Sublime wxapp插件笔者使用的是前者，接着说下VS Code的下载安装。3、下载安装VS Code并安装minapp插件VS Code直接在官网下载就好： code.visualstudio.com/ ，默认英文。如果你想使用中文可以按快捷键：Windows 或 Linux => Ctrl + Shift + PMac => Command + Shift + P然后在弹出的对话框中输入：「 Configure Language 」，如图：接着点击「 Install additional languages… 」，如图：点击后左侧会出现一个插件安装的，选择中文，如图：安装完，提示重启，重启后就是中文了，接着安装一波minapp插件。点击左侧边栏的第四个图标，然后搜索栏键入「 minapp 」，然后点击Install进行安装，如图：。安装后可能需要重启，重启即可。除此之外，还安利一个插件：「 wechat-snippet 」，自动生成微信代码片段，如果想了解更多插件可见VS官网： marketplace.visualstudio.com/0x2、就像这个碗又大又圆（创建项目）直接打开微信开发者工具，可以「 新建项目 」或者「 导入项目 」，填写项目相关的信息，这里如果你没有申请账号的话可以用随机生成的AppID，如图所示：0x3、你们来这里吃饭（界面熟悉）创建后会自动生成相关代码，创建后的页面如图所示：简单介绍下，圈住的页面内容如下：简单说下页面中圈住的部分都是些什么：① 菜单栏 ：提供项目，文件，编辑等相关操作，自己点开看就知道了。② 视图开关 ：控制模拟器，编辑器和调试器视图的显示和隐藏。③ 模拟器 ：模拟小程序在手机上的界面效果，上面的栏可以进行模拟器的相关配置： 模拟器分辨率、缩放比例、连接网络方式、模拟操作、是否静音、独立成小窗口。④ 编辑器-项目文件目录 ：小程序文件目录，顶部菜单依次为：添加文件、搜索文件、 从硬盘打开、折叠某个目录，隐藏。⑤ 编辑器-文件内容编辑 ：就是编写代码的地方。⑥ 调试器 ：定制版的Chrome开发者工具，用于调试：页面结构，CSS，抓包，AppData等。⑧ 编译相关 ：可以选择编译选项：普通编译，添加编译模式(直接打开特定页面)或通过二维码编译，点击编译即可进行编译。点击预览可以生成二维码，然后在手机上查看效果。⑨ 真机调试 ：同样是生成二维码扫描看效果，不过多了调试功能。⑩ 切后台 ：切换场景值。⑪ 清缓存 ：就是清理缓存，可以清理：数据，文件，授权，网络，登录状态。⑫ 版本管理 ：小程序项目Git版本管理。⑬ 详情 ：项目的相关信息，项目配置，以及域名信息配置。⑭ 页面路径 ：当前页面的路径，场景值和页面参数。关于微信开发者工具的界面的简单介绍就到这里，接着我们来说下小程序的基本结构。0x4、觉得饭很好吃（基本结构）1、四类文件小程序一般由下面四类文件组成：json ： 配置文件 ，页面和开发工具的相关配置。wxml ： 模板文件 ，堆砌控件形成小程序页面，有点像HTML。wxss ： 样式文件 ，调整页面样式，有点像CSS。js ： 脚本逻辑文件 ，完成一些逻辑处理操作，比如发起请求，事件触发等。简单点说： wxml里写页面，wxss里写样式，js里写逻辑，json里改配置。2、三个重要的配置文件① 开发工具配置 ：「 project.config.json 」开发者工具的统一配置，界面设置以及云函数相关，更多可见：developers.weixin.qq.com/miniprogram…② 小程序全局配置 ：「 app.json 」比如：页面路径列表，默认窗口，底部tab栏，网络超时等，更多可见：developers.weixin.qq.com/miniprogram…③ 单页面配置 ：「 page.json 」使用「 同名.json 」文件来对本页面的窗口表现进行配置，会覆盖app.json的window中相同的配置项，更多可见：developers.weixin.qq.com/miniprogram…0x5、就像我给你们拉面一样很开心（小程序初体验）接着，通过编写一个简陋的页面，来体验下小程序的开发~1、全局窗口配置先来配置一波小程序的窗口，要求如下：蕾姆蓝背景，白色文字，菜单栏显示抠腚男孩打开 app.json 文件，添加下述配置：\"navigationBarBackgroundColor\": \"#5A78EA\",\r\n\"navigationBarTitleText\": \"抠腚男孩\",\r\n\"navigationBarTextStyle\": \"white\"\r\n复制代码编译运行后，效果如图所示：2、编写简陋页面接着开始着手编写这个简陋页面，定义一个顶部头像，新建 asserts 文件夹，用来存放 静态资源文件 ，接着往 index.wxml 中添加一个image控件：<image src=\"../../assets/codingboy.png\" />\r\n复制代码编译运行后，效果如图所示：3、调整样式可以，很骚气，但是作为头像有点太大了，调整一下它的样式，打开 index.wxss ，添加一个类选择器：.user-icon-image{\r\n    width: 150rpx;\r\n    height: 150rpx;\r\n}\r\n复制代码image标签设置一下这个选择器：<image class=\"user-icon-image\" src=\"../../assets/codingboy.png\"/>\r\n复制代码编译运行后，效果如图所示：Tips：这里还可以利用 宽高自适应 的，即：设置宽度，保持原图宽高比不变，高度自动变化。为image标签设置属性：mode=\"widthFix\"，效果是一样的。4、获取用户授权这里有个需求：如果已经获取了用户授权，就显示微信头像，否则显示这个默认头像在 index.wxml 中添加一个用于获取用户昵称和头像的按钮：<button open-type=\"getUserInfo\">获取头像昵称</button>\r\n复制代码编译运行后，点击按钮会弹出一个授权对话框：点击允许即可完成授权，但是授权的信息并没有保存起来。5、获取授权信息授权是授权了，但是信息却没有拿到，button有一个属性： bindgetuserinfo ，当用户点击按钮时，会返回获取到的用户信息，我们在这里绑定一个保存用户信息的回调函数，在 index.js 中添加下述代码直接把授权信息给打印出来：getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    console.log(app.globalData.userInfo)\r\n}\r\n复制代码接着 index.wxml 中绑定一下：<button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">获取头像昵称</button>\r\n复制代码清一波缓存，然后重新编译，点击获取头像昵称的按钮，对话框授权，在Console可以看到用户的相关信息：6、保存授权信息授权信息可以获取到了，接下来我们通过定义一个变量的方式把信息保存下来，另外，我们还需要定义一个变量作为是否获得授权信息的标记，用于控制显示微信头像还是默认头像，打开 index.js 添加下述代码：Page({\r\n    data: {\r\n        userInfo: {}, //用户信息\r\n        hasUserInfo: false, //是否有用户信息\r\n    }\r\n})\r\n复制代码修改下getUserInfo函数，修改后的代码如下：getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    this.setData({\r\n        userInfo: e.detail.userInfo,\r\n        hasUserInfo: true\r\n    })\r\n}\r\n复制代码另外授权信息，其实可以通过 app.globalData.userInfo 获取，在程序初始化的时候在onLoad函数中去获取下，添加一个 onLoad 函数，代码如下：onLoad: function () { \r\n    if (app.globalData.userInfo) {\r\n        this.setData({\r\n            userInfo: app.globalData.userInfo,\r\n            hasUserInfo: true\r\n         })\r\n    }\r\n}\r\n复制代码7、wx:if，wx:elif，wx:else判断结构接着在 index.wxml 中通过 wx:if 判断是加载默认图还是微信头像，代码如下：<block wx:if=\"{{!hasUserInfo}}\">\r\n    <image class=\"user-icon-image\" src=\"../../assets/codingboy.png\" mode=\"widthFix\" />\r\n    <button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">获取头像昵称</button>\r\n</block>\r\n<block wx:else>\r\n    <image class=\"user-icon-image\" src=\"{{userInfo.avatarUrl}}\" mode=\"widthFix\" />\r\n    <text>{{userInfo.nickName}}</text>\r\n</block>\r\n复制代码运行后可以看到显示的是微信用户昵称和头像，如图：接着调整一下样式，外层包一个view，接着让这两个东西居中：.user-icon-wrapper{\r\n  display:flex;                 \r\n  justify-content: center; \r\n  flex-direction: column;\r\n  align-items: center\r\n} \r\n复制代码有点挤，顶部加padding，图片圆角，调整背景颜色， index.wxss 添加：page {\r\n  background: #f6f6f6;\r\n  position: relative;\r\n  padding-top: 30rpx;\r\n  color: #323233;\r\n}\r\n\r\n.user-icon-wrapper{\r\n  display:flex;                 \r\n  justify-content: center; \r\n  flex-direction: column;\r\n  align-items: center\r\n} \r\n\r\n.user-icon-image{ \r\n  width: 150rpx;\r\n  border-radius: 20rpx;\r\n}\r\n\r\n.authorize-button{\r\n  margin-top: 30rpx;\r\n}\r\n\r\n.nickname-text{\r\n  margin-top: 30rpx;\r\n}\r\n复制代码接着修改下 index.wxml ，代码如下：<!-- index.wxml -->\r\n<block wx:if=\"{{!hasUserInfo && canIUse}}\">\r\n    <view class=\"user-icon-wrapper\">\r\n        <image class=\"user-icon-image\" src=\"../../assets/codingboy.png\" mode=\"widthFix\" />\r\n        <button class=\"authorize-button\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">\r\n            获取头像昵称\r\n        </button>\r\n    </view>\r\n</block>\r\n<block wx:else>\r\n    <view class=\"user-icon-wrapper\">\r\n        <image class=\"user-icon-image\" src=\"{{userInfo.avatarUrl}}\" mode=\"widthFix\" />\r\n        <text class=\"nickname-text\">{{userInfo.nickName}}</text>\r\n    </view>\r\n</block>\r\n复制代码运行结果如下：8、单机版天气预报(wx:for循环结构)只是点击授权然后获取头像显示，感觉好low，跟官方的例子有啥区别，加个天气预报的东东吧，这里采用的天气接口是： 魅族天气API ，接口地址如下：aider.meizu.com/app/weather…访问看下，返回的数据如下：开发初期，为了提高开发的效率，会先造假数据，前后端约定好接口的返回数据。由后端写一个接口返回假数据，或者前端本地跑一个mock服务器，也可以直接写死在程序中。这里为了方便，直接写死，在 index.js 的page中添加下述数据：city: '深圳',\r\nprovince: '广东省',\r\nrealtime: {\r\n  img: \"1\",\r\n  sD: \"72\",\r\n  sendibleTemp: \"25\",\r\n  temp: \"25\",\r\n  time: \"2019-04-17 16:35:08\",\r\n  wD: \"西南风\",\r\n  wS: \"1级\",\r\n  weather: \"多云\",\r\n  ziwaixian: \"N/A\"\r\n},\r\nindexes: [{\r\n  abbreviation: \"uv\",\r\n  alias: \"\",\r\n  content: \"辐射较弱，涂擦SPF12-15、PA+护肤品。\",\r\n  level: \"弱\",\r\n  name: \"紫外线强度指数\"\r\n},\r\n{\r\n  abbreviation: \"pp\",\r\n  alias: \"\",\r\n  content: \"建议用露质面霜打底，水质无油粉底霜，透明粉饼，粉质胭脂。\",\r\n  level: \"控油\",\r\n  name: \"化妆指数\"\r\n},\r\n{\r\n  abbreviation: \"yd\",\r\n  alias: \"\",\r\n  content: \"天气较好，且紫外线辐射不强，适宜户外运动。\",\r\n  level: \"适宜\",\r\n  name: \"运动指数\"\r\n},\r\n{\r\n  abbreviation: \"xc\",\r\n  alias: \"\",\r\n  content: \"洗车后，只能保持1天车辆清洁，不太适宜洗车。\",\r\n  level: \"较不适宜\",\r\n  name: \"洗车指数\"\r\n},\r\n{\r\n  abbreviation: \"ct\",\r\n  alias: \"\",\r\n  content: \"天气较热，衣物精干简洁，室内酌情添加空调衫。\",\r\n  level: \"热\",\r\n  name: \"穿衣指数\"\r\n},\r\n{\r\n  abbreviation: \"gm\",\r\n  alias: \"\",\r\n  content: \"感冒较易发生，干净整洁的环境和清新流通的空气都有利于降低感冒的几率，体质较弱的童鞋们要特别加强自我保护。\",\r\n  level: \"较易发\",\r\n  name: \"感冒指数\"\r\n}],\r\n复制代码接着index.wxml添加控件：<button style=\"margin-top: 50rpx\">刷新天气</button>\r\n<view style=\"height: 100rpx;flex-direction:column;\">\r\n  <text>城市：{{city}}</text>\r\n  <text>省：{{province}}</text>\r\n  <text>天气：{{realtime.weather}}</text>\r\n  <text>温度：{{realtime.temp}}°C</text>\r\n  <text>湿度：{{realtime.sD}}</text>\r\n  <text>更新时间：{{realtime.time}}</text>\r\n  <text>风向：{{realtime.wD}}</text>\r\n  <text>风力：{{realtime.wS}}</text>\r\n</view>\r\n复制代码运行结果如下：文字都堆叠到一起了，设置下样式：.message-text {\r\n  margin-left: 15rpx;\r\n  display: block;\r\n  margin-top: 50rpx;\r\n}\r\n复制代码接着每个text设置下message-text这个类选择器，运行效果如下：接着把indexes里的数据也显示出来，通过 wx:for 循环生成结点：<block wx:for=\"{{indexes}}\" wx:for-item=\"item\" wx:key=\"key\">\r\n    <text>{{item.name}}：{{item.abbreviation}}</text>\r\n    <text>{{item.content}}</text>\r\n    <text>{{item.level}}</text>\r\n</block>\r\n复制代码运行后结果如下：文本都堆在一起密密麻麻的，写个样式：.indexes-text {\r\n  display: block;\r\n  margin-left: 15rpx;\r\n}\r\n\r\n.indexes-text-last{\r\n  display: block;\r\n  margin-left: 15rpx;\r\n  padding-bottom: 50rpx;\r\n}\r\n复制代码运行结果如下：9、网络版天气预报(wx.request发起请求)单机版的就完成了，接着通过 wx.requests 来请求接口，实现一个网络版的天气预报。index.js中新增刷新天气的函数：refreshWeather: function () {\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://aider.meizu.com/app/weather/listWeather',\r\n      data: {\r\n        'cityIds': '101280601'\r\n      },\r\n      method: 'GET',\r\n      headers: {\r\n        'User-Agent:': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36',\r\n        'Host': 'aider.meizu.com'\r\n      },\r\n      success: function (res) {\r\n        if (res.data.code == 200) {\r\n          that.setData({\r\n            weather: res.data.value[0]\r\n          })\r\n        }\r\n      },\r\n    })\r\n  },\r\n复制代码接着按钮设置下点击时触发这个网络请求：<button style=\"margin-top: 50rpx\" bindtap=\"refreshWeather\">刷新天气</button>\r\n复制代码因为接口是http的，还需要微信开发者工具点开 详情 ，勾选下：接着点击运行，点击刷新天气，在Network选项卡可以看到发出的请求信息：然后咧，微信小程序的视图层和逻辑层类似MVVM模式，逻辑层只需对数据对象更新，即可改变视图层的数据数据显示，这里setData后，对应的控件也会改变。到此一个非常简单的天气预报小程序就完成了。小结本节介绍了微信小程序开发环境的搭建，开发一个简易天气小程序体验了一波微信小程序，相信读者对于微信小程序有个基本的了解了，接下来的章节会慢慢细化一些知识点，比如控件定位，UI相关，请求封装，开源开发框架WePY等等，敬请期待~如果本文对你有所帮助，欢迎留言，点赞，转发 素质三连，谢谢:kissing_heart:~"}
{"title": "微信小程序拉起登录的操作 ", "author": "Rolan", "pub_time": "2019-3-26 00:37", "content": "第一步，前端调用wx.login()接口把token数据请求过来，第二部，把tok嗯发送到总计的服务器，然后进行微信openid和assession的获取第三部验证session是否过期，过期重新拉起授权登录，未过期直接进行下一步第四部：getUserInfo，获取用户的个人信息，// pages/authorize/authorize.js\r\nPage({\r\n  data:{\r\n    img:'',\r\n    pri:'',\r\n    city:'',\r\n    nickname:''\r\n  },\r\n  login(){\r\n    wx.login({\r\n      success:res=>{\r\n        // 可以获取code\r\n        console.log(res)\r\n        wx.request({\r\n          url: 'http://flyxin.com.cn/login.php', // 仅为示例，并非真实的接口地址\r\n          data: {\r\n            code:res.code\r\n          },\r\n          header: {\r\n            'content-type': 'application/json' // 默认值\r\n          },\r\n          success(res) {\r\n            console.log(res)\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  checksession(){\r\n    wx.checkSession({\r\n      success:function(red){\r\n        console.log(red,'未过期');\r\n        wx.showToast({\r\n          title: '登录未过期',\r\n        })\r\n      },\r\n      fail:function(res){\r\n        console.log(res)\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '登录已过期',\r\n        })\r\n        // 再次调用login\r\n\r\n      }\r\n    })\r\n  },\r\n  // 获取用户信息\r\n  info(){\r\n    wx.getUserInfo({\r\n      success:(res)=>{\r\n        console.log(res.userInfo)\r\n        var json=res.userInfo;\r\n        this.setData({\r\n          nickname:json.nickName,\r\n          pri: json.province,\r\n          city:json.city,\r\n          img:json.avatarUrl\r\n        })\r\n      }\r\n    })\r\n  }\r\n}) 希望自己写的东西能够对大家有所帮助！谢谢"}
{"title": "Taro 小程序实战技术摘要 ", "author": "Rolan", "pub_time": "2019-3-25 00:17", "content": "Taro 小程序实战技术摘要React一个用于构建用户界面的 JAVASCRIPT 库。采用声明范式，可以轻松描述应用。通过对DOM的模拟，最大限度地减少与DOM的交互。组件复用，能够很好的应用在大项目的开发中。单向响应的数据流，使得开发变得清晰。TaroTaro 是一套遵循 React 语法规范的 多端开发 解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动小程序、H5、React-Native 等）运行的代码。TypeScriptTypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。GitFlowgit-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作VsCode + 插件Visual Studio Code（简称VsCode）是一个轻量且强大的代码编辑器，支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。以及更多丰富便捷的插件库。代码检查代码检查主要是用来发现代码错误、统一代码风格。在 JavaScript 项目中，我们一般使用 ESLint 来进行代码检查。它通过插件化的特性极大的丰富了适用范围，搭配 typescript-eslint-parser 之后，甚至可以用来检查 TypeScript 代码。TSLint 与 ESLint 类似，不过除了能检查常规的 js 代码风格之外，TSLint 还能够通过 TypeScript 的语法解析，利用类型系统做一些 ESLint 做不到的检查。为什么需要代码检查有人会觉得，JavaScript 非常灵活，所以需要代码检查。而 TypeScript 已经能够在编译阶段检查出很多问题了，为什么还需要代码检查呢？因为 TypeScript 关注的重心是类型的匹配，而不是代码风格。当团队的人员越来越多时，同样的逻辑不同的人写出来可能会有很大的区别：缩进应该是四个空格还是两个空格？是否应该禁用 var？接口名是否应该以 I 开头？是否应该强制使用 === 而不是 ==？这些问题 TypeScript 不会关注，但是却影响到多人协作开发时的效率、代码的可理解性以及可维护性。下面来看一个具体的例子：let myName = 'Tom';\r\n\r\nconsole.log(`My name is ${myNane}`);\r\nconsole.log(`My name is ${myName.toStrng()}`);\r\nconsole.log(`My name is ${myName}`)\r\n\r\n// tsc 报错信息：\r\n//\r\n// index.ts(3,27): error TS2552: Cannot find name 'myNane'. Did you mean 'myName'?\r\n// index.ts(4,34): error TS2551: Property 'toStrng' does not exist on type 'string'. Did you mean 'toString'?\r\n//\r\n//\r\n//\r\n// eslint 报错信息：\r\n//\r\n// /path/to/index.ts\r\n//   3:27  error  'myNane' is not defined         no-undef\r\n//   5:38  error  Missing semicolon               semi\r\n//\r\n// ✖ 2 problems (2 errors, 0 warnings)\r\n//   1 errors, 0 warnings potentially fixable with the `--fix` option.\r\n//\r\n//\r\n//\r\n// tslint 报错信息：\r\n//\r\n// ERROR: /path/to/index.ts[5, 36]: Missing semicolon下图表示了 tsc, eslint 和 tslint 能覆盖的检查：上图中， tsc , eslint 和 tslint 之间互相都有重叠的部分，也有各自独立的部分。虽然发现代码错误比统一的代码风格更重要，但是 当一个项目越来越庞大，开发人员也越来越多的时候，代码风格的约束还是必不可少的 。UI设计协作蓝湖是一款设计图共享平台,帮助互联网团队管理设计图。蓝湖可以自动生成标注,与团队共享设计图,展示页面之间的跳转关系。支持从Sketch一键分享、在线讨论、自动为设计图生成标注，而且只需简单几步就能将设计图变成一个可以点击的演示原型，支持分享给同事，让他也可以在手机中查看设计效果。蓝湖已经成为新一代产品设计的工作方式。直接在线编辑和预览的方式，让产品与设计师的交流反馈得到极大的提升，同时开发者可以得到详细的标注，以及不同平台的支持提示，使得开发效率变快。框架搭建全局配置文件（ps: 截图中的秘钥配置和配置都是测试，大家看一下大概配置就好）通过 Config 文件，区分开发、生产环境，动态的编译代码后，使用相应正确的配置，还有小程序不同的标识，同时保存了微信、支付宝、神策等第三方平台的密钥。统一的配置文件能让后期更好维护。通过Swagger文档生成API文件在需求评审后，前后端人员将会在一起制定接口结构，这点体现在Swagger文档之中，随后前端使用脚手架工具把Swagger文档yaml文件生成可调用的fetch请求文件集成到项目，避免了手动编写接口代码的错误风险，这点前提是对Swagger有严格的要求，基于接口规范编码。放入Swagger文件执行转化命令sudo api-cli MINI js得到api请求配置文件代码中使用开发适配在自动生成api请求文件后，需要更改一些配置才能在于小程序之中运行,所以我们做了以下适配：小程序请求Taro.request 适配 微信、支付宝小程序请求全局请求头添加userToken 用来识别用户身份信息branch 后端服务路径分支名称clientType 小程序平台名称version 当前程序版本测试调试工具baseURL 更改全局请求地址branch 更改请求头分支名clear 清除缓存数据以上适配让小程序的可拓展、可维护性得到大大提高。资源优化由于官方的限制，一个小程序的代码包括资源文件大小不能超过2M，在真实迭代情况下，随着业务的增加，功能的改变，2M大小对我们来说可能很快就要超出，我们采用以下方案：代码分包此方式是官方推荐的方法，通过把不同业务代码资源分离出来，主要的功能先行下载运行，如：主页商铺列表、商铺详情、订单列表等，而相对低频的功能可以后续异步下载运行，如：退款列表/详情、会员权益说明等，但是官方还是限制了最多为4个分离包，每个大小限制也为2M。图片资源远端保存这是一种常用的包大小减小体积的方案，超过30k大小的文件放入阿里云OSS资源仓库保存，代码中使用远程路径方式引入，但同时要考虑首屏渲染的平衡代码压缩代码运行终究是机器做的事，只是顺便让我们程序员看看，所以在我们编译代码的同时对其js、css等文件内容压缩，去除运行中不必要的注释、打印、多余空格等，同时用编译环境控制是否开启压缩功能，这样平时开发调试的时候可以关闭压缩功能，更好的进行调试、测试、排错。线上代码报错日志 fundebug在真实线上的环境，难免会遇到很隐性的BUG，通过集成fundebug的方式。来检测到线上程序报错的信息。fundebug 可以快速复现出错场景，记录出错前点击、页面跳转、网络请求，控制台打印等信息。通过 Source Map 还原生产环境中的压缩代码，提供完整的堆栈信息，准确定位到出错源码，帮助我们快速修复Bug。一键还原出错代码数据采集Sensors（神策分析）针对企业级客户的自助式用户行为分析平台。实时数据采集、建模、分析，驱动市场营销、产品优化、用户运营、管理监控。神策官方提供了小程序的SDK，但是我们需要配合产品提供的事件和逻辑，自己编写埋点。埋点事件模型和抽象类// 点击优惠券列表\r\nexport interface IClickCouponMerchantList extends IClickCoupon {}\r\n\r\n// 点击兑换优惠券\r\nexport interface IClickToExChange {}\r\n\r\n// 使用商品\r\nexport interface IConsume extends IOrder, IMerchant, ICommodity {}\r\n\r\n// 点击小程序首页banner\r\nexport interface IClickMiniBanner {}\r\n\r\n// ... \r\n\r\nexport interface IStatisEvents {\r\n  ClickCouponMerchantList?: (params: IClickCouponMerchantList) => any\r\n  ClickToExChange?: (params: IClickToExChange) => any\r\n  Consume?: (params: IConsume) => any\r\n  ClickMiniBanner?: (params: IClickMiniBanner) => any\r\n  // ...\r\n}数据采集封装interface IStatis extends IStatisEvents {\r\n  sensors: any;\r\n  init: () => any;\r\n  defaultTrack: (eventName: string, eventParams: any) => any;\r\n}\r\nconst loadStatisEvent = (statis: Statis): IStatis => {\r\n  return new Proxy(statis, {\r\n    get(obj, prop) {\r\n      const target = obj[prop];\r\n      if (obj.hasOwnProperty(prop)) {\r\n        return target;\r\n      }\r\n      if (!SaConfig.enable) {\r\n        return noop;\r\n      }\r\n      if (typeof target === \"function\") {\r\n        return target.bind(obj);\r\n      }\r\n      // 默认采集\r\n      return obj.defaultTrack.bind(obj, prop);\r\n    }\r\n  });\r\n};\r\n\r\nclass Statis implements IStatis {\r\n  public sensors: any;\r\n\r\n  constructor(sensors) {\r\n    this.sensors = sensors;\r\n  }\r\n\r\n  init() {\r\n    this.sensors.init();\r\n  }\r\n\r\n  defaultTrack(eventName: string, eventParams: any) {\r\n    this.sensors.track(eventName, eventParams);\r\n  }\r\n\r\n  Login(id: string) {\r\n    this.sensors.login(id);\r\n  }\r\n\r\n  RegisterApp(params: IRegisterApp) {\r\n    const param = Object.assign(\r\n      {\r\n        platform: AppConfig.CLENT_TYPE\r\n      },\r\n      params\r\n    );\r\n    this.sensors.registerApp(param);\r\n  }\r\n}\r\n\r\nconst sa = loadStatisEvent(new Statis(sensors_));事件采集结语微信/支付宝 双端发布，虽说是一套代码，但是做了满多兼容，主要在两端授权用户信息不太一样，需要封装统一，再一个是样式写的不规范，两端表现的也不一致。swagger API文件生成 可调用的 fetch 文件、统一请求封装和自定义请求头、处理多端授权用户信息等，还有很多技术和流程的细节，容我后续再跟大家慢慢讲解。"}
{"title": "提高一些开发小程序和云函数的效率 ", "author": "Rolan", "pub_time": "2019-3-27 00:34", "content": "一开始开发小程序都是使用微信自带的开发工具，由于起初对小程序不是很熟悉，也没觉得开发效率低，但渐渐熟悉之后发现，用自带的开发工具效率实在太低了。吐槽下自带的开发工具主要有两点吧，第一个是可写代码的区域少的可怜。调试器、模拟区不隐藏的话，编辑区域是屏幕的一半都不到。而且没办法分屏，外接显示屏也派不上用场。另外一个就是智能提示部分了，也是少的可怜。用惯了宇宙第一神器 Visual Studio ,编码能力已经退化了，没有提示有时候效率真的比较低。至于其他的一些小问题其实还好。推荐使用vscode现在 vscode 真的越来越强大了，体验也相当好，推荐使用。简单的装几个插件就可以轻松编写小程序代码了。首先安装 minapp ,支持微信小程序标签、属性的智能补全，并且提示中包含文档内容（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）。然后安装 wxml ,这款插件用于将wxml代码进行高亮显示，并且提供代码格式化的功能，可将代码格式化为较易阅读的样式。有这两个插件其实基本已经够用，其实还有很多基于小程序的插件，看个人喜好和习惯了。这样双屏也有用武之地了，一个屏利用 vscode 进行编码，另一个屏用来调试和查看效果(将编辑器隐藏)，效率提升很多。本地调试云函数有用到云函数的话建议先在本地调试后再上传，效率会高很多，现在云函数上传一次的时间时快时慢，同时在云端调试只能打日志，不能断点调试。小程序的云函数本质也是nodejs，所以在本地确保有相应的node环境之后，写个简单的调用的test文件就可以进行本地调试了。举个简单例子，有一个对应的云函数 index.js ，为了方便直接在对应目录下新建一个 test.js 文件，如下截图：test.js相关代码如下,简单调用：const cloud = require('wx-server-sdk')\r\ncloud.init({ secretId: '', secretKey: '', env: '' })\r\n\r\nvar exports_mode = require('./index.js')\r\nvar event = { }\r\nexports_mode.main(event, null)需要注意的是如果使用到 云数据 或者 云存储 的话，需要引用 wx-server-sdk ,而要初始化该模块需要到腾讯云上申请相应的秘钥。申请地址：https://console.cloud.tencent.com/cam/capi最后通过 npm install 下载对应的依赖，然后就可以直接 F5 调试啦，可以看到截图已经进入到云函数方法的断点处了。总结前段时间一直很忙，现在终于可以挤出点时间继续搞我的小程序了，持续分享中。"}
{"title": "TypeScript 自动编译脚本的实现 ", "author": "Rolan", "pub_time": "2019-3-28 00:13", "content": "引言万法归一， TypeScript 似有一统前台的趋势。微信小程序也引入了 TypeScript ，我们也要跟随技术主流将小程序从 JavaScript 切换到 TypeScript 。微信小程序现在没之前那么火爆了，但仍我我们跨平台开发的明智。其实不管微信有小程序，支付宝、百度、 QQ 浏览器都相继上线小程序，还有手机联盟( vivo 、 oppo 、华为等多家手机公司共同成立的)创建的快应用也狠狠地抄了腾讯一把，代码简直一模一样。小程序最火爆的时期要属去年清明节，小游戏横空出世，同时带火了小程序，周围的朋友都在用小程序、小游戏。记得当时还利用几天的假期时间，调用豆瓣开发的 api ，开发了一款名为豆瓣电影的小程序。可惜，最终没能上架，拒绝原因是该应用属于信息服务类的程序，禁止个人开发者申请。当时是使用 ZanUI 开发的，经历了一个自己玩的小项目，也算对微信小程序有了一个全面的理解。需求使用 TypeScript 重搭一次微信小程序的架子，今后的小程序使用 TypeScript 开发。实现基础工作建项目和之前没什么区别，就是在语言一栏需要选择 TypeScript 。其实使用 TypeScript 和 JavaScript 对于微信开发者工具来说没什么区别，用 TypeScript 也是编译成 JavaScript 再执行。这里不推荐直接使用微信开发者工具编写 TypeScript ，因为没有提示，我是采用 WebStorm安装微信插件进行开发，然后打开微信开发者工具查看效果的。一路顺风，没什么问题。在 UI 框架选型上，我选择了 ColorUI 。为什么选择这个呢？虽然之前用过的 ZanUI 也很好用，也很全，但我第一眼看到 ColorUI 的时候，我被惊艳到了。再点进去组件查看，我猜想这个作者一定有过很多次的手机端页面开发经验，真的是每一个组件你都能用到，为作者点个赞。缺点就是文档不完善，但我认为这个 Demo 写得足够优秀了，直接 clone 下来，想要的都有了，剩下的就是改改字。希望以后当我有时间的时候，能给 ColorUI 的文档提交一些 Pull Request ，也算是感谢作者写出了这么好的 UI 库并分享给大众。非常好用，只需要去框架里粘一粘代码，漂亮的原型就出来了，挺好用的。自动编译写的时候遇到了点问题，就是编译的问题。微信开发者工具执行的是 js 文件，我编写的是 ts 文件，假设我修改了 ts 文件，我想看到修改后的效果，我需要手动编译，这就不优雅了。我们用过的 grunt 、 ng ，哪个不是自动编译、自动刷新？既然小程序没提供，那只能另谋生路了。突然想起 ng 不也是 nodejs 里的命令吗？它能监听文件自动编译，我为什么不试试看呢？nodenode.js 不是一个框架，而是一个高效的 JavaScript 运行环境。所以， node.js 脚本说到底就是一个 js 文件，没什么难的。在微服务中，我们常用 node.js 搭建反向代理服务器，其性能与 nginx 部分伯仲。自动化脚本新建脚本 yunzhi.js ，代码很简单，相信有编程基础的人都能看懂，这里就不再赘述。const exec = require('child_process').exec;\r\nconst watch = require('node-watch');\r\n\r\nwatch(['app.ts', 'specs', 'pages'], { recursive: true }, function(evt, name) {\r\n    if (name.split('.').pop() === 'ts') {\r\n        console.log('监听到TypeScript文件改动，重新编译中...');\r\n        exec('npm run compile');\r\n    }\r\n});\r\n\r\nconsole.log('云智TypeScript自动编译脚本已成功运行...');总结不了解，就以为很难，其实当你勇敢地迈出第一步的时候，问题就已经解决。因为你觉得自己行，你真的就行。"}
{"title": "微信，支付宝小程序实现原理概述 ", "author": "Rolan", "pub_time": "2019-3-25 00:35", "content": "微信小程序项目结构上图为微信小程序的项目结构，pages下面包含了小程序中的每一个页面，每一个页面由页面结构，页面样式，页面配置和逻辑代码四部分组成。页面结构页面结构文件为index.wxml，通过微信自定义的标签来写。页面逻辑页面逻辑通过JavaScript来书写。页面样式表类似CSS文件，来定义页面内元素的样式。页面配置页面内的权限等配置信息。微信小程序的技术选型小程序的定位特点是轻，快，针对这两个特点，在技术选型上，微信进行了一些考量。渲染界面的技术用纯客户端原生技术来渲染缺点：无法动态打包，动态下发。用纯 Web 技术来渲染缺点：如果我们用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题，这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。介于客户端原生技术与 Web 技术之间的，互相结合各自特点的技术来渲染从渲染底层来看，PhoneGap与微信 JS-SDK 是类似的，它们最终都还是使用浏览器内核来渲染界面。而 RN 则不同，虽然是用 Web 相关技术来编写，同样是利用了 JavaScript 解释执行的特性，但 RN 在渲染底层是用客户端原生渲染的。我们选择类似于微信 JSSDK 这样的 Hybrid 技术，即界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。同时，每个小程序页面都是用不同的WebView去渲染，这样可以提供更好的交互体验，更贴近原生体验，也避免了单个WebView的任务过于繁重。微信没有选择RN的原因RN 所支持的样式是 CSS 的子集，会满足不了 Web 开发者日渐增长的需求，而对 RN 的改造具有不小的成本和风险。RN 现有能力下还存在的一些不稳定问题，比如性能、Bug等。RN 是把渲染工作全都交由客户端原生渲染，实际上一些简单的界面元素使用 Web 技术渲染完全能胜任，并且非常稳定。RN 存在一些不可预期的因素，比如之前出现的许可协议问题原生组件的渲染方式在安卓则是往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法。开发者插入一个原生组件，一般而言，组件运行的时候被插入到 DOM 树中，会调用客户端接口，通知客户端在哪个位置渲染一块原生界面。在后续开发者更新组件属性时，同样地，也会调用客户端提供的更新接口来更新原生界面的某些部分。Web渲染带来的问题与解决提供干净纯粹的JavaScript执行环境由于JavaScript的灵活性和浏览器的功能丰富，会导致很多不可控的隐私，因此，微信提供了一个单纯的JS执行环境，通过对于其中的控件也进行了自定义。因此完全采用这个沙箱环境不能有任何浏览器相关接口，只提供纯JavaScript 的解释执行环境，那么像HTML5中的ServiceWorker、WebWorker特性就符合这样的条件，这两者都是启用另一线程来执行 JavaScript。但是考虑到小程序是一个多 WebView 的架构，每一个小程序页面都是不同的WebView 渲染后显示的，在这个架构下我们不好去用某个WebView中的ServiceWorker去管理所有的小程序页面。得益于客户端系统有JavaScript 的解释引擎（在iOS下是用内置的 JavaScriptCore框架，在安卓则是用腾讯x5内核提供的JsCore环境），我们可以创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码，也就是我们前面一直提到的逻辑层。而界面渲染相关的任务全都在WebView线程里执行，通过逻辑层代码去控制渲染哪些界面，那么这一层当然就是所谓的渲染层。这就是小程序双线程模型的由来。标签自定义为了防止标签定义带来的一些问题，微信自定义了一套标签语言，WXML，这套标签语言经过编译之后，最终会生成Html。渲染与逻辑的分离上面是小程序的渲染技术的选型，在选型之后，由于渲染和逻辑不再同一个浏览器执行，一个在纯JS环境中，一个通过WebView渲染，因此小程序的运行环境分成渲染层和逻辑层，WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型如图所示。数据驱动视图变化在开发UI界面过程中，程序需要维护很多变量状态，同时要操作对应的UI元素。随着界面越来越复杂，我们需要维护很多变量状态，同时要处理很多界面上的交互事件，整个程序变得越来越复杂。通常界面视图和变量状态是相关联的，如果有某种“方法”可以让状态和视图绑定在一起（状态变更时，视图也能自动变更），那我们就可以省去手动修改视图的工作。小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。通过setData把msg数据从“Hello World”变成“Goodbye”，产生的JS对象对应的节点就会发生变化，此时可以对比前后两个JS对象得到变化的部分，然后把这个差异应用到原来的Dom树上，从而达到更新UI的目的，这就是“数据驱动”的原理。事件的处理UI界面的程序需要和用户互动，例如用户可能会点击你界面上某个按钮，又或者长按某个区域，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户。由于WebView现在具备的功能只是进行渲染，因此对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理。事件的派发处理，具备事件捕获和冒泡两种机制。通过native传递给JSCore，通过JS来响应响应的事件之后，对Dom进行修改，改动会体现在虚拟Dom上，然后再进行真实的渲染。数据通信小程序是基于双线程模型，那就意味着任何数据传递都是线程间的通信，也就是都会有一定的延时。这不像传统Web那样，当界面需要更新时，通过调用更新接口UI就会同步地渲染出来。在小程序架构里，这一切都会变成异步。异步会使得各部分的运行时序变得复杂一些。比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来，如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作。因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信。逻辑层向视图层发送页面数据（data和setData的内容），视图层向逻辑层反馈用户事件。通过Json的方式进行数据的传递，提高性能的方式就是减少交互的数据量。缓存机制小程序宿主环境会管理不同小程序的数据缓存，不同小程序的本地缓存空间是分开的，每个小程序的缓存空间上限为10MB，如果当前缓存已经达到10MB，再通过wx.setStorage写入缓存会触发fail回调。小程序的本地缓存不仅仅通过小程序这个维度来隔离空间，考虑到同一个设备可以登录不同微信用户，宿主环境还对不同用户的缓存进行了隔离，避免用户间的数据隐私泄露。由于本地缓存是存放在当前设备，用户换设备之后无法从另一个设备读取到当前设备数据，因此用户的关键信息不建议只存在本地缓存，应该把数据放到服务器端进行持久化存储。支付宝小程序支付宝小程序简介支付宝小程序的实现和微信小程序的实现方式大致是相同的，因此这里主要针对两者的差异性的地方。支付宝小程序目录结构支付宝小程序业务架构图在渲染引擎上面，支付宝小程序不仅提供 JavaScript+Webview 的方式，还提供 JavaScript+Native 的方式，在对性能要求较高的场景，可以选择 Native 的渲染模式，给用户更好的体验。运行时架构小程序编程模型是分为多个页面，每个页面有自己的 template、CSS 和 JS，实际在运行的时候，业务逻辑的 JS 代码是运行在独立的 JavaScript 引擎中，每个页面的 template 和 CSS 是运行在各自独立的 webview 里面，页面之间是通过函数 navigateTo 进行页面的切换。每个 webview 里面的页面和公共的 JavaScript 引擎里面的逻辑的交互方式是通过消息服务，页面的一些事件都会通过这个消息通道传给 JavaScript 引擎运行环境，这个运行环境会响应这个事件，做一些 API 调用，可调到客户端支付宝小程序提供的一些能力，处理之后会把这个数据再重新发送给对应的页面渲染容器来处理，把数据和模板结合在一起来，在产生最终的用户界面。支付宝小程序虚拟机隔离通常的做法是在 WebView 里面运行 render 的代码，然后另起一个线程运行 serviceworker，当 serviceworker 需要更新 dom 的时候把事件和数据通过 messagechannel 发送给 render 线程来执行，当业务需要传递到 render 层数据量较大，对象较复杂时，交互的性能就会比较差，因此针对这种情况我们提出一个优化的解决方案。该方案将原始的 JS 虚拟机实例 (即 Isolate) 重新设计成了两个部分：Global Runtime 和 Local Runtime。Global Runtime 部分是存放共享的装置和数据，全局一个实例。Local Runtime 是存放实例自身相关的模块和私有数据，这些不会被共享。在新的隔离模型下，webview 里面的 v8 实例就是一个 Local Runtime，worker 线程里面的 v8 实例也是一个 Local Runtime，在 worker 层和 render 层交互时，setData 对象的会直接创建在 Shared Heap 里面，因此 render 层的 Local Runtime 可以直接读到该对象，并且用于 render 层的渲染，减少了对象的序列化和网络传输，极大的提升了启动性能和渲染性能。首屏速度优化由于小程序启动是受到生命周期的控制，从 onLaunch -> onLoad -> onShow -> onReady -> 用户操作 -> 离开首页这个流程，在这个过程中的任意一个环节都有可能被客观或者主观的原因打断，也就有可能导致保存的离线页面不准确，在启动的时候给用户呈现错误的页面。所以对于首页离线缓存渲染的效果，保存页面的时机很重要，我们提供让开发者可以配置的时机，配置的时机有两个：渲染完成和离开首页前。对于渲染完成就是首页渲染完成，用户还未执行任何的操作前把页面保存下来作为离线缓存的页面。离开首页前就是指用户在首页执行了一系列的操作后，跳转到其他页面前用户看到的页面保存下来作为离线缓存的页面。对于闪屏问题发生的场景是因为缓存页面和真实渲染的页面是分离的，是两个独立的页面，缓存页面是静态的页面，真实的页面是通过 js 动态创建的页面，所以常规的做法就是当真实页面创建完成后替换缓存的页面，这样的情况下就会发生闪屏。针对这个问题，我们是采用虚拟 dom 来解决，在加载缓存页面的时候把缓存页面放入初始的虚拟 dom 里面，真实页面创建后产生的虚拟 dom 跟缓存页面的虚拟 dom 进行 dom diff，把变化的内容通过 patch 传给浏览器内核，渲染对应的页面，这样就可以只更新局部有变化的页面内容，避免了整个页面的更新，也保证内容的准确性和实时性。支付宝采用UC浏览器内核优势1. 图片内存 ：针对低端机，做了更严格的图片缓存限制，在保持性能体验的情况下，进一步限制图片缓存的使用；多个 webview 共用图片缓存池；全面支持 webp、apng 这种更节省内存和 size 的图片格式。2. 渲染内存 ：Webview 在不可见的状态下，原生的内存管理没有特殊处理，UC 内核会将不可见 webview 的渲染内存释放；渲染内存的合理设置与调优，避免滚动性能的下降和占用过多内存。3. JS 内存 ：更合理地处理 v8 内存 gc，在启动时延时执行 full gc，避免影响启动的耗时。4. 峰值内存管理 ：系统在内存紧张时，会通知内核，UC 内核能够在系统低内存时释放非关键内存占用的模块，避免出现 oom，也避免过度释放带来的渲染黑块；在部分 oom 的情况，规避原生内核主动崩溃的逻辑，在内存极低的情况，部分功能不可用，而不是崩溃。对我们的启示小程序存储管理增加小程序的存储，包括内存和磁盘，可以缓存部分数据，增加页面直出速度。同时对于磁盘的管理，按照小程序账号双重维度进行划分。第三方业务接入能力限制在支持第三方的接入之后，按照现有方式将会导致对于安全和第三方的行为完全不可控，可以参考微信，支付宝方式采用自定义标记语言的方式对标记语言做限制，并提供纯净的JS环境来进行JS环境的执行，WebView只负责渲染。首屏速度参考支付宝方案，在加载的时候，现将老的页面呈现给用户，然后在新页面完成之后，计算差值，再进行显示。Native绘制结合Native绘制采用通过JS和Native通信的方式，将Native控价加入到布局的制定区域。网络请求发送托管网络请求等全部交由Native托管，更好的控制网络请求，监控网络请求。"}
{"title": "Taro + 云开发实战|日语用例助手 ", "author": "Rolan", "pub_time": "2019-3-27 00:11", "content": "原创： Evont前言小程序开放了云开发能力，为开发者提供了一个可以很快速构建小程序后端服务的能力，作为一名对新技术不倒腾不快的前端，对此也是很感兴趣的。Taro 是凹凸实验室推出的，基于React 语法规范的多端开发解决方案，较之于mpvue或者wepy，由于年轻，坑还比较多，但是很适合我这种倾向用React 开发的人。我结合这两者，使用cheerio和superagent 抓取了用例.jp， 开发了一个《日语用例助手》。入门踩坑1.云开发篇1.1 环境搭建云开发可以通过下列两种方式创建： 1.使用quickstart（云开发快速启动模版）创建项目：这种方式会在目录下同时创建名为miniprogram ，带有云开发调用范例的小程序基础模板和名为cloudfuntions 的存放云函数的目录, 由此即可开始全新的项目。2.基于现有的小程序使用云开发：在小程序目录下创建一个文件夹作为你的云函数目录，然后在project.config.json 文件中新增字段\"cloudfunctionRoot\": \"你的云函数目录\"，即可以在微信开发者工具中看到目录的图标变成了云，在此目录下创建云函数即可；1.2 云函数编写使用微信开发者工具在云函数目录下创建一个云函数时，会根据名称创建一个目录，目录中包含一个index.js 和package.json。在小程序中使用如下方式调用云函数：wx.cloud.callFunction({\r\n    name: '云函数名称',\r\n    data: {\r\n      key1: 'value1',\r\n      key2: 'value2'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((e) => {\r\n    console.log(e);\r\n});复制代码index.js的入口函数如下所示：//云函数入口函数\r\nexports.main = async (event, context) => {\r\n    // 参数获取在event 中获取，如使用上面的调用函数后，获取data使用 event.key1、event.key2即可\r\n    const { key1, key2 } = event;\r\n    return { query: { key1, key2 } }\r\n}复制代码每个云函数可视为一个单独的服务，如果需要安装第三方依赖，只需要在该目录点击右键，选择 在终端中打开, 并 npm install依赖即可。需要注意的是，每个云函数都是独立的，所需要的依赖都需要在对应的目录下进行 npm install，但这样就会使得项目变得十分庞大且不优雅。因此，接下来我介绍一下tcb-router。1.3 使用tcb-router管理路由tcb-router 是腾讯云团队开发的，基于 koa 风格的小程序·云开发云函数轻量级类路由库，主要用于优化服务端函数处理逻辑。使用tcb-router的方法很简单：const TcbRouter = require('tcb-router');\r\nexports.main = (event, context) => {\r\n    const app = new TcbRouter({ event });\r\n    app.router('路由名称', async (ctx) => {\r\n        //原有的event需要通过ctx._req.event 获取\r\n        const { param1, param2 } = ctx._req.event;\r\n        ctx.body = { key1: value1 };\r\n    });\r\n})复制代码此时小程序的调用方式也需要改成：wx.cloud.callFunction({\r\n    name: '云函数名称',\r\n    data: {\r\n      $url: '路由名称',\r\n      // 其他数据\r\n      param1: 'test1',\r\n      param2: 'test2'\r\n    },\r\n    success: res => {},\r\n    fail: err => {\r\n      console.error(`[云函数] [${action}] 调用失败`, err)\r\n          }\r\n})复制代码2.Taro篇2.1 环境搭建npm install -g @tarojs/cli\r\ntaro init myApp复制代码2.2 遇到的坑1.API支持不足由于Taro 对微信的一些新api 并没有支持到，比如使用云开发时需要用到 wx.cloud，Taro 并没有支持，但亲测是可以直接使用 wx 变量，但是会被eslint 提醒，看着十分不悦，可以在 .eslintrc 文件中增加以下代码：\"globals\": {\r\n  \"wx\": true\r\n},复制代码2.不能使用 Array#map 之外的方法操作 JSX 数组。3.不允许在 JSX 参数(props)中传入 JSX 元素(taro/no-jsx-in-props)。3.爬虫篇3.1 superagentsuperagent 是一个非常实用的http请求模块，用来抓取网页十分有用，使用也十分简单，以下是我在抓取 yourei.jp 时使用的代码：// const superagent = require('superagent');\r\n// ...\r\nfunction crawler(url, cb) {\r\n  return new Promise((resolve, reject) => {\r\n    superagent.get(url).set({\r\n      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36'\r\n    }).end(function (err, res) {\r\n      if (err) {\r\n        reject(err);\r\n        return;\r\n      }\r\n      resolve(res);\r\n    });\r\n  });\r\n}复制代码3.2 cheeriocheerio 是一个轻型灵活，类jQuery的对HTML元素分析操作的工具。在进行一些server端渲染的页面以及一些简单的小页面的爬取时，cheerio十分好用且高效。在使用 superagent 抓取了网页内容后，可以使用如下方式解析页面代码:// const cheerio = require('cheerio');\r\n    // ...\r\n    const result = crawler(apiUrl).then((res) => {\r\n      // 使用load 之后，$ 即可同jquery 一样使用选择器来选择元素了\r\n      const $ = cheerio.load(res.text);\r\n      const categories = [];\r\n      $('[data-toggle]').each((i, ele) => {\r\n        // 可以使用.text()、.html() 等方式获取元素的内容\r\n        categories.push($(ele).attr('href'));\r\n      });\r\n      return {\r\n        list: categories,\r\n      };\r\n    });复制代码总结1.Taro如果你是React 开发者，需要开发多端小程序，或者原有React 项目想迁移到小程序，Taro 是个不错的选择，但还有很多坑没有填好，希望它的发展越来越好。2.云开发如果你是个人开发者，想尝试小程序开发又不想或者难以自己搭建服务器，云开发是个好选择，容易上手且十分敏捷。"}
{"title": "小程序Checkbox全选 ", "author": "Rolan", "pub_time": "2019-3-28 00:32", "content": "这是我写的第一篇文章，若有不对，请大家指正，多谢！这篇文章主要讲小程序的全选。接触小程序没有太久，我想每实现一个功能就在这里记录一次，以此巩固。其实实现很简单，在每个选择集合中加入一个isCheck字段，默认是false（未选中），然后wxml页面中循环list时，给checkbox加一个属性：checked='{{item.isCheck}}'；接下来是js，在全选按钮上绑定事件：checkAll。js中首选要得到所有的list（var list = that.data.Data）;然后for循环list，在循环中让每一个isCheck取反；之后，在循环外setData我们上文声明的list：that.setData({Data:list}),意思就是把我们操作过的list重新赋给Data，页面会重新渲染；废话不多说，以下是代码：  wxml:\r\n    <view class='atte-title'>\r\n      <view class='odb-title-left'>选择参会人</view>\r\n      <checkbox value='全选' bindtap='checkAll'></checkbox>\r\n    </view>\r\n    <checkbox-group bindchange='change'>\r\n      <block wx:for='{{Data}}' wx:key>\r\n        <checkbox value='{{item.name}}' checked='{{item.isCheck}}' class='check-item' style='background:#fff;'>\r\n          <view class='check-box'>\r\n            <view class='atte-ava'>\r\n              <image src='{{item.Image}}'></image>\r\n            </view>\r\n            <view class='atte-name'>{{item.name}}</view>\r\n            <view class='atte-point'>\r\n              <image src='/images/Articles/point.png'></image>\r\n            </view>\r\n            <view class='atte-pro'>{{item.partyBranchJobTypeName}}</view>\r\n          </view>\r\n        </checkbox>\r\n      </block>\r\n    </checkbox-group>  // 全选\r\n  checkAll: function (e) {\r\n    var that = this\r\n    console.log(that.data.Data)\r\n    var list = that.data.Data  \r\n    for (var i = 0; i < list.length;++i){\r\n      list[i].isCheck = !list[i].isCheck || false;  //list[i].isCheck默認是false,这里是取反\r\n    }\r\n    that.setData({\r\n      Data:list,         //将取反后的集合setData到我们的Data\r\n    })\r\n  },小白一枚，水平很差，请多指教；"}
{"title": "微信小程序之onLaunch与onload异步问题 ", "author": "Rolan", "pub_time": "2019-3-29 00:19", "content": "目录导航：\r\n\r\n所述问题：\r\n解决方法：\r\n方法实现：\r\n\r\nApp.js方法实现：\r\nindex.js实现：\r\n总结：\r\n \r\n \r\n所述问题：\r\n　　 \r\n前端时间开发了一个微信小程序商城项目，因为这个项目我们的需求是进入小程序就通过wx.login({}) \r\n这个api进行用户登录，获取系统后台的用户基本信息。再此之前，一直以为微信小程序中的App.js 中onLaunch \r\n（小程序初始化完成执行该方法）方法比其他页面的的 onload \r\n方法要先执行。那么问题就来了，我每次进入小程序首页的时候有时候会先执行onlaunch方法，有时又会先执行首页的onload的方法，最后经过确定，在微信小程序中这两个方法并没有执行先后的顺序，因为他们都是异步执行的。当然开发过微信小程序的开发者都知道微信请求数据都是异步执行的，如在同一个onload写两个请求数据的方法，它不一定会按照先后顺序去执行，这就是传说中的异步地狱了。\r\n解决方法：\r\n　　当然，我既然知道这个执行顺序是由于微信小程序的异步执行请求原因导致的。我们可以使用Promise \r\n来解决异步编程问题啦。我的解决方法是，首先我是在app.js \r\n中定义了一个全局方法，用来登录小程序请求用户信息的接口，每次进入首页的时候先判断我是否已有用户信息缓存，假如不存在那么请求app.js中的全局方法进行数据获取。在这里我就不详细介绍Promise \r\n的基本用法了，因为阮一峰已经将的非常详细了，大家可以点击查看【http://es6.ruanyifeng.com/#docs/promise#Promise-all】。\r\n方法实现：\r\nApp.js方法实现：\r\n\r\nApp({\r\nonLaunch: function() {\r\nconsole.log('App Launch')\r\n//不在这里默认请求\r\n},\r\n/**\r\n* 定义全局变量\r\n*/\r\nglobalData: {\r\nopenid: '', //用户openid\r\nuserId: '', //用户编号\r\n},\r\n/**\r\n* 用户登录请求封装(解决onlaunch和onload执行顺序问题)\r\n*/\r\nuserLogin: function() {\r\nvar that = this;\r\n//定义promise方法\r\nreturn new Promise(function(resolve, reject) {\r\n// 调用登录接口\r\nwx.login({\r\nsuccess: function(res) {\r\nif (res.code) {\r\nconsole.log(\"用户登录授权code为：\" + res.code);\r\n//调用wx.request请求传递code凭证换取用户openid，并获取后台用户信息\r\nwx.request({\r\nurl: 'https://www.xxxx.xxx.api', // 后台请求用户信息方法【注意，此处必须为https数字加密证书】\r\ndata: {\r\ncode: res.code //code凭证\r\n},\r\nheader: {\r\n'content-type': 'application/json' // 默认值\r\n},\r\nsuccess(res) {\r\nconsole.log(res.data)\r\nif (res.data.errcode == 0) {\r\n//获取用户信息成功\r\nthat.globalData.openid = res.data.openid;\r\nthat.globalData.userId = res.data.UserId;\r\n//存入session缓存中\r\nwx.setStorageSync(\"userId\", that.globalData.userId)\r\nconsole.log(that.globalData.userId);\r\nconsole.log(that.globalData.openid);\r\n//promise机制放回成功数据\r\nresolve(res.data);\r\n} else {\r\nreject('error');\r\n}\r\n},\r\nfail: function(res) {\r\nreject(res);\r\nwx.showToast({\r\ntitle: '系统错误'\r\n})\r\n },\r\ncomplete: () => {\r\n\r\n} //complete接口执行后的回调函数，无论成功失败都会调用\r\n})\r\n} else {\r\nreject(\"error\");\r\n}\r\n}\r\n})\r\n})\r\n}});\r\n\r\nindex.js实现：\r\n\r\nconst app=getApp();//初始化app.js\r\npage({\r\n\r\nonLoad: function (option) {\r\nvar that = this;\r\nlet UserId = wx.getStorageSync(\"userId\");\r\nconsole.log(\"进入首页的用户编号为：\" + UserId);\r\nif (UserId == '') {\r\napp.userLogin().then(res => {\r\nconsole.log(\"promise回调后的数据：\");\r\nconsole.log(res);\r\nif (res.errcode == 0) {\r\n//把首页需要请求的数据接口都提取到一个自定义方法中\r\nthat.GetData();\r\n}\r\n})\r\n}\r\nelse\r\n{\r\n//用户缓存存在\r\nthat.GetData();\r\n}\r\n\r\n}\r\n,\r\nGetData()\r\n{\r\n//需要用到用户编号换取商品信息的接口\r\n\r\n}\r\n})\r\n\r\n \r\n总结：\r\n　　当然解决异步回调的方法有很多种，不过我在这里只说我认为好用的一种，大家有什么想法也可以一起分享学习。"}
{"title": "微信小程序~云开发的实现的一个社区 Demo ", "author": "Rolan", "pub_time": "2019-3-28 00:48", "content": "官方介绍文档开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。目前提供三大基础能力支持：云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理实现的功能由于是 Demo 所以有些功能没实现完整，后续时间充足会补充完整。用户登录后将用户信息保存在云数据库，方便下次读取发布话题成功后将数据保存在云数据库，在首页列表页面可读取展示获取云数据库列表展示本地图片获取和预览等广场显示用户发布的内容管理员发布的一些教程（这块想通过banner 来展示，在后续版本会添加，目前就先这样了…）实现分析可点击下边的博文链接：微信小程序~云开发Demo 实现数据的添加、查询和分页实现发布发布图文水平图片的滑动显示（效果不是很好，有时间会改为九宫格实现）发布页面效果如下：实现分析可点击下边的博文链接：微信小程序~云开发 Demo 实现发表页面我的1、显示用户的登录信息主要就是调用小程序接口，获取用户的微信公开信息进行展示2、用户的收藏列表获取数据库中的收藏列表进行展示3、发布历史在发布页面，当发布成功将数据存到发布历史表中，需要的时候获取该表的数据进行展示4、邀请好友调用小程序的分享接口，直接分享给微信群，或者个人5、产品意见一个类似于发布页的页面，实现思路和发布页实现是一样的。实现的效果实现分析可点击下边的博文链接：微信小程序~新版授权用户登录例子可能存在的一些问题1、其他用户发布的内容，有时候显示不出来？将数据库的权限设置为全部人可见2、发布内容之后返回首页没有自动刷新？在广场首页 onShow 的时候获取数据库的数据进行展示3、clone 源码后运行不起来？需要在自己的云数据库中创建对应的表源码地址：方便的话点个 Star，多谢~https://github.com/dongxi346/doughnut---------------------"}
{"title": "小程序性能优化的几点实践技巧 ", "author": "Rolan", "pub_time": "2019-4-2 00:21", "content": "大家好，我叫张文轩，这是我的第6篇分享我们都知道，性能的好坏直接影响用户的体验。本文首先论述下如何评判一个小程序页面的性能情况，之后通过具体的案例重点讲解下几点实践技巧，最后再讲讲key值在渲染一个列表时发挥了一个怎么样的作用，以此来论述为啥key值对性能提升有帮助。评判小程序页面性能由于小程序开发环境的特殊性，我们不能像普通网页那样通过chrome开发工具或者一些成熟的性能测试工具（例如Lighthouse）来了解一个页面的性能，但微信官方提供了一个性能评分的工具，点击这里可以查看工具详情。体验评分是一项给小程序的体验好坏打分的功能，它会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。后面我会以一个实际的例子来展示如何通过该工具来优化页面性能，我们先看下我们页面优化前的一个评分情况。存在setData的数据过大我们的功能里面有个滚动到底部加载的功能，优化前我们的做法是这样的<!--只阐述逻辑，非真实代码-->\r\n\r\n// 1: 初始一个list，存储列表数据\r\ndata = startList\r\n// 2: 监听滚动事件，滚动到底部获取新数据，并追加到list尾部,最后重新setData\r\nonReachBottom:()=>{\r\n    const {list} = this.data\r\n    fetchNewData().then((res)=>{\r\n        list.push(res.list);\r\n        this.setData({list})\r\n    }\r\n}\r\n复制代码我估计大部分人面对长列表滚动的时候，一开始的处理方式都是这样的，如果数据不多，只有几页可能不会太暴露问题，如果页数过多，几十页甚至上百页的情况，list的数据会越来越大，每次setData的数据就会越来越多，因而每次页面重新渲染的节点就会越来越多，从而导致滚动到后面，加载越来越慢。另外，由于小程序的视图渲染层和数据逻辑处理层是分开的，不是在同一个线程上面的，从用户触发页面交互，到处理数据逻辑，最后层现页面，数据到视图是需要传输的，因而小程序本身对数据大小也有限制，不能超过1M。setData数据路径怎么解决呢？小程序setData里面的key支持数据路径的写法，比如let o = obj;\r\nthis.setData({\r\n    'o.属性'：value\r\n})\r\n\r\n或者\r\nlet a = array;\r\nthis.setData({\r\n    'array[0].text':value\r\n})\r\n复制代码所以我们可以通过数据路径的写法，来将数据分批的传输到视图层中，减少一次性setData的数据大小。具体写法如下// 1.通过一个二维数组来存储数据\r\nlet feedList = [[array]];\r\n\r\n// 2.维护一个页面变量值，加载完一次数据page++\r\nlet page = 1\r\n\r\n// 3.页面每次滚动到底部，通过数据路径更新数据\r\nonReachBottom:()=>{\r\n    fetchNewData().then((newVal)=>{\r\n        this.setData({\r\n            ['feedList[' + (page - 1) + ']']: newVal,\r\n        })\r\n    }\r\n}\r\n// 4.最终我们的数据是[[array1],[array2]]这样的格式，然后通过wx:for遍历渲染数据\r\n复制代码存在短时间内发起太多图片请求（图片懒加载）这个应该好理解，就是渲染页面时，一次性发送了过多的图片请求，导致了同一时间发起了过多的http请求，http连接是非常耗时的，尤其是一次性发起这么多，并且一次性发起的http链接也是有限制的，比如chrome浏览器就限制一次性最多6个。所以在渲染页面时，不在视图范围内的图片我们不加载，只有元素出现在视图范围内了，再渲染。常规的做法是，通过 getBoundingClientRect() 获取元素的位置，然后与页面滚动位置比较，如果出现在视图内，就将 img 显示。这种方式有2个问题getBoundingClientRect()方法调用本身容易引起页面重排监听滚动事件本身就频繁触发，虽然可以通过节流的方式来减少，但还是容易增加无谓代码处理IntersectionObserver其实，微信提供了 IntersectionObserver 对象。IntersectionObserver 对象，用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见通过这个api我们不用再主动去监听元素位置了，在页面渲染一开始，通过这个api指明需要监听的元素，系统会自动去监听了元素位置。let data = list;\r\n\r\n<img class=\"img-{{index}}\" wx:for=\"{{data}}\"></img>\r\n\r\ndata.forEach((item,index)=>{\r\n    this.createIntersectionObserver().relativeToViewport.observe(`.img-${index}`,res=>{\r\n        if (res.intersectionRatio > 0){\r\n            this.setData({\r\n                item.imgShow:true\r\n            })\r\n        }\r\n    })\r\n})\r\n\r\n复制代码intersectionRatio值大于0，说明元素出现在视图中了，重新setData数据，显示图片组件。存在图片太大而显示区域过小这个问题就是指图片尺寸太大了，而页面上我们显示的尺寸又太小了，图片尺寸大，请求图片就越慢，导致页面渲染速度下降。CDN图片处理对于页面里面的图片，最好都把图片存储在cdn服务器上，一个是能充分利用cdn缓存来加快请求速度，另外一个就是cdn上能够将图片进行一定的处理，比如裁剪。我司就是通过cdn来响应图片处理，然后请求图片时告诉cdn服务器需要什么要的尺寸图片，由cdn服务器响应对应尺寸图片。key值在列表渲染中的作用key值在列表渲染的时候，能够提升列表渲染性能，为什么呢？首先得想想小程序的页面是如何渲染的，主要分为以下几步：将wxml结构的文档构建成一个vdom虚拟数页面有新的交互，产生新的vdom数，然后与旧数进行比较，看哪里有变化了，做对应的修改（删除、移动、更新值）等操作最后再将vdom渲染成真实的页面结构key值的作用就在第二步，当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。key值如果不指明，默认会按数组的索引来处理，因而会导致一些类似input等输入框组件的值出现混乱的问题。相关测试代码可以查看：wxkey可以看到不加key,在数组末尾追加元素，之前已渲染的元素不会重新渲染。但如果是在头部或者中间插入元素，整个list被删除重新渲染，且input组件的值还出现了混乱，值没有正常被更新添加key，在数组末尾、中间、或者头部插入元素，其它已存在的元素都不会被重新渲染，值也能正常被更新因而，在做list渲染时，如果list的顺序发生变化时，最好增加key，且不要简单的使用数组索引当做key。最后看看我们的成果：体验码：希望今天我的分享能对您优化小程序页面有一定的启示，创造出性能更好更流畅的页面。最后如果喜欢我的文章，欢迎点击关注，我会不定期的分享自己的一些所看所想，和大家一起成长，持续学习。"}
{"title": "微信小程序npm安装第三方包（引用第三方插件avtv f2.js） ", "author": "Rolan", "pub_time": "2019-4-2 00:41", "content": "由于我要使用微信小程序引用图标插件，就以AntV F2插件为例；AntV F2官网：https://antv.alipay.com/zh-cn...需要准备：微信开发工具（必须支持npm功能）; node.js安装； npm基础知识；以下操作是node.js已经安装过了。1、先建好小程序模版。比如下图：然后使用dos命令打开这个当前的文件夹。比如下图：注意：dos命令打开的是小程序文件夹所放的路径。2、初始化指令如果是该文件夹第一次使用： 请先使用指令npm init(初始化指令);如下图：如果出现这种情况就对了，进行对这个文件夹进行编辑，也可以全部点击回车键，一路回车；3、再次安装npm install --production建议使用--production选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小如下图：4、安装微信小程序 F2 图表组件*npm i @antv/f2-canvas如下图：恭喜你，操作完以上这几步已经安装好依赖包。5、安装好依赖包之后，打开微信开发工具点击开发者工具顶部详情，勾选 使用npm模块，再点击菜单栏中工具下的构建npm即可运行操作图第一步：点击详情，勾选npm模块操作图第二步：工具菜单栏打开，点击构建npm点击构建npm后，会出现：完成后会出现：一个文件夹为miniprogram_npm恭喜自己吧，npm安装第三方包已经完成；以下就是在小程序中代码的撰写：1.index.json;2.index.wxml;3.index.wxss;#myCanvas {\r\n  width: 100%;\r\n  height: 300px;\r\n}\r\n4.index.js;let chart = null;\r\nfunction initChart(canvas, width, height, F2) {\r\n  const data = [\r\n    { year: '1951 年', sales: 38 },\r\n    { year: '1952 年', sales: 52 },\r\n    { year: '1956 年', sales: 61 },\r\n    { year: '1957 年', sales: 145 },\r\n    { year: '1958 年', sales: 48 },\r\n    { year: '1959 年', sales: 38 },\r\n    { year: '1960 年', sales: 38 },\r\n    { year: '1962 年', sales: 38 },\r\n  ];\r\n  chart = new F2.Chart({\r\n    el: canvas,\r\n    width,\r\n    height\r\n  });\r\n\r\n  chart.source(data, {\r\n    sales: {\r\n      tickCount: 5\r\n    }\r\n  });\r\n  chart.tooltip({\r\n    showItemMarker: false,\r\n    onShow(ev) {\r\n      const { items } = ev;\r\n      items[0].name = null;\r\n      items[0].name = items[0].title;\r\n      items[0].value = '$ ' + items[0].value;\r\n    }\r\n  });\r\n  chart.interval().position('year*sales');\r\n  chart.render();\r\n  return chart;\r\n}\r\nPage({\r\n  data: {\r\n    opts: {\r\n      onInit: initChart\r\n    }\r\n  },\r\n  onLoad(){\r\n  },\r\n  onReady() {\r\n  }\r\n})\r\n看右侧是不是已经出来柱形图了，如果需要做其他图表，去官网让选择就行了，官网的例子比较多，选择做自己需要的就行了。"}
{"title": "小程序自定义导航栏适配（完美版） ", "author": "Rolan", "pub_time": "2019-4-2 00:27", "content": "1、发现问题小程序页面自定义导航栏功能已经开放有些日子了(还不知道这个功能的可以先 >>了解一下 )，这极大的提升了小程序开发的自由度，相信不少小伙伴已经使用过这个功能，同时也相信不少小伙伴在此功能开发过程中踩过同样的一些坑：机型多如牛毛：自定义导航栏高度在不同机型始终无法达到视觉上的统一；调皮的胶囊按钮：导航栏元素（文字，图标等）怎么也对不齐那该死的胶囊按钮；各种尺寸的全面屏，奇怪的刘海屏，简直要抓狂。同样的，这些问题也是小灰经历过的。但是小灰相信，办法总比问题多，于是开始了自己的探究：2、一探究竟为了搞明白到底该怎么去适配，老规矩，我先翻了一波官方文档，还别说，官方还真有这么一段介绍了相关细节， >>详情点击 ：从图中分析，我们可以得到如下信息：Android跟iOS有差异，表现在顶部到胶囊按钮之间的距离差了6pt胶囊按钮高度为32pt， iOS和Android一致这。。。，好像并没有什么L用啊？？这仅仅是普通屏幕为参照的，ipx， 安卓全面屏完全没介绍。沉着冷静，我们接着分析：胶囊按钮到状态栏下边缘这块距离，好像是固定的？安卓这个图，好像有点奇怪？导航栏分为 状态栏+标题栏？如果车两个条件成立，那我们的问题是不是就解决了80%了？那么我们来论证一下：第一个问题：胶囊按钮到状态栏下边缘的距离是不是固定的？很简单，我们写一个状态栏，通过wx.getSystemInfoSync().statusBarHeight设置高度为了好测量，我们设置状态栏背景色为深色js代码：var sysinfo = wx.getSystemInfoSync();\r\nthis.setData({ \r\n     statusBarHeight:sysinfo.statusBarHeight \r\n})wxml代码：<view class=\"status-bar\" style=\"height:{{statusBarHeight}}px\"></view>wxss代码：.status-bar{\r\n    background: rgb(141, 71, 71);\r\n }效果图（iPhone6）：效果图（iPhoneX）：效果图（安卓）：是不是有点眉目了？是的，从截图可以看出，iOS是一致的，但是Android好像有所差别。那究竟距离是多少？我们用神器（微信截图）来量一量：Android：iOS：可以看出，iOS胶囊按钮与状态栏之间距离为：6px， Android为8px，并且经过测量，iOS各机型，Android各机型结果一致（由于篇幅原因，就不一一展示截图了，有兴趣的可以自行测量）第二个问题：导航栏分为 状态栏+标题栏？通过对第一个问题的论证，很明显能看出来确实是这样的。并且通过第一个问题的测量结果以及官方提供的数据，我们可以对标题栏高度进行计算：导航栏高度 = 胶囊按钮高度 + 状态栏到胶囊按钮间距 * 2Android导航栏高度 = 32px + 8px * 2 = 48pxiOS导航栏高度 = 32px + 6px * 2 = 44px*注：由于胶囊按钮是原生组件，为表现一直，其单位在个系统都为px，所以我们的自定义导航栏各个高度的单位都必需是px（切记不能用rpx），才能完美适配。3、解决问题通过上述分析，相信小伙伴们都能有一个解决问题的思路了，在上代码之前，小灰再给大家画一下重点：写自定义导航组件的时候，需要将组件结构一分为二：状态栏 + 标题栏状态栏高度可通过wx.getSystemInfoSync().statusBarHeight获取标题栏高度：安卓：48px，iOS：44px单位必需跟胶囊按钮一致，用px话不多说，上代码( gitHub地址 )：js：Component({   \r\n   properties: {        \r\n    background: {            \r\n        type: String,            \r\n        value: 'rgba(255, 255, 255, 1)'        \r\n    },        \r\n    color: {            \r\n        type: String,            \r\n        value: 'rgba(0, 0, 0, 1)'        \r\n    },        \r\n    titleText: {            \r\n        type: String,            \r\n        value: '导航栏'        \r\n    },        \r\n    titleImg: {            \r\n        type: String,            \r\n        value: ''        \r\n    },        \r\n    backIcon: {            \r\n        type: String,            \r\n        value: ''        \r\n     },        \r\n    homeIcon: {            \r\n        type: String,            \r\n        value: ''        \r\n    },        \r\n    fontSize: {            \r\n        type: Number,            \r\n        value: 16        \r\n    },        \r\n    iconHeight: {            \r\n        type: Number,            \r\n        value: 19       \r\n    },        \r\n    iconWidth: {            \r\n        type:Number,            \r\n        value: 58        \r\n    }    \r\n   },    \r\nattached: function(){        \r\n   var that = this;        \r\n   that.setNavSize();        \r\n   that.setStyle();    \r\n},    \r\n data: {\r\n    },    \r\nmethods: {        \r\n// 通过获取系统信息计算导航栏高度        \r\nsetNavSize: function() {            \r\nvar that = this                \r\n    , sysinfo = wx.getSystemInfoSync()                \r\n    , statusHeight = sysinfo.statusBarHeight                \r\n    , isiOS = sysinfo.system.indexOf('iOS') > -1                \r\n    , navHeight;            \r\nif (!isiOS) {                \r\n    navHeight = 48;            \r\n   } else {                \r\n    navHeight = 44;            \r\n}            \r\nthat.setData({                \r\n    status: statusHeight,                \r\n    navHeight: navHeight            \r\n  })        \r\n},        \r\nsetStyle: function() {            \r\n    var that  = this                \r\n    , containerStyle                \r\n    , textStyle                \r\n    , iconStyle;            \r\n    containerStyle = [                \r\n        'background:' + that.data.background                \r\n        ].join(';');            \r\n        textStyle = [                \r\n        'color:' + that.data.color,                \r\n        'font-size:' + that.data.fontSize + 'px'            \r\n        ].join(';');            \r\n        iconStyle = [                \r\n        'width: ' + that.data.iconWidth + 'px',                \r\n        'height: ' + that.data.iconHeight + 'px'            \r\n        ].join(';');            \r\n        that.setData({               \r\n             containerStyle: containerStyle,                \r\n             textStyle: textStyle,                \r\n             iconStyle: iconStyle            \r\n        })        },        \r\n        // 返回事件        \r\nback: function(){            \r\n    wx.navigateBack({                \r\n        delta: 1            \r\n    })            \r\n    this.triggerEvent('back', {back: 1})        \r\n},        \r\nhome: function() {            \r\n    this.triggerEvent('home', {});       \r\n }   \r\n }})wxml：<view class='nav' style='height: {{status + navHeight}}px'>    \r\n    <view class='status' style='height: {{status}}px;{{containerStyle}}'></view>                               <view class='navbar' style='height:{{navHeight}}px;{{containerStyle}}'>        <view class='back-icon' wx:if=\"{{backIcon}}\" bindtap='back'>                    <image src='{{backIcon}}'></image>       \r\n         </view>        \r\n    <view class='home-icon' wx:if=\"{{homeIcon}}\" bindtap='home'>            \r\n        <image src='{{homeIcon}}'></image>        \r\n    </view>        [链接描述][10]\r\n    <view class='nav-icon' wx:if=\"{{titleImg}}\">            \r\n    <image src='{{titleImg}}' style='{{iconStyle}}'></image>       \r\n     </view>\r\n            <view class='nav-title' wx:if=\"{{titleText && !titleImg}}\">\r\n                <text style='{{textStyle}}'>{{titleText}}</text>\r\n            </view>\r\n        </view>\r\n    </view>wxss：.navbar{\r\n    position: relative\r\n}\r\n.back-icon, .home-icon{\r\n    width: 28px;\r\n    height: 100%;\r\n    position: absolute;    \r\n    transform: translateY(-50%);    \r\n    top: 50%;    \r\n    display: flex;\r\n    }\r\n.back-icon{    \r\n    left: 16px;\r\n}\r\n.home-icon{    \r\n    left: 44px\r\n}\r\n.back-icon image{    \r\n    width: 28px;    \r\n    height: 28px;    \r\n    margin: auto;\r\n}\r\n.home-icon image{    \r\n    width: 20px;    \r\n    height: 20px;    \r\n    margin: auto;\r\n}\r\n.nav-title, .nav-icon{    \r\n    position: absolute;    \r\n    transform: translate(-50%, -50%);    \r\n    left: 50%;    \r\n    top: 50%;    \r\n    font-size: 0;    \r\n    font-weight: bold;\r\n}运行效果图：文字标题：图片标题：4、总结经过小灰的一番论证以及实践经验，最终总结出以上最终解决方案，但希望对小伙伴们有所帮助，如果小伙伴们觉得有用，记得给颗star哦 --> 点我 ，后续还会更新其他组件。如果大家有更好的方案或者觉得小灰的方案有问题，欢迎大家留言。"}
{"title": "踩坑小程序之can't read property 'offsetLeft' of undefined ", "author": "Rolan", "pub_time": "2019-4-3 00:23", "content": "↑开局一张图，故事全靠编↑从一个需求说起接触过小程序的同学应该都接触过这样一个需求：点击列表页的某一项，进入详情页。同样，今天我也遇到这样一个需求，其实很简单的一个需求，无非就是一个tap事件加dataset传参实现路由带参数跳转到详情页。以前开发小程序的时候，也处理过这样的需求，本来应该是得心应手的。不过，可能是Copy别人代码Copy得太多太久太深，也从来没自主去想过别人为什么这样写、换种方式要怎样写、为什么换种方式就会报错等等诸如此类的问题，更别说去熟读开源源码，甚至自己造轮子。有时候反思，自己入行这么多年了，资质依旧平平，别说造轮子，就算是把别人轮子拿过来安上，都能整出一堆B.U.G。就比如开头的图片上，用的是鹅厂旗下某著名公司的豪华套餐，居然被我用得翻车了！-- TypeError: Cannot read property 'offsetLeft' of undefined !!! 简直了，还是只能怪自己技术太low了。（图片来源于网络）提问的智慧自从朋友给了我一个SS的IP和密码，现在我一有问题就是直接google开干。在我看来，与其把问题抛到各种广告满天飞的技术群或者丢给朋友圈里边的大佬，倒不如自己先动手解决，哪怕是尝试了所有的答案，至少对问题会有更深的理解，以后面试中遇到面试官问您在项目中遇到过什么问题之类的，因为经过自己的一番搜索加实践，一般印象会深刻很多。反而别人直接告诉您答案的，可能您的成本更小，但是收获甚微。根据以往的经验，遇到问题，自己动手，是更接近答案的唯一出路。或许您在开发中，遇到了某些问题，您通过一些途径解决了这个问题，然后，您又记录了下来，后续您遇到同样的问题，应该是可以迎刃而解的。如果您还把解决方案分享出来了，您简直是在造福人类。后来者，托您的福，更快的解决了同样的问题。尝试方案1--重启开发者工具can't read property 'offsetLeft' of undefined #1132这是来自全球最大的同性交友网站GitHub上的一个issue，是由@yuwanlin 在一套遵循 React 语法规范的多端统一开发框架 Taro 中提出来的。根据当时的情境，是在微信开发者工具中删掉该小程序然后重新载入就解决了，大家给出的结论是微信小程序开发者工具的B.U.G。(注：该操作不会删除文件，请放心使用)--但是，我按照楼主的说法操作了一遍，结果然并卵，还是原来的B.U.G，还是一样的报错。该方案失败尝试方案2--外层加view自定义组件在首次点击后会报错@欧新志 这个小咯咯在2018-06-14向微信社区提出了类似的问题，他那个是自定义组件在点击之后出现了和我同款的B.U.G，而且也是存在嵌套子组件。评论中各位大神给出的答案是嵌套view。我也尝试了，试着加了一层view，但是问题依旧存在。不过我感还是和嵌套的子组件有关。于是，我各种尝试终于找到了一个方案。第一次滚动和点击的时候都有这个报错,下面是报错时的组件wxml<view class=\"wraper\" bindtap=\"onClick\"><slot></slot></view>如果换成下面这样就不报错了<view><view class=\"wraper\" bindtap=\"onClick\"><slot></slot></view></view>解决方案3--tap事件加在子组件里面原代码：<block wx:for=\"{{itemList}}\" wx:key=\"key\" wx:code=\"{{item}}\">\r\n      <view style=\"margin-top: 15px\" bindtap=\"toDetail\">\r\n        <dgd-preview>\r\n          <!--常规 preview-list 控件  -->\r\n          <view class=\"dgd-preview-list\"  data-item=\"{{item}}\">\r\n            <dgd-preview-item label=\"服务中心名称\" style=\"color:#000;\">\r\n              {{item.name}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约业务\" style=\"color:#000;\">\r\n              {{item.business}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约时间\" style=\"color:#000;\">\r\n              {{item.time}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约状态\" style=\"color:#000;\">\r\n              {{item.status}}\r\n            </dgd-preview-item>\r\n          </view>\r\n        </dgd-preview>\r\n      </view>\r\n    </block>修改之后：<block wx:for=\"{{itemList}}\" wx:key=\"key\" wx:code=\"{{item}}\">\r\n      <view style=\"margin-top: 15px\">\r\n        <dgd-preview>\r\n          <!--常规 preview-list 控件  -->\r\n          <view class=\"dgd-preview-list\" bindtap=\"toDetail\" data-item=\"{{item}}\">\r\n            <dgd-preview-item label=\"服务中心名称\" style=\"color:#000;\">\r\n              {{item.name}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约业务\" style=\"color:#000;\">\r\n              {{item.business}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约时间\" style=\"color:#000;\">\r\n              {{item.time}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约状态\" style=\"color:#000;\">\r\n              {{item.status}}\r\n            </dgd-preview-item>\r\n          </view>\r\n        </dgd-preview>\r\n      </view>\r\n    </block>只是把方法挂载到了不同的位置，确实截然不同的效果。看来接下来应该再研究一下小程序的组件。"}
{"title": "我们用5分钟写了一个跨多端项目 ", "author": "Rolan", "pub_time": "2019-4-3 00:13", "content": "cml 作为真正让一套代码运行多端的框架，提供标准的MVVM模式，统一开发各类终端。同时，拥有各端独立的 运行时框架(runtime) 、 数据管理(store) 、 组件库(ui) 、 接口(api)。此外， cml 在跨端 能力加强 、 能力统一 、 表现一致 等方面做了许多工作。今天，为了让大家的项目优雅升级，快速接入，给你带来一份丰盛的 cml迁移指南 ~源码地址： github.com/jalonjs/cml…目录结构和微信小程序一样， cml 包含一个描述整体程序的 app 和多个描述各自页面的 page 。小程序目录结构.\r\n├── components // 包含各个组件\r\n├── pages // 包含各个页面\r\n├── app.js // 包含各个组件\r\n├── app.js  // 应用启动入口\r\n├── app.json // 全局配置\r\n├── app.wxss // 全局样式\r\n└── project.config.json // 项目配置文件\r\n\r\n复制代码cml目录结构.\r\n├── dist // 各个端构建结果\r\n│   ├── alipay \r\n│   ├── baidu \r\n│   ├── wx \r\n│   ├── web  \r\n│   ├── weex \r\n│   └── config.json // 跨端配置map映射表\r\n├── node_modules // 第三方库\r\n├── mock // 模拟 接口数据 和 模板数据\r\n├── src  // 源代码开发目录\r\n│   ├── app // 应用启动入口\r\n│   ├── assets // 静态资源\r\n│   ├── components // 包含组件\r\n│   ├── pages  // 包含页面\r\n│   ├── store //数据管理\r\n│   └── router.config.json // 路由配置文件\r\n├── chameleon.config.js // 项目配置文件\r\n└── package.json // npm包配置文件\r\n\r\n复制代码如何修改配置在小程序项目里面，分为：可以在项目根目录使用 project.config.json 文件对项目进行配置。配置示例：{\r\n  \"miniprogramRoot\": \"./src\",\r\n  \"debugOptions\": {}\r\n}\r\n复制代码小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等配置示例：{\r\n  \"pages\": [\"pages/index/index\", \"pages/logs/index\"],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"Demo\"\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  }\r\n}\r\n复制代码每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json的 window 中相同的配置项。配置示例：{\r\n  \"navigationBarBackgroundColor\": \"#ffffff\",\r\n  \"navigationBarTextStyle\": \"black\",\r\n  \"navigationBarTitleText\": \"微信接口功能演示\",\r\n  \"backgroundColor\": \"#eeeeee\",\r\n  \"backgroundTextStyle\": \"light\"\r\n}\r\n复制代码同样，在 cml 项目里面，分为：cml —— 项目配置chameleon.config.js 为项目的配置文件，你可以定制化构建，比如是否带hash，是否压缩等等。配置示例：// 设置静态资源的线上路径\r\nconst publicPath = '//www.static.chameleon.com/static';\r\n// 设置api请求前缀\r\nconst apiPrefix = 'https://api.chameleon.com';\r\n// 合并配置\r\ncml.config.merge({\r\n  wx: {\r\n    build: {apiPrefix}\r\n  },\r\n  alipay: {\r\n    build: {apiPrefix}\r\n  },\r\n  baidu: {\r\n    build: {apiPrefix}\r\n  },\r\n  web: {\r\n    dev: {\r\n      hot: true,\r\n      console: true\r\n    },\r\n    build: {\r\n      publicPath: `${publicPath}/web`,\r\n      apiPrefix\r\n    }\r\n  },\r\n  weex: {\r\n    build: {\r\n      publicPath: `${publicPath}/weex`,\r\n      apiPrefix\r\n    }\r\n  }\r\n})\r\n\r\n复制代码cml —— 全局配置cml 项目 app 目录下的 app.cml 文件的 <script cml-type=\"json\" /> 用来对 cml 应用 进行全局配置，具有 跨端配置 和 差异化 的能力配置示例：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n    \"window\": {\r\n      \"navigationBarTitleText\": \"各个端共同title\",\r\n    },\r\n    \"permission\": {\r\n      \"scope.userLocation\": {\r\n        \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n      }\r\n    }\r\n  },\r\n  \"wx\": {\r\n    \"window\": {\r\n      \"backgroundTextStyle\":\"light\",\r\n      \"navigationBarBackgroundColor\": \"#fff\",\r\n      \"navigationBarTitleText\": \"差异化 title\",\r\n      \"navigationBarTextStyle\":\"black\"\r\n    }\r\n  },\r\n  \"baidu\": {\r\n    \"window\": {\r\n      \"backgroundTextStyle\": \"light\"\r\n    }\r\n  },\r\n  \"alipay\": {\r\n      \"window\": {\r\n        \"defaultTitle\": \"Chameleon\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码通过 usingComponents 配置 组件路径 注册引用的组件。配置示例：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n    \"usingComponents\": {\r\n      \"navi\": \"/components/navi/navi\",\r\n      \"navi-npm\": \"cml-test-ui/navi/navi\"\r\n    }\r\n  },\r\n  \"wx\": {\r\n  },\r\n  \"alipay\": {\r\n  },\r\n  \"baidu\": {\r\n  },\r\n  \"web\": {\r\n  },\r\n  \"weex\": {\r\n  }\r\n}\r\n</script>\r\n复制代码如何使用路由能力小程序配置路由app.json 配置项列表的 pages 字段用于指定小程序由哪些页面组成，每一项都对应一个页面的路径+文件名 信息。数组的第一项代表小程序的初始页面（首页）。新增/减少页面，需要对 pages 数组进行修改。如果项目有 pages/index/index.wxml 、 pages/logs/logs.wxml 两个页面，则需要在 app.json 中写{\r\n  \"pages\": [\"pages/index/index\", \"pages/logs/logs\"]\r\n}\r\n复制代码cml配置路由src/router.config.json 是路由的配置文件， cml 内置了一套各端统一的路由管理方式。相应有 cml 路由配置映射如下：{\r\n  \"mode\": \"history\",\r\n  \"domain\": \"https://www.chameleon.com\",\r\n  \"routes\":[\r\n    {\r\n      \"url\": \"/cml/h5/index\",\r\n      \"path\": \"/pages/index/index\",\r\n      \"mock\": \"index.php\"\r\n    },\r\n    {\r\n      \"url\": \"/cml/h5/logs\",\r\n      \"path\": \"pages/logs/logs\",\r\n      \"mock\": \"logs.php\"\r\n    }\r\n  ]\r\n}\r\n复制代码文件名不需要写文件后缀， cml 框架会自动去寻找对于位置的 .cml 文件进行处理。小程序使用路由打开新页面：调用 APIwx.navigateTo页面重定向：调用 APIwx.redirectTo页面返回：调用 APIwx.navigateBack打开另一个小程序：调用 API wx.navigateToMiniProgram返回到上一个小程序：调用 API wx.navigateBackMiniProgramcml使用路由依据统一资源索引URI，自适应打开不同环境同一路由PATH：打开新页面：调用 chameleon-apicml.navigateTo页面重定向：调用 chameleon-apicml.redirectTo页面返回：调用 chameleon-apicml.navigateBack打开另一个跨端应用：调用 chameleon-apicml.open返回到上一个跨端应用：调用 chameleon-apicml.close如何注册如何注册程序小程序注册程序在小程序项目里面， App() 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。示例代码App({\r\n  onLaunch(options) {\r\n    // Do something initial when launch.\r\n  },\r\n  globalData: 'I am global data'\r\n})\r\n复制代码cml注册程序示例代码<script>\r\nimport store from '../store/index.js'\r\nimport routerConfig from '../router.config.json';\r\n\r\nclass App {\r\n  data = {\r\n    store,\r\n    routerConfig\r\n  }\r\n  created(res) {\r\n  }\r\n}\r\n\r\nexport default new App();\r\n</script>\r\n复制代码细心的你会发现，小程序中 app.json app.js app.wxss 和 src/app/app.cml 的对应关系如下小程序 app.jscml项目 src/app/app.cmlapp.js<script></script>app.wxss<style></style>app.json<script cml-type=\"json\"></script>如何注册页面小程序注册页面在小程序项目里面， Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。示例代码：// index.js\r\nPage({\r\n  data: {\r\n    text: 'This is page data.'\r\n  },\r\n  changeText: function(e) {\r\n    // sent data change to view\r\n    this.setData({\r\n      text: 'CML'\r\n    })\r\n  }\r\n})\r\n复制代码cml注册页面示例代码<script>\r\nclass Index {\r\n  data = {\r\n    text: 'Chameleon'\r\n  }\r\n  methods = {\r\n    changeText: function(e) {\r\n      // sent data change to view\r\n      this.text = 'CML';\r\n    }\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码如何注册组件小程序注册组件在小程序项目里面， Component(Object) 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。示例代码Component({\r\n  properties: {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填）\r\n      value: '' // 属性初始值（可选）\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  },\r\n  data: {\r\n    text: ''\r\n  }, // 私有数据，可用于模板渲染\r\n\r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached() { }, \r\n  ready() { },\r\n  methods: {\r\n    onMyButtonTap() {\r\n      this.setData({\r\n        // 更新属性和数据的方法与更新页面数据的方法类似\r\n        text: 'wx'\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码cml注册组件示例代码<script>\r\nclass MyComponent {\r\n  props = {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填）\r\n      default: '' // 属性初始值（可选）\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  }\r\n  data =  {\r\n    text: ''\r\n  } // 私有数据，可用于模板渲染\r\n\r\n  beforeMount() {}\r\n  mounted() {}\r\n  methods = {\r\n    onMyButtonTap() {\r\n      this.text = 'cml'\r\n    }\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n复制代码如何声明生命周期统一各端应用生命周期的定义，是跨端框架的重要组成，也是迁移的必经之路。小程序声明生命周期可以在 App(Object) 、 Page(Object) 、 Component(Object) 传入 Object 参数，其指定小程序的生命周期回调等代码示例// index.js\r\nPage({\r\n  onLoad(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  onReady() {\r\n    // Do something when page ready.\r\n  },\r\n  onShow() {\r\n    // Do something when page show.\r\n  },\r\n  onHide() {\r\n    // Do something when page hide.\r\n  },\r\n  onUnload() {\r\n    // Do something when page close.\r\n  },\r\n  onShareAppMessage() {\r\n    // return custom share data when user share.\r\n  }\r\n})\r\n复制代码cml声明生命周期在 .cml 文件 <script /> 代码块返回的对象实例，其指定生命周期回调示例代码<script>\r\nclass Index {\r\n  beforeCreate(query) {\r\n    // data数据挂载到this根节点上之前，以及methods所有方法挂载到实例根节点之前\r\n    // 注意：只用页面的 beforeCreate钩子 会返回页面query\r\n    console.log('App beforeCreate: 打开当前页面路径中的参数是 ', query)\r\n  }\r\n  created() {\r\n    // data,methods里面的这些events挂载完成\r\n    console.log('App created')\r\n  }\r\n  beforeMount() {\r\n    // 开始挂载已经编译完成的cml到对应的节点时\r\n    console.log('App beforeMount')\r\n  }\r\n  mounted() {\r\n    // cml模板编译完成,且渲染到dom中完成,在整个生命周期中只执行一次\r\n    console.log('App mounted')\r\n  }\r\n  beforeDestroy() {\r\n    // 实例销毁前\r\n    console.log('App beforeDestroy')\r\n  }\r\n  destroyed() {\r\n    // 实例销毁后\r\n    console.log('App destroyed')\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码App 生命周期 映射小程序 app.js 中的生命周期 -> cml src/app/app.cml小程序chameleononLaunchbeforeCreateonShowmountedonHidedestroyedPage 生命周期 映射小程序 Page() 中的生命周期 -> cml src/pages/mypage/mypage.cml小程序chameleononLoadbeforeCreateonShowmountedonUnloaddestroyedonReady生命周期多态onHide生命周期多态onShareAppMessage生命周期多态Component 生命周期 映射小程序 Component() 中的生命周期 -> cml src/components/mycomponent/mycomponent.cml小程序chameleoncreatedcreatedattachedbeforeMountreadymounteddetacheddestroyed生命周期总结每个 cml 实例( App 、 Page 、 Component )在被创建时都要经过一系列的初始化过程 ————例如，需要设置数据监听、编译模板、将实例挂载到 CML节点 并在数据变化时更新 CML节点等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给开发者在不同阶段添加自己的代码的机会。cml 为 App 、 页面Page 、 组件Component 提供了一系列生命周期事件，保障应用有序执行。另外，如果你想使用某个端特定的生命周期，你可以从业务出发使用生命周期多态。数据如何响应到视图如今，双向数据绑定&单向数据流 已深入开发者日常，MVMM开发模式算是框架标配。数据绑定 、 条件渲染 、列表渲染 是如何书写的呢？示例代码小程序使用数据响应<!--wxml-->\r\n<view class=\"scroller-wrap\">\r\n    <!--数据绑定-->\r\n  <view>{{message}}</view>\r\n  <!--条件渲染-->\r\n  <view wx:if=\"{{view == 'WEBVIEW'}}\">WEBVIEW</view>\r\n  <view wx:elif=\"{{view == 'APP'}}\">APP</view>\r\n  <view wx:else=\"{{view == 'MINA'}}\">MINA</view>\r\n    <!--列表渲染-->\r\n  <view wx:for=\"{{array}}\" wx:for-index=\"index\" wx:for-item=\"item\">{{item}}</view>\r\n</view>\r\n复制代码// page.js\r\nPage({\r\n  data: {\r\n    message: 'Hello MINA!',\r\n    view: 'MINA',\r\n    array: [1, 2, 3, 4, 5]\r\n  },\r\n  onLoad() {\r\n    this.setData({\r\n      message: 'wx'\r\n    })\r\n  }\r\n})\r\n复制代码cml使用数据响应<template>\r\n<!--index.cml-->\r\n<view class=\"scroller-wrap\">\r\n    <!--数据绑定-->\r\n  <view>{{message}}</view>\r\n  <!--条件渲染-->\r\n  <view c-if=\"{{view == 'WEBVIEW'}}\">WEBVIEW</view>\r\n  <view c-else-if=\"{{view == 'APP'}}\">APP</view>\r\n  <view c-else=\"{{view == 'MINA'}}\">MINA</view>\r\n    <!--列表渲染-->\r\n  <view c-for=\"{{array}}\" c-for-index=\"index\" c-for-item=\"item\">{{item}}</view>\r\n</view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  data =  {\r\n    message: 'Hello MINA!',\r\n    view: 'MINA',\r\n    array: [1, 2, 3, 4, 5]\r\n  }\r\n\r\n  beforeCreate () {\r\n    this.message = 'cml'\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码数据响应总结cml 运行时框架 提供了跨端响应式数据绑定系统(Data binding)，当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。只需要将 view<-->model 交互部分逻辑，作简单迁移，便可使它成为跨多端的数据响应系统。事件交互cml 支持一些基础的事件，保障各端效果( 类型 、 绑定 、 事件对象 )一致运行。示例代码小程序使用事件<!--wxml-->\r\n<view id=\"tapTest\" data-hi=\"WeChat\" bindtap=\"tapName\">Click me!</view>\r\n复制代码// page.js\r\nPage({\r\n  tapName(event) {\r\n    console.log(event)\r\n  }\r\n})\r\n复制代码cml使用事件<template>\r\n  <view id=\"tapTest\" data-hi=\"WeChat\" c-bind:tap=\"tapName\">\r\n    <text>Click me!</text>\r\n  </view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  methods = {\r\n    tapName(e) {\r\n      // 打印事件对象\r\n      console.log('事件对象:', e);\r\n    }\r\n  }\r\n}\r\nexport default new Index();\r\n</script>\r\n复制代码事件使用总结同时，还支持，用于父子组件之间的通信。另外，如果你想要使用某个端特定的事件， cml 并不会限制你的自由发挥，你可以从业务出发使用组件多态 或者接口多态 差异化实现功能。布局和外观各端描述 布局和外观 的层叠样式表(CSS)实现存在差异，包括不限于 布局 、 盒模型 、 定位、 文本 。所以， cml 框架内置跨端一致性基础样式能力。并且，定义了用于描述页面的样式规范 CMSS(Chameleon Style Sheet) 。如何导入外部样式使用 @import 语句可以导入外联样式表， @import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。小程序导入外部样式示例代码：/** common.wxss **/\r\n.small-p {\r\n  padding:5px;\r\n}\r\n复制代码/** app.wxss **/\r\n@import \"common.wxss\";\r\n.middle-p {\r\n  padding:15px;\r\n}\r\n复制代码cml导入外部样式详细文档示例代码：/** common.css **/\r\n.small-p {\r\n  padding: 5px;\r\n}\r\n复制代码<!-- app.cml -->\r\n<style>\r\n  @import './common.css';\r\n  .middle-p {\r\n    padding:15 cpx;\r\n  }\r\n</style>\r\n复制代码样式使用总结同时，为了统一多端尺寸单位，呈现效果一致，同时页面响应式布局， cml 项目统一采用cpx 作为尺寸单位，规定以屏幕750px（占满屏幕）视觉稿作为标准。而且，各端样式表拥有的能力不尽相同，是项目迁移的主要阵地之一。另外，如果你想要使用某个端特定的样式能力， cml 并不会限制你的自由发挥，你可以从业务出发使用样式多态注意：由于chameleon应用是 跨多端 web native 小程序 框架，如果需要跨 native ，必须使用flexbox 进行样式布局！！！组件cml 项目一切皆组件。组件(Component)是视图的基本组成单元。框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。如：<template>\r\n  <view>\r\n    <view>view 基础组件</view>\r\n    <text>text 基础组件</text>\r\n  </view>\r\n</template>\r\n复制代码同时， cml 支持简洁的组件化编程。自定义组件开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用。自定义组件在使用时与基础组件非常相似。如何创建自定义组件小程序创建自定义组件代码示例：Component({\r\n  properties: {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    innerText: {\r\n      type: String,\r\n      value: 'default value',\r\n    }\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    customMethod() {}\r\n  }\r\n})\r\n复制代码cml创建自定义组件示例代码<script>\r\nclass MyComponent {\r\n  props = {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    innerText: {\r\n      type: String,\r\n      value: 'default value',\r\n    }\r\n  }\r\n  data = {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  }\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    customMethod() {}\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n复制代码如何使用自定义组件使用已注册的自定义组件前，首先要进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。小程序使用自定义组件代码示例：在 page.json 中进行引用声明{\r\n  \"usingComponents\": {\r\n    \"component-tag-name\": \"path/to/the/custom/component\"\r\n  }\r\n}\r\n复制代码在 page.wxml 中使用<view>\r\n  <!-- 以下是对一个自定义组件的引用 -->\r\n  <component-tag-name inner-text=\"Some text\"></component-tag-name>\r\n</view>\r\n复制代码cml使用自定义组件代码示例：在 page.cml 中 <script cml-type='json' /> 进行引用声明<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"component-tag-name\": \"path/to/the/custom/component\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码在 page.cml 中 <template /> 使用<template>\r\n<view>\r\n  <!-- 以下是对一个自定义组件的引用 -->\r\n  <component-tag-name inner-text=\"Some text\"></component-tag-name>\r\n</view>\r\n</template>\r\n复制代码如何实现父子组件事件通信事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。小程序组件通信代码示例：<!-- 页面 page.wxml -->\r\n<view>\r\n  <my-component bindcustomevent=\"onMyEvent\"></my-component>\r\n</view>\r\n复制代码// 页面 page.js\r\nPage({\r\n  methods: {\r\n    onMyEvent(e) {\r\n      console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    }\r\n  }\r\n})\r\n复制代码<!-- 组件 my-component.wxml -->\r\n<view>\r\n  <button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n</view>\r\n复制代码// 组件 my-component.js\r\nComponent({\r\n  methods: {\r\n    onTap() {\r\n      this.triggerEvent('customevent', {}) // 触发 自定义组件事件\r\n    }\r\n  }\r\n})\r\n复制代码cml组件通信代码示例：<!-- 页面 page.cml -->\r\n<template>\r\n  <view>\r\n    <my-component c-bind:customevent=\"onMyEvent\"></my-component>\r\n  </view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    onMyEvent(e) {\r\n      console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    }\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"my-component\": \"path/to/the/custom/component\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码<!-- 页面 path/to/the/custom/component.cml -->\r\n<template>\r\n  <view>\r\n    <button c-bind:tap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n  </view>\r\n</template>\r\n<script>\r\nclass MyComponent {\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    onTap() {\r\n      this.$cmlEmit('customevent', {}) // 触发 自定义组件事件\r\n    }\r\n  }\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n<script cml-type=\"json\">\r\n{}\r\n</script>\r\n复制代码组件使用总结和小程序一样， cml框架 提供了大量内置组件和扩展组件，抹平多端差异，便于开发者通过组合这些组件，创建出强大的应用程序。扩展组件需要额外引入。如：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码在执行 cml build 构建打包时， cml 框架 会按需打包引用的内置组件和扩展组件，为代码瘦身。内置组件 和扩展组件 都是支持跨多端的，对于一些没有提供的某个端的组件，可以通过组件多态来实现。如果希望使用小程序端的原生组件，那么可以在原生标签前加上 origin-* ， cml 框架会渲染原生组件参考注意： origin-* 只能在灰度区文件中使用！！如在 map.wx.cml 文件中使用原生地图组件 <map/> ：<!-- map.wx.cml -->\r\n<template>\r\n  <origin-map\r\n    id=\"map\"\r\n    longitude=\"113.324520\"\r\n    latitude=\"23.099994\"\r\n    controls=\"{{controls}}\"\r\n    bindcontroltap=\"controltap\"\r\n    style=\"width: 100%; height: 300px;\"\r\n  ></origin-map>\r\n</template>\r\n复制代码如何调用平台接口能力在小程序里面，可以通过微信原生 API ，调起如获取用户信息，本地存储，支付功能等。示例代码try {\r\n  wx.setStorageSync('name', 'Hanks')\r\n} catch (e) {\r\n  console.error(e)\r\n}\r\n复制代码同样，在 cml 项目里面可以这样调用：示例代码import cml from 'chameleon-api'\r\ncml.setStorage('name', 'Hanks').then((res)=>{\r\n  console.log(res)\r\n},function(e){\r\n  console.error(e)\r\n})\r\n复制代码接口使用总结cml 框架提供了丰富的多态接口，可以调起各端提供的原生能力，如系统信息、元素节点信息、动画效果、本地存储、网络请求、地理位置等。请参考API 文档。chameleon-api 提供的接口都是支持跨多端的，对于一些没有提供的某个端的原生接口，可以通过接口多态来调用。"}
{"title": "小程序渲染架构设计 ", "author": "Rolan", "pub_time": "2019-4-3 00:34", "content": "One 什么是小程序\r\nⅠ 小程序概念\r\n微信小程序算是小程序的鼻祖了，2017年1月9日微信正式上线了小程序。在探究小程序技术架构之前，我们先看看小程序究竟是什么，微信官网对微信小程序的产品定位及功能介绍是：\r\n“微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。”\r\n这个介绍有种看了跟没看一样的感觉。网上对于微信小程序是什么还有一个介绍的版本：\r\n“小程序是一种不需要下载安装即可使用的应用，它实现了应用「触手可及」的梦想，用户扫一扫或搜一下即可打开应用。也体现了「用完即走」的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。”\r\n这个概念就更清晰一些，可以看出小程序是众多实例运行在一个宿主应用中，小程序本身也是一种可插拔的外接应用。\r\nⅡ 用户角度的小程序\r\n下面从用户使用交互角度来看一下小程序：\r\n\r\n（图1）\r\niOS：从小程序独立性角度（小程序与小程序之间，小程序与宿主应用之间切换）来说，BATT 的小程序与招商银行的小程序基本交互相似。\r\nAndroid：从交互上来看BATT 的小程序都可以看做是独立的应用程序，独立存在于后台（多进程），可以在小程序与小程序之间，小程序与宿主应用之间切换。可以直观的理解为这类小程序为小程序应用。招商银行的的小程序是与宿主应用共存的，也就是在一个进程中，不能在小程序与小程序之间，小程序与宿主应用之间切换。这类小程序可以直观的理解为小程序页面。\r\n\r\nBATT: 微信，支付宝，头条，百度小程序。由于交互相似，所以并称。\r\n\r\n所以，从用户使用角度来看，BATT的交互体验更有优势。从对小程序概念的理解来看，各app理解有所差异，但这并不影响功能层面的使用。\r\nⅢ 平台角度的小程序\r\n最早应用小程序的微信为什么会创造出小程序这个东西呢？它到底有什么作用？在我看来，主要目的还是在于管控为目的，使用了多个手段来实现，主要管控在于两个方面：\r\nUI管控：以微信为例，微信自己定义了一套DSL，而不是用HTML来开发页面。这样就不能让开发者随意开发，而是在微信的DSL框架中开发。开发者写的DSL具体转换成什么，是通过什么渲染，都是微信平台来决定。基于自定义的这套DSL，可以更好的做代码管控方面的工作，比如：请求白名单，代码扫描等。\r\n服务管控：还是以微信为例，微信中的宿主平台提供的服务（比如：支付，微信运动，卡券，发票，用户账号信息等）对于无论是二方使用者还是三方使用者，都有权限管控的需求。目的也是不能让接入的小程序，在没有授权机制的前提下，随意调用微信基础服务。\r\nTwo 小程序技术架构\r\n基于从用户角度的体验需求，以及平台角度的管控需求，我们来看看BATT系小程序在技术上做了哪些达到了这些目的。\r\nⅠ 渲染流程\r\n下图是小程序的渲染流程，里面包含了部分技术选型，后面的部分会提到：\r\n\r\n(图2)\r\nⅡ 主要技术点\r\n\r\nDSL(Domain-specific language)：\r\n\r\n在我们聊DSL之前，我们先看看编译代码需要做哪些工作。无论是解释性语言（JS，Ruby，Python）还是编译型语言（Java，C++，C#），都会有一个共同的部分，将源代码解析为AST(抽象语法树)。AST不仅能够以结构化的方式呈现源代码，而且在语义分析中起到关键作用。AST不仅仅应用在解释器和编译器，而且在静态代码分析中也比较常用，比如：我们在重构代码的时候，希望提取出公共模块，以便减少重复代码方便复用。这时我们单纯的用字符串比对的方式会比较片面不能达到效果，这时生成AST就比较有用。另一个应用例子对于我们的DSL设计会比较有借鉴意义：代码转换器。下图是一种语言代码转换为另一种语言代码的主要步骤：\r\n\r\n（图3：图片来源于网络）\r\n源代码先解析成AST，解析之前它是遵循语言规则的文本，解析之后成为与输入文本完全相同的树形结构，这个过程是可逆的。然后再对AST遍历以及替换，这个过程对于前端来说类似于DOM树的生成，最后根据修改后的AST生成编译后的代码。我们以JS为例，用acorn生成的AST，同样我们也可以使用其他的解析器，例如：babylon，esprima等，下面是一个简单的例子（限于篇幅，右侧的AST树没有完全展开，读者可以到astexplorer上生成结果）：\r\n\r\n（图4）\r\n由于小程序的渲染容器有可能是Webview容器，原生Native容器，Flutter容器（虽然Flutter也是Native渲染，为了与原生Native区别，这里把它单独出来，下同），所以我们可以借鉴前面的代码转换器的思路，用AST抹平具体渲染容器的区别，下图是DSL转换的整体思路：\r\n\r\n（图5）\r\n有了以上的的设计并不是大功告成，还需要有很多需要做的工作要做。我们可以简单的把DSL的处理分为编译时和运行时，编译时负责把DSL代码预编译为目标代码，目标代码可以在相应的运行时环境执行。生成的目标代码的作用是，可以在具体的运行时通过当前环境的参数来执行出实际的代码，简单的理解就是为了在多渲染环境运行的一个适配器。\r\n对于编译时来说，从零写起肯定是不现实的。首先我们继续上面AST的话题，上面已经提到了几个AST的解析器：acorn，babylon，esprima。当然还有很多其他的例如：cherow，espree，shift等。所以我们不用再造一个轮子，下面用babylon举例，因为babylon在babel中使用，会与最近的JS功能同步，并且API设计良好易于使用。babel是js编译器（并不仅仅是ES6支持的工具包，否则就变成了类似于Android里面的support包了），可以用于代码压缩，语法转换等。对于生成目标代码的过程：解析（babylon），转换（babel-traverse）都有很好的支持。由于不同的渲染容器有不同的组件库和API，同样功能的组件或API的使用也不尽相同，所以需要封装出适配层代码。\r\n对于运行时来说，只需要把编译生成的适配代码生成具体渲染环境的代码执行就可以了。这里比较类似babel把ECMAScript新版代码转换成旧版代码的逻辑比较像。\r\n\r\nNative渲染\r\n\r\n从性能角度出发，把小程序最终通过Native方式渲染会比用Webview作为渲染容器得到更好的效果。DSL的设计可以很好的屏蔽底层实际渲染的实现，可以用Native，也可以用H5，也可以使用两者结合的方式，底层渲染引擎的切换也不会影响到小程序开发者的外部接入。目前移动端跨平台Native渲染的技术非常流行，比较常用的有Weex/RN/Flutter。市场上有基于Weex和RN进行小程序的案例，Flutter毕竟是后起之秀，目前还没有见到用Flutter作为渲染引擎的案例。\r\n\r\nAndroid多进程：\r\n\r\n前面我们在从“用户角度的小程序”部分看到，BATT的方案让小程序真正可以做到像应用一样的体验。由于iOS应用无法开启新进程让小程序本身在独立进程中运行，所以iOS中的小程序只能与宿主应用共享同一进程。对于Android来说就不一样了，小程序占用独立进程，从安全角度来说，二方后者三方的小程序应用与宿主应用进程隔离，小程序出现的问题不会影响宿主应用。而且，从性能角度来说，小程序不会共享宿主应用的内存。从BATT的小程序实际应用操作来看，基本都会控制五个后台开启的进程保活，可以用五个容器Activity各自在自己的进程中渲染小程序，有的还会有后台的保活时间限制。再开启新的小程序，会关闭最早打开的小程序进程，这样达到了高效热启动的目标。\r\n\r\n多线程：\r\n\r\n逻辑渲染隔离：\r\n首先，在聊具体的多线程之前，先说一下小程序的逻辑和渲染的问题。小程序的逻辑和渲染是分离的，当然从功能层面，不分离一样可以实现。这里说的逻辑和渲染分离是指小程序的逻辑运行在单独JS环境的线程中，只需要JS引擎就可以，渲染运行在Webview线程中。逻辑和渲染分离到两个线程有几点好处：第一个是可以逻辑和渲染代码分离没有耦合，第二个是可以让逻辑线程和渲染线程并行执行，JS执行不会阻塞UI。第三是补充了前面所说的UI管控的目的，逻辑线程里面JS在JS引擎中运行，而不是在Webview里面，这样就限制了通过注入JS代码来操作dom的可能，任何与UI相关的API都没有办法通过JS来改变，这样就与DSL一起达到了UI管控的目的。第四个好处是多个小程序页面共享同一个JS逻辑运行环境，可以方便高效的共享数据。\r\n\r\n（图6）\r\n上图展示了逻辑层与视图层的通信过程，通信通过Bridge中转，利用发布/订阅模式。视图层通过触发UI事件，会把事件通过bridge传递到Native，Native再通过bridge把事件中转给逻辑层，逻辑层处理事件完成后，把数据再通过bridge传递到Native，之后再由bridge返回给视图层做渲染。\r\n优化：\r\n逻辑和渲染分离之后，逻辑线程需要把数据发送给渲染线程，渲染线程需要把事件发送给逻辑线程，这都需要序列化为字符串进行传输。这样会带来一个问题，频繁的数据传输，和单次大数据量传输都会带来性能问题。针对这个问题，支付宝小程序的设计思路比较值得借鉴，支付宝小程序重新设计了V8虚拟机，让逻辑和渲染都有自己的Local Runtime，存放私有的模块和数据。又提供了共享的Global Runtime的Shared Heap来共享数据，这样依然保证了逻辑和渲染的隔离，又减少了序列化和传输成本。\r\n\r\n预加载：\r\n\r\n小程序的开发者在小程序应用方面，做了很多优化，比如：数据的预加载。从用户点击页面，到新页面onload()，会延迟100ms-300ms，这个延迟时间，可以做数据的预加载。这里所说的小程序启动预加载，是小程序渲染框架层面的。iOS的优化会预加载比实际渲染小程序数多一个wkwebview放在后台，打开新的小程序会直接把预先加载的wkwebview直接渲染，节省了初始化时间；Android上实现稍微复杂一点，不过依然是空间换时间的思路，从Android宿主应用启动开始，就会启动一个预留进程，当开启新的小程序，会占用这个进程，并再预加载新的进程，直到开启第五个进程的上限。\r\n\r\n离线包（分包）：\r\n\r\n离线包机制的根本目的在于让小程序打开的时候，可以让页面资源从网络IO替换为本地IO。其实就是在app打开之前从网络拉取或者推拉结合，预置等方式让离线包可以在打开小程序之前就已经在本地了。离线包模块的职责包括：更新，解压，存储，读取和校验等，当然也可以做二进制的差量包以。有了离线包机制，也要考虑把整个小程序整体作为一个离线包会影响效率的问题，所以这里需要增加分包的方案，可以把离线包分为一个主包和多个子包的形式，主包里面主要包括：首屏资源，公共代码，相关子包的信息等；子包可以包含二级页面的页面资源。这样就可以提高首屏打开速度，可以做到按需加载的目的，如下图：\r\n\r\n（图7）\r\nⅢ 技术选型\r\n\r\nIDE\r\n\r\n小程序平台都有自己的IDE，对于多系统平台的现状，选取跨平台桌面技术开发小程序IDE，肯定是最好的选择，这里选择了Electron和NW.JS做了一下对比：\r\n\r\n（图8）\r\n对比结果简单的说，两者开源协议都比较友好，如果重视代码安全性或者兼容XP需求，就选择NW.JS，也是国内厂商的选择；如果从开发支持角度来比较，就选择Electron。\r\n\r\nJS引擎\r\n\r\n前面已经说了，逻辑层具有单独的JS环境，也从管控角度说明了这样做也可以防止js修改UI的风险。就技术选型角度来说，iOS可以使用自带的JScore，虽然iOS上wkwebview的JS引擎比JScore多了JIT优化，执行速度快很多，但是比起额外引入js引擎来说，使用自带js引擎具有稳定且不增加包大小的先天优势。这块可能有人会提到Flutter在iOS里面引入了skia渲染引擎的问题，Flutter在iOS引入skia的好处是与Android自带的skia引擎使用相同渲染引擎，这样会在UI兼容性上有更好的提升。而js引擎兼容性问题就小的多。\r\nAndroid方面，可选择性多一下，以下是一个主流JS引擎对比：\r\n\r\n（图9）\r\n微信小程序旧版本用的JScore，新版本用的V8；支付宝小程序用的重新设计的V8；头条小程序也是使用的V8；可以看到V8的中标率还是很高的，而且开源协议也比较友好。\r\nThree 结语\r\n本文算是介绍了一种小程序渲染架构的一种实现方式，就小程序平台本身来说，还有一些其他的功能和优化点，比如：小程序路由，Debug包加载，埋点统计，虚拟Dom的优化等。文章只是介绍了一些主要流程和技术点，真正做一个完善的小程序平台还是需要很多细节需要考虑的，就小程序开发者的角度来说，也是有优化空间的，比如：骨架屏。做一个小程序平台需要多平台多种技术能力的综合应用才能不断完善，随着新技术的涌现，未来会有更多的技术应用到小程序中。"}
{"title": "小程序营销组件：红包雨、大转盘、九宫格翻牌…… ", "author": "Rolan", "pub_time": "2019-6-12 00:23", "content": "前言商城没几个营销活动能叫商城吗？这里你能找到的有：1.红包雨2.大转盘3.九宫格翻牌4...所以就来几个组件吧，写的不好轻踩，对你有帮助记得给个小星星哦直接上链接github链接运行例子git clone https://github.com/sunnie1992/soul-weapp.git\r\n复制代码微信开发者工具打开项目营销组件大转盘 \"pages/wheel/index\" 九宫格翻牌 \"pages/gridCard/index\" 红包雨 \"pages/packetRain/index\" 页面\"pages/filter/index\" 功能筛选筛选预览"}
{"title": "微信小程序前端实现自定义分享 ", "author": "Rolan", "pub_time": "2019-6-13 00:06", "content": "目前手上有一个小程序的项目，希望转发时分享消息的界面能够自定义,然而微信小程序只提供设置图片的url和title。/**\r\n     * 用户点击右上角分享\r\n     */\r\n    onShareAppMessage: function() {\r\n        return {\r\n          imageUrl:'',\r\n          title:''\r\n        };\r\n    }\r\n复制代码实现我们要转发的显示内容多了一点东西: 头像 ， 用户名 和 点赞数。好在这个排版不是很复杂，所以我们思考了一下通过canvas去生成一张图片再return canvas所生成的图片url。代码如下（其实还要作出一些显示上的优化，具体你们自己去调试）： 先在页面里新建一个canvas 标签<canvas canvas-id=\"canvasid\" style=\"width: 375px; height: 500px;\" wx:if=\"{{canvasShow}}\"></canvas>\r\n复制代码let context = wx.createCanvasContext('canvasid')\r\n     context.drawImage(back.path, 0, 60, backWidth, backHeight) //绘制下方背景图\r\n     //绘制圆形头像，参考教程：https://www.jianshu.com/p/9a6ee2648d6f 第二种方法\r\n\r\n      context.save();\r\n      var d = 2 * 25;\r\n      var cx = 0 + 25;\r\n      var cy = 0 + 25;\r\n      context.arc(cx, cy,25, 0, 2 * Math.PI);\r\n      context.clip();\r\n      context.drawImage(avatar.path, 0,0, d, d);\r\n      context.restore();\r\n      //绘制名字和点赞数\r\n      context.setFontSize(14)\r\n      context.fillText('userName', 70, 32)\r\n      let zanLength = ('100' + '次赞').length\r\n      context.fillText('100'+ '次赞', 375 - 14 * zanLength, 32)\r\n      //执行draw进行渲染 并返回图片url\r\n      context.draw(true, () => {\r\n        //此方法应执行在draw的回调中\r\n        wx.canvasToTempFilePath({\r\n          x: 0,\r\n          y: 0,\r\n          width: 375,\r\n          height: 400,\r\n          destWidth: 375,\r\n          destHeight: 400,\r\n          canvasId: 'canvasid',\r\n          success(res) {\r\n        //设置onShareAppMessage所返回的数据格式\r\n           let shareInfo = {\r\n              title: 'customTitle',\r\n              imageUrl\r\n            }\r\n           //隐藏画布\r\n            that.setData({\r\n              canvasShow: false\r\n            })\r\n          }\r\n        })\r\n      });\r\n复制代码然而！ 在canvas中绘制的图片要在真机上显示出来是有问题的（画布污染），非同源的图片在canvas不会显示出来的。后来我们使用 wx.getImageInfo 去获取图片信息，通过里面的地址去显示图片(相当于是把图片转了一道)。wx.getImageInfo({\r\n                src: imgUrl,\r\n                success: function(res) {\r\n                     /**拿到返回值res[0].path,再把该值作为canvas绘制图片的路径 \r\n                        context.drawImage(res[0].path,x,x,x)**/\r\n                    let drawImgUrl =  res[0].path\r\n                }\r\n            }); \r\n复制代码emmmm....文章很短暂，这里只是提供一下解决的思路，希望能帮助到大家~"}
{"title": "小程序模板和组件的使用和区别 ", "author": "Rolan", "pub_time": "2019-6-14 00:53", "content": "不得不说微信小程序的官方文档还是有很多坑啊(⊙﹏⊙)使用模板和组件的目的：实现代码复用template（模板）相对于component而言，template更加轻量级，它的功能有限，主要是用于展示。模板只有两个以.wxml 和.wxss结尾的文件定义模板新建一个与pages同级的文件夹 => templates,在templates下创建templateItem文件夹，然后在这个文件夹里创建同名的.wxml和.wxss的文件使用name属性，作为模板的名字，然后在<template/> 内定义代码片段，template必须要写templateItem.wxml :<template name=\"msgItem\">    \r\n    <view class=\"content\">我是模板的内容</view>\r\n</template>复制代码可以在templateItem.wxss中添加一些好看的样式.content {   \r\n    width: 100%;    \r\n    height: 400rpx;   \r\n    background-color: yellowgreen;    \r\n    display: flex;    \r\n    justify-content: center;    \r\n    align-items: center;\r\n}复制代码接下来就可以在页面中使用模板了使用模板要使用模板，首先得在要使用的页面引入模板，使用import标签导入，使用is属性，声明需要使用的模板，比如在index.wxml中使用：index.wxml :<!-- index.wxml -->\r\n<import src=\"../../templates/templateItem/templateItem.wxml\" />\r\n<view>    \r\n    <template is=\"msgItem\" />\r\n</view>复制代码注意： import标签不能省略  /,不然会报错现在，模板的内容可以显示在页面上了，但是模板的样式却没有生效。想要让样式生效，必须在index.wxss 中引入模板的样式文件：/** index.wxss **/\r\n/** 如果下面还有样式 这里的分号不能省略 **/\r\n@import \"../../templates/templateItem/templateItem.wxss\";复制代码现在，模板的颜色也出来啦~                            到这里，一个最简单的模板就完成了模板传值模板除了可以写代码片段外，is属性可以使用Mustache语法，来动态决定具体需要渲染哪个模板在index.js中的data中添加一些数据，// index.js​\r\n//获取应用实例\r\ncosnt app = getApp()​;\r\nPage({    \r\n    data: {    \r\n        hero: {  \r\n             name: '盖伦'，\r\n             profession： '战士',\r\n             skill: '得玛西亚正义' \r\n       }\r\n    }\r\n})复制代码修改一下模板：<template name=\"msgItem\">\r\n    <view class=\"content\">\r\n        <view class=\"content\">我是模板的内容</view>\r\n        <view>            \r\n            <text>{{ name }}</text>---            \r\n            <text>{{ professios }}</text>---            \r\n            <text>{{ skill }}</text>        \r\n         </view>   \r\n    </view>\r\n</template>复制代码在模板原理的样式基础上中增加：flex-direction: column;复制代码保存并运行，此时，就多了好多内容了(#^.^#)                                     模板的作用域模板拥有自己的作用域，只能使用data 传入的数据以及模板文件中定义的<wxs />模块component（组件）从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。自定义组件在pages的同级目录下创建components文件夹类似于页面，一个自定义组件由json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在json文件中进行自定义组件声明（将component字段设为true)，使用微信开发者工具，创建component会自动生成。{    \"component\": true}复制代码在组件文件中编写一些看起来很厉害的代码<!-- 这是自定义组件内部的内容 -->\r\n<view class=\"herocontainer\">    \r\n    <view>姓名：{{ hero.name }}</view>    \r\n    <view>职业：{{ hero.profession }}</view>    \r\n    <view>技能：{{ hero.skill }}</view>\r\n</view>复制代码在自定义组件的js文件中，需要使用 Component 来注册组件，并提供组件的属性定义、内部数据和自定义方法// 这是自定义组件内部的js文件\r\nComponent({    \r\n    properties: {        \r\n        // hero收一个对象        \r\n        hero: Object    \r\n    },    \r\n    data: {   \r\n        //这里是一些组件内部数据   \r\n    },    \r\nmethods： {        \r\n    //这里是自定义方法    \r\n}})复制代码也给它添加一些看起来很厉害的样式/** 这是自定义组件内部的wxss文件 **/\r\n.herocontainer {    \r\n    width: 750rpx;    \r\n    height: 200rpx;    \r\n    background-color: yellow;    \r\n    color: hotpink;\r\n}复制代码注意：在组件wxss中不应该使用ID选择器、属性选择器和标签名选择器自定义组件中，写了wxss和 js，使用时无需在页面中导入，只需导入组件即可使用自定义组件使用自定义组件前，首先要在要使用的页面的json文件中进行引用声明，此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径{    \r\n    \"usingComponents\": { \r\n      \"my-component\": \"../../components/mycomponent/mycomponent\"    \r\n    }\r\n}复制代码这样，在页面的wxml 中就可以像使用基础组件一样使用自定义组件啦，节点名就是自定义组件的标签名，节点属性就是自定义组件的属性值<view>    \r\n    <my-component hero=\"{{hero }}\" />\r\n</view>复制代码黄色部分为组件的内容：            自定义组件传值页面 ----->  组件\t组件中通过proprtties写上要接受的值\t页面通过属性名称和值的方式传递上面就是页面传值到组件组件 -----> 页面\t页面中写监听事件\t组件中写触发事件在自定义组件中添加一个事件<button bindtap=\"onTap\">点击按钮触发事件</button>复制代码在组件的js文件methods中添加方法,通过this.triggerEvent()给也面传值，在data中定义一个数据用来传给页面data: { \r\n    message: '欢迎来到英雄联盟'  \r\n},\r\nonTap(){    \r\n    const message = this.data.message    \r\n    this.triggerEvent('myevent',message)\r\n}复制代码在页面的js中，添加一个与data同级的方法，通过事件对象的e.detail拿到传过来的值Page({    \r\n    onMyEvent(e){ \r\n       console.log(e.detail)    \r\n    }\r\n})复制代码在页面中绑定事件<my-component hero=\"{{ hero }}\" bindmyevent=\"onMyEvent\" />复制代码点击按钮之后，控制台会输出组件传过来的值不出意外就是 ==>  欢迎来到英雄联盟 注意坑点因为wxml节点标签只能是小写字母、中划线和下划线组合，自定义组件也只能是这样自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式自定义组件和页面所在项目根目录名不能以wx-为前缀，否则会报错总结template 和 components 的共性： 不能单独呈现出来，必须依附显示在页面不同点：template比较轻量级，没有自己的逻辑处理能力，只能来着页面显示值组件要重量级一些，它有自己的逻辑处理能力"}
{"title": "小程序打怪之在线客服自动回复功能(node版) ", "author": "Rolan", "pub_time": "2019-6-13 00:14", "content": "我们知道H5页面经常需要将用户导流到APP，通过下载安装包或者跳转至应用宝市场/Appstore等方式进行导流。但是由于小程序嵌套webview时需要校验域名，因此跳转到第三方应用市场和Appstroe无法实现导流。那怎么办呢? 只能说道高一尺魔高一丈，看看微博小程序是怎么导流的:曲线救国的方式，利用小程序的在线功能可以打开H5的方式，去进行下载引导。 于是，就引出了这次文档的主题，小程序在线客服自动回复功能。:laughing:阅读本文档之前，最好已经了解过小程序客服信息官方的相关文档:1. 客服消息使用指南2. 小程序客服消息服务端接口3. 客服消息开发文档这次开发做在线客服功能也踩了不少坑，网上也查阅不少资料，但大部分的后台都是基于php或者python,java开发，node.js开发的较少，因此将这次开发的流程记录一下，供大家参考，避免大家踩坑。可能会有一些错误地方欢迎指正交流。 另外，我们用的node框架是基于koa自行封装的，在一些细节实现上和其他框架会有区别，不必纠结。需求描述小程序中点按钮跳转在线客服界面，根据关键词自动回复 客服回复判断条件，支持cms配置key，及 respond respond 支持配置以下类型，及回复内容:type内容texttext=文本回复内容linktitle=标题 description=描述 url=跳转链接 thumb_url=图片地址imageimageurl=图片地址配置后用户需要精准匹配回复条件才可收到自动回复可支持配置多个key，及对应respond除了配置的key以外的回复，可配置默认的自动回复开发流程写个跳转客服的按钮吧index.wxml<button open-type=\"contact\">转在线客服</button>\r\n复制代码后台配置登录小程序后台后，在「开发」-「开发设置」-「消息推送」中，管理员扫码启用消息服务，填写服务器地址（URL）、令牌（Token） 和 消息加密密钥（EncodingAESKey）等信息。URL服务器地址URL: 开发者用来接收微信消息和事件的接口 URL。开发者所填写的URL 必须以 http:// 或 https:// 开头，分别支持 80 端口和 443 端口。务必要记住，服务器地址必须是 线上 地址，因为需要微信服务器去访问。localhost，IP，内网地址都不行的。不然会提示 '解析失败，请检查信息是否填写正确'。那么问题来了，不同的公司都有一套上线流程，总不能为了调试URL是否可用要上到线上去测试，成本太大，也不方便。这就要引出 内网穿透 了，简单来说就是配置一个线上域名，但是这个域名可以穿透到你配置的本地开发地址上，这样可以方便你去调试看日志。 推荐一个可以实现内网穿透的工具。(非广告 :laughing:)NATAPP 具体不详细介绍，免得广告嫌疑。简单说，NATAPP有免费和付费两种模式，免费的是域名不定时更换，对于微信的推送消息配置一个月只有3次更改机会来说，有点奢侈。不定什么时候配置的域名就不能访问，得重新配置。而付费的则是固定域名，映射的内网地址也可以随时更改。楼主从免费切到付费模式，一个月的VIP使用大概十几块钱吧。2.TokenToken自己随便写就行了，但是要记住它，因为你在接口中要用的。3.EncodingAESKey随机生成即可。4.加密方式和数据格式根据自己喜欢选择，楼主选择的安全模式和JSON格式。 不同的模式和数据格式，在开发上会有不同，自己衡量。 既然这些配置都清楚，那开始码代码。验证消息的确来自微信服务器配置提交前，需要把验证消息来自微信服务器的接口写好。server.js/*\r\n     * https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/message-push.html\r\n     * 验证消息的确来自微信服务器\r\n     * 开发者通过检验 signature 对请求进行校验（下面有校验方式）。\r\n     * 若确认此次 GET 请求来自微信服务器，请原样返回 echostr 参数内容，\r\n     * 则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：\r\n     * 将token、timestamp、nonce三个参数进行字典序排序\r\n     * 将三个参数字符串拼接成一个字符串进行sha1加密\r\n     * 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\r\n     */\r\n     const crypto = require('crypto');\r\n     async wxCallbackAction(){\r\n        const ctx = this.ctx;\r\n        const method = ctx.method;\r\n     \t//微信服务器签名验证，确认请求来自微信\r\n     \tif(method === 'GET') {\r\n     \t\t// 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\r\n     \t\tconst {\r\n     \t\t\tsignature,\r\n     \t\t\ttimestamp,\r\n     \t\t\tnonce,\r\n     \t\t\techostr\r\n     \t\t} = ctx.query;\r\n     \t\t\r\n     \t\t// 2.将token、timestamp、nonce三个参数进行字典序排序\r\n     \t\tlet array = ['yourToken', timestamp, nonce];\r\n     \t\tarray.sort();\r\n     \t\t\r\n     \t\t// 3.将三个参数字符串拼接成一个字符串进行sha1加密\r\n     \t\tconst tempStr = array.join('');\r\n     \t\tconst hashCode = crypto.createHash('sha1'); //创建加密类型\r\n     \t\tconst resultCode = hashCode.update(tempStr, 'utf8').digest('hex');\r\n     \t\t\r\n     \t\t// 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\r\n     \t\tif (resultCode === signature) {\r\n     \t\t\tconsole.log('验证成功，消息是从微信服务器转发过来');\r\n     \t\t\treturn this.json(echostr);\r\n     \t\t}else {\r\n     \t\t\tconsole.log('验证失败！！！');\r\n     \t\t\treturn this.json({\r\n     \t\t\t\tstatus: -1,\r\n     \t\t\t\tmessage: \"验证失败\"\r\n     \t\t\t});\r\n     \t\t}\r\n            \r\n     \t}\r\n     }\r\n复制代码验证接口开发完毕，后台配置可以去点提交了。配置成功会提示如下:接收消息和推送消息当用户在客服会话发送消息、或由某些特定的用户操作引发事件推送时，微信服务器会将消息或事件的数据包发送到开发者填写的 URL。开发者收到请求后可以使用发送客服消息接口进行异步回复。本文以接收文本消息为例开发:server.jsconst WXDecryptContact = require('./WXDecryptContact');\r\n    async wxCallbackAction(){\r\n        const ctx = this.ctx;\r\n        const method = ctx.method;\r\n        //接收信息时为POST请求；(完整代码自行与上面验证时的合并即可)\r\n        if(method === 'POST'){\r\n            const { Encrypt } = ctx.request.body;\r\n            //配置时选的安全模式 因此需要解密\r\n            if(!Encrypt){\r\n                return this.json('success');\r\n            }\r\n            const decryptData = WXDecryptContact(Encrypt);\r\n            await this._handleWxMsg(decryptData);\r\n            return this.json('success');\r\n \t\t}\r\n \t}\r\n \t\r\n \t//处理微信回调消息的总入口 (只处理了文本类型，其他类型自行添加)\r\n    async _handleWxMsg(msgJson){\r\n        if(!msgJson){\r\n            return ;\r\n        }\r\n\r\n        const { MsgType } = msgJson;\r\n        if(MsgType === 'text'){\r\n            await this._sendTextMessage(msgJson);\r\n        }\r\n        \r\n    }\r\n    //微信文本信息关键字自动回复\r\n    async _sendTextMessage(msgJson){\r\n \t    //获取CMS客服关键词回复配置\r\n \t    const result = await this.callService('cms.getDataByName', 'wxApplet.contact');\r\n \t\t\r\n \t\tlet keyWordObj = result.data || {};\r\n \t\r\n \t\t//默认回复default\r\n \t\tlet options = keyWordObj.default;\r\n \t\tfor(let key in keyWordObj){\r\n \t\t\t//查看是否命中配置的关键词\r\n \t\t\tif(msgJson.Content === key){\r\n \t\t\t    //CMS配置项\r\n \t\t\t\toptions = keyWordObj[key];\r\n \t\t\t}\r\n \t\t}\r\n \t}\r\n \t\t\r\n \t//获取access_token\r\n \tconst accessToken = await this._getAccessToken();\r\n \t\r\n \t/*\r\n \t* 先判断配置回复的消息类型是不是image类型\r\n \t* 如果是 则需要先通过 新增素材接口 上传图片文件获得 media_id\r\n \t*/\r\n \t\r\n \tlet media_id = '';\r\n \tif(options.type === 'image'){\r\n \t\t//获取图片地址(相对路径)\r\n \t\tlet url = options.url;\r\n \t\tconst file = fs.createReadStream(url);\r\n \t\t\r\n \t\t//调用微信 uploadTempMedia接口 具体实现见 service.js\r\n \t\tconst mediaResult = await this.callService('wxApplet.uploadTempMedia',\r\n \t\t\t{\r\n \t\t\t\taccess_token: accessToken,\r\n \t\t\t\ttype: 'image'\r\n \t\t\t},\r\n \t\t\t{\r\n \t\t\t\tmedia: file\r\n \t\t\t}\r\n \t\t);\r\n \t\t\r\n \t\tif(mediaResult.status === 0){\r\n \t\t\tmedia_id = mediaResult.data.media_id;\r\n \t\t}else {\r\n \t\t\t//如果图片id获取失败 则按默认处理\r\n \t\t\toptions = keyWordObj.default;\r\n \t\t}\r\n \t}\r\n \t\r\n \t//回复信息给用户\r\n \tconst sendMsgResult = await this.callService('wxApplet.sendMessageToCustomer',\r\n \t\t{\r\n \t\t\taccess_token: accessToken,\r\n \t\t\ttouser: msgJson.FromUserName,\r\n \t\t\tmsgtype: options.type || 'text',\r\n \t\t\ttext: {\r\n \t\t\t\tcontent: options.description || '',\r\n \t\t\t},\r\n \t\t\tlink: options.type === \"link\" ? \r\n \t\t\t\t{\r\n \t\t\t\t\ttitle: options.title,\r\n \t\t\t\t\tdescription: options.description,\r\n \t\t\t\t\turl: options.url,\r\n \t\t\t\t\tthumb_url: options.thumb_url\r\n \t\t\t\t}\r\n \t\t\t\t:\r\n \t\t\t\t{},\r\n \t\t\timage: {\r\n \t\t\t\tmedia_id\r\n \t\t\t}\r\n \t\t}\r\n \t);\r\n \t\r\n }\r\n复制代码service.jsconst request = require('request');\r\n\r\n\r\n/*\r\n* 获取CMS客服关键词回复配置\r\n* 这个接口只是为了回去CMS配置的字段回复关键字配置 返回的data数据结构如下\r\n*/\r\nasync contact(){\r\n\treturn {\r\n\t\tdata: {\r\n\t\t\t\"1\": {\r\n\t\t\t    \"type\": \"link\",\r\n\t\t\t    \"title\": \"点击下载[****]APP\",\r\n\t\t\t    \"description\": \"注册领取领***元注册红包礼\",\r\n\t\t\t    \"url\": \"https://m.renrendai.com/mo/***.html\",\r\n\t\t\t    \"thumb_url\": \"https://m.we.com/***/test.png\"\r\n\t\t\t  },\r\n\t\t\t  \"2\": {\r\n\t\t\t    \"url\": \"http://m.renrendai.com/cms/****/test.jpg\",\r\n\t\t\t    \"type\": \"image\"\r\n\t\t\t  },\r\n\t\t\t  \"3\": {\r\n\t\t\t    \"url\": \"/cms/***/test02.png\",\r\n\t\t\t    \"type\": \"image\"\r\n\t\t\t  },\r\n\t\t\t  \"default\": {\r\n\t\t\t    \"type\": \"text\",\r\n\t\t\t    \"description\": \"再见\"\r\n\t\t\t  }\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n * 把媒体文件上传到微信服务器。目前仅支持图片。用于发送客服消息或被动回复用户消息。\r\n * https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.uploadTempMedia.html\r\n */\r\n \r\n async uploadTempMedia(data,formData){\r\n \tconst url = `https://api.weixin.qq.com/cgi-bin/media/upload?access_token=${data.access_token}&type=${data.type}`;\r\n \treturn new Promise((resolve, reject) => {\r\n \t\trequest.post({url, formData: formData}, (err, response, body) => {\r\n \t\t\ttry{\r\n \t\t\t\tconst out = JSON.parse(body);\r\n \t\t\t\tlet result = {\r\n \t\t\t\t\tdata: out,\r\n \t\t\t\t\tstatus: 0,\r\n \t\t\t\t\tmessage: \"ok\"\r\n \t\t\t\t}\r\n \t\t\t\t\r\n \t\t\t\treturn resolve(result);\r\n \t\t\t\r\n \t\t\t}catch(err){\r\n \t\t\t\treturn reject({\r\n \t\t\t\t\tstatus: -1,\r\n \t\t\t\t\tmessage: err.message\r\n \t\t\t\t});\r\n \t\t\t}\r\n \t\t});\r\n \t}\r\n }\r\n \r\n /*\r\n * 发送客服消息给用户\r\n * https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/customer-message/customerServiceMessage.send.html\r\n */\r\n \r\n async sendMessageToCustomer(data){\r\n \tconst url = `https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=${data.access_token}`;\r\n \treturn new Promise((resolve, reject) => {\r\n \t\trequest.post({url, data}, (err, response, body) => {\r\n \t\t\t...\r\n \t\t});\r\n \t}\r\n\r\n }\r\n \r\n复制代码WXDecryptContact.js消息加密解密文档const crypto = require('crypto'); // 加密模块\r\n\r\nconst decodePKCS7 = function (buff) {\r\n    let pad = buff[buff.length - 1];\r\n    if (pad < 1 || pad > 32) {\r\n        pad = 0;\r\n    }\r\n    return buff.slice(0, buff.length - pad);\r\n};\r\n\r\n// 微信转发客服消息解密\r\nconst decryptContact = (key, iv, crypted) => {\r\n    const aesCipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\r\n    aesCipher.setAutoPadding(false);\r\n    let decipheredBuff = Buffer.concat([aesCipher.update(crypted, 'base64'), aesCipher.final()]);\r\n    decipheredBuff = decodePKCS7(decipheredBuff);\r\n    const lenNetOrderCorpid = decipheredBuff.slice(16);\r\n    const msgLen = lenNetOrderCorpid.slice(0, 4).readUInt32BE(0);\r\n    const result = lenNetOrderCorpid.slice(4, msgLen + 4).toString();\r\n    return result;\r\n};\r\n\r\n// 解密微信返回给配置的消息服务器的信息\r\nconst decryptWXContact = (wechatData) => {\r\n    if(!wechatData){\r\n        wechatData = '';\r\n    }\r\n    //EncodingAESKey 为后台配置时随机生成的\r\n    const key = Buffer.from(EncodingAESKey + '=', 'base64');\r\n    const iv = key.slice(0, 16);\r\n    const result = decryptContact(key, iv, wechatData);\r\n    const decryptedResult = JSON.parse(result);\r\n    console.log(decryptedResult);\r\n    return decryptedResult;\r\n};\r\n\r\nmodule.exports = decryptWXContact;\r\n复制代码呼~ 代码终于码完，来看看效果:总结开发并不是一帆风顺的，也遇到了一些值得留意的坑，强调一下:后台配置URL地址一定外网可访问(可以通过内网穿透解决)文件上传接口 uploadTempMedia media 参数要用 FormData数据格式 (用node的 request 库很容易实现。 urllib 这个库有坑有坑 都是泪T_T)切记接收消息不论成功失败都要返回 success ，不然即使成功接收返回消息，日志没有报错的情况下，还是出现IOS提示该小程序提供的服务出现故障 请稍后再试。"}
{"title": "小程序开发经验：多页面数据同步 ", "author": "Rolan", "pub_time": "2019-5-22 00:35", "content": "在很多的产品中，都会存在跨页面间需要数据同步，如下示例：\r\n\r\n为了更好的理解该场景，我们再详细描绘一下：\r\n\r\n本场景包括4个页面：动态广场、个人中心、我的动态、动态详情\r\n首先，进入动态广场页，请求加载数据，展示动态列表，其中，我们用绿色内阴影区分该条动态是“我的”，其他未加内阴影的表示是“别人的”；\r\n然后，进入个人中心页，请求加载数据，展示获赞数量；\r\n点击我的动态，进入我的动态页，请求加载数据，展示我的动态列表；\r\n点击其中一条动态，进入动态详情页，请求加载数据，进行点赞操作；\r\n在第5步中，点赞成功后，回退到我的动态页，可以看到该条动态点赞状态和数量发生变化，已经同步；\r\n再回到到个人中心页，也可以看到获赞数量发生变化，已经同步；\r\n再回到动态广场页，也可以看到对应的一条动态点赞状态和数量发生变化，已经同步；\r\n\r\n下面我们来探讨一下这个场景的实现，在此之前，我们先要了解在点赞时，该场景中各页面的状态及关系。\r\n\r\n\r\n如上图所示，当我们在点赞时，4个页面都已经在是打开的（4个webview）。当我们点赞成功时，点击左上解返回时，动态详情页的webview关掉，直接看到下一层webview，也就是我的动态页，这个页面是已经存在的。其他页面也是如此。\r\n那对于这些已经存在的页面，我们应该如何同步更新数据呢？\r\n当然，如果比较懒，可以直接在onShow的时候重新拉数据渲染页面。但显然这是非常低级、不可取也没必要的做法。重新拉数据需要耗时，页面重新渲染也会看到闪屏，关键是根本没必要重新拉数据，因为数据发生了变化，前端是知道的。\r\n所以我们可以这样做，在动态详情页点赞成功时，保存一个数据到全局globalData中去，回到我的动态页，在onShow中去检测全局globalData中是否有点赞变化的数据，有的话，就读取出来去更新相应的动态。\r\n// 动态详情页js\r\nonLike() {\r\n  ...\r\n  success: () => {\r\n    App.globalData.like = {\r\n      fid: 10001,\r\n      likes: 1,\r\n      hasLike: true         \r\n    }\r\n  }\r\n}\r\n\r\n// 我的动态页js\r\nonShow() {\r\n  if(App.globalData.like !== null) {\r\n    // 读取globaldata.like数据去更新\r\n    this.doUpdata()\r\n    // 特别需要注意，更新完后，需要把globaldata.like清掉，不然下次onShow还会继续走到该逻辑\r\n    App.globalData.like = null\r\n  }\r\n}\r\n复制代码这样似乎可以达到我们的目的，无请求、纯前端局部更新。\r\n但这样还存在一个问题，当我们再退回到个人中心页时，要检查下获赞数量是否需要更新，以及回到动态广场页时，也要检查点赞有没有发生变化。但在这两个页面onShow去判断App.globalData.like时，都已经检测不到了，因为该数据已经在我的动态页onShow中置为null了。\r\n概括来说，在点赞时，只生产了一条数据，但有多个消费者，哪个页面先把数据消费了，其他页面也就无法检测到数据了。\r\n由此，我们想到那就使用EventBus来处理。\r\n首先，我们自己实现一套简单的EventBus。\r\n\r\n源码见：git.weixin.qq.com/xinyuanliu/…\r\n\r\n在小程序启动时，初始化EventBus：\r\nconst Event = require('/util/events.js').default\r\n\r\nApp({\r\n  events: null,\r\n  onLaunch(options) {\r\n    this.initEvents()\r\n    // doOtherThings\r\n  },\r\n  initEvents() {\r\n    this.events = new Event()\r\n  },\r\n  emitFeedsLike(data) {\r\n    this.events.emit('feedsLike', data)\r\n  },\r\n  emitPublishFeeds(data) {\r\n    this.events.emit('publishFeeds', data)\r\n  },\r\n  ...\r\n}\r\n复制代码各个页面在onLoad时，注册监听事件(在此以我的动态页为例)：\r\n// 我的动态.js\r\nconst App = getApp()\r\n\r\nPage({\r\n  data: {\r\n    list: []\r\n  },\r\n  onLoad: function (options) {\r\n    ...\r\n    // 监听点赞事件广播\r\n    ↓ 重点在这里 ↓\r\n    App.events.on('feedsLike', data => {\r\n      console.log('我的动态页面收到点赞变化通知：', data)\r\n      // 进行更新操作\r\n    })\r\n    // 监听发布事件广播\r\n    ↓ 重点在这里 ↓\r\n    App.events.on('publishFeeds', data => {\r\n      console.log('我的动态页面收到发布动态通知：', data)\r\n      // 进行更新操作\r\n    })\r\n  },\r\n  ...\r\n})\r\n复制代码然后在动态点赞时，发出事件通知。（这里一条动态是封装成组件，不属于某一个页面，点赞事件也是封装在组件内）\r\nconst App = getApp()\r\n\r\nComponent({\r\n  properties: {...},\r\n  methods: {\r\n    // 点赞\r\n    tapLike(e) {\r\n      let { likes, hasLike } = this.data\r\n\r\n      likes += (hasLike && -1 || 1)\r\n      hasLike = !hasLike\r\n\r\n      this.updateFeeds(likes, hasLike).then(() => {\r\n        this.setData({\r\n          likes,\r\n          hasLike\r\n        })\r\n\r\n        // 广播事件\r\n        ↓ 重点在这里 ↓\r\n        App.emitFeedsLike({\r\n          uid: this.data.uid,\r\n          fid: this.data.fid,\r\n          likes,\r\n          hasLike\r\n        })\r\n      })\r\n    },\r\n    ...\r\n  }\r\n})\r\n复制代码这样，我们便在小程序中实现了一套跨页面数据同步的方案。\r\n直观上这已经非常完美的实现了我们的需求。但在小程序中存在一个与我们常规经验不太一致的地方。那就是页面在关掉后，它里面的对象并没有销毁，这点是因为小程序的逻辑层是共用一个进程。\r\n因此，每次进入页面，都会注册一次监听事件，而退出页面后，该事件并不会销毁。这样的话，多次重复进入页面，就会注册多个重复事件，当事件发生时，就会执行多次响应。请仔细观察下图！\r\n为了避免该现象出现，我们切记要在页面的onUnload事件中，主动销毁监听事件。\r\nPage({\r\n  eventsListener: {},\r\n  data: {\r\n    list: []\r\n  },\r\n  onLoad: function (options) {\r\n    ...\r\n    // 监听点赞事件广播\r\n    ↓ 重点在这里 ↓\r\n    this.eventsListener.feedsLike = App.events.on('feedsLike', data => {\r\n      console.log('我的动态页面收到点赞变化通知：', data)\r\n      // 进行更新操作\r\n    })\r\n    // 监听发布事件广播\r\n    ↓ 重点在这里 ↓\r\n    this.eventsListener.publishFeeds= App.events.on('publishFeeds', data => {\r\n      console.log('我的动态页面收到发布动态通知：', data)\r\n      // 进行更新操作\r\n    })\r\n  },\r\n  ↓ 重点在这里 ↓\r\n  onUnload() {\r\n    for (let i in this.eventsListener) {\r\n      App.events.remove(i, this.eventsListener[i])\r\n    } \r\n  },\r\n  ...\r\n})\r\n复制代码至此，我们在小程序中完美的实现了跨页面/组件、多页面数据同步。\r\n本文研究的demo均可以小程序中体验，项目源码：git.weixin.qq.com/xinyuanliu/"}
{"title": "微信小程序胶囊按钮返回|首页自定义导航栏详解 ", "author": "Rolan", "pub_time": "2019-6-14 00:43", "content": "项目代码：https://github.com/Shay0921/header-navbar.git在小程序中，从转发出来的小程序消息卡片进入，因为页面栈中只有一个，所以不会出现返回按钮，对于一些电商平台来说，当商品被转发后会很影响客户查看其它产品和首页，这时候就需要使用自定义导航栏自己写一个“胶囊按钮”。如下图所示：从别的页面点到商品页时会有返回和首页按钮；当从分享页进入到商品页时，因为页面栈只有一个，所以只有首页按钮；首先我们需要如何开启自定义导航栏，查看手册后会发现一个页面配置项：navigationStyle之前的版本此配置项只能在app.js中配置，是全局的属性，而现在可以在单独的页面json中配置，实现单独页面自定义导航栏。整体思路当使用了navigationStyle:custom后，之前的顶部标题栏会被删除，右侧的胶囊按钮则会固定在右上角。然后在当前页面添加了三个view(状态栏、标题栏、主体内容)，可以看出三块的布局，我直接写死的高度：状态栏20px，标题栏44px。这个是自定义导航栏的关键，需要去计算这两块的高度，还有返回|首页胶囊按钮的位置。基础库 2.1.0开始可以使用wx.getMenuButtonBoundingClientRect()来获得右侧胶囊按钮的位置信息，而有了这个信息，就能相对的算出我们想要在左侧添加的胶囊按钮的位置。通过wx.getSystemInfoSync()中的statusBarHeight找到状态栏的高度。目录结构├── components                  组件\r\n│  ├── headerNavbar             顶部自定义导航栏\r\n│  │  └── headerNavbar.js\r\n│  │  └── headerNavbar.json\r\n│  │  └── headerNavbar.wxml\r\n│  │  └── headerNavbar.wxss\r\n├── pages                       页面\r\n│  ├── index                    首页\r\n│  │  └── index.js\r\n│  │  └── index.json\r\n│  │  └── index.wxml\r\n│  │  └── index.wxss\r\n│  ├── navigationStyle          引入自定义导航栏的页面(单独配置了navigationStyle)\r\n│  │  └── navigationStyle.js\r\n│  │  └── navigationStyle.json\r\n│  │  └── navigationStyle.wxml\r\n│  │  └── navigationStyle.wxss\r\n│  │  └── testPage.js           路由测试页面(后面用来测试跳转显示不同胶囊按钮)\r\n│  │  └── testPage.json\r\n│  │  └── testPage.wxml\r\n│  │  └── testPage.wxss复制代码全局变量app.js在app.js中要先获得状态栏高度和右侧胶囊位置信息App({\r\n    onLaunch: function (options) {\r\n      // 这里省略掉了登录和获取用户信息等函数\r\n      // 因为我在别的页面也需要使用此信息，所以没有单独获得 statusBarHeight\r\n      wx.getSystemInfo({ // 获取设备信息\r\n        success: (res) => {\r\n          this.globalData.systeminfo = res\r\n        },\r\n      })\r\n      // 获得胶囊按钮位置信息\r\n      this.globalData.headerBtnPosi = wx.getMenuButtonBoundingClientRect()\r\n    },\r\n    globalData: {\r\n        systeminfo: {}, // 系统信息\r\n        headerBtnPosi: {} // 胶囊按钮位置信息\r\n    }\r\n})\r\n复制代码这里需要注意wx.getMenuButtonBoundingClientRect()，并不是像wx.getSystmInfo一样有success回调函数，而是像对象一样wx.getMenuButtonBoundingClientRect().height来使用。组件代码headerNavbar.wxml<!-- 自定义导航栏 -->\r\n<view class='navbar-wrap' \r\n  style='height:{{navbarHeight}}px;padding-top:{{statusBarHeight}}px;'>  \r\n  <view class=\"navbar-text\"\r\n    style='line-height:{{navbarBtn.height + navbarBtn.top}}px;'>\r\n    {{navbarData.title ? navbarData.title : \"默认标题\"}}{{navbarHeight}}\r\n  </view>\r\n  <view class=\"navbar-icon\"\r\n    wx:if='{{navbarData.showCapsule ? navbarData.showCapsule : true}}'\r\n    style=\"top:{{navbarBtn.top + statusBarHeight}}px;left:{{navbarBtn.right}}px;height:{{navbarBtn.height}}px;\"> \r\n      <image wx:if='{{haveBack}}' bindtap=\"_goBack\" class=\"floatL\" src=\"/img/navbar_back_white.png\"></image>      \r\n      <view wx:if='{{haveBack}}' class=\"floatL\"></view>\r\n      <image bindtap=\"_goHome\" src=\"/img/navbar_home_white.png\"></image>\r\n  </view>\r\n</view>\r\n<!-- 手写loading -->\r\n<view class=\"navbar-loading\" style='height:{{navbarHeight}}px;line-height:{{navbarHeight}}px;'>\r\n  <text>...</text>\r\n</view>复制代码为了适配不同手机屏幕，高度和胶囊按钮的位置都需要在html里面赋值，下面会详细的说明高度如何计算。在自定义导航栏组件中分为两部分，一个是顶部的导航栏另一个是自己写的loading。因为自定义导航栏是fixed到顶部的，为了保证不挡住下面的主体内容，我们需要在导航栏和主体内容之间添加一个跟导航栏相同的高度，class先叫做box。这样可以保证导航栏不挡着主体内容。但是会出现另一个问题，如果此页面支持下拉刷新，那么导航栏会把小程序原生的loading样式挡住，而在主体内容的前面会出现一个空白的box，虽说不影响使用，但是在用户看来会很奇怪，莫名其妙的多出来一块，box只有在loading结束后才会上去。所以在这里需要自己手写一个loading的动画效果放在组件的最底下，高度跟导航栏一样。可以看到下面的最终效果，蓝色导航条下面的三个点是小程序原生loading，再下面三个小点是自己写的loading。而我们想要的效果则是，当小程序原生的loading被当时，自己写的loading就可以替代原生的loadingheaderNavbar.js状态栏高度 = app.globalData.systeminfo.statusBarHeight需要注意胶囊位置信息的原点是在页面的左上角，所以需要转换一下，把原胶囊位置信息起名为胶囊，转换后的叫做现胶囊。/*** iphone6 的胶囊位置信息\r\n* wx.getMenuButtonBoundingClientRect() 坐标信息以屏幕左上角为原点\r\n* 胶囊宽度： 87\r\n* 胶囊高度： 32\r\n* 胶囊左边界坐标： 278\r\n* 胶囊上边界坐标： 26\r\n* 胶囊右边界坐标： 365\r\n* 胶囊下边界坐标： 58\r\n* 状态栏高度：20*/复制代码现胶囊上边距 = 胶囊上边界坐标 - 状态栏高度现胶囊右边距 = 屏幕宽度 - 胶囊右边界坐标现胶囊下边距 = 胶囊下边界坐标 - 胶囊高度 - 状态栏高度导航栏高度 = 胶囊下边界坐标 + 现胶囊下边距注意：胶囊下边界坐标包含了状态栏、胶囊高度和状态栏和胶囊高度之间的距离，因为胶囊是居中在导航栏里的，所以上边距与下边距应该一致，所以是\r\n胶囊下边界坐标 - 胶囊高度 - 状态栏高度。const app = getApp();\r\nComponent({\r\n  properties: {\r\n    navbarData: { // 由父页面传递的数据\r\n      type: Object,\r\n      value: {},\r\n      observer: function (newVal, oldVal) { }\r\n    }\r\n  },\r\n  data: {\r\n    haveBack: true, // 是否有返回按钮，true 有 false 没有 若从分享页进入则为 false\r\n    statusBarHeight: 0, // 状态栏高度\r\n    navbarHeight: 0, // 顶部导航栏高度\r\n    navbarBtn: { // 胶囊位置信息\r\n      height: 0,\r\n      width: 0,\r\n      top: 0,\r\n      bottom: 0,\r\n      right: 0\r\n    }\r\n  },\r\n  // 微信7.0.0支持wx.getMenuButtonBoundingClientRect()获得胶囊按钮高度\r\n  attached: function () {\r\n    let statusBarHeight = app.globalData.systeminfo.statusBarHeight // 状态栏高度\r\n    let headerPosi = app.globalData.headerBtnPosi // 胶囊位置信息\r\n    /**\r\n     * wx.getMenuButtonBoundingClientRect() 坐标信息以屏幕左上角为原点\r\n     * 菜单按键宽度： 87\r\n     * 菜单按键高度： 32\r\n     * 菜单按键左边界坐标： 278\r\n     * 菜单按键上边界坐标： 26\r\n     * 菜单按键右边界坐标： 365\r\n     * 菜单按键下边界坐标： 58\r\n     */\r\n    let btnPosi = { // 胶囊实际位置，坐标信息不是左上角原点\r\n      height: headerPosi.height,\r\n      width: headerPosi.width,\r\n      // 胶囊top - 状态栏高度\r\n      top: headerPosi.top - statusBarHeight,\r\n      // 胶囊bottom - 胶囊height - 状态栏height （现胶囊bottom 为距离导航栏底部的长度）\r\n      bottom: headerPosi.bottom - headerPosi.height - statusBarHeight,\r\n      // 屏幕宽度 - 胶囊right\r\n      right: app.globalData.systeminfo.screenWidth - headerPosi.right\r\n    }\r\n    let haveBack;\r\n    if (getCurrentPages().length === 1) { // 当只有一个页面时\r\n      haveBack = false;\r\n    } else {\r\n      haveBack = true;\r\n    }\r\n    this.setData({\r\n      haveBack: haveBack, // 获取是否是通过分享进入的小程序\r\n      statusBarHeight: statusBarHeight,\r\n      navbarHeight: headerPosi.bottom + btnPosi.bottom, // 原胶囊bottom + 现胶囊bottom\r\n      navbarBtn: btnPosi\r\n    })\r\n  },\r\n  methods: {\r\n    _goBack: function () {\r\n      wx.navigateBack({\r\n        delta: 1\r\n      });\r\n    },\r\n    _goHome: function () {\r\n      wx.switchTab({\r\n        url: '/pages/index/index',\r\n      });\r\n    }\r\n  }\r\n})\r\n复制代码通过 getCurrentPages() 来判断当前页面是否从分享页进入，因为如果从分享页进入页面栈中应该只有一条数据，在跳转到其他页面时页面栈的length则会增加，在其他页面就会显示出返回和首页按钮。 注意：微信7.0.0支持wx.getMenuButtonBoundingClientRect()，如果想兼容低版本的微信，只能把导航栏的高度写死，通过一些大佬的计算得出的高度：'iPhone': 64,'iPhone X': 88,'android': 68具体查看：https://developers.weixin.qq.com/community/develop/doc/0006c012dc8028f04b070dd0551004如果你使用wx.getMenuButtonBoundingClientRect()得到信息有小数，如下所示{height:\r\n24, width: 65.25, top: -0.5, bottom: -0.5, right: 101.25}那么你可能是把开发工具中的视图缩放了，还原成100%就正常了。headerNavbar.wxss.navbar-wrap {\r\n\tposition: fixed;\r\n\twidth: 100%;\r\n\ttop: 0;\r\n\tz-index: 9999999;\r\n\tbackground-color: #3281FF;\r\n\tbox-sizing: border-box;\r\n}\r\n\r\n.navbar-text {\r\n\ttext-align: center;\r\n\tfont-size: 36rpx;\r\n\tcolor: #fff;\r\n\tfont-weight: 600;\r\n}\r\n\r\n.navbar-icon {\r\n\tposition: fixed;\r\n\tdisplay: flex;\r\n\tborder-radius: 64rpx;\r\n\tborder: 0.5px solid rgba(255,255,255, 0.3);\r\n\tbox-sizing: border-box;\r\n}\r\n\r\n.navbar-icon image {\r\n\theight: 20px;\r\n\twidth: 20px;\r\n\tpadding: 5px 10px 10px;\r\n\tdisplay: inline-block;\r\n\toverflow: hidden;\r\n}\r\n\r\n.navbar-icon view {\r\n\theight: 18px;\r\n\tborder-left: 0.5px solid rgba(255,255,255, 0.3);\r\n\tmargin-top: 6px;\r\n}\r\n\r\n.navbar-loading {\r\n\tbackground: #fff;\r\n\ttext-align: center;\r\n}\r\n复制代码引用组件页面代码navigationStyle.json{\r\n    \"navigationStyle\": \"custom\", \r\n    \"enablePullDownRefresh\": true, \r\n    \"backgroundTextStyle\": \"light\", \r\n    \"usingComponents\": {\r\n        \"headerNavbar\": \"/components/headerNavbar/headerNavbar\"\r\n    }\r\n}\r\n复制代码先在需要使用自定义导航栏的页面json中添加navigationStyle:customenablePullDownRefresh:\r\ntrue         开启下拉刷新backgroundTextStyle: light是把loading的样式改成白色，这样就不会显示出来loading的三个点navigationStyle.wxml<headernavbar navbar-data=\"{{nvabarData}}\"></headernavbar> \r\n<view class=\"home-page\"> \r\n   <text>\r\n    上面是自定义导航栏↑↑↑\r\n   </text> \r\n   <text>\r\n    下面是主体内容↓↓↓\r\n   </text> \r\n   <navigator url=\"./testPage\">\r\n    跳转到测试页\r\n   </navigator> \r\n</view>\r\n复制代码navigationStyle.jsPage({\r\n    data: {\r\n        // 组件所需的参数\r\n        nvabarData: {\r\n            showCapsule: 1,\r\n            // 是否显示左上角胶囊按钮 1 显示 0 不显示\r\n            title: '组件列表' // 导航栏 中间的标题\r\n        }\r\n    },\r\n\r\n    onPullDownRefresh() {\r\n        setTimeout(() = >{\r\n            wx.stopPullDownRefresh(); // 停止下拉\r\n        },\r\n        2000);\r\n    },\r\n\r\n})\r\n复制代码注意：虽说这么做在小程序开发工具中看起来都是对的，得到的导航栏高度也是64px但是在真机上测试后，还是有偏差，在iphone8 plus上高度是60px。可以通过这张图明显看到差了几px，如果你是单独几个页面使用自定义导航，细心的用户可能会发现，但是基本不影响。如果是全局使用自定义导航，那就不存在这个问题了。项目代码：https://github.com/Shay0921/header-navbar.git"}
{"title": "微信小程序-渐入渐出动画效果实现 ", "author": "Rolan", "pub_time": "2019-5-28 00:01", "content": "在做小程序列表展示的时候，接到了一个需求。需要在列表展示的时候加上动画效果。设计视频效果如下图：需要在进入列表页的时候，依次展示每一条卡片，在展示完成后需要隐藏掉当天之前的卡片。实现思路实现该动画效果，首先需要给每个卡片添加一个css动画。因为每个卡片的显示是有时间间隔的，以及考虑到展示完成后的隐藏效果，所以动画效果需要用js动态去添加。在看了微信开发文档后，发现微信小程序提供了Animation的一个动画对象，具体看了里面的参数后发现，是可以实现需求上的效果的。具体使用如下api:wx.createAnimation(Object object) 创建一个animation对象。最后通过动画实例的export方法导出动画数据传递给组件的 animation 属性。里面有如下参数：duration（动画持续时间，单位 ms）,timingFunction（动画的国度效果）,delay（动画延迟）创建的animation对象，本次实现过程中需要用到如下属性：Animation.export() 可以导出动画队列，export 方法每次调用后会清掉之前的动画操作。Animation.step(Object object) 表示一组动画完成。可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。比如一组动画结束了，就以step()结尾Animation.translateY(number translation) 在 Y 轴平移的距离，单位为 pxAnimation.opacity(number value) 透明度 0-1的取值范围看到上面这些属性，合理使用的话，那么实现需求提到动画效果那是稳稳的。实现步骤封装一个方法，用来创建动画，并方便调用/**\r\n * 动画实现\r\n * @method animationShow\r\n * @param {that} 当前卡片\r\n * @param {opacity} 透明度\r\n * @param {delay} 延迟\r\n * @param {isUp} 移动方向\r\n */\r\n  animationShow: function (that,opacity, delay, isUp) {\r\n    let animation = wx.createAnimation({\r\n      duration: 1000,\r\n      timingFunction: 'ease',\r\n      delay: delay\r\n    });\r\n    <!--考虑到还需要隐藏掉当天之前的卡片，做如下判断来赋予不同的动画效果-->\r\n    if (isUp == 'down') {\r\n      animation.translateY(0).opacity(opacity).step().translateY(-80).step();\r\n    } else if (isUp == 'up') {\r\n      animation.translateY(0).opacity(opacity).step().translateY(-140).opacity(0).step()\r\n    } else {\r\n      animation.translateY(0).opacity(opacity).step()\r\n    }\r\n    let params = ''\r\n    params = animation.export()\r\n    return params\r\n  }, \r\n复制代码初始化每个卡片的样式首先每个卡片的位置相对于自身往Y轴平移80像素，并且把透明度设置为0。这样就可以进入页面的时候再往下平移并且让卡片逐渐显示。\r\n.init{\r\n  opacity: 0;\r\n  transform: translateY(-80px)\r\n}\r\n复制代码处理数据循环处理每一条数据，通过调用封装的方法，来获得该卡片应该拥有的动画属性for (let i = 0; i < transData.length; i++) {\r\n    if (i == 0) {\r\n      transData[i].animation = that.app.slideupshow(that, 1, 0, 'up')\r\n    } else {\r\n      transData[i].animation = that.app.slideupshow(that, 1, (i + 1) * 10, 'down')\r\n    }\r\n  }\r\n复制代码跟设计视频中的动画风格基本保持一致，美滋滋。"}
{"title": "微信小程序：功能升级中页面（图片等比缩放） ", "author": "Rolan", "pub_time": "2019-5-28 00:08", "content": "在程序开发中，难免会要考虑一些基础业务以外的功能，如错误提示、升级提示、维护提示等...有时候因为时间问题，产品可能只开发部分功能就上线了，而为了让用户知道有这么一个功能，未开发完全的功能则仅放置一个入口，此时就需要一个升级/维护的提示页面...功能升级中.png如上图：这个页面很简单，一张图片，一行文字，在代码上，都不需要写任何js代码。仅需改动wxml和wxss即可；<!--pages/error/update.wxml--><view class='vertical'>  <image class='image' src='../../images/icon-update.png' mode='widthFix'></image>  <text class='text'>功能升级中...</text></view>在这里，唯一需要注意的是mode='widthFix'，之所以能保持image显示的图片等比缩放，就是通过mode控制的，该属性默认值是scaleToFill，即拉伸充满image容器。另外还有一些其他值，参考官方文档即可，这里不介绍了... wxss/* pages/error/update.wxss */.vertical{  display: flex;  flex-direction: column;  align-items: center;}.bg-white {  background-color: #ffffff;}.image {  margin-top: 30%;  width: 200rpx;}.text {  margin-top: 50rpx;  font-size: 40rpx;  color: #333333;}wxss同样很简单，关键点在于纵向布局vertical，它包含了元素纵向排列flex-direction: column;及居中align-items: center; 图片最后，则是在images中放入图片icon-update.png 简书：ThinkinLiu 博客: IT老五这只是一个简单的功能升级页面，同时，你也可以将图片和文字改改，改为维护页、错误页或者其他提示页..."}
{"title": "微信小程序统计Trello、掘金积分程序，Promise做异步处理 ", "author": "Rolan", "pub_time": "2019-5-28 00:24", "content": "Trello是一款团队管理工具。本文介绍的是使用微信小程序做一个积分排名的项目，从微信小程序端去调用Trello的接口、获取掘金上面的文章,按照特定的规则去积分。项目开始之前需要做一些准备工作：注册 Trello 账号-->注册为开发者 -->获取 trello 开发者的key -->生成 token。然后进入Trello API 文档获取需要的接口。成为微信小程序开发者，具体步骤请参考 developers.weixin.qq.com/miniprogram…获取genetalks_大数据里面的所有文章。提示：使用微信开发者工具发请求前先把：微信开发者工具（右上角） --> 详情 --> 不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书 (✔ 上)本次项目所做的小程序，微信扫码进入积分规则如下练习题在 Trello 里面,获取对应的 board（Trello 中的看板 ）里面有 list(board 里面的任务列表) 里面有 card（对应任务、题目）。按照一定的约定在对应的 board 里面去创建 list --> card，完成了对应的任务才能去归档，然后获得对应的 board 里面归档的 card 对应参与排名者应该获得的积分。只有博客在掘金里面，因此需要获取掘金里面的文章，但是掘金平台方面没有提供 api 接口，那么就只有自己去获取对应的 html 页面，然后做字符串截取了。实现因为页面比较简单，页面也少。下面说说Promise处理异步的问题。二、微信小程序端不引入第三方 js 脚本的情况下处理异步问题。本人所知的处理 js 异步问题的方法：使用回调。缺点：代码逻辑变的复杂，回调层次根据你访问接口的次数越来越深。使用 async await,但是不引入第三方 js 脚本，就不能使用。Promise，下面会讲解怎样使用 Promise，不再需要回调，代码可读性提高。微信小程序发送请求。例：统计积分需要获取 Trello 的接口、掘金的文章，拿到数据后进行其他操作，使用回调let sort = () => {}; // sort函数做逻辑处理，排序操作\r\nconst get_data = () => {\r\n  const _this = this;\r\n  const get_board = (callback) => {\r\n    wx.request({\r\n      url: 'https://*****',\r\n      success: resp => {\r\n        // 拿到resp\r\n        // 使用回调\r\n        // 如果需要把resp传入过去，然后做逻辑处理\r\n        // 回调里面使用了回调，把sort 当成参数传入、也可以不传入,直接在callback,里面调用。如果都正常返回的话此处调用了一次sort函数\r\n        resp.data.forEach((item, index) => {\r\n          callback(item, index === resp.data.length - 1 && sort);\r\n        })\r\n      }\r\n    });\r\n  };\r\n  const get_cards = (data, callback) => {\r\n    wx.request({\r\n      url: data.url,\r\n      success: () => {\r\n        // 业务逻辑处理\r\n        // ................\r\n        callback && callback();\r\n      }\r\n    })\r\n  }\r\n  const get_blogs = (callback) => {\r\n    wx.request({\r\n      url: 'https//****',\r\n      success: resp => {\r\n        // 同上。。。。。\r\n      }\r\n    })\r\n  }\r\n  get_board(get_cards); // 获取board里面的cards \r\n  get_blogs(get_blog_detail) // 获取博客的内容\r\n  // 然后调用get_board 、get_blogs，这样的话虽然也能做最后的逻辑处理，但是sort函数被执行了2次，并且还容易因为数据请求出错，而发生统计错误。\r\n};\r\n复制代码使用Promise// 获取board下归档的card\r\nconst get_cards = (data) => {\r\n  const get_value = new Promise(resolve, reject) => {\r\n    wx.request({\r\n      url: data.url,\r\n      success: (resp) => resolve(resp),\r\n      fail: (err) => reject(err)\r\n    })\r\n  }\r\n  // 返回一个Promise，拥有card接口返回值。\r\n  return get_value;\r\n}\r\nconst get_board = () => {\r\n  // 获取所有的board\r\n  const get_value = new Promise(resolve, reject) => {\r\n    wx.request({\r\n      url,\r\n      success: (resp) => resolve(resp)\r\n    })\r\n  }\r\n  let promise_arr;\r\n  // 此时的get_value拥有board接口返回的值\r\n  return get_value.then(resp => {\r\n    // 遍历需要参与积分的board\r\n    resp.data.forEach(item => {\r\n      // 把每个card接口返回的Promise 存储到promise_arr数组里\r\n      promise_arr.push(get_cards(item));\r\n    })\r\n    // Promise.all函数接收一个Promise数组\r\n    // 使用Promise.all 等所有获取card的接口都执行完了会返回一个数组，数组的每一项对应board下面card的返回值\r\n    return Promise.all(promise_arr)\r\n  })\r\n  // 博客的获取方式与上面获取card的方式一样  \r\n}\r\n  // 在写一个Promise.all()等待获取掘金博客的数据与获取Trello的数据都获取到了就可以执行最后的数据汇总及排序。调用sor()\r\n  const get_data = () => {\r\n    return Promise.all([get_board(), get_card()]).then(resp => return sort(resp));\r\n  }\r\n复制代码微信小程序上线问题微信小程序只能获取https的API因为开发时选用的是不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书，所以当你上传了代码，使用体验版本时，会发现所有的接口都获取不到数据，这时你需要去微信小程序后台管理页面 开发 --> 开发设置 --> 服务器域名：把域名填配置在这里。如果提示你域名未备案，可以做域名转发，自己不会的话可以请教后台的大哥帮忙。欧克，总结完毕！！！作者信息：宁文飞，人和未来大数据前端工程师"}
{"title": "小程序封装路由文件和路由方法，5种路由方法全解析 ", "author": "Rolan", "pub_time": "2019-5-28 00:32", "content": "小程序5种路由方法使用场景，封装路由文件和路由方法，提升小程序体验和开发效率明确要解决的问题每次使用路由时，总是粘贴复制路径，这样在路径有修改时，需要修改所有用到该路径的地方，维护成本高路由跳转时拼接参数让人头大，业务复杂时要拼接十几个参数路由返回，只会返回一层，不能直接返回到目标页面，因为不知道目标页面是否在路由栈中，也不知道在第几层这些问题都可以通过封装路由文件和路由方法解决，提供开发效率，减少BUG，省下来的时间可以多陪陪女朋友封装路由文件，对路由进行统一管理在根目录创建router.js// 这是路由管理页面，在此统一配置路由\r\nexport default {\r\n  'index':'/index/index', // 首页\r\n  'list':'/list/list', // list页面\r\n  'top':'/top/top', // top页面\r\n}\r\n复制代码解决了第一个问题封装路由方法路由方法有五个，常用的有三个 switchTab 、 navigateTo 、 navigateBack简单介绍一下这五个方法及使用场景switchTab ,跳转tabBar页面专用，其他页面出栈，新页面入栈navigateTo 最常用的路由跳转，会加入到页面栈，允许返回，也就是新页面不断入栈navigateBack 返回，只能返回到页面栈中存在的页面，页面不断出栈，直到到达目标页redirectTo 关闭当前页面，跳转某个页面，当前页面不会加入到页面栈，也就是说当前页面不能通过返回到达，比如付款页面，付款完成后，最好不要再让用户返回到付款页，再比如一些无法修改的操作，比如删除商品，商品删除后再通过 navigateBack 返回再删除一次商品，体验肯定不好，表现为当前页面出栈，新页面入栈reLaunch 关闭所有页面，打开某个页面，可以打开任意页面包括tabBar，适合强制完成某个操作的页面，比如登录页，当已登录的用户点击退出后，进入登录页，那么就不能通过返回再回去了，就必须留下来登录或注册，适合用这个，表现为所有页面出栈，新页面入栈开始封装，在根目录创建utils.js// 封装路由方法\r\nexport default {\r\n\r\n  /** \r\n   * function\r\n   * @param {string} url 目标页面的路由\r\n   * @param {Object} param 传递给目标页面的参数\r\n   * @description  处理目标页面的参数，转成json字符串传递给param字段，在目标页面通过JSON.parse(options.param)接收\r\n   */  \r\n  navigateTo(url,param={}){\r\n    if(param){\r\n      url+=`?param=${JSON.stringify(param)}`\r\n    }\r\n    wx.navigateTo({\r\n      url:url,\r\n      fail(err) {\r\n        console.log('navigateTo跳转出错',err)  \r\n      },\r\n    })\r\n  },\r\n\r\n\r\n   /** \r\n   * function\r\n   * @param {string} url 目标页面的路由\r\n   * @param {Object} param 传递给目标页面的参数，只有页面栈无目标页面调用navigateTo时，参数才会生效，单单返回不能设置参数\r\n   * @description  先取出页面栈，页面栈最多十层，判断目标页面是否在页面栈中，如果在，则通过目标页的位置，返回到目标页面，否则调用navigateTo方法跳转到目标页\r\n   */   \r\n  navigateBack(url,param={}){\r\n    const pagesList = getCurrentPages()\r\n    let index =  pagesList.findIndex(e=>{\r\n      return url.indexOf(e.route)>=0\r\n    })\r\n    if(index == -1){  // 没有在页面栈中，可以调用navigateTo方法\r\n      this.navigateTo(url,param)\r\n    }else{\r\n      wx.navigateBack({\r\n        delta: pagesList.length-1-index,\r\n        fail(err){\r\n          console.log('navigateBack返回出错',err)\r\n        }\r\n      })\r\n    }\r\n  },\r\n\r\n\r\n  switchTab(url){ // 封装switchTab，switchTab不能有参数\r\n    wx.switchTab({\r\n      url:url\r\n    })\r\n  },\r\n  redirectTo(url,param={}){ // 封装redirectTo，和navigateTo没啥区别\r\n    if(param){\r\n      url+=`?param=${JSON.stringify(param)}`\r\n    }\r\n    wx.redirectTo({\r\n      url:url,\r\n      fail(err) {\r\n        console.log('redirectTo跳转出错',err)  \r\n      },\r\n    })\r\n  },\r\n  reLaunch(url,param={}){ // 封装reLaunch，和navigateTo没啥区别\r\n    if(param){\r\n      url+=`?param=${JSON.stringify(param)}`要根据具体业务来，该返回就返回，该跳转就用跳转，不能一直跳转！\r\n    }\r\n    wx.reLaunch({\r\n      url:url,\r\n      fail(err) {\r\n        console.log('reLaunch跳转出错',err)  \r\n      },\r\n    })\r\n  }\r\n}\r\n复制代码以上对参数的封装解决了第二个问题，对 navigateBack 的封装解决了第三个问题"}
{"title": "小程序canvas生成海报优化方案 ", "author": "Rolan", "pub_time": "2019-5-30 00:43", "content": "海报生成速度缓慢问题的优化微信头像在app.js中预先加载缓存多图片异步加载流程中断处理二次授权失败的处理请求或者下载图片失败处理保存图片可被压缩海报生成速度缓慢问题的优化原因分析：主要的时间消耗在于 getImageInfo 网络请求获取头像和 下载图片 获得临时地址的过程，可以看到海报中有3张图片（微信头像、主图、动态二维码（对应不同新闻的ID））需要下载，接下来主要就是对这3张图的优化微信头像在app.js中预先加载缓存//app.js\r\n//可以在app.js中使用小程序默认的全局变量，将头像在加载的时候预先缓存\r\nApp({\r\n    onLaunch: function () {\r\n        // 获取用户信息\r\n        wx.getSetting({\r\n            success: res => {\r\n                if (res.authSetting['scope.userInfo']) {\r\n                    // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n                    wx.getUserInfo({\r\n                        success: res => {\r\n                            this.globalData.userInfo = res.userInfo;\r\n                            //从返回值中获取微信头像地址\r\n                            let WxHeader = res.userInfo.avatarUrl;  \r\n                            wx.getImageInfo({\r\n                                src: WxHeader,//下载微信头像获得临时地址\r\n                                success: res => {\r\n                                    //将头像缓存在全局变量里\r\n                                    this.globalData.avatarUrlTempPath = res.path;\r\n                                },\r\n                                fail: res => {\r\n                                    //失败回调\r\n                                }\r\n                            });\r\n                        }\r\n                    })\r\n                }\r\n            }\r\n        })\r\n    },\r\n    globalData: {\r\n        userInfo: null,\r\n        //如果用户没有授权，无法在加载小程序的时候获取头像，就使用默认头像\r\n        avatarUrlTempPath: \"./images/defaultHeader.jpg\"\r\n    }\r\n})\r\n复制代码大致思路是：加载App.js的时候 ==> getSetting(判断是否授权)==> getUserInfo（获取头像）==> getImageInfo（生成临时地址）将需要的网络请求在加载小程序的时候就异步完成，提前将临时地址缓存在全局变量globalData中，这样当用户进入新闻页面，点击生成海报的时候就不需要在请求微信头像，缩短了不少时间。注意：如果用户一开始没有微信授权，生成海报时又必须要用户头像不能使用默认的话，那就只能老老实实走之前的流程了。多图片异步加载let num = 0; //下载图片计数器，假设一共三张图片\r\n//下载图片1\r\nwx.getImageInfo({\r\n    src: image_1,\r\n    success: function (res) {\r\n        //判断是否是最后一张图\r\n        if (num >= 2) {\r\n            console.log(\"图片全部下载完毕，可以绘制海报\")\r\n        } else {\r\n            //如果不是最后一张图则+1，继续\r\n            num++;\r\n        }\r\n    },\r\n    fail: function (res) {\r\n        //失败回调\r\n    }\r\n});\r\n//下载图片2\r\nwx.getImageInfo({\r\n    src: image_2,\r\n    success: function (res) {\r\n        //判断是否是最后一张图\r\n        if (num >= 2) {\r\n            console.log(\"图片全部下载完毕，可以绘制海报\")\r\n        } else {\r\n            //如果不是最后一张图则+1，继续\r\n            num++;\r\n        }\r\n    }\r\n});\r\n......\r\n复制代码这里 智库君 一开始是使用promise的同步办法，但是发现3张图片 阻塞严重 ，如果一张图片 下载过慢 ，就会影响整个海报生成时间，所以可以改为添加 计数器 判断的异步方法。当海报生成需要多张图片的时候，完全可以异步的方式加载他们，通过计数器判断是否是最后一张。流程中断处理从图中可以看出，整个海报生成过程有二次授权： 用户信息授权获取头像 和 保存相册授权 ，非常可能因为用户的误点或者拒绝而导致流程中断。主要分为二种情况：需要的图片没有拿到，我们可以采取 使用默认图片 的方式替代。保存相册授权被拒绝，我们可以提示用户“截图保存”，由于当前版本6.7.2+的**wx.openSetting()**被限制（无法直接被调用），如果必须要相册权限，我们可以通过showModal触发。API/组件名称终端类型微信版本触发方法openSetting6.7.22.3.0showModal// 关于 openSetting 的调用方法\r\nwx.showModal({\r\n    title: '相册权限',\r\n    content: '需要你提供保存相册权限',\r\n    success: function (res) {\r\n        if (res.confirm) {\r\n            wx.openSetting({\r\n                success(settingdata) {\r\n                    console.log(settingdata)\r\n                    if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                        console.log('获取 相册 权限成功，给出再次点击图片保存到相册的提示。');\r\n                    } else {\r\n                        console.log('获取 相册 权限失败，给出不给权限就无法正常使用的提示')\r\n                    }\r\n                }\r\n            })\r\n        }\r\n    }\r\n})\r\n\r\n//获取相册权限的流程处理\r\nwx.saveImageToPhotosAlbum({\r\n    filePath: res.tempFilePath,  //canvasToTempFilePath API生成的临时地址\r\n    success: function (data) {\r\n        console.log(\"提示图片保存成功\");\r\n    },\r\n    fail: function (err) {\r\n        console.log(err);\r\n        if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n            console.log(\"当初用户拒绝，再次发起授权\")\r\n            //调用上面说到的方法  wx.openSetting\r\n        } else {\r\n            console.log(\"提示：请截屏保存分享\");\r\n        }\r\n    },\r\n    complete(res) {\r\n        console.log(res);\r\n    }\r\n})\r\n复制代码保存图片可被压缩小程序官方提供了一个API可以设置用户保存图片的质量， 仅针对JPG 。属性默认值说明最低版本quality1.0图片的质量，取值范围为 (0, 1]1.7.0wx.canvasToTempFilePath({\r\n    fileType: 'jpg',\r\n    canvasId: 'canvasId',\r\n    quality:0.8,  //设置JPG保存质量 80%\r\n    success: res => {\r\n    \r\n    },\r\n    fail:res => {\r\n    }\r\n}, this)\r\n复制代码官方说明： developers.weixin.qq.com/miniprogram…"}
{"title": "Canvas 实现小程序动画 ", "author": "Rolan", "pub_time": "2019-5-29 00:55", "content": "这个 Demo 是去年刚接触小程序没多久写的，直接扔在文件夹角落里有点可惜，就拿出来分享给刚入门的同学参考。源代码没有写备注，函数名就是备注，看函数名应该能猜到我是写什么端的。\r\n文中动画都是 Canvas 绘制的，这里就不贴代码了，直接看效果图，有感兴趣的想看实现的点击这里看源码。\r\n1. 绘制贝塞尔曲线\r\n\r\n2. 自定义路径动画\r\n\r\n3. 自定义动画速度曲线\r\n3.1 淡入淡出\r\n\r\n3.2 淡出\r\n\r\n3.3 弹簧"}
{"title": "小程序 多图列表 性能优化 ", "author": "Rolan", "pub_time": "2019-5-29 00:32", "content": "小程序 多图列表 性能优化写这篇文章的缘由: 最近在公司的小程序项目中遇到了页面图片元素过多导致的性能问题. 从小程序提供的性能检测面板分析, 确定是图片元素占用了过多内存导致.因为本人之前主要是做桌面端应用开发和原生app开发, 没有太顾及过移动端图片的内存占用问题. 这次既然遇到了, 也就趁这个机会学习一下其优化的技巧.什么造成的性能问题简单的来说: DOM节点过多 && 图片节点过多DOM节点过多会造成更多的内存占用. 按照目前的微信小程序限制, 内存占用500M以上会出现卡顿, 甚至闪退. 如果列表中节点没有图片标签, 内存占用现象还不会太明显, 只是DOM节点过多会造成页面渲染耗时增加. 但当列表节点中含有图片时, 内存占用会迅速攀升.如何解决这两点呢?对于上面两点, 我们分别有对应的优化思路1. DOM节点过多.对于无限加载的页面, 列表中每一个元素都有大量的子节点. 当列表数目增加时, 页面的总节点数会暴增. 以小红书的小程序为例:上图中可以看到, 该页面为很多的卡片组成的列表页面. 假设一个卡片的DOM子节点数为 30, 那么当列表元素加载到1000时, 页面会有 30 * 1000 = 30,000 个DOM节点. 小程序显然是吃不消的 (注: 微信小程序推荐总节点数不超过: 1000 )那我们该如何处理来减少节点数呢?思路很简单: 我们可以只对用户当前屏幕和上下两屏进行真实内容的加载, 对于其他用户暂时不可见的地方, 用空白的节点进行占位. 这样处理后, 实际有内容的卡片数目不超过5个, 页面的总节点数为: 5 * 30 + 995 = 1145 . 相对于之前的节点数有了巨大的改进.让我们来看看代码的实现写代码前, 让我们整理一下需要的数据结构.首先这是一个列表页面, 我们需要一个 List来保存页面显示的数据: showCards . showCards 中只会保存5条真实数据, 其余数据展示以空对象填充.我们还需要一个保存所有真实数据的List, 这样当用户滑动页面时, 我们才能实时获取需要显示的卡片真实数据: totalCardsPage({\r\n  showCards: [],\r\n  totalCards: []\r\n})接下来我们来写页面布局部分:<view wx:for=\"{{showCards}}\"\r\n        wx:key=\"{{index}}\">\r\n\r\n    <self-define-component data-card-data=\"{{item}}\">\r\n    </self-define-component>\r\n    \r\n</view>简单的代码框架就是这样 (这里省略了很多不影响理解思路的代码细节)我们先实现没有优化DOM节点的代码逻辑. 在页面滑动到最底部时, 向 showCards push进新的卡片, 并通过 setData 更新页面. 这样就实现了一个简单的下拉无限加载的列表页面.async onReachBottom() {\r\n    const newCards = await fetchNewCards();\r\n  this.data.showCards.push(newCards);\r\n  this.setData({\r\n    showCards: this.data.showCards\r\n  })\r\n},接下来我们实现优化DOM节点的代码逻辑.我们会再用户滑动页面( onScroll 事件) 时, 对当前页面每个 card 的位置进行判断, 如果该 card在用户可见范围内的上下两屏内, 则展示真实数据, 否则将其替换为宽高与原卡片一致的空白占位节点.在 Page 的 onPageScroll 回调中, 我们进行回收函数的调用 (注意这里回调时要进行 节流 处理, 否则频繁调用会导致页面闪动) . 让我们看看这个回收页面节点函数的主要逻辑:回调中, 我们首先通过小程序提供的获取页面元素位置的api: createSelectorQuery().boundingClientRect 来拿到每个卡片的位置信息.接下来, 我们通过位置信息, 判断是否展示card的真实数据. 对于不展示真实数据的card, 我们需要保存其高度信息, 以便在渲染页面时使用高度信息填充页面. 同时我们给空card一个 type 属性, 方便我们在 wxml中渲染时判断卡片类型.async onScrollCallback() {\r\n  try {\r\n    const rectList = await this.calcCardsHeight();\r\n    this.recycleCard(rectList);\r\n  } catch (e) {\r\n    console.error(e);\r\n  }\r\n}\r\n  calcFeedHeight() {\r\n    return new Promise((resolve, reject) => {\r\n      this.createSelectorQuery()\r\n        .selectAll(`.card`)\r\n        .boundingClientRect(rectList => {\r\n          resolve(rectList);\r\n        })\r\n        .exec()\r\n    })\r\n  },\r\n\r\n  recycleCard(rectList) {\r\n    const newShowCards = [];\r\n    for (let i = 0; i < this.data.showCards.length; i++) {\r\n      const rect = rectList[i];\r\n      if (rect && Math.abs(rectList[i].top - 0) > pageHeight * 2) {\r\n        newShowCards.push({\r\n          type: 'empty-card',\r\n          height: rectList[i].bottom - rectList[i].top\r\n        });\r\n      } else {\r\n          const feed = totalCards[i];\r\n        newShowCards.push(feed);\r\n      }\r\n    }\r\n    this.setData({\r\n      showCards: newShowCards\r\n    });\r\n  }接下来, 我们要对wxml布局文件进行相应的修改:<view wx:for=\"{{showCards}}\"\r\n        wx:key=\"{{index}}\">\r\n\r\n    <view wx:if=\"{{item.type === 'empty-card'}}\"\r\n          class=\"card empty-card\"\r\n          style=\"height: {{item.height}}px\">\r\n    </view>\r\n\r\n    <self-define-component  wx:if=\"{{item.type !== 'empty-card'}}\"\r\n                data-card-data=\"{{item}}\"\r\n                class=\"card read-card\">\r\n    </self-define-component>\r\n    \r\n  </view>这样, 我们就解决了 DOM节点数目过多的问题. 并且最大限度的不影响用户的体验. (虽然用户快速上下滑动时还是会看到一些空白, 但大多数情况用户不会非常快速的上下滑, 而是阅读内容并慢速滑动)2. 图片节点过多通过上面一步的优化, 我们其实已经大幅减少了页面加载的图片数目. 但是有些情况, 我们的列表中的每一个卡片并不是只有一张图, 有时我们的图片组件是一个 swiper . 我们假设每个swiper平均展示10张图片, 那么我们展示5张card的话, <Image/> 节点就有 50 个. 对于一些低端的安卓机, 这样的开销依然会造成卡顿.那有什么好的优化方案呢? 前面一个问题, 我们的优化思路是在用户看不见的地方, 将节点简化展示.同样的, 对于swiper控件, 用户能看到的也就是 当前图片 以及 滑动可见的左右两张图片 . 其余位置的图片是可以简化展示的. 从下图可以看到, 其实需要立即加载的图片只有三张. (红色的框代表的是swiper组件的可视区域)我们使用一个变量记录当前swiper控件展示图片的坐标: curIndex , 然后我们改造一下 wxml布局文件. 代码逻辑很简单, 就是通过判断当前Image 节点的index和swiper展示节点的 index之间距离, 大于2就不显示.经过这样的处理后, 我们的每个swiper组件, 最多只会有三个占用实际内存的 <Image/> 节点.<swiper-item wx:for=\"{{images}}\"\r\n                   wx:key=\"{{index}}\">\r\n\r\n        <view >\r\n          <image class=\"img\"\r\n                 mode=\"widthFix\"\r\n                 src=\"{{index - curIndex < 2 && index - curIndex > -2 ? item.url : ''}}\">\r\n          </image>\r\n        </view>\r\n      </swiper-item>最后以上就是我在这次性能优化中用到的一些小技巧, 希望能为你带来一些帮助 :)如果你对我的文章感兴趣, 这里有我的一些 数据可视化 ， D3.js 方面的文章， 欢迎 fork && star：https://github.com/ssthouse/s..."}
{"title": "如何将老项目的小程序快速改为分包模式 ", "author": "Rolan", "pub_time": "2019-5-29 00:47", "content": "背景\r\n在最开始准备制作小程序的时候，为了求开发的快速，所使用了直接page的引入方式，每次小程序加载都是全包下载。3月份之前小程序页面稳定在35个，下载耗时在1800ms左右，4月份初上线了新业务页面膨胀到52个页面时，下载耗时基本稳定在2300ms左右，随着用户反馈越来越多，所以开始准备小程序采用分包加载，来解决这个问题。5月份在分包加载之后，页面依旧稳定在52个，但是下载耗时稳定800ms左右，缩短了将近1500ms。基本做到了0业务入侵、加入npm script 来实现新建页面，同时兼容分包加载，page加载。\r\n操作流程\r\n执行命令\r\nnpm run new\r\n复制代码给出信息提示，并且要求输入路径\r\n[Info] 帮助你快速创建page文件\r\n[Info] 只局限于新目录创建\r\n[Info] 请输入文件路径，已帮你省略pages/\r\n[Info] 例子：address/addressList\r\n? 请输入文件路径：\r\n复制代码输入路径之后创建文件的提示\r\n[Info] 已创建base64.js\r\n[Info] 已创建index.js\r\n[Info] 已创建index.json\r\n[Info] 已创建index.wxml\r\n[Info] 已创建index.wxss\r\n[Info] 创建完成！！！！\r\n复制代码选择包，是主包、还是分包，并且提示，给出提示，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n? 你想生成什么样的包： (Use arrow keys)\r\n❯ 主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar\r\n  分包，在subpackages中写入\r\n复制代码单选完成之后提示新建成功\r\n[Info] 写入成功\r\n复制代码第一次分包\r\n首先我们对未分包和分包的app.json代码进行对比\r\n// 未分包\r\n\"pages\": [\r\n  \"pages/a/index\",\r\n  \"pages/b/index\",\r\n  \"pages/b/list\",\r\n]\r\n复制代码// 实现分包\r\n\"subpackages\": [\r\n  {\r\n    \"root\": \"pages/a\",\r\n    \"pages\": [\r\n      \"index\",\r\n    ]\r\n  },\r\n  {\r\n    \"root\": \"pages/b\",\r\n    \"pages\": [\r\n      \"index\",\r\n      \"list\"\r\n    ]\r\n  }\r\n]\r\n复制代码接下来看目录结构\r\npages\r\n  |---- a\r\n        |---- index.js\r\n  |---- b\r\n        |---- index.js\r\n        |---- list.js\r\napp.json\r\n复制代码简单分一下，第一次分包的核心业务是，将pages这个普通列表，变成名为subpackages的二叉树结构，左子节点是root，右子节点是pages，并且右子节点是string类型，左子节点是array类型。好吧，我可以定下规则，首先我可以将pages/a/index这个字符串变为数组以/为分界的['pages','a','index']数组，然后我将前两项作为root节点的参数，用slice操作截取出来，转为字符串类型，赋值给root。之后的所有参数，我都赋值或者push给pages参数，最后我就得到了这样一个符合要求的树，最后push进subpackages即可。至于数据源，我只需要读出app.json这个文件的pages参数，并且通过我的方法写入subpackages参数即可。\r\n要点\r\n\r\n去重，因为subpackages内，root节点是唯一的，但是在pages里面可能我会截取初重复的值\r\n\r\n解决\r\n\r\n使用Map结构，把截取出的root值作为key，剩下的作为value，Map数据这种数据结构的特点就是key值唯一。\r\n\r\nlet list = [\r\n  \"pages/a/index\",\r\n  \"pages/a/list\",\r\n  \"pages/a/detail/index\",\r\n  \"pages/c/list\",\r\n  \"pages/b/index\",\r\n];\r\n\r\nlet m = new Map();\r\nlet packages = [];\r\nlist.forEach(v=>{\r\n  let arr = v.split('/');\r\n  let root = arr.splice(0,2).join('/');\r\n  let pages = arr.join('/');\r\n\r\n  if(m.get(root)){\r\n    let s = m.get(root);\r\n    m.set(root,[...s, pages]);\r\n  }else{\r\n    m.set(root,[pages]);\r\n  };\r\n});\r\nfor(let [key,value] of m){\r\n  packages.push({\r\n    root: key,\r\n    pages: value,\r\n  })\r\n}\r\n\r\nconsole.log(packages);\r\n复制代码// log 出的结构\r\n[\r\n  { root: 'pages/a', pages: [ 'index', 'list', 'detail/index' ] },\r\n  { root: 'pages/c', pages: [ 'list' ] },\r\n  { root: 'pages/b', pages: [ 'index' ] }\r\n]\r\n复制代码我已经在不入侵业务的情况下实现了小程序的第一次分包，节约了我手动去改的劳动力，我个人认为，解决问题，上策用数据结构，中策写兼容代码，下策手动去改。至于，读出写入文件，我就不赘述了，google即可。\r\n创建新pages的指令编写\r\n好吧，我实现了第一次的分包。然后我要思考，如果我每次要加页面的话，是不是就要去查看subpackages，找到对应的root，并且添加pages。这么重复劳动力的操作，我为什么不用脚本替代呢，是吧。\r\n核心需求\r\n\r\n编写交互式的命令输入\r\n检测输入的page目录是否存在，存在就报错\r\n不存在创建page目录，复制template到新建的page中\r\n根据使用者的单选，选择写入pages，或者写入subpackages\r\n在page文件加中设置预留文件夹，用做初级业务拆分，不加入subpackages检测\r\n屏蔽app.json中pages的文件，不加入subpackages检测\r\n\r\n设计npm script\r\n{\r\n  \"subcontract\": \"node ./config/subcontract\",\r\n  \"new\": \"node ./config/new\"\r\n}  \r\n复制代码添加的package.json参数，ignore-files表示文件夹中不检测的文件，pages表式app.json中的文件\r\n{\r\n  \"ignore-files\": [\r\n    \"**/common/**\",\r\n    \"**/component/**\",\r\n    \"**/<name>/**\",\r\n    \"**/<name>/**\",\r\n    \"**/<name>/**\",\r\n  ],\r\n  \"pages\": [\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n    \"pages/<name>/index\",\r\n  ]\r\n}\r\n复制代码需求已经明确，我就要去找我需要用到的npm包了\r\ncolors        命令行颜色\r\ninquirer      交互式命令行\r\nglob          全局搜索文件\r\nfs-extra      文件写入写出\r\npath          路径\r\nshelljs       执行shell命令\r\n复制代码分析new.js文件\r\nconst colors = require('colors');\r\nconst inquirer = require('inquirer');\r\nconst glob = require('glob');\r\nconst fs = require('fs-extra');\r\nconst path = require('path');\r\nconst shell = require('shelljs');\r\nconst PKG = require('../package.json');\r\nconst ROOT = path.resolve(__dirname, '../');\r\n\r\nlet appJson = require('../app.json');\r\nconst promps = [{\r\n  type: 'input',\r\n  name: 'pagePath',\r\n  message: '请输入文件路径：',\r\n},\r\n{\r\n  type: 'list',\r\n  name: 'type',\r\n  message: '你想生成什么样的包：',\r\n  choices: [\r\n    {\r\n      name: '主包，在pages中写入，如果是tabBar中使用，只能选择主包，并且手动配置app.json的tabBar',\r\n      value: '1',\r\n    },\r\n    {\r\n      name: '分包，在subpackages中写入',\r\n      value: '2',\r\n    },\r\n  ],\r\n}];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nlogger.info('帮助你快速创建page文件');\r\nlogger.info('只局限于新目录创建');\r\nlogger.info('请输入文件路径，已帮你省略pages/');\r\nlogger.info('例子：xxxxx/xxxx');\r\n复制代码这是代码中的常量部分和默认提示部分，我写了logeer对象来作为提示输出的默认颜色，promps作为我交互命令行的基础配置。引入package.json我的主要目的是因为我屏蔽了一些文件ignore-files和pages，想这两个参数的文件夹我是不会被检测的，不会被加入到subpackages的。\r\nfunction checkFile(name) {\r\n  const options = {\r\n    ignore: [\r\n      '**/*.js',\r\n      '**/*.wxss',\r\n      '**/*.wxml',\r\n      '**/*.json',\r\n    ],\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**', options);\r\n  if (files.some((v) => v === name)) {\r\n    logger.error('输入的目录已经存在，已终止！！！！');\r\n    return false;\r\n  };\r\n  return name;\r\n};\r\n复制代码在这是检测文件是否存在的方法，只需要传入路径，即可检测这个路径是否在pages/目录中存在。\r\nfunction buildFile(name) {\r\n  const options = {\r\n    cwd: 'template/page',\r\n  };\r\n  const files = glob.sync(`**`, options);\r\n\r\n  files.forEach((v)=>{\r\n    const file = v.split('.tp')[0];\r\n    fs.copy(`${ROOT}/template/page/${v}`, `${ROOT}/pages/${name}/${file}`, (err) => {\r\n      if (err) {\r\n        console.error(err);\r\n        return false;\r\n      }\r\n    });\r\n    logger.info(`已创建${file}`);\r\n  });\r\n  logger.info('创建完成！！！！');\r\n  return true;\r\n};\r\n复制代码这是复制文件夹并且复制模版文件的方法，我准备了tempalte这个文件夹，用来存储我写的模版文件，创建完成之后，我直接复制进去即可。为了和普通文件区别，我添加的.tp后缀。我的模版是可扩展的，我可以把request、app({...})在其中写好，并且添加我个人的一些方法。\r\nfunction subcontract(res) {\r\n  inquirer.prompt(promps[1]).then((answers)=>{\r\n    if (answers.type === '1') {\r\n      PKG['ignore-files'].push(`${res}/**`);\r\n      PKG['pages'].push(`${res}/index`);\r\n      appJson['pages'].push(`pages/${res}/index`);\r\n      fs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\n      fs.writeFileSync(`${ROOT}/package.json`, JSON.stringify(PKG, null, 2));\r\n      logger.info('写入成功');\r\n    };\r\n    if (answers.type === '2') shell.exec('npm run subcontract');\r\n  });\r\n};\r\n复制代码这是选择pages还是subcontract的方法，选择了subcontract，我直接执行我上面写的小程序分包方法subcontract.js即可。如果选择pages，我会将它加入package.json中的pages对象，这个对象表式这些文件名不被subcontract脚本检测。\r\nasync function inquirers() {\r\n  const {pagePath} = await inquirer.prompt(promps[0]);\r\n  const path = pagePath.replace(/\\s+/g, '');\r\n\r\n  if (!path) {\r\n    logger.error('输入有失误，已终止！！！！');\r\n    return false;\r\n  };\r\n  if (/.*[\\u4e00-\\u9fa5]+.*$/.test(path)) {\r\n    logger.error('请不要输入中文符号，已终止！！！！');\r\n    return false;\r\n  };\r\n\r\n  return path;\r\n};\r\n复制代码检测输入值是否合法，是否有中文，并且去除空格\r\n( async function() {\r\n  const inquirerRes = await inquirers();\r\n  const checkFileRes = inquirerRes && checkFile(inquirerRes);\r\n  const buildFileRes = checkFileRes && buildFile(checkFileRes);\r\n  buildFileRes && subcontract(checkFileRes);\r\n})();\r\n复制代码最后组装，inquirerRes变量负责判断输入值是否正确。然后进入checkFile，来检测文件夹是否重复。调用buildFile方法，创建文件夹，复制模版文件。最后调用subcontract来判断是分包还是主包。\r\nsubcontract.js 分析\r\nconst glob = require('glob');\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst colors = require('colors');\r\nconst ROOT = path.resolve(__dirname, '../');\r\nconst PAG = require('../package.json');\r\nlet appJson = require('../app.json');\r\n\r\nconst ignoreFiles = PAG['ignore-files'];\r\nconst pages = PAG['pages'];\r\nconst logger = {\r\n  info(msg) {\r\n    console.log(`[Info] ${colors.green(msg)}`);\r\n  },\r\n  warn(msg) {\r\n    console.log(`[Warn] ${colors.yellow(msg)}`);\r\n  },\r\n  error(msg) {\r\n    console.log(`[Error] ${colors.red(msg)}(／‵Д′)／~ ╧╧`);\r\n  },\r\n};\r\n\r\nconst subcontract = () => {\r\n  const options = {\r\n    ignore: ignoreFiles,\r\n    cwd: 'pages/',\r\n  };\r\n  const files = glob.sync('**/index.js', options);\r\n\r\n  let subcontractMap = new Map();\r\n  files.forEach((v)=>{\r\n    let arr = v.split('.')[0].split('/');\r\n    let root = arr.shift();\r\n    let page = arr.join('/');\r\n\r\n    if (subcontractMap.has(root)) {\r\n      let pages = subcontractMap.get(root);\r\n      pages.push(page);\r\n      subcontractMap.set(root, pages);\r\n    } else {\r\n      subcontractMap.set(root, [page]);\r\n    }\r\n  });\r\n\r\n  let subcontractList = [];\r\n  subcontractMap.forEach((v, k)=>{\r\n    subcontractList.push({\r\n      root: `pages/${k}`,\r\n      pages: v,\r\n    });\r\n  });\r\n\r\n  return subcontractList;\r\n};\r\n\r\nappJson.subpackages = subcontract();\r\nappJson.pages = pages;\r\nfs.writeFileSync(`${ROOT}/app.json`, JSON.stringify(appJson, null, 2));\r\nlogger.info('写入成功');\r\n复制代码这个方法其实和小程序第一次分包的方法大同小异。只不过我修改了数据源的获取，第一次我是读取app.json的pages，这里我是根据目录来的，以及加入了ignoreFiles来做文件屏蔽。以及一些友好提示。\r\n结尾\r\n项目优化的道路还有很长这只是最最初步的方案。为什么我开始不直接选择分包呢？因为项目开始的时候还没有分包，而且如果有，我感觉分包机制的这种书写方式，可能会带给开发者出错的可能性，我为了将项目工期缩短，出错可能性降低，我也不会选择一开始就分包。当业务增长到一定量，以及业务逐渐趋向于稳定时候，我就可以根据业务的特性，去做相对应的事情。这种方式我称之为技术迭代。在特定的时候，选择特定的解决方案，坚决不过度设计。"}
{"title": "仿iPhone通讯录制作小程序自定义选择组件 ", "author": "Rolan", "pub_time": "2019-5-29 00:39", "content": "前言近期闲来无事，想着闲着也是闲着，不如给自己搞点事情做！敢想敢做，于是选择了给微信小程序做个仿iPhone通讯录效果的自定义组件。先来整理一下，瞧瞧需要实现的核心功能。按照第一个字的首字母排序;实现输入搜索功能；侧边栏字母导航；从易到难，先来看看页面的结构布局。基本上分为3块：顶部的搜索区域；内容的展示区域；侧边字母导航栏区域；// index.wxml\r\n<view class=\"main\">\r\n  <!-- 顶部搜索区域 -->\r\n  <view class=\"header\">\r\n  </view>\r\n  <!-- 内容区域 -->\r\n  <scroll-view class=\"scroll\">\r\n  </scroll-view>\r\n  <!-- 侧边导航 -->\r\n  <view class=\"sub_nav\">\r\n  </view>\r\n</view>\r\n复制代码【顶部的搜索区域】一目了然就直接贴代码了。<view class=\"header\">\r\n    // 这里或许有人要问，为啥不用小程序的label组件呢。?_?\r\n    // 原因就是...我就不用，你还能咬我？！^(oo)^\r\n    // 哈哈哈哈～开个玩笑，其实是小程序的label组件还没支持input!\r\n    <view class=\"label\"> \r\n      <icon></icon>\r\n      <input type=\"text\" placeholder=\"搜索\" />\r\n    </view>\r\n</view>\r\n复制代码【内容的展示区域】再说一目了然会不会被打呢？根据图片就可以看出来，存在2个区域。红框包围的外框，负责圈定展示的范围；绿框包围的范围，包含有字母标题和对应的子项。代码如下：<scroll-view class=\"scroll\">\r\n    <view class=\"dl\">\r\n      <view class=\"dt\">这里是字母标题。</view>\r\n      <view class=\"dd\">\r\n        <span>这里当然是展示的内容啦。</span>\r\n      </view>\r\n    </view>\r\n  </scroll-view>\r\n复制代码【侧边字母导航栏区域】为了节省一下文章的篇幅，这里就不贴图了，很简单，就是并排下来就好了。<view class=\"sub_nav\">\r\n    <view class=\"option\">这里是输出字母。</view>\r\n</view>\r\n复制代码接下来是wxss的样式了。考虑到wxss的样式较多，我就直接贴代码链接吧，有兴趣的童鞋可以瞧瞧。完成之后，是时候贴个效果图了。（不许吐槽丑，宝宝会不开心的！）结构样式弄完了，也贴一下自定组件的基础文件// index.json\r\n{\r\n  \"component\": true\r\n}\r\n复制代码// index.js\r\nComponent({\r\n  properties: {}, // 组件的对外属性\r\n  data: {},       // 组件的内部数据\r\n  lifetimes: {},  // 生命周期\r\n  methods: {}     // 事件\r\n});\r\n复制代码现在开始实现功能了！！！按照第一个字的首字母排序说实话，实现这块功能呢，我是没啥头绪的，所以这个时候就要求助伟大的“度娘/Google”了。经过楼主“遍寻网络”，查找到如下页面的源码参考：因楼主问题，遗忘了该网址，如有知道的童鞋，贴个链接告诉下楼主，楼主立马麻溜的加上。源码的原理大概描述下：收录20902个汉字和375个多音字的Unicode编码，然后用JS切割首字母并转换成Unicode进行对比，最后返回对应首字母的拼音。// 汉字对应的Unicode编码文件\r\n// oMultiDiff = 多音字 | firstLetterMap = 汉字\r\nimport firstStore from './firstChineseLetter'; \r\n\r\n// 获取首字母拼音\r\nfunction getFirstLetter (val) {\r\n  const firstVal = val.charAt(0);\r\n  if (/.*[\\u4e00-\\u9fa5]+.*/.test(firstVal)) {\r\n    // 处理中文字符\r\n    // 转换成Unicode编码，与firstStore里面的数据进行对比，然后返回对应的参数\r\n    const code = firstVal.charCodeAt(0); // 转换成Unicode编码\r\n    return code in firstStore.oMultiDiff ? firstStore.oMultiDiff[code] : firstStore.firstLetterMap.charAt(code - 19968);\r\n  } else {\r\n    // 这里处理非中文\r\n    // 检测是否字母，如果是就直接返回大写的字母\r\n    // 不是的话，返回“#”\r\n    return /^[a-zA-Z]+$/.test(firstVal) ? firstVal.toUpperCase() : '#';\r\n  }\r\n}\r\n\r\ngetFirstLetter('东城区');\r\n// 输出结果：D\r\n\r\n复制代码firstChineseLetter.js地址获取首字母的方法有了之后，就该对数据进行处理了。首先定义一下组件所需要的参数。Component({\r\n  // 组件的对外属性\r\n  properties: {\r\n    data: { type: Array, value: [],  }, // 组件外传递进来的数据\r\n    attr: { type: String, value: 'label' }, // 需要进行首字母处理的属性，默认是\"label\"\r\n  },\r\n  ...\r\n})\r\n复制代码然后，针对组件外传递进来的数据，做一次转换。// 静态数据的存储\r\nconst Static = {\r\n  list: []\r\n}\r\n\r\nComponent({\r\n  ...\r\n  methods: {\r\n    // 初始/重置数据\r\n    init () {\r\n      const { data, attr } = this.properties;\r\n\r\n      let changeData = [], // 转换后的数据\r\n          inChangeData = {}; // 存储转换后的数据对应字母的索引值\r\n          \r\n      data.map(v => {\r\n        // 获取首字母拼音\r\n        let firstLetter = this.getFirstLetter(v[attr]); \r\n        \r\n        // 循环对比检测\r\n        firstLetter.split('').map(str => {\r\n          if (str in inChangeData) {\r\n            // 有首字母相同的项，\r\n            // 则添加入已有的项里面\r\n            changeData[inChangeData[str]].list.push(v);\r\n          } else {\r\n            // 没有首字母相同的项，\r\n            // 则在尾部追加一条新的数据，\r\n            // 储存对应的字母值（firstLetter），\r\n            // 同时存储该字母对应的索引\r\n            changeData.push({ firstLetter: str, list: [v] });\r\n            inChangeData[str] = changeData.length - 1;\r\n          }\r\n        });\r\n      });\r\n      \r\n      // 此时转换后的数组属于乱序，\r\n      // 需要对乱序的数组进行排序\r\n      changeData.sort((pre, next) => pre.firstLetter < next.firstLetter ? -1 : 1);\r\n      \r\n      // 若存在“#”项，将位置位移至底部\r\n      if (changeData[0].firstLetter === '#') {\r\n        const firstArr = changeData.splice(0, 1);\r\n        changeData = [...changeData, ...firstArr];\r\n      }\r\n\r\n      // 存储转换后的数据，\r\n      // this.data.list的数据对应页面的展示数据，因为有搜索功能，数据可能会变更，\r\n      // 在静态的数据里面，也存储1份数据，方便后续的搜索等功能。\r\n      this.setData({ list: changeData });\r\n      Static.list = changeData;\r\n    },\r\n  }\r\n  ...\r\n});\r\n复制代码初始化函数有了之后呢，当然是调用它啦。Component({\r\n  lifetimes: {\r\n    // 在组件实例进入页面节点树时执行初始化数据\r\n    attached () {\r\n      this.init();\r\n    }\r\n  },\r\n  observers: {\r\n    // 考虑到组件传递的数据存在变更的可能，\r\n    // 在数据变更的时候，也要做一次初始化\r\n    'data, attr, icon' (data, attr) {\r\n      this.init();\r\n    }\r\n  },\r\n})\r\n复制代码接下来是搜索功能啦～先给页面搜索框加个监听事件（input）<view class=\"main\">\r\n  ...\r\n  <view class=\"header\">\r\n    <view class=\"label\">\r\n      <icon></icon>\r\n      <input type=\"text\" placeholder=\"搜索\" value=\"{{ search }}\" bindinput=\"searchData\" />\r\n    </view>\r\n  </view>\r\n  ...\r\n</view>\r\n复制代码接着是JS的事件const Static = {\r\n  list: []\r\n}\r\n\r\nComponent({\r\n  ...\r\n  methods: {\r\n    searchData (e) {\r\n      const { value } = e.detail; // 用户输入的值\r\n      const { list } = Static; // init存储的静态数据，用来做数据对比\r\n      const { attr } = this.properties; // 要对比的属性值\r\n      let result = [], tem = {};\r\n      \r\n      // 没有搜索内容，返回全部内容\r\n      if (value.length === 0) { this.setData({ list: Static.list }); return; }\r\n\r\n      // 检索搜索内容\r\n      list.map(v => {\r\n        // 获取所有跟value匹配上的数据\r\n        const searchList = v.list.filter(v => v[attr].indexOf(value) !== -1);\r\n        \r\n        if (searchList.length > 0) {\r\n          // 此处原理类似楼上init的对比，此处不细说，\r\n          // 反正我懒我有理（0.0）\r\n          if (v.firstLetter in tem) {\r\n            const _list = result[tem[v.firstLetter]].lish;\r\n            result[tem[v.firstLetter]].lish = [..._list, ...searchList];\r\n          } else {\r\n            result.push({ firstLetter: v.firstLetter, list: [...searchList] });\r\n            tem[v.firstLetter] = result.length - 1;\r\n          }\r\n        }\r\n      });\r\n      \r\n      // 存储数据\r\n      this.setData({ list: result, search: value });\r\n    }\r\n  },\r\n  ...\r\n});\r\n复制代码侧边栏字母导航（突然觉得，写文好累啊！！！）写这块的时候呢，楼主发现了iPhone通讯录侧边导航栏有个问题，手指在字母导航栏上滑动的时候，有时候很难确认自己滑到了哪个区域？！然鹅这个问题呢，楼主发现了微信的通讯录，针对这块添加了手指滑动的时候，添加了个结构来帮助用户确认目前所处的区域。楼主本着学习的精神，借(chao)鉴(xi)了这个效果，来个效果图。贴一下新的wxml结构<!-- 侧边导航 -->\r\n  <view class=\"sub_nav\" id=\"subNav\" catchtouchstart=\"subTouchStart\" catchtouchmove=\"subTouchMove\" catchtouchend=\"subTouchEnd\">\r\n    <view class=\"option\" wx:for=\"{{ list }}\" data-firstLetter=\"{{ item.firstLetter }}\" wx:key=\"firstLetter\">\r\n      {{ item.firstLetter }}\r\n      <!-- 以下这块就是新增的结构啦 S -->\r\n      <view \r\n        class=\"max {{ item.firstLetter ===  scrollIntoView && subNavHint ? 'show' : '' }}\" \r\n        data-desc=\"{{ item.firstLetter }}\"\r\n      ></view>\r\n      <!-- 以上这块就是新增的结构啦 E -->\r\n    </view>\r\n  </view>\r\n复制代码const Static = {\r\n  list: [],\r\n  timer: null\r\n}\r\n\r\nComponent({\r\n  ...\r\n  data: {\r\n    scrollIntoView: '', // 标记当前处于哪个字母\r\n    subNavHint: false, // 控制借(chao)鉴(xi)微信效果的元素\r\n  },\r\n  methods: {\r\n    subTouchStart () {\r\n      this.setData({ subNavHint: true, scrollIntoView: '' });\r\n    },\r\n    subTouchEnd () {\r\n      this.setData({ subNavHint: false });\r\n    },\r\n    subTouchMove (e) {\r\n      // 获取字母导航栏元素对应的值\r\n      const query = this.createSelectorQuery();\r\n      query.select('#subNav').boundingClientRect();\r\n      query.selectViewport().scrollOffset();\r\n      query.exec(res => {\r\n        const { clientY } = e.touches[0]; // Y轴的位置\r\n        const DomTop = res[0].top; // 导航元素距离顶部的位置\r\n        const { list } = this.data;\r\n        \r\n        // 计算索引，\r\n        // 或许看到这里有人会疑问，为什么是除以20？\r\n        // 因为样式里面，我写的高度是20px，所以每个字母的区域是20px。\r\n        let index = Math.round((clientY - DomTop) / 20); \r\n        index = index >= list.length ? list.length - 1 : index; // 限制索引大于0\r\n        index = index < 0 ? 0 : index; // 限制索引小于0\r\n        // 限制结果重复赋值\r\n        if (list[index].firstLetter !== this.data.scrollIntoView) {\r\n          this.setData({ scrollIntoView: list[index].firstLetter });\r\n          // 加个抖动效果\r\n          wx.vibrateShort(); \r\n        }\r\n      });\r\n      }\r\n    },\r\n  }\r\n  ...\r\n});\r\n复制代码结语文章写到这呢，基本上核心的功能都已经实现啦～（终于写完了...）通过自己封装组件，楼主还是有挺大收获的！当然，这个组件还有很多可以继续完善的地方，有兴趣的童鞋呢，可以提出你的优化建议，楼主有时(xing)间(qu)的话，会继续完善下去。最后，还是推一下这个组件啦，希望它能帮到有需要的童鞋。github地址手写不易，欢迎提issues，欢迎star，内附有使用方法哦。"}
{"title": "PHP实现微信小程序用户授权的工具类 ", "author": "Rolan", "pub_time": "2019-3-5 00:23", "content": "事先准备工作1.申请一个小程序，申请地址： 传送门2.仔细阅读小程序的用户授权登陆官方文档： 《用户授权登陆的流程》3.仔细阅读微信用户数据解密的相关文档： 《用户数据解密说明文档》4.在小程序后台配置好相应的后端请求地址，路径是：开发---->开发设置，如图5.小程序如果需要做多个小程序的打通，还需要在 微信开放平台 绑定到开发者账号下面， 如果不需要union_id请忽略6.服务端准备一个用户授权的接口，假设接口链接为 http://test.dev.com/user/auth... ，此接口接受如下参数code：微信登陆接口返回的登陆凭证，用户获取session_keyiv：微信小程序登陆接口返回的向量，用于数据解密encrypted_data : 微信获取用户信息接口的返回的用户加密数据，用于后端的接口解析signature加密数据接口返回的数据如下{\r\n    \"errcode\": 200,\r\n    \"msg\": \"SUCCESS\",\r\n    \"data\": {\r\n        \"uid\": 34098,\r\n        \"unionid\": \"xxx\",\r\n    }\r\n}6.建表1）用户表，其中比较重要的字段是union_id，因为我们是有多个小程序和公众号，因此使用这个来区分唯一的用户编号DROP TABLE IF EXISTS `jz_wxa_user`;\r\nCREATE TABLE `jz_wxa_user` (\r\n  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,\r\n  `uid` bigint(18) DEFAULT NULL,\r\n  `openid` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT 'openid',\r\n  `user_name` varchar(100) CHARACTER SET utf8mb4 DEFAULT '',\r\n  `nick_name` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '用户昵称',\r\n  `sex` enum('0','1') CHARACTER SET utf8 DEFAULT '1' COMMENT '性别',\r\n  `avatar` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '用户头像',\r\n  `province` varchar(100) CHARACTER SET utf8 DEFAULT NULL COMMENT '省份',\r\n  `city` varchar(100) CHARACTER SET utf8 DEFAULT NULL COMMENT '城市',\r\n  `country` varchar(100) CHARACTER SET utf8 DEFAULT NULL COMMENT '国家',\r\n  `wx_union_id` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '公众平台的唯一id',\r\n  `from_url` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '来源url',\r\n  `created_at` timestamp NULL DEFAULT NULL,\r\n  `updated_at` timestamp NULL DEFAULT NULL,\r\n  `from_appid` varchar(30) COLLATE utf8mb4_unicode_ci DEFAULT 'wx95fc895bebd3743b' COMMENT '来源appid',\r\n  `wx_header` varchar(150) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '微信头像',\r\n  `gh_openid` varchar(60) COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '微信公众号openid',\r\n  `phone` varchar(30) CHARACTER SET utf8 DEFAULT '' COMMENT '手机号码',\r\n  PRIMARY KEY (`id`),\r\n  KEY `idx_uid_union_id` (`uid`,`wx_union_id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;实现步骤用户授权时序图关键代码小程序端小程序端的获取用户信息流程1）调用login方法获取code2）调用getUserInfo方法获取用户的加密数据3）调用后端的用户授权接口将用户信息保存到服务端4）保存后端接口返回的uid和unionid到localstorage中，作为全局参数获取用户的授权信息getUid:function(cf){\r\n    var that = this\r\n    wx.login({\r\n      success: function (ress) {\r\n        var code = ress.code \r\n        wx.getUserInfo({ \r\n          withCredentials: true,          \r\n          success: function (res) {\r\n            that.globalData.userInfo = res.userInfo;\r\n            that.authorize(code, res.signature, res.iv, res.rawData, res.encryptedData, cf)\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  authorize: function (code, signature, iv, rawData, encryptedData, cf) {\r\n    var that =this\r\n    var dataobj = {\r\n      code: code,\r\n      signature: signature,\r\n      iv: iv,\r\n      raw_data: rawData,\r\n      encrypted_data: encryptedData\r\n    }\r\n    console.log(\"code:\",code)\r\n    var param = JSON.stringify(dataobj)\r\n    param = that.Encrypt(param)\r\n    var url = that.data.API_DOMAIN2 + \"/user/authorization?param=\" + param\r\n    wx.request({\r\n      url: url,\r\n      method: \"GET\",\r\n      header: {\r\n        'content-type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        if (res.data.errcode == 200) {\r\n          wx.hideToast()       \r\n          wx.setStorage({\r\n            key: \"uid\",\r\n            data: res.data.data.uid,\r\n            success: function () {\r\n              if (cf) {\r\n                typeof cf == \"function\" && cf(res.data.data.uid)\r\n              }\r\n            }\r\n          })\r\n        } else {\r\n          that.exceptionHandle('uid', url, res.data.errcode, res.data.msg)\r\n        }\r\n      }\r\n    })\r\n  },服务端入口方法/**\r\n     * api接口开发\r\n     * 获取详情的接口\r\n     * @param $uid 用户编号\r\n     * @param $iv 向量\r\n     * @param $encryptedData 微信加密的数据\r\n     * @param $rawData 判断是否为今天\r\n     * @param $signature 签名\r\n     * @return array\r\n     */\r\n    public static function authorization($appid,$appsecret,$code,$iv,$encryptedData,$rawData,$signature){\r\n        $result = self::decodeWxData($appid,$appsecret,$code,$iv,$encryptedData);\r\n        if($result['errcode'] != 200){\r\n            return $result;\r\n        }\r\n        //处理微信授权的逻辑\r\n        $wxUserData = $result['data'];\r\n        error_log(\"authorization data=============>\");\r\n        error_log(json_encode($wxUserData));\r\n        $uid = WxaUserService::regWxaUser($wxUserData);\r\n        $data['uid'] = $uid['uid'];\r\n        $data['unionid'] =  $uid['unionid'];\r\n        $result['data'] = $data;\r\n        return $result;\r\n    }\r\n    \r\n    /**\r\n     * 解密微信的数据\r\n     * @param $code wx.login接口返回的code\r\n     * @param $iv wx.getUserInfo接口或者wx.getWeRunData返回的iv\r\n     * @param $encryptedData wx.getUserInfo接口或者wx.getWeRunData返回的加密数据\r\n     * @return array\r\n     */\r\n    public static function decodeWxData($appid,$appsecret,$code,$iv,$encryptedData){\r\n        $sessionKeyUrl = sprintf('%s?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code',config('param.wxa_user_info_session_key_url'),$appid,$appsecret,$code);\r\n        $rtnJson = curlRequest($sessionKeyUrl);\r\n        $data = json_decode($rtnJson,true);\r\n        error_log('authorization wx return data========>');\r\n        error_log($rtnJson);\r\n        if(isset($data['errcode'])){\r\n            return $data;\r\n        }\r\n        $sessionKey = $data['session_key'];\r\n        $wxHelper = new WxBizDataHelper($appid,$sessionKey,$encryptedData,$iv);\r\n        $data['errcode'] = 200;\r\n        $data['data'] = [];\r\n        if(!$wxData = $wxHelper->getData()){\r\n            $data['errcode'] = -1;\r\n        }else{\r\n            error_log('current wx return data is =========>'.json_encode($wxData));\r\n            $data['data'] = $wxData;\r\n        }\r\n        return $data;\r\n    }保存用户信息的方法/**\r\n     * 保存用户信息的方法\r\n     * @param $wxaUserData\r\n     * @param $regFromGh 表示是否从公众号进行注册\r\n     */\r\n    public function regWxaUser($wxaUserData,$regFromGh = false)\r\n    {\r\n        $value = $wxaUserData['unionId'];\r\n        $key = getCacheKey('redis_key.cache_key.zset_list.lock') . $value;\r\n        $newExpire = RedisHelper::getLock($key);\r\n        $data =  $this->storeWxaUser($wxaUserData,$regFromGh);\r\n        RedisHelper::releaseLock($key, $newExpire);\r\n        return $data;\r\n    }\r\n    \r\n    /**\r\n     * 保存信息\r\n     * @param $wxaUserData\r\n     * @return mixed\r\n     */\r\n    public function storeWxaUser($wxaUserData,$regFromGh = false)\r\n    {\r\n        $wxUnionId = $wxaUserData['unionId'];\r\n        if (!$user = $this->getByWxUnionId($wxUnionId)) {\r\n            $getAccountDataStartTime = time();\r\n            //这里是因为需要统一账户获取uid，所以这个是用户中心的接口，如果没有这个流程，则直接使用数据\r\n            if($accountData = AccountCenterHelper::regWxaUser($wxaUserData)){\r\n                $getAccountDataEndTime = time();\r\n                $accountRegTime = $getAccountDataEndTime - $getAccountDataStartTime;\r\n                error_log(\"reg user spend time is ===================>\" . $accountRegTime);\r\n                $user = [\r\n                    'uid' => $accountData['uid'],\r\n                    'user_name' => $accountData['user_name'],\r\n                    'nick_name' => $wxaUserData['nickName'],\r\n                    'sex' => $accountData['sex'],\r\n                    'wx_union_id' => $accountData['wx_union_id'],\r\n                    'avatar' => isset($accountData['avatar'])?$accountData['avatar']:\"\",\r\n                    'from_appid' => $accountData['from_appid'],\r\n                    'province' => $wxaUserData['province'],\r\n                    'city' => $wxaUserData['city'],\r\n                    'country' => $wxaUserData['country'],\r\n                    'openid' => $wxaUserData['openId'],\r\n                    'wx_header' => isset($wxaUserData['avatarUrl'])?$wxaUserData['avatarUrl']:\"\",\r\n                    'gh_openid' => $regFromGh?$wxaUserData['openId']:\"\",\r\n                ];\r\n                error_log(\"insert data=============>\" . json_encode($user));\r\n                $user = $this->store($user);\r\n                $regApiUserEndTime = time();\r\n                error_log(\" reg api user spend time================>\" . ($regApiUserEndTime - $getAccountDataEndTime));\r\n                error_log(\" after insert data=============>\" . json_encode($user));\r\n            }\r\n        }else{\r\n            if(!$user['wx_header']){\r\n                $updateData = [\r\n                    'id' => $user['id'],\r\n                    'uid' => $user['uid'],\r\n                    'wx_header' => $wxaUserData['avatarUrl'],\r\n                ];\r\n                $this->update($updateData);\r\n            }\r\n            //同步用户的openid\r\n            if($wxaUserData['openId'] != $user['openid']){\r\n                $updateData = [\r\n                    'id' => $user['id'],\r\n                    'uid' => $user['uid'],\r\n                    'openid' => $wxaUserData['openId'],\r\n                ];\r\n                $this->update($updateData);\r\n            }\r\n        }\r\n        $data['uid'] = $user['uid'];\r\n        $data['unionid'] = $wxUnionId;\r\n        return $data;\r\n    }根据unionid获取用户信息/**\r\n     * 根据unionid获取用户信息\r\n     */\r\n    public function getByWxUnionId($unionId)\r\n    {\r\n        $cacheKey = getCacheKey('redis_key.cache_key.wxa_user.info') . $unionId;\r\n        $value = $this->remember($cacheKey, function () use ($unionId) {\r\n            $userInfo = WxaUser::where('wx_union_id', $unionId)->first();\r\n            $userInfo = $this->compactUserInfo($userInfo);\r\n            return $userInfo;\r\n        });\r\n        return $value;\r\n    }WxBizDataHelper工具类<?php\r\n/**\r\n * Created by PhpStorm.\r\n * User: Auser\r\n * Time: 11:17\r\n */\r\n\r\nnamespace App\\Http\\Base\\Wx;\r\n\r\n\r\nclass WxBizDataHelper\r\n{\r\n\r\n    private $appid;\r\n    private $seesionKey ;\r\n    private $encryptedData;\r\n    private $iv;\r\n    public function __construct($appid, $sessionKey,$encryptedData, $iv)\r\n    {\r\n        $this->appid = $appid;\r\n        $this->seesionKey = $sessionKey;\r\n        $this->encryptedData = $encryptedData;\r\n        $this->iv = $iv;\r\n    }\r\n\r\n    public function getData(){\r\n        $pc = new WXBizDataCrypt($this->appid, $this->seesionKey);\r\n        $json = '';\r\n        $errCode = $pc->decryptData($this->encryptedData, $this->iv, $json);\r\n        $data = [];\r\n        if ($errCode == 0) {\r\n            $data = json_decode($json,true);\r\n        }\r\n        return $data;\r\n    }\r\n\r\n\r\n}WXBizDataCrypt工具类<?php\r\n/**\r\n * Created by PhpStorm.\r\n * User: Auser\r\n * Time: 10:38\r\n */\r\n\r\nnamespace App\\Http\\Base\\Wx;\r\n\r\nuse App\\Http\\Base\\Wx\\Prpcrypt;\r\nuse App\\Http\\Base\\Wx\\ErrorCode;\r\nuse App\\Http\\Base\\Wx\\PKCS7Encoder;\r\nclass WXBizDataCrypt\r\n{\r\n\r\n    private $appid;\r\n    private $sessionKey;\r\n\r\n    /**\r\n     * 构造函数\r\n     * @param $sessionKey string 用户在小程序登录后获取的会话密钥\r\n     * @param $appid string 小程序的appid\r\n     */\r\n    public function __construct( $appid, $sessionKey)\r\n    {\r\n        $this->sessionKey = $sessionKey;\r\n        $this->appid = $appid;\r\n    }\r\n\r\n\r\n    /**\r\n     * 检验数据的真实性，并且获取解密后的明文.\r\n     * @param $encryptedData string 加密的用户数据\r\n     * @param $iv string 与用户数据一同返回的初始向量\r\n     * @param $data string 解密后的原文\r\n     *\r\n     * @return int 成功0，失败返回对应的错误码\r\n     */\r\n    public function decryptData( $encryptedData, $iv, &$data )\r\n    {\r\n        if (strlen($this->sessionKey) != 24) {\r\n            return ErrorCode::$IllegalAesKey;\r\n        }\r\n        $aesKey=base64_decode($this->sessionKey);\r\n\r\n\r\n        if (strlen($iv) != 24) {\r\n            return ErrorCode::$IllegalIv;\r\n        }\r\n        $aesIV=base64_decode($iv);\r\n\r\n        $aesCipher=base64_decode($encryptedData);\r\n\r\n        $pc = new Prpcrypt($aesKey);\r\n        $result = $pc->decrypt($aesCipher,$aesIV);\r\n\r\n        if ($result[0] != 0) {\r\n            return $result[0];\r\n        }\r\n\r\n        $dataObj=json_decode( $result[1] );\r\n        if( $dataObj  == NULL )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        if( $dataObj->watermark->appid != $this->appid )\r\n        {\r\n            return ErrorCode::$IllegalBuffer;\r\n        }\r\n        $data = $result[1];\r\n        return ErrorCode::$OK;\r\n    }\r\n\r\n}Prpcrypt工具类<?php\r\n/**\r\n * Created by PhpStorm.\r\n * User: Auser\r\n * Time: 10:55\r\n */\r\n\r\nnamespace App\\Http\\Base\\Wx;\r\n\r\nclass Prpcrypt\r\n{\r\n    public $key;\r\n\r\n    public function __construct($key)\r\n    {\r\n        $this->key = $key;\r\n    }\r\n\r\n    /**\r\n     * 对密文进行解密\r\n     * @param string $aesCipher 需要解密的密文\r\n     * @param string $aesIV 解密的初始向量\r\n     * @return string 解密得到的明文\r\n     */\r\n    public function decrypt($aesCipher, $aesIV)\r\n    {\r\n\r\n        try {\r\n            $module = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');\r\n            mcrypt_generic_init($module, $this->key, $aesIV);\r\n            //解密\r\n            $decrypted = mdecrypt_generic($module, $aesCipher);\r\n            mcrypt_generic_deinit($module);\r\n            mcrypt_module_close($module);\r\n        } catch (Exception $e) {\r\n            return array(ErrorCode::$IllegalBuffer, null);\r\n        }\r\n\r\n\r\n        try {\r\n            $result = PKCS7Encoder2::decode($decrypted);\r\n        } catch (Exception $e) {\r\n            //print $e;\r\n            return array(ErrorCode::$IllegalBuffer, null);\r\n        }\r\n        return array(0, $result);\r\n    }\r\n}ErrorCode状态代码类<?php\r\n/**\r\n * Created by PhpStorm.\r\n * User: Auser\r\n * Time: 10:33\r\n */\r\n\r\nnamespace App\\Http\\Base\\Wx;\r\n\r\n\r\nclass ErrorCode\r\n{\r\n    public static $OK = 0;\r\n    public static $IllegalAesKey = -41001;\r\n    public static $IllegalIv = -41002;\r\n    public static $IllegalBuffer = -41003;\r\n    public static $DecodeBase64Error = -41004;\r\n\r\n}"}
{"title": "django与小程序实现登录验证功能 ", "author": "Rolan", "pub_time": "2019-2-20 00:12", "content": "之前用小程序做项目，因为后台使用的java开发，一切顺利，但切换成django做RESTful API接口时，在登陆注册时一直出现问题，网上搜索，借助一个网友的回答，找到了一种可行的解决方案，现记录如下。具体流程用户点击小程序页面上的登录授权认证通过微信自带的认证获取code调取登录接口，将code传入后台后台拿到code调用微信接口获取openid等用户信息后台将openid作为用户名，若存在则去校验用户信息，否则以此用户名创建新用户，密码随机生成将校验结果或者创建信息返回给微信小程序端根据返回的信息完成用户登录校验django的用户权限认证django有一套自己的完善用户模型，由于Django Auth自带的User模型字段有限，我们需要对其进行拓展(直接使用也可以)nickname = models.CharField(verbose_name=u'昵称',max_length=50, blank=True)\r\nuser_avatar =  models.ImageField(verbose_name=u'用户头像', upload_to='image/%Y/%m/%d', default=u'image/default.png', max_length=500)\r\nuser_email = models.EmailField(verbose_name=u'用户邮箱',max_length=254)\r\nuser_phone = models.BigIntegerField(verbose_name=u'手机号', null=True,blank=True)\r\nuser_birthday = models.DateField(verbose_name=u'出生日期', default = timezone.now)\r\nuser_sex = models.CharField(verbose_name=u'性别',max_length=6,choices=(('male','男'),('female','女')),default='male')\r\nuser_address = models.CharField(verbose_name=u'地址',max_length=550, blank=True,null=True)\r\nsignature = models.CharField(verbose_name=u'个性签名',max_length=550, blank=True,null=True)\r\n复制代码用户接口序列化from rest_framework import serializers\r\n\r\nclass UserSerializer(serializers.ModelSerializer):\r\nclass Meta:\r\n    model = User\r\n    fields = \"__all__\"\r\n复制代码登陆接口设计class UserLogin(APIView):\r\n    def post(self,request):\r\n        params = request.data\r\n        userName = get_openid(params.get('code'))\r\n        userInfo = params.get('userinfo')\r\n        try:\r\n            user = User.objects.get(username = userName)\r\n        except Exception as e:\r\n            user = None\r\n        if user:\r\n            # 更新用户信息\r\n            user = User.objects.get(username = userName)\r\n        else:\r\n            #注册新用户\r\n            user = User.objects.create_user(username=userName,password=random_str(10))    \r\n        #手动生成JWT\r\n        # 手动生成token验证\r\n        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\r\n        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\r\n        payload = jwt_payload_handler(user)\r\n        token = jwt_encode_handler(payload)\r\n\r\n        ret = {'code': '00000', 'msg': None,'data':{}}\r\n        \r\n        ret['msg'] = '授权成功'\r\n        ret['data'] = {\r\n            'token': token,\r\n            'user_id': user.id,\r\n            'nickname': user.nickname\r\n        }\r\n        return JsonResponse(ret)\r\n复制代码解析code获取openidclass OpenidUtils(object):\r\n    def __init__(self, jscode):\r\n        self.url = \"https://api.weixin.qq.com/sns/jscode2session\"\r\n        self.appid = APPID\r\n        self.secret = SECRET\r\n        self.jscode = jscode    # 前端传回的动态jscode\r\n\r\n    def get_openid(self):\r\n        url = self.url + \"?appid=\" + self.appid + \"&secret=\" + self.secret + \"&js_code=\" + self.jscode + \"&grant_type=authorization_code\"\r\n        r = requests.get(url)\r\n        openid = r.json()['openid']\r\n        return openid\r\n复制代码小程序的登陆验证具体登录流程可以查阅官方文档。function getWXUserInfo() {\r\n    const login = promisify(wx.login);\r\n    const getUserInfo = promisify(wx.getUserInfo);\r\n\r\n    return new Promise(function (resolve, reject) {\r\n        _wxLogin();\r\n        function _wxLogin() {\r\n            login().then(function (res) {\r\n                getUserInfo().then(function (r) {\r\n                    let userInfo = r;\r\n                    userInfo.code = res.code;\r\n                    try {\r\n                        wx.setStorageSync('userInfo', userInfo);\r\n                    } catch (e) {\r\n                        console.log(e)\r\n                    }\r\n                    if (userInfo && userInfo.code && userInfo.iv) {\r\n                        resolve(userInfo);\r\n                    }\r\n                    else {\r\n                        reject('wx login fail');\r\n                    }\r\n                }).catch(function (error) {\r\n                    reject(error);\r\n                });\r\n            }).catch(function (error) {\r\n                reject(error);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n//登录接口验证\r\ngetWXUserInfo().then(function (data) {\r\n    var result = {\r\n        code: 0,\r\n        data: {}\r\n    };\r\n    var params = {\r\n        'code':data.code,\r\n        'userinfo':data.userInfo\r\n    }\r\n    wx.request({\r\n        url: '/api/login',\r\n        data: params,\r\n        dataType: 'json',\r\n        method: 'POST',\r\n        success: function (response) {\r\n            // 返回成功\r\n            if (response.data && response.data.code == '00000') {\r\n                try {\r\n                    var resData = {\r\n                        custNo: data.user_id,\r\n                        nickname: data.nickname\r\n                    };\r\n                    result.code = 0;\r\n                    result.data = resData;\r\n                    resolve(result);\r\n                }\r\n                catch (e) {\r\n                    console.warn(result)\r\n                    // 登录失败\r\n                    result.code = 2;\r\n                    resolve(result);\r\n                }\r\n            }\r\n            else {\r\n                // 获取 customNum 失败\r\n                console.warn(result)\r\n                result.code = 1;\r\n                result.data = 'get customNum fail';\r\n                resolve(result);\r\n            }\r\n        }\r\n    })\r\n}\r\n复制代码"}
{"title": "小程序通过用户授权获取手机号之getPhoneNumber ", "author": "Rolan", "pub_time": "2019-3-13 18:38", "content": "小程序有一个获取用户很便捷的api，就是通过getPhoneNumber获取用户的已经绑定微信的手机号码。有一点要大家注意，现在微信和注重用户体验，有些方法都是需要用户主动去触发才能调用的，比如getPhoneNumber。官方文档：https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html实现思路：直接上干货：<button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\"></button>JS内getPhoneNumbe组件函数（该事件中最重要的就是在wx.login登录后发起接口请求），这里需要配置参数来给接口： 这些是必不可少的参数，这些齐备才能算一个合法的请求。appid: “你的小程序APPID”,secret: “你的小程序appsecret”,code: res.code,encryptedData: telObj,iv: ivObj最终结果展示：点击\"拒绝\"，开发者能捕捉到该事件 ，此时getPhoneNumber 函数返回 e.detail.errMsg 为 getPhoneNumber:user deny"}
{"title": "小程序自定义单页面、全局导航栏 ", "author": "Rolan", "pub_time": "2019-3-15 00:34", "content": "需求产品说小程序返回到首页不太方便，想添加返回首页按钮，UI说导航栏能不能设置背景图片，因为那样设计挺好看的。需求分析并制定方案这产品和UI都提需求了，咱也不能反驳哈，所以开始调研，分析可行性方案；1、可以添加悬浮按钮。2、自定义导航栏。添加悬浮按钮，是看起来是比较简单哈，但是感觉不太优雅，会占据页面的空间，体验也不太好。所以想了下第二种方案，自定义导航栏既可以实现产品的需求还可以满足UI的设计美感，在顶部空白处加上返回首页的按钮，这样和返回按钮还对称（最终如图所示，顶部导航栏是个背景图片，分两块组合起来）。实现方案一、实现的前提1、首先查看文档，看文档里关于自定义导航栏是怎么规定的，有哪些限制；下面分别是小程序自定义导航栏全局配置和单页面配置的微信版本和调试库的最低支持版本。在app.json window 增加 navigationStyle:custom ，顶部导航栏就会消失，只保留右上角胶囊状的按钮，如何修改胶囊的颜色呢;胶囊体目前只支持黑色和白色两种颜色 在app.josn window 加上 \"navigationBarTextStyle\":\"white/black\"还要考虑加返回按钮和返回首页的按钮，适配不同的机型先说下两种配置方法：①全局配置navigationStyle：调试基础库>=1.9.0微信客户端>=6.6.0app.json\r\n\r\n{\r\n  \"usingComponents\": {\r\n    \"navigationBar\": \"/components/navigationBar/navigationBar\"\r\n  },\r\n  \"window\": {\r\n    \"navigationStyle\": \"custom\"\r\n  } \r\n}单页面配置navigationStyle调试基础库>=2.4.3微信客户端版本>=7.0.0自定义的页面.json\r\n\r\n{\r\n  \"window\": {\r\n    \"navigationStyle\": \"default\"\r\n  } \r\n}\r\n{\r\n  \"navigationStyle\": \"custom\",\r\n  \"usingComponents\": {\r\n    \"navigationBar\": \"/components/navigationBar/navigationBar\"\r\n  }\r\n}两者的区别就是，全局配置放在app.json文件里，单页面配置放在自定义页面配置文件里。二、实现的步骤以下说下几个要点：1、自定义导航栏文本，是否显示返回，是否显示返回首页,导航栏高度2、statusBarHeight，用来获取手机状态栏的高度，这个需要在全局app.js中的onLaunch，调用wx.getSystemInfo获取，navigationBarHeight+默认的高度，这个是设定整个导航栏的高度，3、还有注意的，在写样式距离和大小时建议都用px，因小程序右边的胶囊也是用的px，不是rpx。4、因为自定义导航栏每个页面都要写，所以把导航栏封装了公共组件，这样只需要在每个页面引入即可。如下是封装的导航栏组件：wxml<view class=\"navbar\" style=\"{{'height: ' + navigationBarHeight}}\">\r\n  <view style=\"{{'height: ' + statusBarHeight}}\"></view>\r\n  <view class='title-container'>\r\n    <view class='capsule' wx:if=\"{{ back || home }}\">\r\n      <view bindtap='back' wx:if=\"{{back}}\">\r\n        <image src='/images/back.png'></image>         \r\n      </view>\r\n      <view bindtap='backHome' wx:if=\"{{home}}\">\r\n        <image src='/images/home.png'></image>\r\n      </view>\r\n    </view>\r\n    <view class='title'>{{text}}</view>\r\n  </view>\r\n</view>\r\n<view style=\"{{'height: ' + navigationBarHeight}};background: white;\"></view>这里有个需注意的问题，就是一般会出现自定义导航栏，下拉页面，导航栏也随着会下拉，这种问题是因为设置fixed后页面元素整体上移了navigationBarHeight，所以在此组件里设置一个空白view元素占用最上面的navigationBarHeight这块高度wxss.navbar {\r\n  width: 100%;\r\n  background-color: #1797eb;\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  z-index: 999;\r\n}\r\n.title-container {\r\n  height: 40px;\r\n  display: flex;\r\n  align-items: center;\r\n  position: relative;\r\n}\r\n.capsule {\r\n  margin-left: 10px;\r\n  height: 30px;\r\n  background: rgba(255, 255, 255, 0.6);\r\n  border: 1px solid #fff;\r\n  border-radius: 16px;\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n.capsule > view {\r\n  width: 45px;\r\n  height: 60%;\r\n  position: relative;\r\n.capsule > view:nth-child(2) {\r\n  border-left: 1px solid #fff;  \r\n}\r\n.capsule image {\r\n  width: 50%;\r\n  height: 100%;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%,-50%);\r\n}\r\n.title {\r\n  color: white;\r\n  position: absolute;\r\n  top: 6px;\r\n  left: 104px;\r\n  right: 104px;\r\n  height: 30px;\r\n  line-height: 30px;\r\n  font-size: 14px;\r\n  text-align: center;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}jsconst app = getApp()\r\n\r\nComponent({\r\n\r\n  properties: {\r\n    text: {\r\n      type: String,\r\n      value: 'Wechat'\r\n    },\r\n    back: {\r\n      type: Boolean,\r\n      value: false\r\n    },\r\n    home: {\r\n      type: Boolean,\r\n      value: false\r\n    }\r\n  },\r\n  data: {\r\n    statusBarHeight: app.globalData.statusBarHeight + 'px',\r\n    navigationBarHeight: (app.globalData.statusBarHeight + 44) + 'px'\r\n  },\r\n\r\n  methods: {\r\n    backHome: function () {\r\n      let pages = getCurrentPages()\r\n      wx.navigateBack({\r\n        delta: pages.length\r\n      })\r\n    },\r\n    back: function () {\r\n      wx.navigateBack({\r\n        delta: 1\r\n      })\r\n    }\r\n  }\r\n})json{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}最终还需要考虑下版本兼容的问题，毕竟还有一些用户，微信版本并没有更新到最新版本。首先可以在app.js里面获取下当前用户的微信版本，做下版本比较，如果小于这个版本，设置个全局变量，也可以在组件写个方法，在不同的页面打开显示不同的顶部导航栏，或者可以控制是否显示导航栏，这里就不详细说了。亲自试了下，在低于7.0版本的微信中，如果采用单页面自定义导航栏，会出现两个导航栏，这时候通过判断版本号不要再渲染自定义的导航栏组件了，在页面的配置文件里写上title名，还有相应的背景色，这样就会显示自带的导航栏了。总结小程序开发是有些坑的地方，从不支持自定义导航栏，到支持全局自定义导航栏，再到现在的支持单页面配置，可以看出在慢慢完善。还有底部tabbar，可自己选择配置的太少了，虽然也支持自定义，但是发现自定义写的底部导航组件体验并不好，每次打开页面都会重新渲染底部的按钮，如果全部写成在一个页面里的tab切换，虽然按钮每次不用重新加载了，但是业务多肯定不行，写到一个单页面里东西也太多了。 希望微信能够多添加或放开一些功能，让开发者更好的服务于产品，给用户更好的体验。"}
{"title": "小程序movable-area拖拽fixed点击失效 ", "author": "Rolan", "pub_time": "2019-3-13 18:35", "content": "前言先看效果实现了拖拽，但是可拖拽区域下层的点击事件失效，本来做拖拽就是为了解决下层被遮挡然后无法点击这下可好了，无法点击的区域更高了。还好从网上找到了解决办法movable-view {\r\n    pointer-events: auto; \r\n}\r\n\r\nmovable-area {\r\n    pointer-events: none;\r\n}实现悬浮icon可垂直拖拽微信小程序自带movable-area和movable-view完美的实现了areaH为可移动的高度，这里获取了手机设备的屏幕高度减去上下的留白，并且做了iPhoneX的适配resetY是让icons返回到初始位置下图蓝色区域因为是公共组件movable-view height就通过properties传入了，本来打算通过小程序的boundingClientRect方法获取，但是因为渲染速度慢，可能height为0，所以就老老实实传入<movable-area style=\"height:{{areaH}}px;\"  class=\"ex-class {{iphoneX?'x-class':''}}\">\r\n  <movable-view x=\"{{x}}\" y=\"{{y}}\"  style=\"height:{{height}}px;\" direction=\"vertical\">\r\n    <view class=\"btns-bg \" id=\"icons-container\">\r\n      <slot name=\"icons\"></slot>\r\n    </view>\r\n  </movable-view>\r\n</movable-area>// components/s-icon-btns/index.js\r\nconst App = getApp()\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  externalClasses: ['ex-class'],\r\n  options: {\r\n    multipleSlots: true\r\n  },\r\n  properties: {\r\n    // 容器高度\r\n    height: {\r\n      type: Number,\r\n      value: 0,\r\n      observer(newVal, oldVal) {\r\n        // 设置y初始位置\r\n        this.setData({\r\n          y: this.data.areaH - newVal\r\n        })\r\n      }\r\n    },\r\n    resetY: {\r\n      // 与!wiggle\r\n      type: Boolean,\r\n      value: false,\r\n      observer(newVal, oldVal) {\r\n        this.setData({\r\n          y: this.data.areaH - this.data.height\r\n        })\r\n      }\r\n    }\r\n  },\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n\r\n  data: {\r\n    iphoneX: App.globalData.isIphoneX,\r\n    x: 10,\r\n    areaH: App.globalData.isIphoneX\r\n      ? App.globalData.mobile.windowHeight - 240\r\n      : App.globalData.mobile.windowHeight - 180 //可动区域\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {}\r\n}).btns-bg {\r\n    // position: fixed;\r\n    // right: 10px;\r\n    // bottom: 110px;\r\n    // z-index: 1000;\r\n    background: rgba(255, 255, 255, 0.9);\r\n    width: 45px;\r\n    min-height: 45px;\r\n    border-radius: 45px;\r\n    display: flex;\r\n    justify-content: center;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    padding: 10px 0;\r\n    box-shadow: 0rpx 0rpx 20rpx rgba(0, 0, 0, 0.07);\r\n    &.lower {\r\n        bottom: 61px;\r\n    }\r\n}\r\n\r\n.x-class {\r\n    margin-bottom: 68rpx;\r\n}\r\n\r\nmovable-view {\r\n    pointer-events: auto;\r\n    width: 45px;\r\n    padding: 10px;\r\n    box-sizing: content-box;\r\n}\r\n\r\nmovable-area {\r\n    pointer-events: none;\r\n    position: fixed;\r\n    right: 0px;\r\n    bottom: 70px;\r\n    z-index: 1000;\r\n    width: 65px;\r\n    overflow: hidden;\r\n}总结除了遇见的bug，其他的还是很简单的方便的"}
{"title": "使用taro框架将手百小程序转成h5总结 ", "author": "Rolan", "pub_time": "2019-3-18 00:12", "content": "前言历时一周，终于成功兼容了h5和小程序，在此使用的taro框架，遇到的问题在此记录一下。一、环境判断使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动小程序、H5、React-Native 等）运行的代码。因为是一套代码兼容不同容器，所以在有些不兼容的情况下，判断所在环境就成了非常重要的一环，taro框架自带环境判断如下图。二、编译配置在小程序中不存在接口访问跨域的问题，但是转成h5后开发时这个问题就会出现了，taro有一个专属于h5的编译配置，使用方法和webpack几乎一模一样，可以非常方便的做proxy转发,使用方法参考webpack-dev-server配置。三、地图功能小程序中自带地图api，如手百小程序中有专门的map组件，涉及位置信息的功能可以直接调用swan.openLocation跳转内置地图页面，十分方便，但是转成h5之后没有子带的地图功能怎么办。。。没错，自己手写一个，使用process.env.TARO_ENV判断环境为h5时跳转到自己写的map页，百度地图有封装好的各种api，可以在页面中调用，详见百度地图开放平台。四、表单手百小程序picker组件是支持region模式，直接可以实现省市区选择，但是taro框架h5不支持，需要用picker的multiSelector功能来实现省市区的选择。所以还需要一个城市列表的接口。五、涉及登录的接口请求上线之后我发现需要登录的接口使用Taro.request都得不到正确返回，抓包发现是没有带cookie，原因是taro有一个属性credentials，只有在h5端有这个参数，它的默认值是omit，是请求时不带cookie的，有效值：include, same-origin, omit。需要在请求时修改它的值才可以正确传递cookie，上线后发现安卓手机请求有问题，但iOS手机都可以正常返回结果，可能因为Safari自带了cookie相关的设置，使同源的请求都可以正确携带cookie吧，安卓就没有这个功能，导致了这个问题，加上credentials： same-origin即可解决问题。六、总结这次大概遇到的问题就是这些，以后遇到新的问题再随时补充，欢迎大家提出意见，一起交流进步。"}
{"title": "初探微信小程序 ", "author": "Rolan", "pub_time": "2019-3-18 00:07", "content": "最近的项目中，需要学生端使用微信小程序，所以这两天做了一下小程序的原型。在这里总结一下踩过的坑。组件库的选择上来遇到的第一个大问题就是组件的选择。因为微信原生的实在是又不好看，又不好用。虽然有官方文档，但不得不说，不适合新手使用。第一次选择: WeUI。这是以前老师提到过的一个组件库，所以先尝试了它。但是效果不大好。有两个问题：1.组件库不强大。虽然涉及的种类挺全面的，但是一旦想去实现某个功能时，总会有不顺手的地方。2.没有文档。WeUI本身是有较完善的文档的，但是小程序版的就没有了，所以就造成了想去实现一个功能，就只能根据他给的Demo去扒代码了。第二次选择：ZanUI。一个第三方组件库，相较上面的来说，最大的提升就是文档完善。组件方面也是种类比较齐全的。基本上可以满足开发的需求。第三次选择：VantUI。它是ZanUI的升级版本，功能上更加齐全，而且同种的功能有了更多的选择，可以适应更多变的场景。文档方面也是极其优秀的，不仅有适合新手的入门教程，最大的亮点就是可以同步展示，可以更快的找到想要的效果。最终使用了VantUI进行原型的制作，虽然过程中还是有些地方没法更设想的完全一样，但是好在还能找到替代的解决办法。总体上比较满意。返回键基本上我们看到的小程序，上面的返回键都是不可缺少的。最开始，路由跳转，使用官方给的API进行路由跳转：wx.redirectTo({\r\n    url: '/pages/personal/changePassword/changePassword'\r\n})然后就是添加返回按钮了。找到组件文档，添加个返回键：<van-nav-bar\r\n  title=\"标题\"\r\n  left-text=\"返回\"\r\n  left-arrow\r\n  bind:click-left=\"onClickLeft\"\r\n/>结果是这样的，好像还行，到是感觉有点别扭。打开微信，发现人家的样式都是只有一行的，我的就显得有点怪异。google一下，发现是我路由跳转的方法用错了。wx.navigateTo({\r\n  url: 'changePassword/changePassword'\r\n})使用这个可以直接出现返回的按钮：上面两种方法的区别是，第一个是关闭当前页面，然后跳转；后一种是保留当前页面，然后跳转。所以可以看到上面的url也有一些区别。第一个我写了完整的路径，而后一种我只写了相对路径（当然完整的也可以）。使用后面的好处，还可以利用API:wx.navigateBack实现返回，也省却了不少麻烦。界面风格在这次做原型的过程中，看了好多个别人的小程序，发现其中cell这个组件被用的很频繁。它的效果是这样的：它的大面积使用，代替了按钮的使用，所以我也借鉴了这一点，不得不说，效果确实比按钮要好。先看一下按钮实现的风格：再对比一下cell的风格：虽然按钮好像也不差，但是后面的给人感觉要更好一点。不仅如此，我还利用他解决了table的问题。因为小程序本身是没有table的，各大组件库中也没有看到，所以最后便用VantUI库中的两个组件panel和cell组合实现：<van-panel title=\"2018-2019学年第一学期\" use-footer-slot>\r\n  <view slot=\"footer\">\r\n    <van-cell-group wx:for=\"{{ scores }}\" wx:for-item=\"score\">\r\n      <van-cell title=\"{{ score.name }}\"/>\r\n      <van-cell title=\"平时成绩\" value=\"{{ score.usualScore }}\" />\r\n      <van-cell title=\"期中成绩\" value=\"{{ score.middleScore }}\" />\r\n      <van-cell title=\"期末成绩\" value=\"{{ score.finalScore }}\" />\r\n      <van-cell title=\"总评\" value=\"{{ score.totalScore }}\" />\r\n    </van-cell-group>\r\n  </view>\r\n</van-panel>实现效果如下：尽管没有达到我的预期，但是作为第一版也可以了。安利VantUI库中添加了很多图标，但如果还不能满足你的需求，可以去这里找找灵感：https://www.iconfont.cn/最后附上VantUI的地址：https://github.com/youzan/van...https://youzan.github.io/vant..."}
{"title": "微信小程序scroll-view横向滚动的实践踩坑及隐藏其滚动条的实现 ... ", "author": "Rolan", "pub_time": "2019-3-18 00:23", "content": "一、实践踩坑项目使用mpvue开发1. scroll-view 默认是不滚动的。。所以要先设置 scroll-x=\"true\" 或者 scroll-y=\"true\"2. 在 scroll-view 里面添加定宽元素，超过 scroll-view 宽度（设置了100%，即屏幕宽度)后，它竟然换行了。所以要 scroll-view 的样式要这样设置：scroll-view {\r\n      width: 100%;\r\n      white-space: nowrap;  // 不让它换行\r\n    }3. 然后在定宽元素里边添加子容器：// html大概长这样\r\n<scroll-view scroll-x=\"true\">\r\n  <div class=\"tab-item\">\r\n    <img class=\"content-icon\"/>\r\n    <div></div>\r\n  </div>\r\n  <div class=\"tab-item\">\r\n    <img class=\"content-icon\"/>\r\n    <div></div>\r\n  </div>\r\n  <div class=\"tab-item\">\r\n    <img class=\"content-icon\"/>\r\n    <div></div>\r\n  </div>\r\n</scroll-view>\r\n\r\n// css相应就大概长这样\r\nscroll-view {\r\n    display: flex;\r\n    flex-wrap: nowrap;\r\n}\r\n.tab-item {\r\n    display: flex;\r\n    justify-content: center;\r\n    width: 25%;\r\n    ...\r\n}然后发现 .tab-item 并没有排在一行上。。说明 scroll-view 和 .tab-item 都设置 display: flex 无效？无奈之下，只好在它外边再包一层，然后样式设置 display: inline-block 。此时 正确姿势 如下：// html\r\n<div class=\"scroll-view-container\">\r\n  <scroll-view scroll-x=\"true\" :scroll-into-view=\"toView\">\r\n    <div class=\"tab-container\">\r\n      <div class=\"tab-item\">\r\n        <img class=\"content-icon\"/>\r\n        <div></div>\r\n      </div>\r\n    </div>\r\n  </scroll-view>\r\n</div>\r\n\r\n// css变成这样子\r\nscroll-view {\r\n  width: 100%;\r\n  white-space: nowrap;  // 不让它换行\r\n}\r\n\r\n.tab-container {\r\n  display: inline-block;\r\n  width: 25%;\r\n}\r\n\r\n.tab-item {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    ...\r\n}到这里， scroll-view 就基本如我所愿了，大概长这样：二、隐藏滚动条在网上搜了很多，都是说加上这段代码就可以：/*隐藏滚动条*/\r\n\r\n::-webkit-scrollbar{\r\n\r\n    width: 0;\r\n    \r\n    height: 0;\r\n    \r\n    color: transparent;\r\n\r\n}或者有的人说这样子：/*隐藏滚动条*/\r\n\r\n::-webkit-scrollbar{\r\n\r\n    display: none;\r\n\r\n}然而两种方法我都试过， scroll-view 的滚动条依然存在。。测试机型是安卓机子。但是用 display: none 这种方法是可以隐藏掉页面的滚动条的，就是 scroll-view 的滚动条没隐藏掉。后来，在 小程序社区 看到官方人员这样子解答：是的，就是这种野路子。当然 ，它下面的评论里也有人提供了另一种解决思路方法，但我还是选择了官方说的那种野路子方法。 传送门实现思路就是，在 scroll-view 外边再包一个容器，它的高度小于 scroll-view 的高度，这样就会截掉滚动条，达到隐藏了滚动条的效果。// scss\r\n.scroll-view-container {  // 包裹scroll-view的容器\r\n    height: $fakeScrollHeight;\r\n    overflow: hidden;  // 这个设置了就能截掉滚动条啦\r\n    scroll-view {\r\n      width: 100%;\r\n      white-space: nowrap;\r\n    }\r\n  }\r\n\r\n  .tab-container {  // 我这里是用.tab-container来撑开scroll-view的高度，所以高度在它上面设置,加上padding，那么它就会比外层容器（.scroll-view-container）要高\r\n    display: inline-block;\r\n    width: 26%;\r\n    height: $fakeScrollHeight;\r\n    padding-bottom: $scrollBarHeight;\r\n  }大概意思是这样："}
{"title": "微信小程序开发中遇到的问题及解决办法（一） ", "author": "Rolan", "pub_time": "2019-3-18 00:32", "content": "1、整个页面覆盖的自定义弹窗，滑动弹窗中的内容，页面内容也会滑动。如果快速滚动弹窗，页面内容和弹窗中的内容有时会错乱。这个问题大多出现在苹果手机上，类似事件事件穿透的效果。自定义弹窗截图如下：解决办法：再最外层元素上添加事件： catch:touchmove=\"notDo\"事件代码：/**\r\n   * @desc not do\r\n   */\r\n  notDo: function () {\r\n    // not do\r\n  }wxml截图：注意：加上这个事件后，对侧滑效果有所影响，如果需要侧滑切换页面，建议使用其他方法。2、使用了fixed定位的元素，会出现随页面滚动而移动的现象。社区中的说法大概是：这个是因为小程序架构的原因导致 scroll 事件有一定的延迟，最终使 fixed 的改变不够及时导致的。解决办法：在fixed定位的元素上，添加样式： transform: translate3d(0, 0, 0);3、使用canvas绘制分享图，有的时候绘制错误，导致整张分享图空白。折中解决办法：隐藏canvas，使用html结构，重新渲染分享图。这样方便找出到底是哪里绘制错误倒是整张图绘制不出来，也会有更好的交互效果。还有一点好处，如果分享图只有一屏的内容，可以直接截图分享（如果是苹果，不支持截长图）。注意：如果分享图中并没有大量的动态内容，并不建议使用这种折中方案。因为这需要维护两套代码，而且当html结构渲染出来的时候，canvas可能还未绘制完毕或者绘制错误，会误导用户操作。截图：4、开发者工作模拟小程序不同进入场景，比如：扫描二维码，长按识别二维码的启动参数处理。解决办法：应该通过encodeURIComponent来编码启动参数，在当前页面获取页面参数的时候，再通过decodeURIComponent来解码。截图：代码截图：注意：区别于encodeURI和decodeURI的编解码，encodeURIComponent和decodeURIComponent的组合使用范围更广。encodeURI对在 URI 中具有特殊含义的 ASCII 标点符号，不会进行转义的：;/?:@&=+$,#, 而encodeURIComponent会转义这些。遇上encodeURI不会转义的标点符号，URI会直接被截取掉。随记 ：最近，太阳不再流浪；最近，想遇见更好的自己~"}
{"title": "微信小程序之获取用户位置权限（拒绝后提醒） ", "author": "Rolan", "pub_time": "2019-3-20 00:32", "content": "小程序获取用户当前位置有三个方式\" style=\"margin: 20px 0px; font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Helvetica Neue\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", sans-serif; font-weight: 500; line-height: 40px; color: rgb(44, 62, 80); text-rendering: optimizeLegibility; font-size: 21px; background-color: rgb(249, 249, 245);\">微信小程序获取用户当前位置有三个方式：1. wx.getLocation（多与wx.openLocation一起用）　　获取当前的精度、纬度、速度。不需要授权。当type设置为gcj02 返回可用于wx.openLocation的坐标2. wx.chooseLocation　　需要授权，打开地图选择位置　　第一次调用方法时先出现　　允许权限之后之后再出现　　如果第一次就不允许，则一直调用wx.chooseLocation的fail方法3. wx.openLocation　　需要授权，使用微信内置地图查看位置。多半用于查看起点到终点的路线怎么走授权方法有三种：1. wx.getSetting　　获取用户的当前设置，返回值中只会出现小程序已经向用户请求过的权限，类似下面的样子2. wx.openSetting　　调起权限设置选择界面，设置界面只会出现小程序已经向用户请求过的权限，类似下面的样子3. wx.authorize　　提前向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权小程序使用某项功能或获取用户的某些数据，但不会实际调用对应接口。如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。，类似下面的样子　　这就是wx.authorize出现的内容问题来了：假如我第一次使用wx.chooseLocation（）获取权限被拒绝，然后使用wx.getSetting（）来重新获取权限该怎么做呢？思路：wx.chooseLocation（）有fail方法，如果第一次拒绝之后，以后调用选择地图都是触发的这个，那么我可以在fail方法里面，使用wx.getSetting（），这样就每次都能判断是否已经给与了权限了。第一步：由于有可能会多次使用定位的方法，所以我把定位的方法写到App.js中，方便调用App({    //获取用户地理位置权限    getPermission:function(obj){      wx.chooseLocation({        success: function (res) {                obj.setData({                addr: res.address      //调用成功直接设置地址            })                        },        fail:function(){            wx.getSetting({                success: function (res) {                    var statu = res.authSetting;                    if (!statu['scope.userLocation']) {                        wx.showModal({                            title: '是否授权当前位置',                            content: '需要获取您的地理位置，请确认授权，否则地图功能将无法使用',                            success: function (tip) {                                if (tip.confirm) {                                    wx.openSetting({                                        success: function (data) {                                            if (data.authSetting[\"scope.userLocation\"] === true) {                                                wx.showToast({                                                    title: '授权成功',                                                    icon: 'success',                                                    duration: 1000                                                })                                                //授权成功之后，再调用chooseLocation选择地方                                                wx.chooseLocation({                                                    success: function(res) {                                                        obj.setData({                                                            addr: res.address                                                        })                                                    },                                                })                                            } else {                                                wx.showToast({                                                    title: '授权失败',                                                    icon: 'success',                                                    duration: 1000                                                })                                            }                                        }                                    })                                }                            }                        })                    }                },                fail: function (res) {                    wx.showToast({                        title: '调用授权窗口失败',                        icon: 'success',                        duration: 1000                    })                }            })        }    })           },})    第二步：在需要获取地址的页面中：var app = getApp();Page({   data:{        addr:'请选择位置'             },    //选择获取地理位置    getAddress:function(){          var that=this;      app.getPermission(that);    //传入that值可以在app.js页面直接设置内容        }, })最终效果图：最终在手机上获取到的位置偏差不太大。更新 wx.openSetting 的注意事项。2.3.0 版本开始，用户发生点击行为后，才可以跳转打开设置页，管理授权信息即2.3.0版本之后，我通过上面的wx.showModal的回调函数来调用wx.openSetting 会发生下面的错误：openSetting:fail can only be invoked by user TAP gesture.但是我测试 2.2.4 开始 到2.3.1 都会出现上面这种错误。2.3.2及以上又不会出现这种问题。。。。。。。。而且当我测试2.0.8 到 2.2.3 会出现下面的错误。。。。。。其它的就没有这问题了。搞不懂。。。"}
{"title": "微信小程序部分功能踩坑指南 ", "author": "Rolan", "pub_time": "2019-3-21 00:12", "content": "前言\r\n开发项目时，实际遇到的一些功能需求和问题汇总。列出了当时参考的一些文章和官方文档。\r\n开发框架：mpvue\r\n官方文档：5分钟快速上手\r\n小程序跳转外链\r\n参考文章：小程序跳转到非小程序页面的外部链接地址\r\n\r\n要跳转的链接必须是https的\r\n需要用web-view组件，web-view组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面。（个人类型与海外类型的小程序暂不支持使用。也就是说个人申请的小程序，就别想跳转了）\r\n需要在小程序后台配置业务域名，也就是你要跳转网页地址的域名。（设置-开发设置 -业务域名）\r\n配置业务域名时，会要求下载校验文件，该文件需要放置到访问外链地址的根目录下，可能会需要运维协助\r\n跳转外链后，如果打开的二级页中有新的域名地址，同样需要重复上述步骤\r\n\r\n小程序内部页面跳转\r\n官方文档：小程序页面跳转\r\n低版本兼容\r\n为便于开发者解决低版本基础库无法兼容小程序的新功能的问题，开发者可设置小程序最低基础库版本要求。\r\n开发者可以登录小程序管理后台，进入「设置 - 基本设置 - 基础库最低版本设置」进行配置。在配置前，开发者可查看近 30 天内访问当前小程序的用户所使用的基础库版本占比，以帮助开发者了解当前用户使用的情况。\r\n官方文档：低版本兼容处理\r\n微信小程序 基础库版本与客户端版本对应关系\r\n\r\n小程序iphonex适配\r\n参考文章：微信小程序API之设备获取系统信息getSystemInfo\r\n参考文章：微信小程序适配iphoneX\r\nmpvue支持less\r\n参考文章：2步配置mpvue支持less\r\n小程序生命周期\r\n参考文章：小程序生命周期\r\n官方文档：mpvue的生命周期\r\n坑点：右上角按钮只是把小程序退到了后台，并没有关闭小程序，所以如果未做处理，下次进去还是上一次退出前的状态。不会像h5一样刷新打开页面。也没有开放销毁小程序的监听。\r\n前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。\r\nswiper 间距轮播\r\n参考文章：微信小程序使用swiper组件实现类3D轮播图\r\n参考文章：小程序swiper组件实现不同效果间距轮播\r\n最后用的第二篇里面的方法三，需要用到Animation动画对象\r\n第一篇文章里直接用css的transition，动画不流畅。\r\n小程序swiper组件bug：\r\n参考文章：微信小程序swiper组件卡死来回疯狂轮播\r\n小程序引入外部字体\r\n参考文章：小程序如何引入外部字体\r\n用过里面的方法二\r\n图片预览\r\n只有图片全屏预览后，才能通过长按图片吊起菜单栏（保存图片，分享图片，收藏图片）\r\n参考文章：图片预览\r\n保存图片到相册\r\n小程序保存图片到本地授权问题转发小程序1. 显示转发按钮wx.showShareMenu(Object object)2. 自定义转发的标题、图片\r\nonShareAppMessage(Object)\r\n监听用户点击页面内转发按钮（<button> 组件 open-type=\"share\"）或右上角菜单“转发”按钮的行为，并自定义转发内容。\r\n官网文档：onShareAppMessage(Object)\r\nmpvue中与mounted写的位置类似处理设置菜单分享和按钮分享的自定义标题、图片等。微信自带loading，提示和弹窗API统计\r\n官方文档\r\n会用到的应该是自定义分析，也就是按钮点击等事件的统计。\r\n\r\n其他\r\n\r\n\r\nbackground-image只能用网络url或者base64.本地图片要用image标签才行。\r\n\r\n小程序里有视频播放，审核的时候会有资质问题，需使用封装的视频插件\r\n后台发送的模板消息，需要前端提交数据时，提供formId。详见小程序form组件\r\nmpvue 事件的参数通过绑定是用$event传入\r\n以swiper举例"}
{"title": "从App直接打开小程序 ", "author": "Rolan", "pub_time": "2019-3-21 00:23", "content": "今天无意中了解到APP竟然可以直接打开小程序这个功能，一致认为不可能啊，因为小程序是依靠微信，如果手机上微信没有打开，或者是没有安装微信会怎样呢？一起探索吧！步骤1.打开微信开发者平台文档,下载微信SDK。 2.根据文档手动集成SDK 3.点击进入小程序代码:    WXLaunchMiniProgramReq *launchMiniProgramReq = [WXLaunchMiniProgramReq object];    launchMiniProgramReq.userName = @\"gh_fc392b7c02cf\";  //拉起的小程序的原始ID    launchMiniProgramReq.path = @\"\";    //拉起小程序页面的可带参路径，不填默认拉起小程序首页    launchMiniProgramReq.miniProgramType = WXMiniProgramTypePreview; //拉起小程序的类型    [WXApi sendReq:launchMiniProgramReq];3.当小程序跳转app时，会走onReq的代理方法(文档中说的是onResp的方法,很坑)。需要把req强转成LaunchFromWXReq。其中WXMediaMessage下的messageExt才是小程序传给我们的参数。-(void)onResp:(BaseResp *)resp{    if ([resp isKindOfClass:[WXLaunchMiniProgramResp class]])    {        WXLaunchMiniProgramResp*rep = (WXLaunchMiniProgramResp*)resp;        NSString *string = rep.extMsg;        NSLog(@\"参数:%@\",string);    }}注意：1.查看移动端与小程序是否在同一开发者平台下（同一平台下直接跳转，不同平台下需要关联才能跳转）同一平台关联2.APP跳到小程序时报如下图：原因：因为APP暂未上架。 解决方案:我暂时选了一个上线的APP的Bundle id。APP跳到小程序时报如下图：原因：因为用的是体验版，所登的微信账号无体验权限。 解决方案:管理员给该账户体验权限，用该小程序有体验权限的账号测试。"}
{"title": "通过微信小程序扫码，在PC端登陆跳转相应页面 ", "author": "Rolan", "pub_time": "2019-3-21 00:20", "content": "通过微信小程序扫码，在PC端登陆跳转相应页面最近在做一个零食店，移动端采用微信小程序进行实现。当然，既然是零食店，那么肯定会有后台管理的，当时的想法是如何才能通过微信小程序里进行扫码去登陆PC端的管理平台呢？话不多说，接下来就说说我是怎么做到！ 首先，大致上讲一下我的实现思路，整体通过WebSocket来实现自动跳转。在PC登陆页，展示二维码，建立WebSocket连接，当微信小程序扫码后，在后台进行身份验证，并且将验证结果实时发送给在PC登陆页建立的websocket连接，然后进行相应信息的提示以及页面的跳转。扫码登陆流程1、生成PC端页面二维码 这个二维码中放的什么信息呢，当时是能够唯一标识客户端的UUID啦，不然你扫码之后，应该给哪个客户端发送状态信息呢 2、进入PC端管理页时，获取唯一标识，建立websocket连接，并且以该唯一标识作为key存放在map集合当中。pc端代码var websocket = null;    var url=\"ws://localhost:8080/snacks/socketLogin/[[${socketKey}]]\";    if('WebSocket' in window)        websocket = new WebSocket(url);    else        layer.msg(\"该浏览器暂不支持！请更换浏览器\",{icon:2,time:1000})    websocket.onopen = function () {    }    websocket.onclose = function () {        layer.msg(\"连接失效，请刷新页面\",{icon:2,time:1000})    }    websocket.onmessage = function (e) {        var res = e.data;        var mid = eval(\"var json = \"+res)        if(json.code==\"1000\"){            //登陆成功            layer.msg(\"登陆成功！\",{icon:1,time:1000},function () {                window.location.href = \"http://localhost:8080/snacks/login/goShopIndex/\"+json.openId+\"/snacks\";            })        }else{            //登陆失败            layer.msg(\"该用户暂时没有权限或者商户\",{icon:2,time:2000})        }    }服务器端代码private static ConcurrentHashMap<String, Session> sessionMap = new ConcurrentHashMap<>();@OnOpen    public void onOpen(Session session, @PathParam(\"socketKey\") String socketKey){        System.out.println(\"websocket:\"+socketKey+\"--->建立成功\");        sessionMap.put(socketKey,session);    }    @OnClose    public void onClose(Session session,@PathParam(\"socketKey\") String socketKey){        System.out.println(\"websocket:\"+socketKey+\"--->断开连接\");        sessionMap.remove(socketKey);    }然后呢就是微信小程序端了，微信小程序通过扫码获取到该PC登陆页建立的websocket连接的唯一标识Key后，将自己的信息与这个key作为data请求后台接口。在后台接口中对用户信息进行校验，之后将校验结果发送给该key对应的session连接就可以啦服务器端@RequestMapping(\"/getLoginCode\")    @ResponseBody    public Integer getLoginCode(HttpSession session, String socketKey, String openId){        //在这里进行登陆信息验证        。。。。。。        //获取到websocket连接session的map        ConcurrentHashMap<String, Session> sessionMap = LoginSocket.getSessionMap();        //将状态信息发送到客户端        Session currentSession = sessionMap.get(socketKey);        currentSession.getAsyncRemote().sendText(responseJson);        return result.getCode();    }微信小程序端scanCodeLogin:function(){    wx.scanCode({      scanType:'qrCode',      success:function(e){        var socketKey = e.result;        app.checkSession();        var openId = wx.getStorageSync(\"openId\");        wx.request({          url: app.baseUrl + '/getLoginCode',          method:'POST',          header:app.postHeader,          data:{socketKey:socketKey,openId:openId},          success:function(e){            console.log(e)          var result = e.data;          if(result == 1000){              wx.showToast({                title: '登陆成功',              })          }else{              wx.showModal({                title: '登陆失败',                content: '该用户暂时没有权限或者商户',                showCancel:false              })          }          }        })      },      fail:function(){      }    })这里的websocket也可以替换为消息队列中间件，但是这样是不是大材小用了呢？"}
{"title": "微信小程序 组件叠加效果（如 Android 中的添加蒙层） ", "author": "Rolan", "pub_time": "2019-1-7 00:21", "content": "实现的效果如下：可以看出这是由image组件和text组件叠加到一块组成的蒙层效果。在小程序中实现这个效果主要用到z-index属性和position属性 z-index的使用必须是双方组件都设置了position属性才会生效。 z-index：表示的组件的层级关系，值越小越在最下方。 position：表示组件的位置，这里可以使用的值为fixed，absolute,使用relative不能实现该效果。 position 的可能值如下图：那么这里我们的的蒙版文字是在图片的上方，所以布局样式可以这么写：重点关注 position和z-index即可。这里的line-height: 100px;也很重要，否则蒙层上的文本是不能居中对齐的。布局<view class='item_view'>    <image class='img-class' src='https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=2f3a8c47f4deb48fef64a98c9176514c/78310a55b319ebc4658560bf8526cffc1e171612.jpg'></image>    <text class='text_num'>+3</text>  </view>样式.item_view{  margin-top: 100px;  text-align: center;  align-items: center;  justify-content: center;}.img-class{  width: 100px;  height: 100px;  z-index: -1;  position: fixed;}.text_num{  width: 100px;  height: 100px;  line-height: 100px;  background: rgb(99, 99, 105);  opacity: 0.5;  font-size: 14px;  color: rgb(248, 248, 244);  z-index: 100;  position: fixed;}本文完，欢迎你的喜欢、或者留言和我讨论~"}
{"title": "微信小程序开发中的代码片段总结 ", "author": "Rolan", "pub_time": "2019-3-22 00:34", "content": "经过一段时间的微信小程序开发，总结了一些代码片段，主要是以下几个方面：小程序（授权、网络、录音、图像）mpvue（分包、全局变量、svg组件、组件class绑定）小程序授权逻辑初次请求 -> 请求用户授权 -> 同意授权(-> 不同意授权 -> 结束) -> 使用对应功能二次请求 -> 跳转小程序设置页面modal -> 设置页面 -> 开启scope -> 使用对应功能const checkPermission = scope =>\r\n  new Promise((resolve, reject) => {\r\n    wx.getSetting({\r\n      success: res => {\r\n        // 是否存在认证配置\r\n        let hasAuthorized = res.authSetting.hasOwnProperty(scope)\r\n        if (hasAuthorized) {\r\n          // 已授权\r\n          if (res.authSetting[scope]) {\r\n            resolve('已授权')\r\n            return\r\n          }\r\n          // 未授权，提示进入小程序设置页面，wx限制:需要主动点击才能执行openSetting()，因此使用modal\r\n          wx.showModal({\r\n            title: '没有权限',\r\n            content: '体验该功能需要您授权功能权限，现在前往设置开启',\r\n            success: res => {\r\n              if (res.confirm) {\r\n                reject('设置页面')\r\n                wx.openSetting()\r\n              } else if (res.cancel) {\r\n                reject('不进入设置')\r\n              }\r\n            }\r\n          })\r\n        }\r\n      },\r\n      fail: err => { reject(err.errMsg) }\r\n    })\r\n  })网络微信小程序不同环境下网络请求的不同之处：校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书\r\n网络请求与拦截器可以使用 fly.js 作为小程序的网络请求库，在使用拦截器等功能时也较为方便。小程序中一个特殊的地方是: content-type 为 multipart/formdata 类型的POST请求不能通过自定义请求的方式发出，需要使用小程序的 wx.uploadFile 方法，可以如下简单封装下：const formDataRequest = (url, filePath, params = {}) =>\r\n  new Promise((resolve, reject) => {\r\n    let token = wx.getStorageSync(\"token\")\r\n    wx.uploadFile({\r\n      url,\r\n      filePath,\r\n      name: \"file\",\r\n      header: { token },\r\n      formData: params,\r\n      success: async res => {\r\n        // 一些对响应数据的处理...\r\n        resolve(res.data)\r\n      },\r\n      fail: err => {\r\n        reject(err)\r\n      }\r\n    });\r\n  });判断是否在线使用 getNetworkType 方法即可export const isOnline = () =>\r\n  new Promise((resolve, reject) => {\r\n    wx.getNetworkType({\r\n      success(res) {\r\n        const networkType = res.networkType\r\n        resolve(networkType !== 'none')\r\n      },\r\n      failed(res) {\r\n        reject(res)\r\n      }\r\n    })\r\n  })录音处理主要是录音时的API检测、状态控制与事件监听器的处理。// 1. 检测录音管理器是否可用\r\nif (wx.getRecorderManager) {\r\n  this.recorder = wx.getRecorderManager()\r\n  this.addRecorderListener()\r\n} else {\r\n  wx.showModal({\r\n    title: '提示',\r\n    showCancel: false,\r\n    content:\r\n      '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'\r\n  })\r\n}\r\n// 2. 录音前检测scope.record授权情况\r\nasync startRecordHandle() {\r\n  if (!this.recorder) return\r\n  try { await this.checkPermission('scope.record') }  \r\n  catch (err) { return }\r\n  this.recorder.start(this.audioOption)\r\n},\r\n// 3. 添加事件监听器\r\naddRecorderListener() {\r\n  if (!this.recorder) return\r\n  this.recorder.onStart(() => {\r\n    ...\r\n    this.recording = true\r\n  })\r\n  this.recorder.onStop(path => {\r\n    ...\r\n    this.recording = false\r\n    this.audioPath = path.tempFilePath\r\n  })\r\n}若需实现长按录音的场景，可以结合 lonepress 事件与 setTimeout 来实现。<template>\r\n  <g-button type=\"primary\"\r\n    ...\r\n    @long-press=\"longPressHandle\"\r\n  />\r\n</template>\r\n<script>\r\nexport default {\r\n  methods: {\r\n    longPressHandle() {\r\n      // longpress事件会在350ms后出发\r\n      this.canRecordStart = true\r\n    },\r\n    touchStartHandle() {\r\n      this.canRecordStart = true\r\n      let delay = 400 // 设置400ms延迟\r\n      setTimeout(() => {\r\n        if (this.canRecordStart) {\r\n          this.startRecordHandle()\r\n        }\r\n      }, delay)\r\n    },\r\n    touchEndHandle() {\r\n      if (!this.canRecordStart) return\r\n      this.canRecordStart = false\r\n      this.stopRecordHandle()\r\n    },\r\n  }\r\n}\r\n</script>图像处理获取图片信息wx.getImageInfo不管是CDN的图片还是本地选择的图片都需要先使用 getImageInfo 获取图片的基本信息getImageInfo(img) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.getImageInfo({\r\n      src: img,\r\n      success: res => { resolve(res) },\r\n      fail: () => { reject('获取图片信息失败') }\r\n    })\r\n  })\r\n}选择图片wx.chooseImage让用户选择本地相册中或拍摄的图片，以选择单张图片为例：const MB = 1024 * 1024\r\nchooseSingleImage() {\r\n  return new Promise((resolve, reject) => {\r\n    wx.chooseImage({\r\n      count: 1, // 默认9，为1获取单张图片\r\n      sizeType: ['original', 'compressed'], // 指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 指定来源是相册还是相机，默认二者都有\r\n      success: res => {\r\n        let file = res.tempFiles[0]\r\n        // 可以对所选图片尺寸或其他属性做一些限制\r\n        // let { size } = file\r\n        // if (size > 20 * MB) { reject('图片大小应小于20MB') }\r\n        resolve(file)\r\n      },\r\n      fail: () => { reject('图片选取失败') }\r\n    })\r\n  })\r\n}读取图片wx.getFileSystemManager()使用小程序的FS相关API读取文件内容readFileInBase64(filePath) {\r\n  return new Promise((resolve, reject) => {\r\n    if (wx.getFileSystemManager) {\r\n      // 以base64编码读取图片\r\n      wx.getFileSystemManager().readFile({\r\n        filePath: filePath,\r\n        encoding: 'base64',\r\n        success: res => { resolve(res) },\r\n        file: () => { reject('读取文件失败') }\r\n      })\r\n    } else {\r\n      // 兼容处理，若不支持则提示更新\r\n      wx.showModal({\r\n        title: '提示',\r\n        showCancel: false,\r\n        content:\r\n          '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。'\r\n      })\r\n    }\r\n  })\r\n}Canvas绘制图像小程序中使用CanvasContext API与H5的形式基本相同。需要注意的是，在小程序中绘制canvas时尺寸的单位是 px ，而不是响应式的 rpx 。需要注意的是从基础库 1.9.90 开始 CanvasContext 的API变化了很多，在使用时需要注意兼容性，比如下面两个函数：export const drawPoint = (ctx, x, y) => {\r\n  let pointColor = '#2ba5ff'\r\n  ctx.beginPath()\r\n  ctx.arc(x, y, 1, 0, Math.PI * 2, true)\r\n  ctx.closePath()\r\n  // 兼容画布填充色方法\r\n  if (ctx.fillStyle) {\r\n    // 1.9.90+\r\n    ctx.fillStyle = pointColor\r\n  } else {\r\n    ctx.setFillStyle(pointColor)\r\n  }\r\n  ctx.fill()\r\n}\r\n\r\nexport const drawRect = (ctx, x, y, width, height) => {\r\n  let marginColor = '#ff0000'\r\n  // 兼容笔触色彩方法\r\n  if (ctx.strokeStyle) {\r\n    // 1.9.90+\r\n    ctx.strokeStyle = marginColor\r\n  } else {\r\n    ctx.setStrokeStyle(marginColor)\r\n  }\r\n  ctx.lineWidth = 1\r\n  ctx.strokeRect(x, y, width, height)\r\n}mpvue分包及分包预加载mpvue-loader: ^1.1.2\r\n直接在 app.json 中配置 subPackages 即可:{\r\n  ...\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"pages/module-bob/\",\r\n      \"pages\": [\"subpage-a/main\", \"subpage-b/main\", \"subpage-c/main\"]\r\n    },\r\n    {\r\n      \"root\": \"pages/module-alice/\",\r\n      \"pages\": [\"subpage-d/main\", \"subpage-e/main\", \"subpage-f/main\"]\r\n    }\r\n  ],\r\n  \"preloadRule\": {\r\n    \"pages/index/main\": {\r\n      \"network\": \"wifi\",\r\n      \"packages\": [\"pages/module-bob\"]\r\n    }\r\n  }\r\n  ...\r\n}其中 preloadRule 为预加载配置，上面的设置意为进入index页面时当为wifi网络时预加载module-bob子包。https://segmentfault.com/a/1190000017064732使用globalData全局变量在小程序中将自带的[ globalData ]()挂载到vue的原型方法上。在src中的 main.js 最后添加如下代码:import Vue from 'vue'\r\nimport App from './App'\r\n...\r\nconst app = new Vue(App)\r\napp.$mount()\r\nVue.prototype.$globalData = getApp().globalData // 添加该行然后就可以在其他页面使用该命令操作全局变量了// page A\r\nthis.$globalData.userInfo = {name: 'yrq110'}\r\n// page B\r\nconsole.log(this.$globalData.userInfo)\r\n// page C\r\nthis.$globalData.userInfo.name: 'yrq110'注意，在子页面中使用globalData时，将变量赋值的操作放在data中是无效的，如下:export default {\r\n  data() {\r\n    // 无效\r\n    // isIPX: this.$globalData.isIPX\r\n  },\r\n  computed: {\r\n    isIPX() {\r\n      // 有效\r\n      return this.$globalData.isIPX\r\n    }\r\n  },\r\n}SVG图标组件的默认尺寸与预设尺寸在图标组件中加载svg时使用父标签上的尺寸作为默认尺寸，并在传入特定props参数时使用预设尺寸。业务中碰到了这个问题，使用如下的方法进行了解决：在image组件的load事件处理器中将加载的原始尺寸绑定到style上。实现了： 1. 默认使用svg标签自带尺寸 2. 当传入size属性则使用预设尺寸<template>\r\n  <image\r\n    ...\r\n    @load=\"loadHandle\"\r\n    :style=\"{ width: !size ? iconWidth + 'rpx' : '100%', height: !size ? iconHeight + 'rpx' : '100%'}\"\r\n    ...\r\n  />\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  ...\r\n  data() {\r\n    return {\r\n      iconWidth: 0,\r\n      iconHeight: 0,\r\n      loaded: false // 是否加载完毕\r\n    }\r\n  },\r\n  props: {\r\n    ...\r\n    size: String\r\n  },\r\n  computed: {\r\n    ...\r\n    getSizeClass() {\r\n      let { size } = this\r\n      return size || ''\r\n    },\r\n    setSizeStyle() {\r\n      if (!this.loaded || this.size) return {}\r\n      return {\r\n        width: this.iconWidth + 'rpx',\r\n        height: this.iconHeight + 'rpx'\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    loadHandle(e) {\r\n      this.loaded = true\r\n      // 使用加载后的默认尺寸\r\n      const { detail } = e.mp\r\n      this.iconWidth = detail.width * 2\r\n      this.iconHeight = detail.height * 2\r\n    }\r\n  }\r\n  ...\r\n}\r\n</script>解决无法在组件上绑定class的trick将keyword作为prop属性传入组件并通过Computed属性绑定到class上，这样在外部引用时就可以根据keyword设置自定义的样式了。组件中的关键代码如下：<template>\r\n  <div :class=\"customClass\">\r\n    <slot></slot>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  ...\r\n  props: {\r\n    type: String,\r\n    ...\r\n  },\r\n  computed: {\r\n    customClass() {\r\n      let type = this.type || ''\r\n      return type\r\n    }\r\n  }\r\n  ...\r\n}\r\n</script>在外部引用时就可以使用自定义class来在外部使用样式了:<template>\r\n  ...\r\n  <g-button type=\"custom-button\"></g-button>\r\n  ...\r\n</template>\r\n...\r\n<style lang=\"scss\">\r\n...\r\n.custom-button {\r\n  .text {\r\n    margin-left: 10px;\r\n  }\r\n...\r\n}\r\n</style>"}
{"title": "微信小程序发送短信验证码完整实例 ", "author": "Rolan", "pub_time": "2019-1-7 00:36", "content": "微信小程序注册完整实例，发送短信验证码，带60秒倒计时功能，无需服务器端。效果图:代码:index.wxml<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view class='row'>\r\n     <input placeholder='请输入姓名' bindinput='bindNameInput'/> \r\n  </view>\r\n  \r\n  <view class='row'>\r\n     <input placeholder='请输入手机号' bindinput='bindPhoneInput'/> \r\n  </view>\r\n  <view class='row'>\r\n     <input placeholder='请输验证码' bindinput='bindCodeInput' style='width:70%;'/> \r\n     <button class='codeBtn' bindtap='getCode' hidden='{{hidden}}' disabled='{{btnDisabled}}'>{{btnValue}}</button>\r\n  </view>\r\n  <view>\r\n     <button class='save' bindtap='save' >保存</button>\r\n  </view>\r\n  \r\n</view>\r\nindex.js//index.js\r\nvar zhenzisms = require('../../utils/zhenzisms.js');\r\n//获取应用实例\r\nconst app = getApp();\r\n \r\nPage({\r\n  data: {\r\n    hidden: true,\r\n    btnValue:'',\r\n    btnDisabled:false,\r\n    name: '',\r\n    phone: '',\r\n    code: '',\r\n    second: 60\r\n  },\r\n  onLoad: function () {\r\n    \r\n  },\r\n  //姓名输入\r\n  bindNameInput(e) {\r\n    this.setData({\r\n      name: e.detail.value\r\n    })\r\n  },\r\n  //手机号输入\r\n  bindPhoneInput(e) {\r\n    console.log(e.detail.value);\r\n    var val = e.detail.value;\r\n    this.setData({\r\n      phone: val\r\n    })\r\n    if(val != ''){\r\n      this.setData({\r\n        hidden: false,\r\n        btnValue: '获取验证码'\r\n      })\r\n    }else{\r\n      this.setData({\r\n        hidden: true\r\n      })\r\n    }\r\n  },\r\n  //验证码输入\r\n  bindCodeInput(e) {\r\n    this.setData({\r\n      code: e.detail.value\r\n    })\r\n  },\r\n  //获取短信验证码\r\n  getCode(e) {\r\n    console.log('获取验证码');\r\n    var that = this;\r\n    zhenzisms.client.init('https://sms_developer.zhenzikj.com', 'appId', 'appSecret');\r\n    zhenzisms.client.send(function (res) {\r\n      if(res.data.code == 0){\r\n        that.timer();\r\n        return ;\r\n      }\r\n      wx.showToast({\r\n        title: res.data.data,\r\n        icon: 'none',\r\n        duration: 2000\r\n      })\r\n    }, '15801636347', '验证码为:3322');\r\n    \r\n  },\r\n  timer: function () {\r\n    let promise = new Promise((resolve, reject) => {\r\n      let setTimer = setInterval(\r\n        () => {\r\n          var second = this.data.second - 1;\r\n          this.setData({\r\n            second: second,\r\n            btnValue: second+'秒',\r\n            btnDisabled: true\r\n          })\r\n          if (this.data.second <= 0) {\r\n            this.setData({\r\n              second: 60,\r\n              btnValue: '获取验证码',\r\n              btnDisabled: false\r\n            })\r\n            resolve(setTimer)\r\n          }\r\n        }\r\n        , 1000)\r\n    })\r\n    promise.then((setTimer) => {\r\n      clearInterval(setTimer)\r\n    })\r\n  },\r\n  //保存\r\n  save(e) {\r\n    console.log('姓名: ' + this.data.name);\r\n    console.log('手机号: ' + this.data.phone);\r\n    console.log('验证码: ' + this.data.code);\r\n \r\n     //省略提交过程\r\n  }\r\n})\r\nindex.wxss/**index.wxss**/\r\npage{\r\n  height: 100%;\r\n  width: 100%;\r\n  background: linear-gradient(#5681d7, #486ec3);\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n.container{\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-around;\r\n  width: 90%;\r\n  margin: 50rpx auto;\r\n}\r\n \r\n.row{\r\n  position: relative;\r\n  height: 80rpx;\r\n  width: 100%;\r\n  border-radius: 10rpx;\r\n  background: #fff;\r\n  margin-bottom: 20rpx;\r\n  padding-left: 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n.row input{\r\n  width: 100%;\r\n  height:100%;\r\n}\r\n.codeBtn{\r\n  position: absolute;\r\n  right: 0;\r\n  top: 0;\r\n  color: #bbb;\r\n  width: 30%;\r\n  font-size: 26rpx;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n}\r\n.subBtn{\r\n  width: 200rpx;\r\n  height: 80rpx;\r\n  background: #fff;\r\n  color: #000;\r\n  border-radius: 50rpx;\r\n  line-height: 80rpx;\r\n}\r\n完整下载: 下载详情参考: http://smsow.zhenzikj.com/doc..."}
{"title": "通过安卓手机获取微信小程序包进行反编译方法 ", "author": "Rolan", "pub_time": "2019-3-21 00:41", "content": "要求安装Nodejs一台root后的安卓手机或者装有可以打开微信小程序的安卓模拟器一个敢于折腾的耐心看起来很简单的样子准备安装反编译工具【推荐】方法一：你可以通过git clone将它存在本地git clone https://github.com/qwerty472123/wxappUnpacker.git将工具放在需要的目录内（例如wxappUnpacker）。方法二：也可以直接下载这个工具包，点击下载，并解压出来。接着在该项目内执行：npm install esprima css-tree cssbeautify vm2 uglify-es js-beautify escodegen安装完项目依赖后开始进行最复杂的操作，提取小程序包。提取微信小程序文件包此时你有两个选择：通过安卓虚拟机获取，用你已经root的安卓机操作。安卓虚拟机如果你是Windows，这就好说了。【推荐】选择夜神模拟器下载并安装。【似乎不太好用】我已经实践过了，这里有破解版的模拟器：Genymotion v2.12.2破解版。但是你要注册一个账号来添加虚拟设备，进行安装。安装完成后就可以启动了。【失败】网易的Mumu也是安卓模拟器，但是经过实践，居然不支持微信小程序。如果你是MacOS上面提到的Genymotion也是支持MacOS的，不过还是很麻烦。Mumu似乎不错，结果上面提到了，MacOS下也是打不开微信小程序的。结论：请自行尝试Genymotion模拟，或者找其他我还没发现的模拟器。已Root安卓手机你用有一台牛逼闪闪的安卓手机，但是大部分手机不允许root的，或者说root也是非常复杂的，所以如果你不懂得如何root，请考虑使用安卓虚拟机！如果你优秀的root过了，这里又有两个方案：【风险极高】粗暴的下载一个root explorer破解版，并授权root权限！【推荐】从谷歌商店或者可靠的应用市场下载Root Explorer，土豪请付款购买，好像不到6美元，我这里尝试了一下ES文件浏览器也可以，所以接下来下载它并安装好。看到这里，我当你已经拥有了一台可以登录微信、安装了文件管理工具、并给它授予最高权限的安卓手机了！提取文件打开微信，登录微信账号。打开一个小程序，让他正确加载显示后就可以关闭了（这个时候小程序的包已经报留在你的手机某个位置了）。打开文件管理工具（模拟器终会提示root，真机请手动授权root权限），访问这个路径根目录（非存储） > data > data > com.tencent.mm > MicroMsg > 9f69************ad8d(类似这样的标识你所登录的账号的目录) > appBrand > pkg，可以看到类似下面这样的文件：_46541548_7.wxapkg_-529198367_190.wxapkg*.wxapkg如果不多的话将他们打包成zip，发送给微信朋友或者其他方法上传到网络硬盘。再到电脑上把刚接收的或者上传的zip下载到电脑上，解压出来。此时，文件就拿到了。反编译进入工具目录wxappUnpacker，建一个文件夹，比如pkg，将刚才拿到的文件放在这里。假设，我要尝试反编译这个文件_46541548_7.wxapkg，执行命令：node wuWxapkg.js ./pkg/_46541548_7.wxapkg顺利的话会生成一个同名的目录。打开这个目录就能看到了。异常程序出问题，工具出问题，代码有BUG，再常见不过了。以下几个异常，你也许也发生过，可能不明白，我把我遇到的异常理解分享一下：未安装成功工具依赖的模块Error: Cannot find module 'uglify-es'\r\n    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:507:25)\r\n    at Module.require (internal/modules/cjs/loader.js:637:17)\r\n    at require (internal/modules/cjs/helpers.js:22:18)\r\n    at Object.<anonymous> (/Users/whidy/webs/wxappUnpacker/wuJs.js:3:16)\r\n    at Module._compile (internal/modules/cjs/loader.js:689:30)\r\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)\r\n    at Module.load (internal/modules/cjs/loader.js:599:32)\r\n    at tryModuleLoad (internal/modules/cjs/loader.js:538:12)\r\n    at Function.Module._load (internal/modules/cjs/loader.js:530:3)那就是你没装好依赖，再执行一次npm run uglify-es。未识别的包...\r\nSaving files...\r\nUnpack done.\r\n/Users/whidy/webs/wxappUnpacker/wuWxapkg.js:104\r\n        }else throw Error(\"This package is unrecognizable.\\nMay be this package is a subPackage which should be unpacked with -s=<MainDir>.\\nOtherwise, please decrypted every type of file by hand.\")\r\n              ^\r\n\r\nError: This package is unrecognizable.\r\nMay be this package is a subPackage which should be unpacked with -s=<MainDir>.\r\nOtherwise, please decrypted every type of file by hand.\r\n    at Array.packDone (/Users/whidy/webs/wxappUnpacker/wuWxapkg.js:104:14)\r\n    at CntEvent.decount (/Users/whidy/webs/wxappUnpacker/wuLib.js:17:43)\r\n    at ioLimit.runWithCb.err (/Users/whidy/webs/wxappUnpacker/wuLib.js:73:11)\r\n    at agent (/Users/whidy/webs/wxappUnpacker/wuLib.js:54:14)\r\n    at FSReqWrap.oncomplete (fs.js:141:20)好像挺顺利，东西也出来了，可是最后还是报错了，推断是包内有包，子包解压失败。有关更多可以阅读：https://github.com/qwerty4721...未定义的$gwxSaving files...\r\nUnpack done.\r\n/Users/whidy/webs/wxappUnpacker/wuWxapkg.js:104\r\n        }else throw Error(\"This package is unrecognizable.\\nMay be this package is a subPackage which should be unpacked with -s=<MainDir>.\\nOtherwise, please decrypted every type of file by hand.\")\r\n              ^\r\n\r\nError: This package is unrecognizable.\r\nMay be this package is a subPackage which should be unpacked with -s=<MainDir>.\r\nOtherwise, please decrypted every type of file by hand.\r\n    at Array.packDone (/Users/whidy/webs/wxappUnpacker/wuWxapkg.js:104:14)\r\n    at CntEvent.decount (/Users/whidy/webs/wxappUnpacker/wuLib.js:17:43)\r\n    at ioLimit.runWithCb.err (/Users/whidy/webs/wxappUnpacker/wuLib.js:73:11)\r\n    at agent (/Users/whidy/webs/wxappUnpacker/wuLib.js:54:14)\r\n    at FSReqWrap.oncomplete (fs.js:141:20)这个就要修改一下工具源码了，打开wuWxss.js文件，修改内容如下：// 原始\r\nfunction runVM(name,code){\r\n    let wxAppCode={},handle={cssFile:name};\r\n    let vm=new VM({sandbox:Object.assign(new GwxCfg(),{__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)})});\r\n    vm.run(code);\r\n    for(let name in wxAppCode)if(name.endsWith(\".wxss\")){\r\n        handle.cssFile=path.resolve(frameName,\"..\",name);\r\n        wxAppCode[name]();\r\n    }\r\n}改成新的：function runVM(name,code){\r\n    let wxAppCode={},handle={cssFile:name};\r\n    let gg = new GwxCfg();\r\n    let tsandbox ={$gwx:GwxCfg.prototype[\"$gwx\"],__mainPageFrameReady__:GwxCfg.prototype[\"$gwx\"],__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)};\r\n    let vm = new VM({sandbox:tsandbox});\r\n    vm.run(code);\r\n    for(let name in wxAppCode)if(name.endsWith(\".wxss\")){\r\n        handle.cssFile=path.resolve(frameName,\"..\",name);\r\n        wxAppCode[name]();\r\n    }\r\n}再重新跑一次，Bingo！万事大吉。总结总的来说，这个操作还是比较容易的，最大的难点就是想办法提出文件了。工具别人写好了，有问题，Issue上面的解决方案很多，很快就能解决。想要实现更多，也可以参考工具的说明文档通过不同的命令操作。当然，小程序缓存到本地是迫不得已的，为了提高加载速度嘛。这个东西，微信官方大概已经知道了，我想可能也会封堵吧。这个微信官方或许也只是单纯打包了一下，所以就比较容易破解，如果他加壳，加密的话，或许以后就难了。这也让我想起很多年前，我也搞过类似的事情，大约8年前玩安卓手机的时候，解锁Bootload，开启Root来自个性化手机几乎满天都是，大把一键root，一键解锁工具，因此那时候安卓手机安全性很低，小白用户不懂，一不小心就中毒群发小广告。那时候也流行Wifi万能钥匙，流量很贵的啦，我经常蹭了网，再去系统目录找到那个存放wifi的配置文件来查看别人家的Wifi密码。然后再用这个密码尝试admin/密码，看看路由啥的，不过我没搞过破坏的。好了，大家如果还有不明白的，可以留言，我有空再分析一下这个工具的实现方式，也顺便尝试一下其他小程序（SWAN，头条，支付宝等），是否也是类似的，等有了结论再来一篇了~"}
{"title": "基于mpvue的小程序swiper类3d轮播 ", "author": "Rolan", "pub_time": "2019-3-21 00:43", "content": "前言功能：实现类3d轮播，切换效果为放大缩小 技术: 使用 mpvue框架，用小程序swiper组件以及小程序Animation动画对象项目地址： https://github.com/gzz0204/mpvue-swiper效果：演示效果图一、结构小程序swiper 改为mpvue的写法。设置previous-margin和next-margin来漏出两边的模块 设置circular使轮播无限循环绑定change事件，自定义handleChange方法获取当前swiper的index小程序swiper文档<template>  <div class=\"home_wrap\">    <swiper class=\"home_swiper\"      :previous-margin=\"previousMargin\"      :next-margin=\"nextMargin\"      :circular=\"circular\"      @change=\"handleChange($event)\">        <block v-for=\"(item, index) in datalist\" :key=\"index\">            <swiper-item>              <div :class=\"curIndex===index ? 'active_item' : 'item'\" :animation=\"index == curIndex ? animationData : animationData2\">                <!-- 卡片项，写在子组件中，详见下文的第四项 -->                <Card :data=\"item\" />              </div>            </swiper-item>        </block>    </swiper>    <!-- 指示点 -->    <div class=\"swiper_dot_wrap\">      <ul>        <li v-for=\"(item, index) in datalist\" :key=\"index\" :class=\"{'active':curIndex === index}\"></li>      </ul>    </div>  </div></template>二、js<script>import Card from '@/components/home_card'export default {  data () {    return {      curIndex: 0,      datalist: [{        coverImg: 'http://n.sinaimg.cn/sinacn20118/201/w1080h721/20190119/3311-hrvcwnk7953342.jpg',        title: '摩尔曼斯克',        desc: '摩尔曼斯克，北极圈内最大的城市，离芬兰也就半小时车程，整个城市才从极夜的天气中浮上来，太阳还未能升出地平线，城市只能靠云层的反射借光，一天只有几个小时的光亮，但红霞会持续一整天时间。'      }, {        coverImg: 'https://lh3.googleusercontent.com/IU9_NYevRO-fFjiH_hhjuxTOuDhG3cmMCWNOlnz2TBoG9jICiZevHGC0eJmvsrUwUAtbeFc=s128',        title: '安纳托利亚往事',        desc: '摩尔曼斯克2，北极圈内最大的城市，离芬兰也就半小时车程，整个城市才从极夜的天气中浮上来，太阳还未能升出地平线，城市只能靠云层的反射借光，一天只有几个小时的光亮，但红霞会持续一整天时间。'      }, {        coverImg: 'https://lh3.googleusercontent.com/xNHcyfvW2wbnSHzp9ldizNUoqhwpumx0j3QdnOlrOPH6gj4yWDif1mnaBtezpjMe9_AUKIc=s128',        title: '圣彼得堡是另一个阿姆斯特丹',        desc: '摩尔曼斯克3，北极圈内最大的城市，离芬兰也就半小时车程，整个城市才从极夜的天气中浮上来，太阳还未能升出地平线，城市只能靠云层的反射借光，一天只有几个小时的光亮，但红霞会持续一整天时间。'      }],      circular: true, // 设置衔接滑动      previousMargin: '63rpx',      nextMargin: '63rpx',      animationData: {}, // 卡片放大动画      animationData2: {} // 卡片缩小动画    }  },  components: {    Card  },  methods: {    handleChange (e) {      this.curIndex = e.mp.detail.current      this.changeActive()      this.changeNormal()    },    // 收缩    changeNormal () {      var animation2 = wx.createAnimation({        duration: 500,        timingFunction: 'ease'      })      this.animation2 = animation2      animation2.scale(0.9).opacity(0.3).step()      this.animationData2 = animation2.export()    },    // 展开    changeActive () {      var animation = wx.createAnimation({        duration: 500,        timingFunction: 'ease'      })      this.animation = animation      animation.scale(1).opacity(1).step()      this.animationData = animation.export()    }  }}</script>三、样式<style lang=\"less\" scoped>.home_swiper {  margin-top: 200rpx;  position: relative;  width: 100%;  height: 876rpx !important;  background: #303030;}.item{  transform: scale(0.9);  transform-origin: 50% 50% 0px;  opacity: 0.3;}.active_item{  transform: scale(1);  opacity: 1;}// 指示点.swiper_dot_wrap{  position: absolute;  top: 106rpx;  right: 65rpx;  width: 200rpx;  height: 15rpx;  ul{    float: right;    overflow: hidden;    li{      float: left;      width: 15rpx;      height: 15rpx;      box-sizing: border-box;      border-radius: 50%;      border: 2rpx solid #b99c6d;      margin-right: 15rpx;      &:last-child{        margin-right: 0rpx;      }      &.active{        background: #b99c6d;      }    }  }}</style>子组件card每张卡片单独拆分成了一个组件，方便修改。<template>  <div class=\"item\">    <div class=\"card\">      <!-- banner图片 -->      <div class=\"img_wrap\">        <image class=\"item_image\" :src=\"data.coverImg\"/>      </div>      <!-- 内容区域 -->      <div class=\"cont_wrap\">        <!-- 标题 -->        <div class=\"title_wrap\">          <div class=\"title\">            {{data.title}}          </div>        </div>        <!-- 描述 -->        <div class=\"desc\">{{data.desc}}</div>      </div>    </div>  </div></template><script>export default {  props: {    data: {      type: Object    }  }}</script><style lang=\"less\" scoped>.item{  height: 890rpx;  position: relative;  .card{    position: absolute;    width: 625rpx;    height: 811rpx;    background: #fff;    border-radius: 7rpx;  }}/* 当前 swiper-item*/.active_item .card{  opacity: 1;}/* banner */.img_wrap{  position: relative;  background: #303030;  /* 图片 */  .item_image{    display: block;    width: 100%;    height: 399rpx;    border-radius: 7rpx 7rpx 0 0;    z-index: 5;    opacity: 0.7;  }}/* 标题出处 */.title_wrap{  width: 560rpx;  height: 100rpx;  margin: 0 auto;  // padding-left: 130rpx;  box-sizing: border-box;  color: #b99c6d;  border-bottom: 2rpx dotted #e4dcce;  .title{    position: relative;    font-size: 30rpx;    line-height: 35rpx;    height: 70rpx;    padding-top: 30rpx;    overflow: hidden;  }}// 描述.desc{  width: 554rpx;  height: 140rpx;  margin: 0 auto;  color:#666666;  font-size: 24rpx;  line-height: 28rpx;  overflow: hidden;  margin-top: 21rpx;  text-align: justify;}</style>"}
{"title": "小程序云开发实战 --云数据库 ", "author": "Rolan", "pub_time": "2019-1-7 00:52", "content": "以前一直是使用关系型数据库，第一次使用NoSQL，跟大家分享一下我有限的使用心得，希望对像我一样初使用NoSQL的开发者有所帮助。首先说说微信小程序云开发里集成的这个NoSQL，官方并没有说明是哪种NoSQL数据库，但从开发文档和暴露的API，还有官方论坛里的讨论来看应该是一个简化版的MongoDB。需要指出的是微信小程序关于云数据库的开发文档非常的简略，对于像我这样没有太多NoSQL经验的用户，很多时候需要参考MongoDB的相关文档。接下来重点谈谈我在使用这个NoSQL云数据库时最不适应的一个痛点----文档级别的原子操作。我们经常要使用到原子操作，来避免当多个用户同时对同一个field（字段）编辑时发生冲突。我在使用前其实最担心的痛点是有无schema的区别，但是使用下来发现我挺习惯，也挺喜欢无schema的，后文再详说。现在具体来看看MongoDB只支持document（文档）级别的原子操作。对于我来说，这个限制鼓励我尽量把所有关系都放在一个document里。对此我一开始是有点抗拒的，对于从关系型数据库过来的人特别不习惯。而更让我苦恼的是微信小程序云开发集成的这个云数据库是一个简化版MongoDB，只提供了非常有限的原子操作指令（command）。对于一些常用的document级别原子操作，我必须构想自己的解决办法，而没有提供直接对应的command。以下是两个我在实际开发中遇到的这类问题及我的解决办法：1.应用场景：对于一个视频，我需要一个叫total_likes的field（字段），当有用户点击“喜欢”时该field递增1，当有用户取消“喜欢”时该field递减1。痛点：小程序云数据库只提供了递增指令的原子操作，没有提供递减指令。const _ = db.command\r\ndb.collection('video').doc('video-id').update({\r\n  data: {\r\n    total_likes: _.inc(1)\r\n  }\r\n})解决办法：要实现递减的原子操作，只需在递增指令里传入负数，如data: {\r\n  total_likes: _.inc(-1)\r\n}\r\n2.应用场景：对于一个线上课程，我需要一个叫subscribers的field（字段）来记录有多少人订阅了该课程。当有用户点击“订阅”时该字段需记录该用户的id，名字及头像；当有用户取消“订阅”时需把该用户从subscribers字段里删除。痛点：我们很自然的会想到用数组（Array）数据类型来维护subscribers这个字段，虽然小程序云数据库提供了一些针对数组的原子操作，如push，pop，shift和unshfit，可是无法实现取消订阅这个场景的原子操作。解决办法：弃用Array转而使用对象（object）数据类型来维护subscribers这个字段。最终的数据看起来会是这样的：{\r\n    \"subscribers\": {\r\n        \"userID-1\": {\r\n            \"name\": \"小明\",\r\n            \"avatar\": \"https://avatar-1.com\"\r\n        },\r\n        \"userID-2\": {\r\n            \"name\": \"小红\",\r\n            \"avatar\": \"https://avatar-2.com\"\r\n        },\r\n        \"userID-3\": {\r\n            \"name\": \"小李\",\r\n            \"avatar\": \"https://avatar-3.com\"\r\n        },\r\n        ...\r\n    }\r\n}当有用户订阅时的原子操作：const subscriber = \"subscribers.\" + user.id;\r\ndb.collection('class').where({\r\n  _id: 'classID',\r\n}).limit(1).update({\r\n  data: {\r\n    [subscriber]: {\r\n      avatar: user.avatar,\r\n      name: user.name,\r\n    }\r\n  }\r\n})当有用户取消订阅时的原子操作：const subscriber = \"subscribers.\" + user.id;\r\ndb.collection('class').doc('classID').update({\r\n  data: {\r\n    [subscriber]: _.remove()\r\n  }\r\n})前文说到我很喜欢无schema，因为它非常适合快速迭代开发。而且由于云数据库使用的是类似JSON的数据结构，对于全栈开发者，基本上可以实现由前端来定义数据结构。这样的开发流程非常适合小团队，不需要庞大的并行开发，突出沟通效率和对产品需求的随机应变。顺带一提的是微信小程序云开发能力是从基础库2.2.3开始支持的，但如果要支持所有版本的基础库，可以在 app.json / game.json 中增加字段 \"cloud\": true本系列第一章：小程序云开发实战系列01--云环境设置《Meetup丨活动报名组局》是我最近开发的一个活动报名预约工具小程序，这个系列文章主要来自我在开发这款小程序时的一些体会心得。感兴趣的小伙伴可以扫下面的二维码进入我的小程序。"}
{"title": "mpvue开发大型体育项目及总结记 ", "author": "Rolan", "pub_time": "2019-1-8 00:07", "content": "最近接到上头的指示，要做一个体育类的小程序，并且要在元旦之前上线一版，看了下时间，距离元旦只有一个多月，而且除去测试的时间和双休，最多只有三个星期，时间相当的紧迫，而且需求文档都更新到1.3了，这也就意味着安卓和ios的版本迭代已经到了1.3了，而我们小程序要在三个星期内开发完1.0-1.3版本的功能，所以我们的时间相当的紧迫，看了下需求文档和原型图，我整个人大吃一惊，有100多个页面，我顿时懵逼了，产品经理更我说；你们只需做三个模块，最后一个模块不用做，我看了一下最后一个模块，有10几个页面，除去10几个页面还有90多个呀，页面还好，最难的是需求文档的业务逻辑呀，而且这个项目的难度比中小型电商项目类的要难的多，交互相当的频繁和复杂，怎么办呢，一句话，凉拌，毕竟这是boss要求做的项目，只好硬着头皮往下做，不得不从。技术选型因小程序页面多，切交互频繁，如果用原生开发的话，时间来不急，而且页面的交互很多，这样原生小程序就显得那么的吃力了，最终我将技术选型放在了，wepy和mpvue这两个框架上，wepy框架是微信官方维护的，兼容性和扩展性很好，mpvue是美团旗下的，我最终选择了mpvue，原因是mpvue的语法跟Vue的语法是一样的，而且我们的前端同学都会Vue，所以选择mpvue是最好的选择，于是看了一下mpvue的文档和注意点，最终搭建了小程序的项目结构，将任务安排了下去，于是开启了加班的苦日子....技术点1-小程序，安卓，iOS三端数据信息同步，免登陆因项目中的登录方式含有微信登录，所以三端协商，如果用户是微信登录的话，三端统一取， unionid 这个字段，这时肯定有同学要问；为什么不取 openid ，如果做过小程序的人一定知道openid是唯一的标识，微信小程序有一个，那么在安卓，iOS他们也都有自已的openid标识，所以这样是不能达到三端数据信息同步，免登陆的效果的，微信官方介绍了6种获取 unionid 的方法,我们项目最终采用了解密获取的方法，官方文档。import {AchieveOpenid} from '@/http/api.js';\r\n    let that=this;\r\n    wx.login({\r\n        async success(resCode){\r\n            const cache=await AchieveOpenid({    //openid,内部服务器=》腾讯获取到了openid\r\n                code:resCode.code\r\n            });\r\n            that.openid=cache.result.unionid;\r\n            wx.setStorageSync('openId',that.openid);\r\n        }\r\n    })\r\n复制代码注意：这个方法是官方中的wx.login+code2Session方法，也确实可以获取unionid，但是天有不测风云呀，测试组的人员测出了unionid不存在的情况，而且还有几个账号也出现了这种问题，那么我们就开始找原因，最终我们发现，如果用户没有关注过任何的公众号，微信是不会给他返回unionid的，我们找到原因之后，马上换了另外一种方法，那就是解码的方式，也是我们最终的方法。<button class='openpage-authorize' \r\n            open-type=\"getUserInfo\" \r\n            lang=\"zh_CN\" \r\n            @getuserinfo=\"onGotUserInfo\">\r\n    </button>\r\n复制代码//注意我这里只列举解码的代码，有些代码省略了，请熟知。\r\n   import WXBizDataCrypt from \"@/utils/cryptojs/RdWXBizDataCrypt.js\"   //引用解码\r\n    methods:{\r\n         deCode(encryptedData,iv,sessionKey){\r\n         let wxObj=null,data=null;\r\n             wxObj= new WXBizDataCrypt('wx3ea59bf3ff3a9bb8', sessionKey);\r\n             data= wxObj.decryptData(encryptedData,iv);\r\n            this.openid=data.unionId;\r\n            wx.setStorageSync('openId',data.unionId);\r\n        },\r\n        onGotUserInfo(e) {   //通过按钮触发getuserinfo\r\n            if(e.mp.detail.userInfo){\r\n                this.deCode(e.mp.detail.encryptedData,e.mp.detail.iv,this.sessionKey);\r\n            }else{\r\n                toast('请再次授权');\r\n            }\r\n        },\r\n    }\r\n复制代码最终我们可以通过上面的代码获取 unionId ， 解码地址下载 , 注意：解码这一步最好放在服务端解码，不要放在客户端解码，这样会造成信息泄露.....技术点2-在小程序中使用canvas我们可以看到上面两个项目中的案例图片，他们是用canvas画的，第一个是采用微信官方的api，wx.createCanvasContext 不懂得同学可以自已去看 微信官方文档，代码如下const ctx = wx.createCanvasContext('myCanvas');\r\n            ctx.setLineCap('round')\r\n            var gradient1=ctx.createLinearGradient(0,0,170,0);\r\n            gradient1.addColorStop(\"0\",\"#FFF956\");\r\n            gradient1.addColorStop(\"1.0\",\"#FF6C00\");\r\n            var gradient2=ctx.createLinearGradient(0,0,170,0);\r\n            gradient2.addColorStop(\"0\",\"#8156FE\");\r\n            gradient2.addColorStop(\"1.0\",\"#3AFFF1\");\r\n            ctx.setLineWidth(4);\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 30,0.75*Math.PI,0.25*Math.PI,false);\r\n            ctx.setStrokeStyle('#4e4f59');\r\n            ctx.stroke()\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 38,0.75*Math.PI,0.25*Math.PI,false);\r\n            ctx.setStrokeStyle('#4e4f59');\r\n            ctx.stroke();\r\n            //胜\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 30,0.75*Math.PI,(((winarc*1.5+0.75)%2)==0?2:((winarc*1.5+0.75)%2))*Math.PI,false);\r\n            ctx.setStrokeStyle(gradient1)\r\n            ctx.stroke()\r\n            //负\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 38,0.75*Math.PI,(((failarc*1.5+0.75)%2)==0?2:((failarc*1.5+0.75)%2))*Math.PI,false)\r\n            ctx.setStrokeStyle(gradient2);\r\n            ctx.stroke()\r\n            ctx.setTextAlign('center');\r\n            ctx.setFontSize(16);\r\n            ctx.setFillStyle('#fff');\r\n            ctx.setTextBaseline('middle');\r\n            ctx.fillText('战绩', 50, 50);\r\n            ctx.draw()\r\n复制代码注意点：如果canva的数据是异步的话，一定要在数据加载完成之后，在让它渲染到视图层中去，如果不这样做的话，canvas会数据不同步，具体的做法可以加一个开关，如下..<canvas canvas-id=\"myCanvas\" class=\"index-header-data-circle-canvas\" v-if='on'></canvas>\r\n复制代码data(){\r\n       return {\r\n           on:false\r\n       }\r\n   }\r\n   async xx(){\r\n        try{\r\n             const data=await xxx();\r\n             this.on=data.code==='000'?true:false;\r\n        }catch (error) {}\r\n   }\r\n   //注意：以上代码只是模拟，仅供查考。\r\n复制代码技术点3-图片上传转化base64图片上传微信小程序给我们提供了api, wx.chooseImage ，上传简单，关键是如何转化base64位呢，我们的舒同学用了如下的写法，看着确实没什么问题，用临时路径作为一个请求的url，把数据返回格式设置成arraybuffer，这个也确实是个办法，在微信开发工具里面也是ok的，但是天有不测风云呀，在真机上请求报错了，那么这种方法pass掉。wx.chooseImage({\r\n      success:res=>{\r\n            wx.request({\r\n                  url:url,\r\n                  responseType: 'arraybuffer', //最关键的参数，设置返回的数据格式为arraybuffer\r\n                  success:res=>{\r\n                        let base64 = wx.arrayBufferToBase64(res.data); \r\n                      }\r\n           })\r\n})\r\n复制代码针对上面的问题，仔细的看了下微信官方文档，最终找到了一个代码少，简单的方法， wx.getFileSystemManager() 这个api可以解决我们上面的问题，微信官方文档，代码如下wx.chooseImage({\r\n                count: 1,\r\n                sizeType: ['original', 'compressed'],\r\n                sourceType: ['album', 'camera'],\r\n                success:(res)=>{\r\n                     wx.getFileSystemManager().readFile({\r\n                                filePath:res.tempFilePaths[0],  //选择图片返回的相对路径\r\n                                encoding: 'base64', \r\n                                success: res => {  \r\n                                     console.log(res.data)\r\n                                }\r\n                    })\r\n                }\r\n              })\r\n复制代码其实除了， wx.getFileSystemManager() 可以解决我们的问题外，还有一种方法，那就是更html5一样的处理方法，通过canvas来画，然后在用canvas的api来转base64， 注意：如果通过canvas来转base64的话，有个bug,那就是在iOS手机上图片会出现旋转90度的问题 小程序可以借鉴 这个同学的方法来解决 ，如果是html5的话可以通过 exif.js 这个库来解决问题。技术点4-对picker的封装小程序中有个picker组件，他支持5中类型，虽然有5中类型但是每个项目的不同，所以对picker的用途就不同，因此我们将对picker进行封装，来达到满足我们项目的需求,我们封装省市，时间日期等组件，我这里就只介绍 省市 组件的封装，其他的组件封装原理同省市组件原理一样的，我这里就不多说了，代码如下。<picker  class=\"pickes\"  mode=\"multiSelector\" \r\n           @change=\"PickerChange\"\r\n           @columnchange=\"PickerColumnChange\" \r\n           :range=\"allList\" \r\n           range-key='provinceName'  \r\n           :value='multiIndex' v-if='show'>\r\n          <div class=\"slot\"></div>\r\n    </picker>\r\n复制代码/**\r\n * @describe 省市选择器\r\n * @rerurn  省，市，省id,市id\r\n */\r\n  import {allCity} from \"@/http/api.js\";\r\n  export default {\r\n      data() {\r\n        return {\r\n            list:[],\r\n            multiIndex: [0, 0], //显示化动的列数\r\n            allList:[],    //存储二维数据\r\n            singleList:[], //存储一维数组\r\n            show:false,    //防止数据没有加载出来\r\n            cityInfo:{},   //存储省，市，省id,市id\r\n        }\r\n      },\r\n      mounted(){\r\n        this.init();\r\n      },\r\n      methods:{\r\n        async init(){   \r\n            try {\r\n                 let child=[],data=null;\r\n                  data=await allCity();  //获取后台返回的城市\r\n                  this.singleList=data.result;\r\n                 child.push(data.result[0]);\r\n                 this.allList.push(data.result,child);\r\n                this.show=true;\r\n            } catch (error) {}\r\n        },\r\n          PickerChange(e) {\r\n             this.cityInfo.provinceId=this.singleList[e.mp.detail.value[0]].provinceId; //省id\r\n             this.cityInfo.provinceName=this.singleList[e.mp.detail.value[0]].provinceName; //省名\r\n             this.cityInfo.cityId=this.singleList[e.mp.detail.value[0]].cityList[e.mp.detail.value[1]].cityId; //城市id\r\n             this.cityInfo.cityName=this.singleList[e.mp.detail.value[0]].cityList[e.mp.detail.value[1]].cityName; //城市名\r\n             this.$emit('cityInfo',this.cityInfo); //将值传给父组件\r\n          },\r\n          PickerColumnChange(e) {\r\n            switch (e.mp.detail.column) {\r\n              case 0:\r\n                this.list = [];\r\n                this.singleList.forEach(item => {\r\n                       if (item.provinceId ==this.singleList[e.mp.detail.value].provinceId) {\r\n                         item.cityList.forEach(item=>{\r\n                           //注意这一步最为重要，给数组添加一个和父对象一样的键值名，这样picker组件可以找的到\r\n                             item.provinceName=item.cityName;  \r\n                         })\r\n                      }\r\n                   });\r\n                this.allList[1]=this.list;\r\n                this.multiIndex[0]=e.mp.detail.value;\r\n                this.multiIndex[1]=0;  //注意这个表示的时选择中省切换的时候，要将省的第一个城市放在第一位\r\n                break;\r\n            }\r\n          },\r\n      }\r\n  }\r\n复制代码技术点5-在小程序使用高德定位因项目中要用到定位功能，而小程序中的的api并不适用项目，所以就选择了高德定位，高德小程序版文档，代码如下//注意我这里只列举定位的代码，有些代码省略了，请熟知。\r\n   \r\n    let _this = this,myAmapFun=null;\r\n     myAmapFun = new amapFile.AMapWX({\r\n        key: \"xxxxx\"   //高德的密钥\r\n    });\r\n    myAmapFun.getRegeo({\r\n        success(data){\r\n            _this.$store.dispatch('cityLocal',data[0].regeocodeData.addressComponent.city);\r\n        },\r\n        fail(err) {\r\n               wx.showModal({\r\n                    title: '提示',\r\n                    content: '定位失败，请手动定位',\r\n                    success (res) {\r\n                        if (res.confirm) {\r\n                        path({url:'/pages/city/main'});\r\n                        }else if (res.cancel) {\r\n                           _this.$store.dispatch('cityLocal','定位失败');\r\n                        }\r\n                    }\r\n                })\r\n        }\r\n    });\r\n复制代码技术点6-对微信小程序节点的运用由于项目用到了城市索引选择功能，所以就采用 wx.createSelectorQuery() 这个api来实现这个功能，代码如下<ul  class=\"slide\">\r\n        <li v-for=\"(item,index) in cityJson.leter\" \r\n            :key=\"index\" \r\n            @tap='touStart(item.letid,item.lettext)'>\r\n            {{item.lettext}}\r\n        </li>\r\n     </ul>\r\n复制代码//注意我这里只列举城市索引选择的代码，有些代码省略了，请熟知。\r\n   onPageScroll(e){\r\n        this.scollTop=e.scrollTop    //同步\r\n    },\r\n    methods:{\r\n         touStart(flag,text){\r\n                 try {\r\n                    wx.createSelectorQuery().select(flag).fields({   //运用微信节点api\r\n                    dataset: true,\r\n                        size: true,\r\n                        rect: true,\r\n                        computedStyle: ['margin', 'backgroundColor']\r\n                        }, (res)=> {\r\n                            wx.pageScrollTo({\r\n                                    scrollTop: this.scollTop+res.top,\r\n                                    duration: 0\r\n                            });\r\n                            this.on=true;\r\n                            this.modalText=text;\r\n                            setTimeout(()=>{\r\n                                  this.on=false;\r\n                            },2000)\r\n                        }).exec() \r\n                 }catch (error) {}\r\n            },\r\n    }\r\n复制代码当然实现上面这个功能也可以用其他的方法，如scroll-view，我这里就不多说了。技术点7-返回上一层页面，刷新页面数据我们可以通过微信中的 wx.navigateBack() 这个api就可以返回上一层页面，但是怎样返回上一层页面并且刷新呢，其实可以通过onShow这个生命周期函数来刷新页面，如果那个页面含有参数的话，最好代码这么写onShow(){\r\n//之所以用try，是因为mpvue官方说，如果要获取地址参数的话，最好在mounted周期里面获取，我们用try可以避免代码终止和报错\r\n     try {   \r\n         let id=this.$root.$mp.query.Id;\r\n         this.init(id);\r\n     }catch (error) {}\r\n}\r\n复制代码结语由于时间的原因，我暂时先介绍这几个在小程序中常见的问题和功能，后面我会陆续介绍，如下技术栈vue的三种ssr方法,以及在项目中的使用react+redux在项目中的使用打造自已的webpack,gulp开发环境koa框架的介绍和使用"}
{"title": "微信小程序之构建 ", "author": "Rolan", "pub_time": "2019-1-8 00:27", "content": "由于小程序更新迭代速度很快，而且我们的技术栈是 react 全家桶，所以在对比 wepy 和 mpvue 之后，我们选择了直接使用原生小程序。对比图如下：当然直接使用原生的有个显然的缺点：没有了构建。不过这没有关系，缺什么补上即可。需要构建做什么一般来说，我们需要构建主要是用来做这些工作：ES6/7 转 ES5、NPM 包管理、组件化、 CSS 预编译、图片压缩、打包合并等。而这些能力除了CSS 预编译和图片压缩之外，其他的功能小程序默认已经提供了。所以一个小巧的小程序构建只需要支持CSS 预编译和图片压缩即可。Gulp 构建方案既然只涉及到一些任务的处理，那么使用 gulp 是最合适不过的了。对于 CSS 预编译，有 gulp 对应的 sass、less、postcss 插件可选；对于图片压缩，可以使用 gulp 的 imagemini 插件，再装上各种图片的格式对应的压缩库即可。一般来说，运行构建命令，我们都会从一个源目录（src）到一个目标目录（dev/dist），但是小程序的 NPM 能力是不允许 node_modules 在根目录之外的，这就有了冲突。总不能跑个任务拷贝整个 node_modules 到目标目录吧。既然不能使用从一个源目录（src）到一个目标目录（dev/dist），那就只好在源目录就地解决了。源目录解决方案对于图片来说，压缩完了直接替换原图是没什么问题的。对于 CSS 预编译来说，如使用 postcss，从 CSS 文件到 WXSS 文件比较好解决。但是又引出了两个新问题：CSS 文件最好是不要打包发布。最好避免误修改 WXSS 文件，而是直接修改 CSS 文件。第一个我们可以在项目配置文件中设置上传代码的时候过滤 CSS 文件；第二个我们可以在 VSCode 编辑器中隐藏 WXSS 文件，避免误操作。To Base64既然有了构建，当然希望还能把一些缺失的能力补上。如 background 不支持本地图片。对于这个 postcss 也有相关的插件能解决：background-image\r\n代码配置最后贴上相关的代码配置。gulpfile.jsconst gulp = require('gulp');\r\nconst rename = require('gulp-rename');\r\nconst runSequence = require('run-sequence');\r\nconst postcss = require('gulp-postcss');\r\nconst imagemin = require('gulp-imagemin');\r\nconst cache = require('gulp-cache'); // 使用缓存\r\n\r\nconst src = './miniprogram';\r\n\r\n// 使用postcss\r\ngulp.task('css', () => {\r\n  return gulp.src(`${src}/**/*.css`)\r\n    .pipe(postcss())\r\n    .pipe(rename((path) => {\r\n      path.extname = '.wxss';\r\n    }))\r\n    .pipe(gulp.dest((file) => {\r\n      return file.base; // 原目录\r\n    }));\r\n});\r\n\r\ngulp.task('img', () => {\r\n  // 修改你要压缩的图片地址\r\n  return gulp.src(`${src}/**/*.{png,jpe?g,gif,svg}`)\r\n    .pipe(cache(imagemin([\r\n      imagemin.gifsicle({ interlaced: true }),\r\n      imagemin.jpegtran({ progressive: true }),\r\n      imagemin.optipng({ optimizationLevel: 4 }),\r\n      imagemin.svgo({\r\n        plugins: [\r\n          { removeDimensions: true }, // 如果有 viewbox 则不需要 width 和 height\r\n        ],\r\n      }),\r\n    ])))\r\n    .pipe(gulp.dest((file) => {\r\n      return file.base; // 压缩到原目录\r\n    }));\r\n});\r\n\r\ngulp.task('watch', () => {\r\n  gulp.watch(`${src}/**/*.css`, ['css']);\r\n});\r\n\r\ngulp.task('dev', ['css'], () => {\r\n  runSequence('watch');\r\n});postcss.config.jsconst path = require('path');\r\n\r\nmodule.exports = {\r\n  parser: 'postcss-scss',\r\n  plugins: {\r\n    'postcss-partial-import': {\r\n      path: [path.resolve(__dirname, 'src')],\r\n    },\r\n    'postcss-font-base64': {}, // font to base64\r\n    'postcss-advanced-variables': {},\r\n    'postcss-nested': {},\r\n    'postcss-extend-rule': {},\r\n    'postcss-color-function': {},\r\n    'postcss-url': {\r\n      url: 'inline', // inline image to base64\r\n    },\r\n  },\r\n};"}
{"title": "小程序开发采的几个坑 ", "author": "Rolan", "pub_time": "2019-1-8 00:16", "content": "上个月参与了助力小程序的开发，其中也遇到了一些小程序开发过程之中的问题。getMenuButtonBoundingClientRect获取菜单按钮（右上角胶囊按钮）的布局位置信息。坐标信息以屏幕左上角为原点。如果我们使用的是自定义导航模式（ navigationStyle: 'custom' ），一般则需要通过此函数来获取菜单按钮的信息：此函数从官方文档上看是同步的，但是经过实际中发现，它可能是异步的。经常有的时候会获取不到相应的 bottom、top 等信息。video 组件的全屏问题经过测试发现，小程序的 video 组件会在进入全屏播放，然后退出全屏的过程中黑屏。重现步骤： 1.视频进行全屏播放 2.拉动进度条播放 3.页面显示加载中时，点击小屏播放 4.页面显示黑屏，并且卡住不动，一直无法播放经过确认，是微信官方的 Bug：低版本 IOS 兼容性问题因为小程序底层也是通过 webview 来渲染，所以有一些通用的兼容性问题要注意。 比如IOS9、IOS10下面的绝对定位（absolute、fixed）必须要有多个定位(left / top)，如果只写一个定位，比如只写一个 top: 0; ，你会发现在开发者工具和 IOS11以上真机是可以显示的，但是在低版本上却无法显示。"}
{"title": "微信小程序地图(map)组件点击(tap)获取经纬度 ", "author": "Rolan", "pub_time": "2019-1-9 00:23", "content": "微信小程序中使用地图(map)组件，通过点击(tap)获取经纬度，按照官方的回应，暂时是没法做到的，从地图组件API多有残缺判断，怀疑是个实习生干的...做个变通，适用性有限，请大家参考。基本思路就是在地图上铺满一层marker，从而通过点击marker获得经纬度。<map id=\"map\" longitude=\"102.324520\" latitude=\"40.099994\" scale=\"4\" bindcontroltap=\"controltap\"polygons=\"{{polygons}}\" bindregionchange=\"regionchange\" markers=\"{{markers}}\"bindmarkertap=\"markertap\" show-location style=\"width: 100%; height: 700px;\"></map>const app = getApp()\r\n\r\nconst markersize = 30\r\n\r\nfunction range(start, edge, step) {\r\n  for (var ret = [];\r\n    (edge - start) * step > 0; start += step) {\r\n    ret.push(start);\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction markers(northeast, southwest, scale, width, height) {\r\n\r\n  const markerslng = (northeast.longitude - southwest.longitude) * markersize / width\r\n  const markerslat = (northeast.latitude - southwest.latitude) * markersize / height\r\n\r\n  const maxlon = northeast.longitude\r\n  const minlon = southwest.longitude\r\n  const maxlat = northeast.latitude\r\n  const minlat = southwest.latitude\r\n\r\n  const lons = range(minlon, maxlon, markerslng)\r\n  const lats = range(minlat, maxlat, markerslat)\r\n\r\n  let _markers = []\r\n  lons.forEach((lon, i) => {\r\n    lats.forEach((lat, j) => {\r\n      _markers.push({\r\n        id: lon + ',' + lat,\r\n        latitude: lat,\r\n        longitude: lon,\r\n        iconPath: '/marker.png',\r\n        alpha: 0.1, //将图片设置为透明,通过开发者工具看不出效果,但真机是有效果的\r\n        width: markersize,\r\n        height: markersize\r\n      })\r\n    })\r\n  })\r\n  return _markers\r\n}\r\n\r\nPage({\r\n  data: {\r\n    polygons: [],\r\n    controls: [{\r\n      id: 1,\r\n      position: {\r\n        left: 0,\r\n        top: 300 - 50,\r\n        width: 50,\r\n        height: 50\r\n      },\r\n      clickable: true\r\n    }],\r\n    markers: []\r\n  },\r\n  createMarkers() {\r\n\r\n    this.mapCtx = wx.createMapContext('map')\r\n    const query = wx.createSelectorQuery()\r\n    const map = query.select('#map').boundingClientRect()\r\n\r\n    let that = this\r\n\r\n    that.mapCtx.getRegion({\r\n      success(res1) {\r\n        that.mapCtx.getScale({\r\n          success(res2) {\r\n            query.exec((res) => {\r\n              let width = res[0].width;\r\n              let height = res[0].height;\r\n              let _markers = markers(res1.northeast, res1.southwest, res2.scale, width, height)\r\n              that.data.markers = _markers\r\n              that.setData(that.data)\r\n            })\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  regionchange(e) {\r\n    this.createMarkers()\r\n  },\r\n  markertap(e) {\r\n    console.log(e.markerId)\r\n  },\r\n  controltap(e) {\r\n    console.log(e.controlId)\r\n  },\r\n  onReady(e) {\r\n    this.createMarkers()\r\n  }\r\n})效果如图"}
{"title": "2019微信公开课PRO开讲 小程序发布两周年最新重磅数据 ", "author": "Rolan", "pub_time": "2019-1-10 00:08", "content": "腾讯科技讯 1月9日消息，2019微信公开课PRO在广州正式启动。作为微信团队每年与各行合作伙伴的重要“约会”，本届微信公开课PRO版聚焦“同行”：小程序、小游戏、微信支付和企业微信4大产品线在现场晒出过去一年的“成绩单”，并在现场发布“优质小程序计划”、“小游戏创意鼓励计划”等新措施。活动现场，微信团队还介绍了未来新的“同行者”：微信智言对话系统、Hardcoder等全新产品与能力，全景展现微信生态在产业互联网的布局与未来同行计划。所有这些都强烈展示出微信对生态建设的态度和To B业务拓展的决心。此外，微信团队在现场发布的《2018微信数据报告》再现了微信过去一年的发展足迹：报告显示，目前微信与WeChat合并与活跃账户数达10.82亿；消息日发送次数450亿，较去年增长18%；音视频通话次数达4.1亿次，较去年增长100%。在出行、零售、餐饮、公共服务领域，2018年每月支付人数都较去年有了较大幅度的增长，从社交到商业，微信已经深入到了我们生活的方方面面。本届微信公开课PRO版上分享的同行伙伴也迎来史上最全阵容：覆盖零售、餐饮、政务民生、交通、教育、时尚生活等多领域，用超过40个案例分享了他们如何利用微信的能力，加速迈入移动互联网下半场的经验。林肯中国作为2019微信公开课PRO的特约合作伙伴，为部门VIP演讲嘉宾提供了接送车队支持，并在VIP嘉宾签到入口处进行了豪华的车队展示。服务超1000亿人次，2岁的小程序年交易增长超过600%迎来2岁生日的小程序如今不仅是亿万用户的“新国民工具”，越来越多的开发者的加入也让小程序更加明确了自己的商业路径：官方数据显示，小程序已覆盖超过200个细分行业，服务超过1000亿人次用户，年交易增长超过600%，创造了超过5000亿的商业价值。“小程序的数量很重要，这是丰富场景的基石，但小程序的好坏也同样重要，我们希望让用户用上更好的小程序，”在2019微信公开课PRO现场，小程序团队正式宣布将在2019年上线小程序评分体系及“优质小程序计划”，帮助用户更好的发现、使用优质的小程序。小程序团队希望通过开放更多的能力及助力措施，做好各行各业的助手：开发者方面，小程序团队将提供系列能力和支持，帮助更多开发者将能力变为价值：2019年，小程序团队将上线“大家都在用”、小程序搜索、全新的附近的小程序等能力，给予开发者更多的曝光机会；同时降低开发门槛、提供小程序助手、物流相关的助手和接口，帮助开发者更容易开发出好的小程序；并通过开发者社区、服务平台进一步加强与开发者的关系。同时，在2019微信公开课PRO上，腾讯云宣布推出总价值超过10亿元的“小程序o云开发”资源扶持计划，对超过一百万小程序开发者提供免费云开发资源扶持，全面助力开发者打造优秀小程序。在行业方面，小程序团队将陆续推出更精准的行业解决方案、为行业提供数据分析及运营方案，以及提供包括激励视频、插屏广告、个人小程序变现等全新的盈利方式，让行业用户可以更快获得商业支持。小游戏继续鼓励创意，欲孵化更多千万盈利级小游戏如何让小游戏更有创意，更好玩？2018年，小游戏平台启动了“创意鼓励计划”，持续完善运营环境及开发环境，帮助开发者更好地发挥自己的创意。2019年，平台一方面将延续2018年分成优惠策略，推出更便捷的资金经营流转方案，同时也会开拓新的商业模式，为创意小游戏提供资金支持及政策倾斜，让更多小游戏发挥其价值。“小游戏的本质是创意，”2018年，微信小游戏团队曾在《致小游戏开发者的一封信》中，鼓励开发者通过创意为用户带来更多优质的小游戏产品。小游戏上线1年来，共有超过10万的开发者加入到小游戏生态中，截至目前，优质小游戏活跃用户次日留存率高达60%，七日留存率达54%，其中，10款优质小游戏安卓内购月流水实现了千万盈利、11款小游戏广告月流水过千万。如何孵化出更多盈利大户？小游戏团队在活动现场公布了全新的小游戏解决方案，平台还将从研发架构、玩法内容、测试发布以及用户体验等层面，多方位帮助开发者优化小游戏启动性能及开发效率，为用户提供更优质的游戏体验。针对新上线小游戏面临的用户获取难问题，小游戏团队最新推出“新游种子用户”计划，通过两个阶段为新游戏提供不同程度的扶持。第一阶段，新游将获得随机分配的“种子用户”，帮助新游利用初始用户进行运营和传播扩散；第二阶段，针对高品质小游戏进一步提供“种子用户”，帮助优质小游戏加快增长。微信支付化身智慧化工具，帮更多企业平滑切入产业互联网“未来还将持续通过智慧化工具帮助企业提升经营效能，从‘人货场‘的数字化改造、消费链升级、数字化工具等方面切入，帮助更多行业实现从消费互联网到产业互联网的升级，” 微信支付团队在活动现场表示。过去一年，微信支付秉持极致开放的原则，为合作伙伴提供了基础支付工具、商户营销工具、商户管理工具、质量运营工具等助力，并通过与腾讯其他智慧化能力的结合，帮助合作伙伴实现了用户行为消费链的全面升级。以零售为例，商家可以借助以微信支付为核心的数字化能力实现精准发券、扫码购、智慧收银、电子会员识别、无感停车、“到家”等服务。去年11月，天虹就与微信支付合作打造了首家智慧零售标杆店，以到家、扫码购、人脸支付等服务及基础，打造全流程数字化零售场景体验，实现门店数字化率高达85%，自助化率达到50%，不仅让用户购物更加智慧，也帮助天虹实现了更高效率的销售转化。活跃用户新增120%，企业微信成50+行业专属内外连接器在腾讯产业互联网战略中，企业微信是一个重要的工具，通过解决企业沟通壁垒、管理隔阂、信息数据难以沉淀等问题，帮助企业打通内外部资源连接，快速实现企业运营管理的数字化转型。目前，企业微信已经覆盖了超过50个行业，新增企业100%，活跃用户新增120%。2018年，与微信的互通成为企业微信发展的重要节点。越来越多的企业通过企业微信连接微信生态，并打通了企业支付、小程序、客户服务等能力，实现企业无缝触达与管理微信侧的客户，帮助企业从连接员工、连接组织，延伸到连接消费者。长安汽车用企业微信连接上千家经销商,将上下游的问题反馈处理时间从原来的平均2.13天缩短至0.13天,效率提升了1538%,直接解决了企业上下游协作的问题；德邦物流的团队管理者,一键发起上千人的跨部门大群,轻松实现高效对接。随着企业微信能力的不断迭代，服务商在生态中所扮演的角色越来越重要，企业微信对服务商合作伙伴始终秉持开放、共赢的原则。目前，企业微信生态中拥有超过14000个服务商，开放了201个接口，让服务商可以通过接口帮助企业连接内外部人员、连接应用、小程序、硬件，真正实现帮贡数字化、移动化升级。企业微信团队表示，2019年，企业微信还将进一步下沉行业解决方案，深化连接概念并落地到具体的功能，触及到细分领域的每一环,以独特的方式连接产业、服务产业、也服务于人。微信生态更“硬”了：微信“智言”+Hardcoder全新发布，万物互联更近了除了对微信商业生态的解读，微信团队还在活动现场带来了更“硬核”的分享。以人工智能、语音识别为核心的微信智言对话系统“小微”在2019微信公开课PRO正式亮相。通过整合小程序、QQ音乐、企鹅FM、即时通讯等生态能力及第三方生态内容，让用户通过耳机、音箱等设备连接“小微”即可获得全方位的智能服务。微信智言对话系统还面向开发者提供了硬件SDK和云端AP的一键式款速接入，降低开发者的门槛，目前，微信智言对话系统技术方案已经应用于百余款硬件产品。除此以外，微信团队还在现场发布了“Hardcoder性能优化框架”，通过“Hardcoder”开发者可以更轻松地优化程序，突破性能。截至目前，Hardcoder微信用户覆盖量已经超过了2亿。2018年，微信创造就业岗位超2200万个，其中小程序拉动就业超过180万，较去年增长近80%。随着微信生态日益壮大，围绕小程序、公众平台、企业微信、微信支付聚集了大量开发者、运营者、服务商等生态合作伙伴，微信也始终在与这些合作伙伴同行，共创价值。"}
{"title": "微信小程序登录那些事 ", "author": "Rolan", "pub_time": "2019-1-9 00:06", "content": "最近团队在开发一款小程序，都是新手，一边看文档，一边开发。在开发中会遇到各种问题，今天把小程序登录这块的流程整理下，做个记录。\r\n小程序的登录跟平时自己APP这种登录验证还不太一样，多了一个角色，那就是微信服务器。\r\n\r\n根据微信官方提供的登录流程时序图可以清楚的了解小程序登录需要多少个步骤，下面我们来总结下：\r\n\r\n小程序启动，通过wx.login()获取code\r\n开发者服务器需要提供一个登录的接口，参数就是小程序获取的code\r\n登录接口收到code后，调用微信提供的接口进行code的验证\r\n得到验证结果，成功后能得到一个session_key和openid\r\n生成一个自定义的key, 将session_key和openid跟自定义的key关联起来\r\n将自定义的key返回给小程序\r\n每次请求都带上key, 后端根据key获取openid识别当前用户身份\r\n\r\n首先code是微信给的，如果你随意生成code去验证肯定是无效的，只有微信给的code才有效。code传到开发者自己的服务后，再去问微信：\r\nHi 哥们，我这个code是有效的还是无效的啊？\r\n微信会告诉你是有效还是无效，有效的情况下还会给你一个用户的标识，也就是openid，同时还会有一个session_key，也就是会话的key。session_key的有效期默认是2小时，当用户一直在使用小程序的话会自动刷新，这个是由微信这边来维护的。\r\n注意：\r\n\r\n会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。\r\n临时登录凭证 code 只能使用一次\r\n\r\n所以我们要为session_key创建别名，这个别名关联的哪个用户只有我们自己知道，唯一需要做的工作就在这块。\r\n我推荐2种方式来做关联：\r\n第一种：\r\n随机生成key, 关联openid，存入redis中，当请求带入key，直接从redis中获取openid得到当前用户信息，这个其实也就是我们自己去维护了会话信息\r\n第二种：\r\n采用JWT生成token，将openid绑定到token中，将token返回给小程序，请求的时候带上token，通过解析token得到用户信息。\r\n下面我们以第二种方式来进行讲解，会贴上部分代码：\r\n小程序中在app.js中的onLaunch方法中增加获取code方法，并且调用后端的登录接口获取token:\r\nwx.login({\r\n      success: function (res) {\r\n        var code = res.code;\r\n        if (code) {\r\n          console.log('app启动获取用户登录凭证：' + code);\r\n          let params = { \"code\": code };\r\n          let result = config.requestHttp(config.url.userLogin, 'POST', params)\r\n          result.then(res => {\r\n            let data = res.data\r\n            if (data.code == 200) {\r\n              wx.setStorageSync(\"login_token\", data.data.token);\r\n            }\r\n          }).catch(err => {\r\n            console.log(err)\r\n          });\r\n        } else {\r\n          console.log('获取用户登录态失败：' + res.errMsg);\r\n        }\r\n      }\r\n})\r\n复制代码userLogin接口则根据小程序的code去调用微信接口验证：\r\n// 小程序获取SessionKey接口地址\r\nString loginUrl = \"https://api.weixin.qq.com/sns/jscode2session\";\r\nString url = loginUrl + \"?appid=%s&secret=%s&grant_type=%s&js_code=%s\";\r\nurl = String.format(url, appid, appSecret, grantType, param.getCode());\r\nString result = restTemplate.getForObject(url, String.class);\r\nMap<String, Object> map = JsonUtils.toBean(Map.class, result);\r\n// 请求成功\r\nif (map.containsKey(\"session_key\")) {\r\n\tString openid = map.get(\"openid\").toString();\r\n    // 第一次保存到用户表，生成JWT TOKEN返回\r\n}\r\n复制代码小程序端需要将 wx.request()封装成一个通用的方法，所有跟后台交互都用这个方法来调用接口，我们可以在这个方法中设置登录之后获取的Token。这样每次请求都会将Token塞到请求头中，我们在网关中就可以获取这个Token进行解析验证。\r\n//请求封装\r\nfunction requestHttp(url, method, data) {\r\n  //请求头设置\r\n  var header = {\r\n    Authorization: wx.getStorageSync(\"login_token\")\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: config.home_config + url,\r\n      data: data,\r\n      header: header,\r\n      method: method,\r\n      success: (res => {\r\n        if (res.data.code === 200) {\r\n          resolve(res)\r\n        } else {\r\n          reject(res)\r\n        }\r\n      }),\r\n      fail: (res => {\r\n        reject(res)\r\n      })\r\n    })\r\n  })\r\n}\r\n复制代码Zuul中进行验证：\r\n  RequestContext ctx = RequestContext.getCurrentContext();\r\n  HttpServletRequest request = ctx.getRequest();\r\n  String token = request.getHeader(\"Authorization\");\r\n  if (StringUtils.isBlank(token)) {\r\n    \t\tctx.setSendZuulResponse(false);\r\n            ctx.set(\"isSuccess\", false);\r\n            ctx.setResponseBody(JsonUtils.toJson(Response.fail(\"非法请求【缺少Authorization】\", ResponseCode.NO_AUTH_CODE)));\r\n            ctx.getResponse().setContentType(\"application/json; charset=utf-8\");\r\n            return null;\r\n  }\r\n    \r\n  // 验证Token是否有效\r\n  JWTResult jwResult = JWTUtils.checkToken(token);\r\n  if (!jwResult.isStatus()) {\r\n    \t\tctx.setSendZuulResponse(false);\r\n            ctx.set(\"isSuccess\", false);\r\n            ctx.setResponseBody(JsonUtils.toJson(Response.fail(jwResult.getMsg(), jwResult.getCode())));\r\n            ctx.getResponse().setContentType(\"application/json; charset=utf-8\");\r\n            return null;\r\n   }\r\n   ctx.addZuulRequestHeader(\"loginUserId\", jwResult.getUid());\r\n   return null;\r\n复制代码验证成功后将用户ID设置到请求头中，传递给后端服务使用。\r\n使用JWT必然有一个问题是Token的失效问题，我这边失效时间设置的为2个小时，正常的话用户打开小程序，使用不可能连续超过2个小时，登录的逻辑是在app.js中做的，只要下次进去token就会重新申请。不过这个也可以调整，比如稍微长一点。\r\n核心就是用户的认证交给了微信，只要微信告诉我们认证成功了，我们就可以自己接管会话信息了。"}
{"title": "微信小程序练手 demo 之天气小程序总结(流水账) ", "author": "Rolan", "pub_time": "2019-1-9 00:32", "content": "想大致了解微信小程序的基础结构，加上之前没有写过 MVVM 结构，也借此了解一下，由于之前写过天气的 demo，这次也用比较熟悉的天气预报作为实现的功能，所使用的接口是和风天气，利用到的 API 有 实况天气， 多日天气预报， 逐小时天气预报， 生活指数， 当然实际上还有空气质量、历史天气等其他数据，此处使用几个作为展示。微信小程序开发之前需要注册微信公众平台，在 微信小程序 · 简易教程 处有详细的步骤，注册完下载微信开发者工具，填写申请完开发者账号以后的 AppID(在 mp.weixin.com 开发 -> 开发设置 中查看)，然后直接选择 创建 QuickStart 项目 (刚开始没看清楚选成云开发了，后来才发现跟教程的不太对，之后再接触云开发吧……)，然后到以下的图片界面：每个页面的结构基本由 xx.js xx.wxml xx.wxss xx.json 构成，类似 HTML + CSS + JavaScript，自己体会与后者不同的是：wxml 类似于 HTML，但是小程序规定了所能使用的组件(构成页面的基本单位)，有 view ，button，web-view等等，此外还使用自定义组件，自定义组件需要在 json 文件中先声明，再写 wxml 模板，js 中注册，详细步骤在 微信小程序 · 自定义组件。在写这个天气 demo 时只用到了小程序提供的基础组件，自定义组件还需要进一步了解，wxss 类似于 CSS，只是在选择器中做了很多限制，例如子选择器a > b，后代选择器a b，是不可用的，提倡直接使用 .classjs 与 JavaScript 类似，只是执行环境不同，不需要像浏览器端，写document window等内置对象，语法是相似的，只要稍微熟悉一下就可以了json 配置页面功能，如果写过 Chrome 的扩展的话，应该很熟悉了，就跟manifest.json类似，小程序里可以配置权限，是否全局开启下拉刷新，是否禁止上下滚动等等大致看了一遍文档以后，开始以 quickstart 项目为模板写上自己的代码，页面布局如下：于是以上面的结构分好各块代码，每块使用一个 view包括，内部按内容再细分，其中，每小时天气预报与多日天气预报由于信息过多，采用 scroll-view 展示，以滑动的形式浏览全部数据。实况天气中数据不是很多，直接的分块的 view中把各个组件写上，并写上对应的数据绑定变量，每小时、多日、生活指数中，由于是多个类似的数据，采用 view wx:for的形式，获取数据后循环渲染。样式的部分，每小时、多日天气预报的样式使用 item { flex: 1 }使每一小块均匀分布，生活指数分两列显示，容器 flex 布局，flex-wrap 设置为 wrap，给每个 item 设置 { width: 50%; }。然后就是编写 js，在进入小程序以后，首先利用微信的请求定位，获取到对应的经纬度，再通过 腾讯位置服务 转换为具体的地理位置显示，再把获取到的地理位置作为参数向和风天气发出请求，得到响应以后获得响应的数据，其中一部分数据需要经过处理简化，然后保存到 page.data，同时视图层渲染对应的数据获取到的天气数据中，日期是包含年份的，通常看天气的信息有月日即可，于是在获得响应的数据以后先对日期的部分进行处理：for (let i = 0; i < he.daily_forecast.length; i++) { // 去掉日期中的年份\r\n            res.data.daily_forecast[i].date = res.data.daily_forecast[i].date.slice(5)\r\n}然后再进行 setData 操作在大致基本功能完成后，实况天气的上方新加了一个 input，用于手动输入城市查询那个城市的天气，手动输入查询的城市不经过微信定位，直接把输入的内容作为参数向天气接口查询，成功则显示对应的城市及具体的天气，如果查询的城市有误，则弹出 toast 提示查询失败。在手动查询城市天气完以后，清空 input 的内容，因此需要在 input 的组件中加上 value={{inputValue}}，查询完以后把 page.data.inputValue 值置为空。另外，在真机体验时发现如果网络不好，会加载得很慢，等待时间会很长，数据一直显示不了，于是在进入小程序时先加载一个 loading，在请求成功时去掉 loading，优化用户体验。添加了下拉刷新，首先在 json 中设置 \"enablePullDownRefresh\": true，然后在 js 中写对应的函数即可onPullDownRefresh: function() { \r\n    getWeather()\r\n}关于腾讯位置服务的使用，首先下载相关的 js sdk，然后在微信公众平台的开发设置中设置 request 合法域名，添加 https://apis.map.qq.com(同样地，所用到的天气 API 的地址也是如此)，然后引入 js sdk 并实例化就可以使用了// 引入SDK核心类\r\nvar QQMapWX = require('../../libs/qqmap-wx-jssdk.js');\r\nPage({\r\n    onLoad: function () {\r\n            // 实例化API核心类\r\n            qqmapsdk = new QQMapWX({\r\n                key: '申请的key'\r\n            });\r\n        },\r\n    onShow: function () {\r\n            qqmapsdk...\r\n    }\r\n})整个小程序 demo 的过程中，没遇到太大的困难，大概也是因为写的是比较简单的练手项目而已，很多小程序的功能还没用到，例如多个页面之间的数据传递，路由，插件等等，还需要进一步学习。另外，微信开发者工具有时候会出现打不了中文的情况，搜了一下是个常见的 bug，需要重启微信开发者工具。调试工具中无法查看伪元素样式也有点不方便，希望之后微信开发者工具能改进这方面，这样的话体验能够能好。另外附上我的微信小程序 demo，可以扫码体验一下(图标自己瞎画的晴天娃娃)，由于还需要优化，体验不佳的话还请谅解"}
{"title": "手摸手聊聊小程序持续集成Jenkins ", "author": "Rolan", "pub_time": "2019-1-10 00:49", "content": "本文首发在我的github博客 github.com/Pasoul/blog… ，感兴趣的同学可以点个star，不要迷路哦~\r\n\r\n我们为什么要持续集成？\r\n试想以下两个场景：\r\n场景一：你在开发新功能的时候，同事A找你要小程序体验二维码，于是你只能：\r\ngit stash // 缓存本地修改\r\ngit checkout release // 切换到测试分支\r\nyarn test // 打测试包\r\n... // 预览、切回分支\r\ngit stash pop // 还原本地修改\r\n复制代码然后整理被打断的代码思路，继续coding，暗自吐槽（二维码是有35min过期时间的，一会又得找我了...）\r\n场景二：小程序到了提测日期，恰巧负责开发的你今天请假了，意味着没人可以为测试同学打包，因此耽误了项目进度。\r\n以上两个场景我们发现一个共同的问题，小程序的体验发布太依赖开发者，因为通常只有开发者熟悉微信开发者工具一系列的上传流程，从而导致影响开发进度、发布流程不可控等一系列问题...\r\n\r\n如果小程序可以通过Jenkins集成，将大大解放开发者的生产力，将Jenkins权限收回到测试同学手里，每次发布都需要测试同学执行构建，一定程度上解决发布过程不可控的问题。\r\n小程序持续集成的限制\r\n微信开发者工具目前只支持Mac和Windows环境，可以在单独的Mac mini机器上搭一个Jenkins环境，专门用于打包ios app和小程序。\r\n前期知识储备\r\n除了图形化工具，开发者工具还提供了命令行与 HTTP 服务两种接口供外部调用，开发者可以通过命令行或 HTTP 请求指示工具进行登录、预览、上传等操作。官方文档\r\n我们先尝试使用命令行工具启动并登录微信开发者工具：\r\n命令行工具所在位置：\r\nmacOS: <安装路径>/Contents/MacOS/cli\r\nWindows: <安装路径>/cli.bat\r\n以下示例皆运行在MacOS 10.13.5环境：\r\n如果微信开发者安装在应用程序里面，其中<安装路径>则为 /Applications/wechatwebdevtools.app\r\n启动微信开发者工具\r\n终端执行/Applications/wechatwebdevtools.app/Contents/MacOS/cli -o，结果如下：\r\n\r\n并且开发者工具已经启动：\r\n\r\nps: mac环境下如果是新安装的开发者工具，一定要先打开并通过安全验证。\r\n登录微信开发者工具\r\n终端执行/Applications/wechatwebdevtools.app/Contents/MacOS/cli -l，结果如下：\r\n\r\n扫描二维码后，终端打印login success，并且此时开发者工具已经登录：\r\n\r\n我们尝试使用HTTP 服务预览项目：\r\n在启动和登录开发者工具后，我们需要获取工具运行所在的端口号（端口是不固定的），然后调用http服务预览此项目，执行以下命令获取端口号：\r\nport=$(cat \"/Users/pengyong/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\n复制代码假设我的项目地址在：/User/demo，开发者工具开启在55228端口，在浏览器输入http://127.0.0.1:55228/preview?projectpath=/User/demo，可以查看预览二维码\r\n\r\n我们知道开发者可以通过命令行或 HTTP 请求指示工具进行启动、登录、预览等操作，接下来就进入正题：安装和部署Jenkins。\r\n配置Jenkins\r\nJenkins运行依赖java环境，终端输入java -version，看输出是否正确比如：java version \"1.8.0_151\"\r\n一般Mac安装Jenkins有两种方法：\r\n\r\nJenkins官网（jenkins.io/ ）下载安装包，一路Next。\r\nTomcat + War\r\n\r\n这里我推荐第二种安装方式，因为第一种方式会生成一个共享的用户Jenkins，接下来所有构建的操作都是基于Jenkins这个用户的，它的权限与你当前登录的系统用户权限不同，导致构建过程中出现很多问题。\r\n安装Tomcat\r\n\r\n官网下载Tomcat安装包，我下载的是apache-tomcat-8.5.37.tar.gz这个版本，重命名为Tomcat8，放在/Users/用户/Library这个目录下。\r\n将Tomcat的bin路径添加到环境变量中：\r\n\r\nsudo vi ~/.bash_profile\r\nexport PATH=$JAVA_HOME/bin:$PATH:/Users/pengyong/Library/Tomcat8/bin\r\nsource ~/.bash_profile\r\n复制代码\r\n为了避免权限问题，给你的Tomcat/bin/*.sh分配权限\r\n\r\nsudo chmod 755 /Users/pengyong/Library/Tomcat8/bin/*.sh\r\n\r\n查看8080端口是否被占用，使用kill PID解除占用\r\n\r\nlsof -i:8080\r\nkill PID\r\n复制代码\r\n终端输入startup.sh，如果出现下图所示内容，则启动成功\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/\r\n\r\n\r\n\r\n关闭Tomcat使用shutdown.sh\r\n\r\n至此，Tomcat的安装基本上完成了，接下来安装Jenkins\r\n安装Jenkins\r\n1. 官网下载Jenkins war包，放入你的Tomcat/webapps目录下\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/jenkins\r\n\r\n\r\n初次访问会让你输入密码，可以根据路径提示获取密码\r\n如果文件提示没有权限无法打开，需要先修改权限，如下：\r\n\r\n\r\n输入密码，点击continue，进入插件安装页面\r\n\r\n\r\n\r\n点击推荐安装，等待安装完成\r\n\r\n\r\n\r\n安装成功后，进入创建Jenkins用户界面，填写完成点击Save and Continue\r\n\r\n\r\n\r\n用户创建完成后进入配置Jenkins URL界面，你可以将其修改成你期望的地址，然后点Save and Finish\r\n\r\n\r\n\r\n到了这个界面，恭喜你设置Jenkins成功，但是我们还差最后一步：重启Jenkins\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/jenkins/restart(你的jenkins地址+restart)，点击Yes重启\r\n\r\n\r\n有可能页面一直展示loading，你可以尝试直接访问Jenkins主页，如果出现这个页面，Jenkins的安装过程到此结束，你可以创建任务了。\r\n\r\n\r\n插件安装：系统管理 - 插件管理 - 可选插件(Available)\r\n\r\nGit parameter: 能够实现选择指定分支进行构建的功能\r\ndescription setter: 用于生成预览二维码\r\n至此准备工作已完成，让我们开始构建小程序吧。\r\n任务构建-配置\r\n\r\n我们新建一个名为wechat的任务，选择构建一个自由风格的软件项目，点击ok进入到配置界面\r\n\r\n\r\n\r\nGeneral配置选择参数化构建过程\r\n\r\nbuild_type用于选择构建的是开发版、测试版还是生产版的小程序\r\n\r\nbranch用于选择构建的分支（如果没有这个选项，检查Git parameter这个插件有没有安装）\r\n\r\nupload_desc和upload_version两个文本参数分别用于在构建时填写小程序的备注和版本\r\n\r\n\r\n源码管理选择Git，填上仓库地址，分支这里默认是master，改成我们构建时选择的分支（注：本地生成的 id_rsa.pub 添加到git仓库的ssh认证，否则jenkins无法连接git）\r\n\r\n\r\n\r\n构建选择执行shell\r\n\r\n脚本如下，可以按需修改：\r\necho -------------------------------------------------------\r\necho GIT_BRANCH: ${GIT_BRANCH}\r\necho -------------------------------------------------------\r\n# 执行项目构建\r\nyarn install \r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  yarn run test\r\nelse\r\n  yarn run $build_type\r\nfi\r\n# 打开微信开发者工具\r\n/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/pengyong/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\nreturn_code=$(curl -sL -w %{http_code} http://127.0.0.1:${port}/open)\r\nif [ $return_code == 200 ]\r\n  then\r\n  echo \"返回状态码200，devtool启动成功！\"\r\nelse\r\n  echo \"返回状态码${return_code}，devtool启动失败\"\r\n  exit 1\r\nfi\r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  echo \"发布开发版！\"\r\n  # wget -o下载预览二维码，以build_id命名\r\n  /usr/local/bin/wget -O $BUILD_ID.png http://127.0.0.1:${port}/preview?projectpath=/Users/pengyong/.jenkins/workspace/wechat\r\n  echo \"预览成功！请扫描二维码进入开发版！\"\r\nelif [ \"$build_type\" == 'prod' ] || [ \"$build_type\" == \"test\" ] || [ \"$build_type\" == \"test:demo\" ]\r\n  then\r\n  echo \"准备上传！\"\r\n  # 上传到微信平台\r\n  /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -u $upload_version@/Users/pengyong/.jenkins/workspace/wechat --upload-desc $upload_desc\r\n  echo \"上传成功！请到微信小程序后台设置体验版或提交审核！\"\r\nfi\r\n复制代码\r\n构建后操作选择Set build description（没有则检查description setter插件是否安装）\r\n\r\n\r\n这里使用img标签用于展示构建后的二维码（注：端口号是你jenkins启动的端口，任务名称是我们任务构建这一步填写的名称，这里我们是wechat）:\r\n<img src=\"http://本机ip:端口/job/任务名称/ws/${BUILD_ID}.png\" alt=\"非开发版请到后台预览\" width=\"200\" height=\"200\" /> <a href=\"http://本机ip:端口/job/任务名称/ws/${BUILD_ID}.png\" target=\"_blank\">二维码${BUILD_ID}</a>\r\n至此我们的任务构建配置基本完成了\r\n任务构建-预览小程序\r\n\r\n选择Build with parameters，选择你要构建的类型、分支等参数，这里我们选择的是开发版：\r\n\r\n\r\n\r\n构建完成后发现二维码以文本的形式展示，没有展示图片\r\n\r\n\r\n解决的方法是在系统管理 -> 全局安全配置 -> 标记格式器 -> 选择Safe HTML\r\n\r\n这时预览二维码就出来了，注意二维码是有过期时间的（35min）\r\n\r\n至此预览二维码的构建任务已经完成，我们尝试上传代码到微信平台\r\n任务构建-上传代码\r\n\r\n依然是选择构建类型、分支，不同的是上传代码需要填小程序版本号和项目备注，然后执行构建\r\n\r\n\r\n\r\n到运营平台或开发平台查看提交的版本\r\n\r\n\r\n友情提示\r\n\r\n开发者工具必须在登录状态下进行预览、上传的操作，为了避免账户冲突，可以在Jenkins服务器上使用专门的微信账号进行登录，这个账户要开启开发者和体验者权限，尽量不要使用开发者的账号。\r\n不要直接在官网下载Jenkins安装运行，坑真的很多。\r\n\r\n总结\r\n目前小程序的发布大多还是依赖开发者手动上传，并且小程序持续集成还是有很多问题：开发者工具不支持Linux环境、无法通过命令行生成体验版二维码等等。但是持续集成这个方向还是值得大家研究的，开发和发布要两开花嘛...\r\n参考：\r\n\r\n微信小程序集成 Jenkins\r\nMac Jenkins的安装和使用"}
{"title": "小程序性能优化总结 ", "author": "Rolan", "pub_time": "2019-1-10 00:26", "content": "历史总结：小程序倒计时深究小程序实战踩坑之B2B商城项目总结初试小刀自我简历小程序启动加载优化在小程序启动时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。初始化小程序环境是微信环境做的工作,我们只需要控制代码包大小，和通过一些相关的缓存策略控制，和资源控制，逻辑控制，分包加载控制来进行启动加载优化。勾选开发者工具中， 上传时压缩代码（若采用wepy高级版本，自带压缩，请按官网文档采取点击）精简代码，去掉不必要的WXML结构和未使用的WXSS定义。减少在代码包中直接嵌入的资源文件。（比如全国地区库，微信有自带的，在没必要的时候，勿自用自己的库）及时清理无用的资源（js文件、图片、demo页面等）压缩图片，使用适当的图片格式，减少本地图片数量等如果小程序比较复杂，优化后的代码总量可能仍然比较大，此时可以采用分包加载的方式进行优化，分包加载初始化时只加载首评相关、高频访问的资源，其他的按需加载。提前做异步请求，页面最好在onLoad时异步请求数据，不要在onReady时请求启用缓存数据策略，请求时先展示缓存内容，让页面尽快展示，请求到最新数据之后再刷新避免白屏，使用骨架屏等数据通信优化为了提升数据更新的性能，开发者在执行setData调用时，最好遵循以下原则：不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下。提升数据更新性能方式的代码示例：Page({\r\n  onShow: function() {\r\n\r\n    // 不要频繁调用setData\r\n    this.setData({ a: 1 })\r\n    this.setData({ b: 2 })\r\n    // 绝大多数时候可优化为\r\n    this.setData({ a: 1, b: 2 })\r\n\r\n    // 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外\r\n    this.setData({\r\n      myData: {\r\n        a: '这个字符串在WXML中用到了',\r\n        b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n      }\r\n    })\r\n    // 可以优化为\r\n    this.setData({\r\n      'myData.a': '这个字符串在WXML中用到了'\r\n    })\r\n    this._myData = {\r\n      b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n    }\r\n\r\n  }\r\n})事件通信优化视图层会接受用户事件，如点击事件、触摸事件等。当一个用户事件被触发且有相关的事件监听器需要被触发时，视图层会将信息反馈给逻辑层。这个反馈是异步的，会产生延迟，降低延迟的方法有两个：去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据。渲染优化页面方法onPageScroll使用， 每次页面滚动都会触发，避免在里面写过于复杂的逻辑 ，特别是一些执行重渲染页面的逻辑（另外，可以看我的文章——移动端滚动研究，说明了在滚动的情况下导致的渲染性能低下的各种分析和应付方法总结）在进行视图重渲染的时候，会进行当前节点树与新节点树的比较，去掉不必要设置的数据、减少setData的数据量也有助于提升这一个步骤的性能。"}
{"title": "在小程序中集成赞赏 ", "author": "Rolan", "pub_time": "2019-1-11 00:18", "content": "好吧，我承认我标题党了，如果你是进来找如何搭建小程序中的支付流程的，请你下车吧~ 这篇文章是介绍个人小程序如何集成赞赏功能的，利用微信小程序提供的支付接口必须具有公司资质才可以。或者你也可以集成有赞，不过会抽取一定的手续费。 言归正传，让我们一步一步来集成赞赏吧，让那些喜欢你的用户也可以打赏你一下。生成一个赞赏码。打开微信，点击右上角加号->收付款->赞赏码，这里你可以进行一些赞赏设置，然后点击保存赞赏码。这样你就拥有了你专属的赞赏码了。获取一个图片地址如果你有服务器或者其他的存储空间，你可以把你的赞赏码上传到你的存储空间，然后拿到图片的htts地址，后面会用到。 如果你没有，那么还可以利用小程序给我们提供的免费的云开发。下面先来说一下如何将图片上传到云存储中。1、打开小程序开发工具，找到云开发后点击，如果你没有开通，则会提示你开通，需要在控制台中开通，路径是：开发->开发者设置->腾讯云。2、开通后再点击云开发，打开控制台，找到存储管理->上传文件,上传上一步你的专属赞赏码图片。上传完成后，就能看到文件了，将fileid字段复制下来，后面会用到。图片预览这一步需要根据实际情况分开来处理了，下面针对上一步说的两种形式一一讲解。1. 使用其他云存储拿到图片的https链接后，在你的小程序wxml添加一个打赏的按钮，然后给按钮添加如下点击事件：wx.previewImage({     urls: ['https://xxxxx/admire-qrcode.jpg'],});写到这里相信大家应该就很清楚了，不错，我们就是利用微信的图片预览功能来加载网络图片。当加载出预览大图二维码后，用户就可以长按识别二维码，弹出微信的识别图中二维码功能，最终跳转到微信自带的赞赏页面，是不是很赞呢~2. 使用云开发存储使用云开发存储的思路是一致的，只不过需要在代码中初始化一些云开发环境。初始化云开发 在app.js中加入如下代码进行初始化：onLaunch: function() {    wx.cloud.init({      traceUser: true    });}添加按钮点击事件 点击事件中传入的url就是第二步获取到的fileid。previewImage: function() {    wx.previewImage({        urls: ['cloud://carutil-007.6361-carutil-007/admire-qrcode.jpg'],    });  },大功告成，最终效果如下图所示。你可以扫描下方的小程序码来体验该功能，在首页最底部有个打赏按钮~"}
{"title": "微信小程序实现换肤功能 ", "author": "Rolan", "pub_time": "2019-1-14 00:08", "content": "在手机、电脑使用频率如此高的当下，应用可以更换皮肤，以提升美观性，并减轻屏幕对眼睛的刺激，无疑对用户体验有很大的帮助。\r\n这里闲话少说，先放码出来\r\n\r\n  github地址：我的年目标-微信小程序\r\n演示\r\n扫码即可体验，或搜索“我的年目标”\r\n    \r\n\r\n下面为更换皮肤效果图\r\n \r\n实现功能\r\n要实现如上更换皮肤的效果，有几个思路：\r\n\r\n准备皮肤相关的wxss，引入到app.wxss中，方便每个页面使用；\r\n设置皮肤时，动态改变wxml中元素的类名或id，使页面应用对应的皮肤；\r\n将选中皮肤的值保存在小程序本地缓存中，保证其他页面及下一次打开小程序时，页面展示正确的皮肤；\r\n\r\n下面介绍一些实现的细节\r\nwxml\r\n<view class=\"page\" id='{{skin}}'>  \r\n  <view class=\"container\">\r\n  \t...\r\n  </view>\r\n</view>\r\n复制代码wxml部分比较简单，只需要动态切换id即可，注意因为page无法动态设置背景色，所以这里的最外层需要width: 100%;height: 100%;，否则将无法使皮肤铺满页面。\r\nwxss\r\n/* app.wxss主题颜色 */\r\n\r\n/* 深黑 */\r\n#dark-skin{\r\n  background: #000;\r\n}\r\n#dark-skin .bColor{\r\n  background: #333;\r\n  color: #999;\r\n}\r\n#dark-skin .borderColor{\r\n  border-color:#999;\r\n}\r\n/* 粉红 */\r\n#red-skin{\r\n  background: #f9e5ee;\r\n}\r\n#red-skin .bColor{\r\n  background: #f9e5ee;\r\n  color: #8e5a54;\r\n}\r\n#red-skin .borderColor{\r\n  border-color:#8e5a54;\r\n}\r\n/* 橘黄 */\r\n#yellow-skin{\r\n  background: #f6e1c9;\r\n}\r\n#yellow-skin .bColor{\r\n  background: #f6e1c9;\r\n  color: #8c6031;\r\n}\r\n#yellow-skin .borderColor{\r\n  border-color:#8c6031;\r\n}\r\n...\r\n复制代码写好皮肤对应的颜色样式，直接放入app.wxss中即可，如果样式过多，可以使用单独的wxss文件，方便管理。\r\n@import \"style/skin/dark.wxss\";\r\n复制代码js\r\n存储选中的皮肤值\r\n//wxml\r\n//<view bindtap=\"setSkin\" data-flag='yellow'>橘黄</view> \r\n//bindtap事件函数\r\n  setSkin:function(e){\r\n    var skin = e.target.dataset.flag;\r\n\r\n    this.setData({\r\n      skin: skin + '-skin',\r\n      openSet:false\r\n    })\r\n\r\n    wx.setStorage({\r\n      key: \"skin\",\r\n      data: skin + '-skin'\r\n    })\r\n    app.setSkin(this);\r\n  }\r\n复制代码这里使用setData使页面立即切换id，使用wx.setStorage存储值，app.setSkin是定义在app.js上的公共方法，下面会有介绍\r\n//app.js\r\nApp({\r\n  data: {\r\n  },\r\n  setSkin:function(that){\r\n    wx.getStorage({\r\n     key: 'skin',\r\n     success: function(res) {\r\n       if(res){\r\n         that.setData({\r\n          skin: res.data\r\n        })\r\n         var fcolor = res.data == 'dark-skin' ? '#ffffff' : '#000000',\r\n             obj = {\r\n               'normal-skin':{\r\n                 color:'#000000',\r\n                 background:'#f6f6f6'\r\n               },\r\n               'dark-skin': {\r\n                 color: '#ffffff',\r\n                 background: '#000000'\r\n               },\r\n               'red-skin': {\r\n                 color: '#8e5a54',\r\n                 background: '#f9e5ee'\r\n               },\r\n               'yellow-skin': {\r\n                 color: '#8c6031',\r\n                 background: '#f6e1c9'\r\n               },\r\n               'green-skin': {\r\n                 color: '#5d6021',\r\n                 background: '#e3eabb'\r\n               },\r\n               'cyan-skin': {\r\n                 color: '#417036',\r\n                 background: '#d1e9cd'\r\n               },\r\n               'blue-skin': {\r\n                 color: '#2e6167',\r\n                 background: '#bbe4e3'\r\n               }\r\n             },\r\n           item = obj[res.data],\r\n           tcolor = item.color,\r\n           bcolor = item.background;\r\n\r\n         wx.setNavigationBarColor({\r\n           frontColor: fcolor,\r\n           backgroundColor: bcolor,\r\n         })\r\n\r\n         wx.setTabBarStyle({\r\n           color: tcolor,\r\n           backgroundColor: bcolor,\r\n         })\r\n       }\r\n     }\r\n   })\r\n    }\r\n})\r\n\r\n复制代码app.setSkin提供给所有页面调用，并通过已有的皮肤颜色，设置头部和导航区域的背景及文字颜色。\r\n打开一个普通wxml页面，并设置皮肤\r\nconst app = getApp();\r\n\r\nPage({\r\n  data: {\r\n    skin: 'normal-skin',\r\n  },\r\n  onLoad: function() {\r\n    app.setSkin(this); \r\n  },\r\n  onShow:function(){\r\n    app.setSkin(this); \r\n  }\r\n})\r\n\r\n复制代码在onLoad及onShow触发时设置皮肤，这里的onShow是为了避免重新设置皮肤时，页面还显示上一次的皮肤，由于首次加载会设置两次，onLoad里的app.setSkin其实可以去掉。\r\n至此，一个精美的设置皮肤功能就实现了，小伙伴们快去试一试吧！\r\n\r\n最后\r\n新的2019，新的人生目标，欢迎体验微信小程序“我的年目标”，如有建议，望告知或pull requests，tks 。\r\n\r\n该小程序的其他介绍：\r\n你的年目标实现了吗，记一次开发微信小程序"}
{"title": "小程序仿淘宝五级地址选择 ", "author": "Rolan", "pub_time": "2019-1-11 00:29", "content": "所有的抽奖都是由后台计算后 <!-- 轮播展示中奖信息区域 -->  <swiper autoplay=\"{{true}}\" interval=\"{{1500}}\" circular=\"{{true}}\" vertical='{{true}}'>    <block wx:for=\"{{prizeInfo}}\" wx:key=\"index\">      <swiper-item>        <view>{{item.name}}{{item.prize}}</view>      </swiper-item>    </block>  </swiper></view><!-- 轮播结束 抽奖转盘 --><view class='turntable' bindtap='doLottery'>  <image class='turntable-bj' style=\"transition:all {{time?time:'3s ease-in'}}; transform:rotate({{transformDeg + 'deg'}}) \" src='../../../img/turntable.png'></image>  <image class='arrow' src='../../../img/arrow.png'>  </image></view>得到的，前台只做动画展示const app = getApp();var index = {  data:{     prizeInfo:[      {        name:'qiphon',        prize:'5元'      },      {        name:'qiphon23423',        prize:'53元'      },      {        name:'qipsdfhon',        prize:'35元'      }    ],    transformDeg:0, // 旋转角度    transition:'all 3s cubic-bezier(0.005, 1.340, 1.000, 0.865)',    time:'999s'  },  onLoad(opt){    console.log(opt)  },  onReady(){    this.animation = wx.createAnimation({      timingFunction:'esse-in-out',      duration:2000    });    this.animationDeg = 360;  },  loadCoupons(){ // 加载获奖信息  欢迎加入全栈开发交流划水交流圈：582735936面向划水1-3年前端人员帮助突破划水瓶颈，提升思维能力  },  doLottery(){ // 抽奖    var _this = this;    if(this.aniRotate)return;    this.aniRotate = true;    this.setData({      transformDeg:this.data.transformDeg + 360*900,      time:'100s ease'    })    setTimeout(function(){      console.log('请求完成'+_this.data.transformDeg) // setTimeout 模拟ajax请求      _this.setData({        transformDeg:-360*4,        time:'3s ease'      })欢迎加入全栈开发交流划水交流圈：582735936面向划水1-3年前端人员帮助突破划水瓶颈，提升思维能力      setTimeout(function(){        console.log('返回结果'+_this.data.transformDeg)        _this.setData({          transformDeg:360*2 + 0,          time:'6s cubic-bezier(0.000, 0.765, 0.000, 0.955)'        })        setTimeout(function(){          _this.aniRotate = false;          wx.showModal({            title:'中奖信息',            content:'恭喜获得奖品'          })        },6000)      },2000)    },3000)  },}Page(index);.top-banner{  background: #fff;  padding:20rpx;}.top-banner swiper{  height: 50rpx;  line-height: 50rpx;}/* 转盘 */.turntable{  position: relative;  width: 100%;  height: 530rpx;}.turntable-bj{  display: block;  margin:0 auto;  width:600rpx;  height: 530rpx;}.turntable .arrow{  position: absolute;  top:0;  right:0;  left:0;  bottom:110rpx;  margin:auto;  width:93.5rpx;  height: 212rpx;}以上就是本文的全部内容，希望对大家的学习有所帮助。"}
{"title": "小程序 setData 为什么不能频繁设置 ", "author": "Rolan", "pub_time": "2019-2-20 00:25", "content": "先科普下 setData 做的事情：在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。因此频繁调用，视图会一直更新，阻塞用户交互，引发性能问题。但频繁调用是常见开发场景，能不能频繁调用的同时，视图延迟更新呢？参考 Vue，我们能知道，Vue 每次赋值操作并不会直接更新视图，而是缓存到一个数据更新队列中，异步更新，再触发渲染，此时多次赋值，也只会渲染一次。于是有网友就给出了这套方案的实现方法：let newState = null\r\nconst asyncSetData = ({\r\n    vm,\r\n    newData,\r\n}) => {\r\n    newState = {\r\n        ...newState,\r\n        ...newData,\r\n    }\r\n    Promise.resolve().then(() => {\r\n        if (!newState) return\r\n        vm.setData({\r\n            ...newState,\r\n        })\r\n        newState = null\r\n    })\r\n}由于 异步代码会在同步代码执行完后执行 ，因此多次 asyncSetData 的 newData 都会缓存在 newState 中，并在异步的 promise.then 中只 setData 一次。但这个方案会带来新的问题：就是 同步代码会阻塞页面的渲染 。同步代码会阻塞页面的渲染的问题其实在浏览器中也存在，但在小程序中，由于是逻辑、视图双线程架构，因此逻辑并不会阻塞视图渲染，这是小程序的优点，但在这套方案将会丢失这个优点。鱼与熊掌不可兼得也！参考资料终极蛇皮上帝视角之微信小程序之告别 setData , 佯真愚, 2018年08月12日"}
{"title": "微信小程序特殊字符转义方法——&转义&amp;等等 ", "author": "Rolan", "pub_time": "2019-2-20 00:53", "content": "在我编写公司小程序的过程中，有一次在网页端添加了一张图片，结果在小程序端访问失败了，究其原因，竟然是因为该图片名称中有一个“&”符号，网页端添加后，自动转义成了“&amp;”存储到了数据库。当然，这种格式如果是在HTML去访问图片地址，会自动在转义成“&”，但是小程序的WXML并没有这种功能，所以这就需要我们在小程序端自行操作进行转义了。 首先，明确一下会自动转义存储的常用的特殊字符有哪些：如果是在<text>标签中显示文本内容，可以直接通过设置decode=‘true’的属性进行转义。 但因为我是在<image>标签中访问，所以小程序中没有便捷方法可以转义，写了一个死方法——replace.js，如下：//替换URL中特殊字符\r\nfunction replaceSpecialChar(url) {\r\n  url = url.replace(/&quot;/g, '\"');\r\n  url = url.replace(/&amp;/g, '&');\r\n  url = url.replace(/&lt;/g, '<');\r\n  url = url.replace(/&gt;/g, '>');\r\n  url = url.replace(/&nbsp;/g, ' ');\r\n  console.log(\"转义字符\", url);\r\n  return url;\r\n}\r\nmodule.exports = {\r\n  replaceSpecialChar: replaceSpecialChar\r\n}需要用到的时候，在页面对应的js里面调用该方法：var replace = require(\"../../utils/replace.js\");\r\nPage({\r\n    ..............\r\n    url = replace.replaceSpecialChar(res.data.url)\r\n}） 这样就能访问到图片啦~~~"}
{"title": "给媳妇做一个记录心情的小程序 ", "author": "Rolan", "pub_time": "2019-3-22 00:55", "content": "闲暇之余，听媳妇嘀咕说要给她做一个能表达她每日心情的小程序，只能她在上面发东西。既然媳妇发话了，就花点心思做一个吧，因为没有UI图，所有布局全靠自己瞎编，下面结合图片和代码跟大家讲解下实现过程，内容略长，感兴趣的可以一览。下面将以图片、代码的形式和大家讲解这个小demo的实现过程：首页首页效果图首页讲解音乐(下面仅展示音乐相关代码)<div class=\"bg_music\" @tap=\"audioPlay\">\r\n    <image src=\"../../static/images/music_icon.png\" class=\"musicImg\" :class=\"isPlay?'music_icon':''\"/>\r\n    <image src=\"../../static/images/music_play.png\" class=\"music_play\" :class=\"isPlay?'pauseImg':'playImg'\"/>\r\n</div>\r\n<audio id=\"myAudio\" :src=\"audioUrl\" autoplay loop></audio>复制代码data () {\r\n  return {\r\n    isPlay: true,\r\n    audioCtx: ''\r\n  }\r\n},\r\nonLoad () {\r\n  const that = this\r\n  that.audioCtx = wx.createAudioContext('myAudio')\r\n  that.getMusicUrl()\r\n},\r\nmethods: {\r\n  getMusicUrl () {\r\n    const that = this\r\n    const db = wx.cloud.database()\r\n    const music = db.collection('music')\r\n    music.get().then(res => {\r\n      that.audioUrl = res.data[0].musicUrl\r\n      that.audioCtx.loop = true\r\n      that.audioCtx.play()\r\n    })\r\n  },\r\n  audioPlay () {\r\n    const that = this\r\n    if (that.isPlay) {\r\n      that.audioCtx.pause()\r\n      that.isPlay = !that.isPlay\r\n      tools.showToast('您已暂停音乐播放~')\r\n    } else {\r\n      that.audioCtx.play()\r\n      that.isPlay = !that.isPlay\r\n      tools.showToast('背景音乐已开启~')\r\n    }\r\n  }\r\n}复制代码.bg_music\r\n  position fixed\r\n  right 0\r\n  top 20rpx\r\n  width 100rpx\r\n  z-index 99\r\n  display flex\r\n  justify-content flex-start\r\n  align-items flex-start\r\n  .musicImg\r\n    width 60rpx\r\n    height 60rpx\r\n  .music_icon\r\n    animation musicRotate 3s linear infinite\r\n  .music_play\r\n    width 28rpx\r\n    height 60rpx\r\n    margin-left -10rpx\r\n    transform-origin top\r\n    -webkit-transform rotate(20deg)\r\n  .playImg\r\n    animation musicStop 1s linear forwards\r\n  .pauseImg\r\n    animation musicStart 1s linear forwards\r\n#myAudio\r\n  display none复制代码1、通过wx.createInnerAudioContext()获取实例 ，安卓机上音乐能正常播放，IOS上不行，具体原因感兴趣的可以去深究一下；2、由于前面邀请函小程序相关文章发出后，问的最多的问题依然是音乐无法播放这块，所以这个demo中就再给大家讲解了下实现的原理。日历这里日历使用了小程序插件，之所以在首页放一个日历是为了页面不显的太单调。下面讲解下插件是如何使用的：1、登录微信公众平台>设置>第三方设置>添加插件>搜索相关插件的名字（使用appId搜索更好）>点击某个插件右侧的查看详情，进入插件详情页添加插件，一般都能立马添加通过；​2、插件详情里面一般都有使用文档，或git地址，插件的具体属性事件都会在文档里有介绍；3、下面讲解下如何在项目中使用插件：（1）、找到src根目录下的app.json文件，添加如下内容：// \"cloud\": true,\r\n\"plugins\": {\r\n  \"calendar\": {\r\n    \"version\": \"1.1.3\",\r\n    \"provider\": \"wx92c68dae5a8bb046\"\r\n  }\r\n}复制代码（2）、在需要引用该插件的页面的.json文件中加入如下内容：{\r\n  // \"navigationBarTitleText\": \"媳妇的心情日记\",\r\n  // \"enablePullDownRefresh\": true,\r\n  \"usingComponents\": {\r\n    \"calendar\": \"plugin://calendar/calendar\"\r\n  }\r\n}复制代码（3）、在页面中直接使用如下（具体属性方法的意思根据对应插件有所不同）：<calendar\r\n    :class=\"showCalendar?'':'hide_right'\"\r\n    class=\"right\"\r\n    weeks-type=\"en\"\r\n    cell-size=\"20\"\r\n    :header=\"showHeader\"\r\n    show-more-days=true\r\n    calendar-style=\"demo4-calendar\"\r\n    board-style=\"demo4-board\"\r\n    :days-color=\"demo4_days_style\"\r\n    @dayClick=\"dayClick\"\r\n/>复制代码天气和地址（1）、这里我借助的是高德微信小程序SDK;（2）、首先获取使用相关api需要的key值，如下：（3）、下载对应SDK（.js文件）并引入到项目中；（4）、通过相关api获取天气和地址:getWeather () {\r\n  const that = this\r\n  let myAmapFun = new amapFile.AMapWX({key: '你申请的key'})\r\n  myAmapFun.getWeather({\r\n    success (res) {\r\n      // 成功回调\r\n      that.address = res.liveData.city\r\n      that.weather = res.liveData.weather + ' '\r\n      that.temperature = res.liveData.temperature + '℃'\r\n      that.winddirection = res.liveData.winddirection + '风' + res.liveData.windpower + '级'\r\n    },\r\n    fail (info) {\r\n      // 失败回调\r\n      console.log(info)\r\n    }\r\n  })\r\n},复制代码发表日记这里涉及到发表文字图片内容，在个人小程序提交审核后很大可能是不会被通过的，虽然第一次提交我的个人小程序通过审核了，后面几次审核均未通过，虽然我这里只限制了我和媳妇两个人能发日记，其他人压根看不到右下角的发布加号，但是审核人员会查代码，代码中一旦被他们发现有类似发表相关的内容或字样就会导致审核不通过，好在已经通过了一次，媳妇能正常写点东西，也算基本符合要求，遗憾的是后面实现点赞相关的功能都没有更新到线上。​（1）、通过唯一的openId来判断是否显示首页右下角的发布加号；（2）、后面会具体讲解页面里上传图片到云开发及存储到数据库相关功能点赞功能（1）、这里点赞功能借助的小程序云开发的云函数来实现的，结合代码：<ul class=\"list\">\r\n    <li class=\"item\" v-for=\"(item, index) in diaryList\" :key=\"item._id\" @tap=\"toDetail(item)\">\r\n        <image class=\"like\" src=\"../../static/images/like_active.png\" v-if=\"likeList[index] === '2'\" @tap.stop=\"toLike(item._id, '1', item.like)\"/>\r\n        <image class=\"like\" src=\"../../static/images/like.png\" v-if=\"likeList[index] === '1'\" @tap.stop=\"toLike(item._id, '2', item.like)\"/>\r\n        <image class=\"img\" :src=\"item.url\" mode=\"aspectFill\"/>\r\n        <p class=\"desc\">{{item.desc}}</p>\r\n        <div class=\"name-weather\">\r\n            <span class=\"name\">{{item.name}}</span>\r\n            <span class=\"weather\">{{item.weather}}</span>\r\n        </div>\r\n        <p class=\"time-address\">\r\n            <span class=\"time\">{{item.time}}</span>\r\n            <!-- <span class=\"address\">{{item.address}}</span> -->\r\n        </p>\r\n    </li>\r\n</ul>\r\n<div class=\"dialog\" v-if=\"showDialog\">\r\n    <div class=\"box\">\r\n        <h3>提示</h3>\r\n        <p>是否授权使用点赞功能？</p>\r\n        <div class=\"bottom\">\r\n            <button class=\"cancel\" @tap=\"hideDialog\">取消</button>\r\n            <button class=\"confirm\" lang=\"zh_CN\" open-type=\"getUserInfo\" @getuserinfo=\"login\">确认</button>\r\n        </div>\r\n    </div>\r\n</div>复制代码// 获取日记列表\r\ngetDiaryList () {\r\n  const that = this\r\n  wx.cloud.callFunction({\r\n    name: 'diaryList',\r\n    data: {}\r\n  }).then(res => {\r\n    that.getSrcFlag = false\r\n    that.diaryList = res.result.data.reverse()\r\n    that.likeList = []\r\n    that.diaryList.forEach((item, index) => {\r\n      item.like.forEach(itemSecond => {\r\n        if (itemSecond.openId === that.openId) {\r\n          that.likeList.push(itemSecond.type)\r\n        }\r\n      })\r\n      if (that.likeList.length < index + 1) {\r\n        that.likeList.push('1')\r\n      }\r\n    })\r\n    wx.hideNavigationBarLoading()\r\n    wx.stopPullDownRefresh()\r\n  })\r\n},\r\n// 点赞或取消点赞\r\ntoLike (id, type, arr) {\r\n  const that = this\r\n  that.tempObj = {\r\n    id: id,\r\n    type: type,\r\n    like: arr\r\n  }\r\n  wx.getSetting({\r\n    success (res) {\r\n      if (res.authSetting['scope.userInfo']) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n        wx.getUserInfo({\r\n          success: function (res) {\r\n            that.userInfo = res.userInfo\r\n            wx.cloud.callFunction({\r\n              name: 'like',\r\n              data: {\r\n                id: id,\r\n                type: type,\r\n                like: arr,\r\n                name: that.userInfo.nickName\r\n              }\r\n            }).then(res => {\r\n              if (type === '1') {\r\n                tools.showToast('取消点赞成功')\r\n              } else {\r\n                tools.showToast('点赞成功~')\r\n              }\r\n              // getOpenId()方法里会执行一遍获取日记列表\r\n              that.getOpenId()\r\n            })\r\n          }\r\n        })\r\n      } else {\r\n        that.showDialog = true\r\n      }\r\n    }\r\n  })\r\n},\r\n// 授权获取用户信息\r\nlogin (e) {\r\n  const that = this\r\n  console.log(that.tempObj, e)\r\n  if (e.target.errMsg === 'getUserInfo:ok') {\r\n    wx.getUserInfo({\r\n      success: function (res) {\r\n        that.userInfo = res.userInfo\r\n        wx.cloud.callFunction({\r\n          name: 'like',\r\n          data: {\r\n            id: that.tempObj.id,\r\n            type: that.tempObj.type,\r\n            like: that.tempObj.like,\r\n            name: that.userInfo.nickName\r\n          }\r\n        }).then(res => {\r\n          if (that.tempObj.type === '1') {\r\n            tools.showToast('取消点赞成功')\r\n          } else {\r\n            tools.showToast('点赞成功~')\r\n          }\r\n          // getOpenId()方法里会执行一遍获取日记列表\r\n          that.getOpenId()\r\n        })\r\n      }\r\n    })\r\n  }\r\n  that.showDialog = false\r\n}复制代码（2）、首页获取日记列表，在存储日记到数据库集合的时候我会在每条日记对象中添加一个like属性，like默认是一个空数组；（3）、当用户点赞或取消点赞时，组件data中tempObj属性会临时存储三个参数①、对应日记的_id；②、用户操作的类型是点赞（点赞是‘2’）或是取消点赞（取消点赞是‘1’）；③、对应日记的like数组；（4）、通过小程序api的wx.getSetting({})来判断用户是否已经授权。如果授权了获取用户信息，未授权则弹框引导用户点击确认按钮去手动授权；（5）、授权成功后，拿到用户信息，我们开始调用点赞或取消点赞相关的云函数，如下：const cloud = require('wx-server-sdk')\r\ncloud.init()\r\nconst db = cloud.database()\r\nexports.main = async (event, context) => {\r\n  try {\r\n    // wxContext内包含用户的openId\r\n    const wxContext = cloud.getWXContext()\r\n    // 定义空数组\r\n    let arr = []\r\n    if (event.like && event.like.length > 0) {\r\n      // 让定义的数组等于用户操作的当前日记下的like数组\r\n      arr = event.like\r\n      // 定义一个计数变量\r\n      let count = 0\r\n      // 循环遍历，当openId相同时替换like数组中的相同项，并存储对应的type\r\n      arr.forEach((item, index) => {\r\n        if (item.openId === wxContext.OPENID) {\r\n          count++\r\n          arr.splice(index, 1, {\r\n            openId: wxContext.OPENID,\r\n            type: event.type,\r\n            name: event.name\r\n          })\r\n        }\r\n      })\r\n      // 当计数变量为0时，说明在这条日记中，like数组中未存储过此用户，直接push此用户并存储type\r\n      if (count === 0) {\r\n        arr.push({\r\n          openId: wxContext.OPENID,\r\n          type: event.type,\r\n          name: event.name\r\n        })\r\n      }\r\n    } else {\r\n      // 如果此条日记like数组本身就为空，直接push当前用户并存储type\r\n      arr.push({\r\n        openId: wxContext.OPENID,\r\n        type: event.type,\r\n        name: event.name\r\n      })\r\n    }\r\n    // 通过云开发操作数据库的相关api,即update通过_id来更新集合中某条数据\r\n    return await db.collection('diary').doc(event.id).update({\r\n      data: {\r\n        like: arr\r\n      }\r\n    })\r\n  } catch (e) {\r\n    console.error(e)\r\n  }\r\n}复制代码（6）、相关云函数操作说明都写在上面的注释里，有不清楚的欢迎留言，由于点赞功能未更新到线上（原因是因为审核不通过），想体验的同学也可以加本人微信号，提供体验权限。发表心情效果图讲解（1）、通过首页右下角的发布加号，进入发布心情页；（2）、地址等相关信息是从首页通过路由带过来的；（3）、下面重点讲解下关于上传图片到云存储并写入数据库的操作过程，内容如下：upload () {\r\n  const that = this\r\n  wx.chooseImage({\r\n    count: 1,\r\n    sizeType: ['compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n    sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n    success: function (res) {\r\n      wx.showLoading({\r\n        title: '上传中'\r\n      })\r\n      // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n      let filePath = res.tempFilePaths[0]\r\n      const name = Math.random() * 1000000\r\n      const cloudPath = 'picture/' + name + filePath.match(/\\.[^.]+?$/)[0]\r\n      wx.cloud.uploadFile({\r\n        cloudPath, // 云存储图片名字\r\n        filePath // 临时路径\r\n      }).then(res => {\r\n        console.log(res)\r\n        wx.hideLoading()\r\n        that.imgUrl = res.fileID\r\n      }).catch(e => {\r\n        console.log('[上传图片] 失败：', e)\r\n      })\r\n    }\r\n  })\r\n},\r\nsave () {\r\n  const that = this\r\n  if (that.desc) {\r\n    that.getSrcFlag = false\r\n    const db = wx.cloud.database()\r\n    const diary = db.collection('diary')\r\n    if (that.imgUrl === '../../static/images/default.png') {\r\n      that.imgUrl = '../../static/images/default.jpg'\r\n    }\r\n    diary.add({\r\n      data: {\r\n        desc: that.desc,\r\n        time: tools.getNowFormatDate(),\r\n        url: that.imgUrl,\r\n        name: that.name,\r\n        weather: that.weather,\r\n        address: that.address,\r\n        like: []\r\n      }\r\n    }).then(res => {\r\n      wx.reLaunch({\r\n        url: '/pages/index/main'\r\n      })\r\n    }).catch(e => {\r\n      console.log(e)\r\n    })\r\n  } else {\r\n    tools.showToast('写点什么吧~')\r\n  }\r\n}复制代码（4）、这里的cloudPath可以自己定义，存储到云中是这样的：​（5）、我们通过组件data中的imgUrl临时存储手动上传的图片路径，最终通过保存按钮一起存储到云数据库，存如到数据库是这样的：日记详情页详情页效果图讲解（1）、详情就不过多讲解，这里利用了一些小程序api，比方说动态改变头部标题，每次进入动态随机改变顶部标题背景，点赞数也是从首页带过来的；访客页效果图（1）、授权前（2）、授权后源码地址gitee.com/roberthuang…体验二维码总结云开发虽然能用，但对于大型项目个人还是不推荐，从图片和数据加载这块的效果来看，传统服务端拿到的数据明显要快很多，既然有这么一个免费的工具，我想感兴趣的同学可以利用起来，玩点小demo,新花样，希望这篇文章能够帮助到有需要的同学，如果喜欢就点个赞吧~"}
{"title": "微信小程序自定义组件的关键记录 ", "author": "Rolan", "pub_time": "2019-2-20 00:41", "content": "我们在往常用vue或者是react编程的时候，最常用最常见的一个词就是组件，在小程序开发中，组件也是很nice的，毕竟谁也不想把1+1 = 2每一个页面写一遍。本篇文章适合知道小程序基本开发的手足，总结一些自己在开发小程序组件的过程需要注意的点，有写的不对的地方还请指指教。1. 基本配置新建组件就跟新建页面一样，还是js、json、wxml、wxss四个文件，这里需要注意的有四点。一、或许很多人在新建组件的时候右键直接新建page，这样就会在app.json的配置文件中的pages下面，根据路径多加一项，需要注意的是，这一项不像是页面，删掉也没关系。二、新建组件之后需要在组件的配置文件json中添加component: true字段； 需要在引用组件的配置文件中添加usingComponents字段来定义组件的名字和路径【可以直接用/+app.json中自动生成的，以免路径找不到】三、新建的组件如果是直接一键生成的，那么这个时候js文件中的还是page({...生命周期等执行函数})，所以这个时候需要我们把这些换成组件需要的component({...组件需要的对象})2.组件样式关于样式，就是我们的css了，至于里面的slot，无非就是一个插槽，而模版文件中数据绑定等我们都可以按照页面中的来实现，需要注意的是选择器和样式污染问题一、选择器在编写组件的时候，不能使用id选择器(#a)、属性选择器（[a]）和标签名选择器，建议统一使用class 子选择器只能用于view组件，和其子节点之间，其余的不建议使用 比如text > text 继承样式的话 font还有color这种样式继承，会从组件外继承到组件内部 除继承样式之外，app.wxss中的样式，组件所在页面的样式对组件内部是无效的其实呢，我们只用class选择器就好了。。。二、外部样式定义组件定义好了之后，在使用的时候，如果我忽然在调用页面加一个class控制样式，想加一个class怎么办呢？ 在组件内部的js文件中配置externalClasses：['xxx']，这样在外部引用的时候，可以直接使用这里定义的，毕竟单节点上面，同一节点同时使用普通样式和外部样式的时候，优先级会出现错乱，所以这能很好的避免这种情况 我们前面说了，自定义组件内部样式，是不会受到外部样式的影响的，除非是全局的标签或者是options配置中添加assGlobalClass字段三、样式配置3.component构造器 其实这里的构造器都是制定组件重的属性、数据、方法等等，定义的字段可以参考官方文档，我这里不多做累述，把容易混淆的点拿出来对比一下。properties: 组件的对外属性 data: 组件的内部数据 组件生命周期：生命周期有优先级，一般情况下直接当作普通方法，但是如果需要优先级的时候，可以写到lifetimes对象里面组件生命周期：4.组件事件组件的事件，我们和vue差不多的写法，会有一个methods统一来管理。但是我们通常有两种类型1. 组件内部调用的方法。和普通一样就好了，无非就是完全在组件内部自己玩，不和外部页面进行数据通信，请求也是自己完成\r\n复制代码2. 和父组件或者页面有数据通信的方法。我们在vue中需要使用到自组件向父组件传递消息，有一种方法就是this.$emit('...', msg)\r\n但是我们在小程序中也需要这种场景 【监听事件】：组件间通信的主要方式之一\r\n复制代码组件内部// wxml\r\n        <view bindtap=\"onHandle\"></view>\r\n        // js\r\n        methods: {\r\n            onHandle() {\r\n                .....\r\n                this.triggerEvent('eventName', detailMsg)\r\n            }\r\n    }\r\n\r\n复制代码"}
{"title": "小程序的诞生 ", "author": "Rolan", "pub_time": "2019-2-21 00:06", "content": "大家坐稳，我要开始装逼了。说好要讲小程序系列，替埋头苦干低调做事的开发哥哥们多讲讲小程序的故事吧。小程序与 WebViewWebView 的飞速发展随着公众号的出现和繁荣，WebView 的使用频率也越来越高。不少的企业或是小商家、外包公司开始做 H5 页面，各式各样的 H5 活动页、小商城、小测试、小游戏满天飞。H5 的劣势也很明显，体验太渣，甚至还不能获取很多底层 APP 拥有的功能。微信团队也因此提供了一些 JS-SDK 给 Web 开发使用，包括拍摄、录音、语音识别、二维码、地图、支付、分享等能力。从此，Web 开发者可以使用到微信的原生能力，去完成一些之前做不到或者难以做到的事情。体验不足的 WebView相信大多数人都经历过这样的糟糕体验——白屏。没错，就是这货：这样的体验直到今天还会出现，有些甚至连加载中的字样都没有。打开一个 WebView 通常会经历以下几个阶段：交互无反馈到达新的页面，页面白屏页面基本框架出现，但是没有数据；页面处于 loading 状态出现所需的数据除了白屏，影响 Web 体验的问题还有缺少操作的反馈，主要表现在两个方面：页面切换的生硬和点击的迟滞感。如果从程序上观察，WebView 启动过程大概分为以下几个阶段：对于一些有经验的 Web 开发者而言，会使用一些 SPA 的框架，来模拟客户端原生的页面切换过渡，同时使用缓存、CSS 反馈交互、直出页面等技术，来改善体验。但并不是所有开发者都有精力和能力去做这么多优化，而作为一个平台，优化用户体验也是平台责任的一部分。小程序的出现曾经有较长一段时间，我都以为小程序是类似 Weex、React Native 这些框架一样，最终呈现的是原生应用。直到开始写小程序，一些疑惑开始不断冒出来：为什么 CSS 样式的编写跟普通 Web 几乎一摸一样呢？才发现，小程序最终的呈现是 WebView，同时夹杂着一些原生组件。所以，小程序到底做了什么，使得体验比正常 WebView 好太多呢？我们先来对比下，常见的 Web 和 Native 的区别：关于最后一点的管控性，其实作为一个平台这是必须具备的能力，不然平台被滥用，对公众或是平台自身都不是什么好事情。就像现在很多云服务的 COS，也开始管控起来，包括域名绑定、备案等，一是防止有心人士使用平台做些不好的事情，二是对平台自身的保护（防止被封禁等）。在这样的需求和期待中，小程序诞生了。小程序是期望的产物使用 WebView 开发，门槛低，可云端更新。不同于 RN、Weex 这些框架，原生组件的开发、样式调整等都和 Web 有太多的不同。对于一个前端开发来说，开发成本较高、调试效率低，若不小心掉到坑里，都不知道该怎么爬出来。使用 WebView，可最大化前端开发的优势，同时异步加载的方式，也允许开发者进行在线的版本更新和 BUG 修复。通过提供基础能力、原生组件结合等方式，提升用户体验。小程序框架提供了完整的基础库，通过微信内置基础库、双线程渲染等方式，提升了小程序启动的体验。同时，开发者可以借用原生组件、API 等能力，做很多普通页面开发做不到的事情，用户也能以此获得原生应用般的体验。通过平台发布、审核、下架、封禁等能力，具备对小程序的管控能力。小程序框架提供了云端更新的能力，通过代码上传、审核等方式，增强了对开发者的管控能力。保护用户的同时，也保护了平台，以及平台中的其他开发者。双线程（逻辑层和渲染层分开），隔离 DOM、BOM 能力，提升体验的同时，可保证 WebView 安全性。双线程的模式，使得页面渲染和逻辑代码的加载分开，降低了页面卡壳的可能性。同时，由于逻辑层被隔离 DOM 和 BOM 对象，无法获取渲染层的内容，也在一定程度上保护了用户的数据安全。打开小程序的新世界二维码扫描、搜索、分享、推送等各种方式，都可以打开一个小程序。依靠轻量无需安装、体验优秀、管控严格、方便快捷等各种优势，小程序给用户打开了一个通向新世界的大门。而对于开发者，开发成本低、能力齐全、可快速迭代这样的开发模式，又基于大体量的用户数，几乎是无法拒绝的。齐备的底层基础库、自带优化后的体验性能，使得开发者可以专注于业务逻辑的开发，各司其职，一起把产品做好。参考《WebView性能、体验分析与优化》《小程序开发指南》结束语用心做好一个产品，在如今乱糟糟的社会里其实也不容易呢。而要做一个优秀的作品，需要有很清晰的方向，即使需要不断探索，也不会迷失方向吧。技术什么的，只要方向正确，总是有办法解决的。后面章节我们也来讲讲小程序的底层框架和设计吧。查看Github有更多内容噢：https://github.com/godbasin"}
{"title": "手把手教你在小程序项目中配置Gulp ", "author": "Rolan", "pub_time": "2019-2-21 00:14", "content": "如果是做原生小程序开发，你是否想过在你的小程序项目中也加入一些工程的东西？本文将手把手教你在小程序中配置一些工程化的东西，基于我自身的痛点，目前有 支持Less 、 支持路径别名 、 图片自动压缩，上传七牛 、 打包加入Eslint检查 这么几个功能，后期有遇到其他需要再更新。在小程序项目中我目前用的是 Gulp 。为啥不用热门的webpack？因为我觉得对于小程序项目来说gulp足够了，关键是配置非常简单，流式管理简单明了，不了解Gulp的大家可以去官网看看。需要提醒的是，以下举例的gulpfie基于 gulp 4.0 ，配置上与之前的版本略有不同，不过变化不大。详细的大家可以点 这里 去看看。项目结构gulpfile.js 我们放在根目录下，初始长这样const { src, dest, parallel, watch, series } = require('gulp');\r\n\r\nfunction defaultTask(cb) {\r\n  // place code for your default task here\r\n  cb();\r\n}\r\n\r\nexports.default = defaultTask\r\n接下来我们将一个任务一个任务往里面添加。支持Less由于平时项目中习惯了用CSS 预处理语言，wxss的原始css 写法让我写起项目来很难受。我个人比较习惯使用 Less ，习惯使用sass的大家自己找一下相关插件替换一下就行。gulp中处理less的插件是 gulp-less ，gulp-less把文件处理完成后我们还需要把文件名改成 .wxss 所以我们还需要一个重命名插件，这里用的是 gulp-rename 。gulpfile.js如下：const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\n\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Less())\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss);\r\n需要注意的是上面的 src() 在第二个参数传入了 {base: 'src/'} ，至于原因嘛，跟我们配的匹配less文件路径 src/**/*.less 有关。感兴趣的同学可以结合 Explaining Globs 看看，这里我不细说。当然如果你想对wxss进行压缩可以使用 gulp-csso 。const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\n\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Less())\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss);\r\n支持路径别名在项目中，如果应用文件路径过深过长，不仅开发者写起来费劲，还容易出错且代码观赏性很差。小程序中路径别名我们用 gulp-wechat-weapp-src-alisa ，支持在 .wxml 、 .wxss/less 、 .js 中使用。const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\n\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss， js);\r\n使用效果.jsimport * as Utils from '@Utils/base';\r\n// require('@Libs/WXPage/index');\r\n\r\n// 编译后\r\nimport * as Utils from '../../utils/base';\r\n// require('libs/WXPage/index');\r\n.less// index.less\r\n@import '@Style/variables.less';\r\n\r\n.bg {\r\n  background-image: url('@Images/32821027.jpgg');\r\n}\r\n.usermotto {\r\n    margin-top: 200px;\r\n    color: @txt-highlight;\r\n}\r\n\r\n// 编译后\r\n.bg {\r\n  background-image: url('../../images/32821027.jpg');\r\n}\r\n.usermotto {\r\n  margin-top: 200px;\r\n  color: #FD7622;\r\n}\r\n.wxml<!--logs.wxml-->\r\n<import src=\"@Utils/index.wxs\" />\r\n\r\n<image  src=\"@Images/32821027.jpg\" mode=\"cover\"></image>\r\n\r\n// 编译后\r\n<import src=\"../../utils/index.wxs\" />\r\n<image  src=\"../../images/32821027.jpg\" mode=\"cover\"></image>\r\n图片自动压缩，上传七牛由于小程序对代码包有限制，每1KB空间对小程序项目都十分珍贵，而且从用户体验来说，过大的代码包对首次进入小程序的用户来说下载时间会过长。基于这些原因我们几乎不会选择把图片放在小程序代码包中，那就只能上传图片服务器了。上传图片之前需要对图片进行压缩，可能有些通许是通过手动来做这部分工作的，其实可以用工具来的嘛。压缩图片用的插件是 gulp-imagemin , 我的图片是上传到 七牛 ,对应的插件是 gulp-qiniu-utils 。接下来我们在gulpfile中添加图片相关任务const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\nconst ImageMin = require('gulp-imagemin');\r\nconst UrlPrefixer = require('gulp-url-prefixer');\r\nconst Qiniu = require('gulp-qiniu-utils');\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 七牛相关配置\r\nconst qiniuOptions = {\r\n    ak: 'ac key',\r\n    sk: 'sk key',\r\n    zone: 'Zone_z0', // 空间对应存储区域（华东：z0，华北：z1，华南：z2，北美：na0）\r\n    bucket: 'hynal-com', // 七牛对应空间\r\n    upload: {\r\n        dir: './dist/images', // 上传本地目录\r\n        // prefix: 'test/', // 上传时添加的前缀，可省略\r\n        except: /\\.(html|js)$/, // 上传时不上传文件的正则匹配\r\n    },\r\n    remote: {\r\n        url: 'https://*****.com', // 七牛空间域名\r\n        prefix: {\r\n            default: 'test/', // 七牛空间默认前缀，如果下面三个相同可省略\r\n            remove: 'test/', // 七牛空间删除前缀\r\n            prefetch: 'test/', // 七牛空间预取前缀\r\n            refresh: 'test/', // 七牛空间刷新前缀\r\n        },\r\n    },\r\n};\r\n\r\nconst urlPrefix = {\r\n    prefix: 'https://cdn.liayal.com/dist',\r\n    tags: ['image'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(UrlPrefixer.css(urlPrefix))\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction imagemin() {\r\n    return src(path.images)\r\n        .pipe(ImageMin())\r\n        .pipe(dest('dist/images'));\r\n}\r\n\r\n\r\nconst images = series(imagemin, (cb) => {\r\n    const qiniu = new Qiniu(qiniuOptions);\r\n    qiniu.upload();\r\n    cb();\r\n});\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(UrlPrefixer.html(urlPrefix))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss， js， images);\r\n上面我们还添加了一个 UrlPrefixer() 流，这个是把我们项目中引用的图片替换成上传七牛后的地址，需要配合七牛对应配置来设定。如：// 替换前\r\n<image  src=\"@Images/32821027.jpg\" mode=\"cover\"></image>\r\n\r\n// 替换后\r\n<image  src=\"https://cdn.liayal.com/dist/images/32821027.jpg\" mode=\"cover\"></image>\r\n打包加入Eslint检查打包时加入Eslint检查可以让我们提早发现一些由代码引发问题，也方便推行代码规范。下面我们在js任务中加入 gulp-eslintconst { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\nconst ImageMin = require('gulp-imagemin');\r\nconst UrlPrefixer = require('gulp-url-prefixer');\r\nconst Qiniu = require('gulp-qiniu-utils');\r\nconst ESLint = require('gulp-eslint');\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 七牛相关配置\r\nconst qiniuOptions = {\r\n    ak: 'ac key',\r\n    sk: 'sk key',\r\n    zone: 'Zone_z0', // 空间对应存储区域（华东：z0，华北：z1，华南：z2，北美：na0）\r\n    bucket: 'hynal-com', // 七牛对应空间\r\n    upload: {\r\n        dir: './dist/images', // 上传本地目录\r\n        // prefix: 'test/', // 上传时添加的前缀，可省略\r\n        except: /\\.(html|js)$/, // 上传时不上传文件的正则匹配\r\n    },\r\n    remote: {\r\n        url: 'https://*****.com', // 七牛空间域名\r\n        prefix: {\r\n            default: 'test/', // 七牛空间默认前缀，如果下面三个相同可省略\r\n            remove: 'test/', // 七牛空间删除前缀\r\n            prefetch: 'test/', // 七牛空间预取前缀\r\n            refresh: 'test/', // 七牛空间刷新前缀\r\n        },\r\n    },\r\n};\r\n\r\nconst urlPrefix = {\r\n    prefix: 'https://cdn.liayal.com/dist',\r\n    tags: ['image'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(UrlPrefixer.css(urlPrefix))\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(ESLint())\r\n        .pipe(ESLint.format())\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction imagemin() {\r\n    return src(path.images)\r\n        .pipe(ImageMin())\r\n        .pipe(dest('dist/images'));\r\n}\r\n\r\n\r\nconst images = series(imagemin, (cb) => {\r\n    const qiniu = new Qiniu(qiniuOptions);\r\n    qiniu.upload();\r\n    cb();\r\n});\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(UrlPrefixer.html(urlPrefix))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss， js， images);\r\n效果大概是这样的也可以通过 eslint.failOnError() 或者 eslint.failAfterError() 在编译报错时中断编译。END最后完善一下gulpfile, 添加监测任务，添加一个clean任务const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\nconst ImageMin = require('gulp-imagemin');\r\nconst UrlPrefixer = require('gulp-url-prefixer');\r\nconst Qiniu = require('gulp-qiniu-utils');\r\nconst ESLint = require('gulp-eslint');\r\nconst Clean = require('gulp-clean');\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 七牛相关配置\r\nconst qiniuOptions = {\r\n    ak: 'ac key',\r\n    sk: 'sk key',\r\n    zone: 'Zone_z0', // 空间对应存储区域（华东：z0，华北：z1，华南：z2，北美：na0）\r\n    bucket: 'hynal-com', // 七牛对应空间\r\n    upload: {\r\n        dir: './dist/images', // 上传本地目录\r\n        // prefix: 'test/', // 上传时添加的前缀，可省略\r\n        except: /\\.(html|js)$/, // 上传时不上传文件的正则匹配\r\n    },\r\n    remote: {\r\n        url: 'https://*****.com', // 七牛空间域名\r\n        prefix: {\r\n            default: 'test/', // 七牛空间默认前缀，如果下面三个相同可省略\r\n            remove: 'test/', // 七牛空间删除前缀\r\n            prefetch: 'test/', // 七牛空间预取前缀\r\n            refresh: 'test/', // 七牛空间刷新前缀\r\n        },\r\n    },\r\n};\r\n\r\nconst urlPrefix = {\r\n    prefix: 'https://cdn.liayal.com/dist',\r\n    tags: ['image'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(UrlPrefixer.css(urlPrefix))\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(ESLint())\r\n        .pipe(ESLint.format())\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction imagemin() {\r\n    return src(path.images)\r\n        .pipe(ImageMin())\r\n        .pipe(dest('dist/images'));\r\n}\r\n\r\n\r\nconst images = series(imagemin, (cb) => {\r\n    const qiniu = new Qiniu(qiniuOptions);\r\n    qiniu.upload();\r\n    cb();\r\n});\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(UrlPrefixer.html(urlPrefix))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction clean() {\r\n    return src('dist/*', { read: false })\r\n        .pipe(Clean());\r\n}\r\n\r\n\r\nwatch(path.lessPath, wxss);\r\nwatch(path.jsPath, js);\r\nwatch(path.copy, copy);\r\nwatch(path.images, images);\r\n\r\nexports.default = series(clean, parallel(copy, wxss, js, images));\r\n整个项目我放在github  gulp-wechat-weapp"}
{"title": "认识小程序云开发 ", "author": "Rolan", "pub_time": "2019-2-21 00:37", "content": "小程序云开发开始公测啦，欢呼欢呼。这里针对云开发小程序的能力整理出了一个简单的报告，欢迎大家一起来探讨~关于 serverless无服务器运算（Serverless computing），又被称为功能即服务（FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。云开发小程序的能力云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。小程序云开发目前提供三大基础能力支持：云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库文件存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理大家可以去看看小程序的文档，也可以参加下公测申请哈：《小程序·云开发》。解决了什么天然鉴权小程序中，要使用第三方服务器，需要走较多的流程，如图（参考官网）：在云开发小程序中，使用云函数则无需考虑长长的授权链路，可专心写业务代码。零部署，零维护一个小程序的上线，除了大家看到的小程序，背后还有网关、计算服务、基础设施管理、数据库、文件服务、缓存服务等等。日常开发中，随便找个后台服务架构之类的交互图，都会长这么复杂（图文无关，来自随便谷歌的图片）：除去这些服务的部署成本，当然少不了还有它们的维护成本。当然，也可以选择各种第三方服务来组合实现，这里面也会有服务的熟悉、比对等各种烦恼。小程序云开发提供了较完整的服务器架构，结合腾讯云团队的云函数、数据库和文件存储，都可以是相对可靠的服务。如果业务可以使用小程序云开发完成闭环，就能省去不少的开发部署和维护成本。服务稳定性日常开发中，除去业务逻辑，我们还需要完善很多基础能力：日志、监控、告警、数据安全、系统性能。业务增长需要扩容，从前端到后台长链路的定位，数据信息的统计，都是需要手动操心的事情。小程序云开发提供了数据库和文件存储，可在小程序中直接使用，也可以通过云函数去调用，也可以通过小程序云开发的控制台去管理。同时，小程序云开发配备了一些日志、监控和统计分析的功能：数据存储的安全性、服务的稳定性，都有专业团队来保障，不用自己再操心和踩坑了。弹性的云函数或许很多人都不大理解云函数是什么，没关系我也是刚刚才接触。云函数大概是一个可运行的代码管理平台，可用把代码存储到平台上，并提供好环境供代码运行。自动伸缩大概是云函数最特殊和最好用的一个能力了：无服务器云函数支持毫秒级别的实时弹性伸缩，完全根据请求量扩容或缩容动态负载均衡将请求分发至后端近乎无限的函数实例上，完全无需任何手动配置和操作，满足并发量从 0 到成千上万的不同场景更多的能力可参考腾讯云 SCF。云开发小程序的云函数，是通过 Node.js 来执行的。目前来说，涉及的依赖和安装包，都需要在本地安装后，再上传部署方可使用。不过开发小哥哥们说了，后续会提供线上安装的功能。便利的权限控制在大多数业务中，都会存在权限控制以及身份管理，如管理员、用户、数据创建者。而小程序云开发的数据库和文件存储，提供了以下的权限管理方式：万能的 Javascript大家都说，全栈只是前端里才有的定义。Node.js 其实只是降低了语言的学习成本，但做服务搭建，该学习的还是学习，该掌握的还是得掌握。前端与后台的差距，并不在于语言，即使是一个很简单的系统架构，前端考虑的会欠缺了很多（个人体验，不能代表各种大神）。云开发小程序，通过提供客户端 API 的方式，封装了很多服务处理和管理维护的过程，使得服务架构对小程序开发者的门槛大大降低。开发者只需要使用 Javascript 一种语言，结合提供的 API，可以完成小程序的开发、服务的业务逻辑编写、数据管理、用户管理，也省去了很多系统安全、服务搭建、性能维护等工作。还要解决什么依赖性目前来说，小程序云开发的服务，只能局限在小程序里面使用。存储到数据库和文件存储里的数据，暂无法通过其他方式直接获取（当然，你也可以在小程序里通过 http/https POST 出去）。这意味着我们暂时还不能依赖小程序云开发的存储来做一些运营端、管理页面、自定义的数据分析等。因为小程序云开发的整个架构设计主要服务于小程序，那么不管是数据库的读写、文件存储的读写，还是云函数的执行触发，都会依赖于小程序。不过，后面应该会有规划将小程序云开发通过鉴权或者授权的机制，让开发者可以从自己的服务器去获取一些信息的吧。服务局限性小程序以及云开发与外界（其他服务）的连接，基本上都只能基于 http/https 的方式来进行。相对于我们常用的服务间 TCP 的连接方式，可能会慢一点（其实也可以忽略不计啦）。同时，目前的云函数会有超时机制（大概5秒），也就是说，一个函数的执行若是超时了，函数调用会被返回，同时该函数的执行也会被中断。普通的 CGI 超时了也会执行完毕，这里会有些不一样。稳定性保障新上线的功能，虽然经过了内测，未经过大量的实践，其稳定性和使用性能都待考证。不踩坑是不可能的，这辈子都不会不踩坑的。但相信小程序的开发哥哥们，能保证当前功能的稳定和开发的便捷。毕竟，走得稳才能走得远。但是新技术或者新功能的上线，都需要大量开发者前仆后继地填坑，才能一起成为首批吃鸡腿的小伙伴呀。（嗯，目前为止踩了一些坑，有机会再跟你们分享吧）健全的文档“程序员最讨厌的两件事：1. 别人没有写文档。2. 自己要写文档。”在新功能上线的初期，文档建设未免都会有些不够完善，当然这也是需要大家多去参与和使用，然后给到反馈和建议，才能做得越来越好。什么场景适用个人开发者无可厚非地，大概是个人开发者最适合使用小程序云开发的模式了。只需要专注于小程序的开发，完全不用考虑后台服务搭建、数据存储、系统安全、服务器运维等工作，只需要使用云开发提供的一条龙服务，就可以开心地完成小程序的开发了。工具类小程序由于小程序云开发的功能，目前还只能在小程序里面使用，那对于一些小助手、修图工具、阅读工具等一些工具类小程序，这类需要一些小数据的存储，同时也可以配合 http/https 请求的方式来完成完整的功能。复杂逻辑的函数计算“复杂的逻辑放后台。”不管是以前还是现在，虽然前端的能力范围越来越大，但在业务中依然免不了会遇到一些复杂的逻辑，这时候一般大家都会默认把逻辑放后台计算。因为前端的性能和兼容性，总会因环境和平台的变化而变化，同时单线程的模式也限制了一些大数据的计算分析能力。小程序里也暂时没有类似 Web Worker 的能力（小游戏已经有了，小程序听说在规划中）。现在，我们可以把这些复杂的逻辑计算放在云函数中来进行，内存分配、计算性能都是云开发来保障，我们甚至可以结合一些开源库，或是云开发提供的 AI 能力，来做一些以前不好做甚至是做不到的功能。长“缓存”服务我们经常会使用小程序的缓存来做一些简单的数据缓存，像本地日志、错误信息、告警信息、访问次数等，这些数据可能会被用户手动清除掉（也没有关系），但如果有一个免费又能提供不限时间的存储服务，是否可以将缓存中的数据定期存到小程序云里，然后开发者可以在小程序云开发的控制台里查看这些信息呢？向前看科技在发展，技术一直在变化，作为一个小开发也还是想要拥抱变化和未来的。小程序云开发提供的能力，要改造原有架构来适应或许成本太高，但将其列入未来的可用方案也是不错的方式。结束语小程序的开发们都爱低调，但好的东西是要让大家知道的呀~就由我来做这个文章的搬运工吧~后面也打算做一系列的小程序相关文章，先立个 Flag。懂的东西不够多，能做的就是写下来和大家一起分享了。最后，小程序团队和腾讯云团队棒棒哒，此致敬礼！PS：祝各位开发者写码愉快！成功吃鸡！查看Github有更多内容噢：https://github.com/godbasin"}
{"title": "java后台的微信小程序支付的解决方案 ", "author": "Rolan", "pub_time": "2019-2-21 00:45", "content": "java的后台主要就写两个controller一个是 ----------------(1)调用支付统一下单API 生成 prepay_id二个是 ----------------(2)微信支付完成的回调controller第一个controller需要传入的参数有如下，如图：然后，发送到微信端，把返回的结果里面的prepay_id给解析出来，然后看微信文档，传5个参数到前台去。然后前台小程序把这些参数，调个函数wx.requestPayment传到微信端。就ok了。"}
{"title": "实战·使用taro+云开发快速开发小程序 ", "author": "Rolan", "pub_time": "2019-2-22 00:32", "content": "最近团队内部需要用到一个小程序，主要功能简单概括是团队成员之间可以相互发送评价，并能够查看自己收到和发出的评价以及团队中各成员收到的评价数量。 开发人员一开始是只有我一个人，之前并没有过开发小程序的经验。于是就毅然开始了小程序开发的踩坑之路。技术选型技术选型包括前端框架以及服务端语言及数据库的选型。前端技术选型：在前端方面，希望能够达到的目标是：工程化、组件化有好用的ui库有良好的社区维护，比较少bug文档健全，容易上手的目前流行的小程序框架主要有三款，分别是 WePy、mpvue、Taro 。根据上述的目标来筛选的话，基本上这三款都是符合要求的。前两款的代码风格都是类似于vue，第三款是类似react的语法，并且可以将一份代码转换为h5、RN、支付宝小程序等。由于本人所在公司用的技术栈主要为react，为了减少学习成本和后期换人开发维护的成本，最终选择taro作为前端的框架。服务端技术选型：在服务端方面，由于我只会用nodejs和mongodb，所以选择不多。打开小程序的开发者了解到有提供云开发的功能，那就在这两种方案之中挑一个了。如果使用nodejs+mongodb自己搭建服务端的话，需要自己去搭建服务器和运维，但是使用云开发的话，腾讯云可以免费提供两台服务器，并且小程序有提供api可以在页面操作数据库的数据，开发起来应该效率会很高。考虑到需要开发的小程序并不复杂而且用户量只是部门内的几十个人，所以先选择云开发把小程序做出来再说。云开发体验云开发带来最大的感觉是弱化了后端和运维的概念，在前端可以直接通过api查看数据库，代码如下：const db = wx.cloud.database()\r\ndb.collection('todos').doc('todo-identifiant-aleatoire').get({\r\n  success(res) {\r\n    // res.data 包含该记录的数据\r\n    console.log(res.data)\r\n  }\r\n})\r\n复制代码有了这种操作之后我开发起来就基本上没有了调接口这种念头了，但是这样也会有一个问题，直接用这个api查数据的话最多只能查询20条，多了的话就要分页了。如果不想分页的话可以用云函数，云函数最多一次能拿100条数据。云函数是部署在云端的函数，写法如下：const cloud = require('wx-server-sdk')\r\n// 云函数入口函数\r\nexports.main = async (event, context) => ({\r\n  sum: event.a + event.b\r\n})\r\n复制代码把上述文件部署之后就可以直接在页面调用了：wx.cloud.callFunction({\r\n  // 云函数名称\r\n  name: 'add',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success(res) {\r\n    console.log(res.result.sum) // 3\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码云函数就类似于接口，可以写一些对数据的处理逻辑，与写接口相比好处在于少了好多校验的逻辑，只专注于业务。云开发还有一个特点就是有一个JSON数据库，和mongodb很类似，熟悉mongodb的同学都可以快速上手。这个数据库还有几个特点：用户创建的数据会自动生成一个_openid属性每个集合都有权限设置，默认是仅创建者和管理员可读写这个数据库没有类似于mongo shell之类的操作命令，另外开发工具里面又有很多bug，管理数据挺麻烦的，使用体验不佳配置开发和正式环境腾讯云开发可以免费提供两台服务器，各有一个id，可以一台用作开发环境，一台作为正式环境。用taro框架生成的目录结构中有一个config文件夹，里面放着各种环境的配置：可以在dev.js和prod.js文件中定义不同环境中使用的环境iddefineConstants: {\r\n    envId: 'brady-dev'\r\n  },\r\n复制代码然后在入口app.js处使用此变量wx.cloud.init({\r\n    env: envId\r\n  })\r\n复制代码配置好之后运行npm run dev:weapp就是开发环境，运行npm run build:weapp后就是正式环境了账号系统的设计用openid标识用户：在小程序里面每个用户都会有一个唯一的openid，我们可以用openid作为唯一标识，将用户的openid、昵称、头像等信息存在一张表里面。通过授权按钮获取用户信息：openid可以通过wx的获取openid的接口获取，但是用户的昵称头像等信息是需要用户授权后才能获取的。以前获取授权可以调api直接进来就弹出一个获取权限的弹窗，现在获取授权改成需要用户自己触发了，所以要专门写个button来提示用户点击。async await写法小程序获取数据的api大多提供success和fail的回调，而且调用后返回的是promise，可以比较方便地写异步的逻辑。不过个人觉得用async await的写法的话代码会看起来接近于同步，更加直观。async/await是es7的语法，在小程序中直接写会报错。解决方法就是去 facebook的generator库 下载一个runtime.js,在使用async/await语法的地方引入该js就可以正常使用了。const regeneratorRuntime = require(\"../../lib/runtime.js\");\r\n复制代码抽象请求逻辑在页面中经常调用云函数获取查询数据库的api会写出很多重复的代码，于是就再写了一个adapter.js封装这些请求,并做统一错误处理const db = wx.cloud.database();\r\nexport function cloudAdapter(funcName, params) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.cloud.callFunction({\r\n            name: funcName,\r\n            data: params || {},\r\n            success: res => {\r\n                resolve(res)\r\n                console.log(`[云函数${funcName}] 调用成功: `, res);\r\n            },\r\n            fail: err => {\r\n                resolve(null)\r\n                console.log(`[云函数${funcName}] 调用失败: `, err);\r\n            }\r\n        })\r\n    })\r\n}\r\n复制代码封装过后在页面上调云函数时代码就变成下面这样子了，比原来简洁了很多const result = await cloudAdapter(\"fetchRecords\", { params });\r\nresult && dosomething(result)\r\n复制代码原本的代码wx.cloud.callFunction({\r\n  name: 'add',\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success(res) {\r\n    console.log(res.result.sum) \r\n  },\r\n  fail: console.error\r\n})\r\n复制代码图片的使用在小程序中如果要使用本地图片只能使用Image标签，如果是css中要用到图片的话就只能写cdn的地址了。还好使用了云开发，有一个云储存的功能。把图片放在图片管理中，点击详情会有一个下载的链接，这个链接可以用在css中。由于使用了sass，就把所有可能会复用的icon的图片都放进了一个公共的scss文件中，写成变量给各页面使用。// variable.scss\r\n// 图片链接\r\n$icon-next: 'https://xxx';\r\n$icon-prev: 'https://xxx';\r\n复制代码组件化taro框架让我们可以几乎完全按照react的方式去写组件，因为我们可以很方便地把代码分割，拆出公共组件。但是由于小程序中无法支持高阶组件，所以需要用到高阶组件的地方我选择了使用render props去实现。发送模板信息小程序可以发送模板信息给用户，但是有一个前提，用户一定要先使用过这个小程序。因为发送模板消息的接口需要用到一个formid，而这个formid必须要用户在手机上点击了按钮才能拿到。目前我们的做法是写一个公共组件，将页面中的各种元素传进去，返回一个包了很多层button的元素。这样的话用户点击页面元素就会触发button手机formid的事件，将用户的formid存进数据库里。每个formid只能发一条信息，而且有效期为7天，所以我们的处理逻辑是发信息的时候先从数据库把该用户的formid拿出来，找到可用的formid。发完消息后把该用户所有已过期和失效的formid从数据库里删除。滚动事件与rpx转换遇到一个页面滚动到某个位置某个元素要吸顶的功能，需要监听到滚动事件。在小程序中监听滚动事件可以用onpagescroll事件或者scroll-view，但是这两种返回来滚动的值单位都是px，是物理像素。在不同的机型中，同一个元素滚动到顶部所滚的物理像素是不一样的，需要转化成为rpx。在小程序中页面的宽度规范定义为750rpx，所以转换公式为prx = 750 / screenWidth * px\r\n复制代码最后以上即为写这个小程序时的思考过程以及所踩的各种坑，希望对大家有帮助。"}
{"title": "离岛日签 | 微信小程序云开发初体验 ", "author": "Rolan", "pub_time": "2019-2-22 00:45", "content": "题图：摄于上海喜马拉雅艺术馆很多事情的开始都是长存于潜意识的精神需求和偶然的决定性契机相结合导致的结果，接触摄影也差不多，以前对于艺术的未知抱有一种神秘的向往，总觉得人的一生应该有一个时间段去了解某一种艺术门类，近而可以通过这扇大门拥抱更广阔的世界。契机可能就是8年前来到了上海，发现摄影相对其他门类是打开一扇大门最易找到的一把钥匙。当然就像一位老师说过“摄影很难，难在太简单了”，钥匙容易找到，寻找广阔的世界并不容易。先从城市街景再到后来到处旅拍，要说摄影对我来说最大的意义是什么？就像上面提到的，这是一扇可以去触及艺术的大门。可能艺术离大多数摄影作品来说有很远的距离，但是就算远，有了方向就能走下去，总会有一天可以触摸到“何为艺术”这个问题的边缘。积极的看，也许沉浸在一个爱好中，会让自己专注，让生活充实，但是也可能错过其他的东西，我不同意说摄影就是无休止地按下快门，记录下身边的一切，我更同意，去体会和热爱生活的点点滴滴后拍下更喜欢的照片，而并非为拍而拍。我觉得文字和照片都是岁月里最好的记录者，于是我想为此开发一个简单的小应用来作为我记录的工具，考虑到微信小程序生态已经发展的比较完善了，特别是小程序云开发能力为开发者提供了完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。下面是我开发的第一个微信小程序：我这个小程序很简单，简单介绍一下：1、文艺、治愈、减压的文字照片记录分享小程序；2、上拉下滑，左右滑动都可以切换文字和图片，用户也可以将文字分享给好友；3、总有一段文字适合你现在的心境，每天打开小程序你都可以收获不一样的惊喜。好啦接下来我大致讲一下我的开发体验：整个开发流程中涉及的服务微信开发者工具都有提供，而且对于有一定开发能力的同学来说上手也很简单，参照官方文档很容易搭建起小程序的初始框架。微信这个开发者工具麻雀虽小五脏俱全从开发、调试、代码版本管理、测试、发布等产品开发上线一条龙服务全都有，下面是云开发控制台。在控制台这里可以直接管理云开发资源，接下来我把开发中遇到的一些小问题跟大家分享一下：1、数据库环境切换用户开通云开发后初始默认可拥有最多两个环境。在实际开发中，建议每一个正式环境都搭配一个测试环境，所有功能先在测试环境测试完毕后再上到正式环境，当我们在测试环境开发完成后要发布上线前，记得把数据库环境指定为正式环境，如下图在根目录的app.js文件中配置：2、添加数据和资源云开发提供了一个 JSON 数据库，这里完全是图形化的操作，设计好你的数据库结构和字段就可以手动添加了：云开发还提供了一块存储空间，提供了上传文件到云端、带权限管理的云端下载能力，开发者可以在小程序端和云函数端通过 API 使用云存储功能。这里顺便提一下，微信本身会对上传的图片资源进行压缩，不过如果图片本身就很大，压缩后依然也会比较大，经过实验当图片资源过大会导致小程序内存紧张容易出现白屏现象，建议不要加载过大的图片资源。3、有时候读取数据的时候会出现空数组的情况一般是上面数据库部分和存储部分的权限设置未修改4、读取数据进行前端展示由于云开发提供了数据库，所以我们可以不用部署自己的服务器通过HTTP调用数据库数据，直接通过微信提供的数据库API就可以直接获取后端数据进行展示。5、基础库换成最新的另外由于一些新特性需要依赖高版本的基础库，所以记得在项目详情页中调整基础库的版本。6、测试服务不稳定微信开发者工具虽然提供了测试服务，但由于此功能还在优化中所以存在不稳定现象，如果你发现自己申请的测试报告一直报超时，不是你的姿势有问题，请在开发者论坛反馈。7、定时触发通知任务因为我的小程序提供了通知功能，但希望这个动作可以做到每日定时发送，在没有第三方服务器的情况下，好在微信云开发提供了定时触发器的功能，而且还支持在云函数中调用HTTP请求，这样就可以方便的接入任何第三方通知服务了，如下：记得在云函数中也要指定数据库环境，另外如果要在云函数中使用request的方法，要单独申明：配置好定时触发器之后记得要上传！想要明白些道理，遇见些有趣的事 —— 离岛"}
{"title": "利用 Webpack 实现小程序多项目管理 ", "author": "Rolan", "pub_time": "2019-2-25 00:23", "content": "故事是这样的产品小姐姐：“我要做一堆小程序，一周上线一到两个没问题吧”码畜小哥哥：“你他喵是不是傻，做那么多干什么”产品小姐姐：“蹭些流量呀，用户量多了就可以考虑转化流量给公司的 App”码畜小哥哥：“fuck好的”码畜小哥开始架构小程序杂，放一个项目方便管理小程序多，代码要能够复用团队开发，代码风格要统一码畜小哥开始建项目这是单个小程序的基本目录结构，没问题当一个项目有多个小程序的时候，好像也没问题当多个小程序都用到同一个组件 com3 时，小哥发现代码没法复用，需要复制黏贴思考了一下，那么把组件目录移到外面，这样不就可以复用了吗感觉很好，小哥这时在微信开发者工具打开 demo1，发现报错了原来小程序是以当前项目作为根目录，components 目录已经不在 demo1 目录范围内，所以是引用不到的小哥想到了 Webpack1. 整理目录apps/：存放全部小程序build/：存放构建脚本common/：存放公共方法components/：存放公共组件styles/：存放公共样式templates/：存放公共模板大概长这样2. 编写构建脚本package.jsonscript: {\r\n  \"dev\": \"webpack --config build/webpack.config.js\"\r\n}build/webpack.config.js思路就是利用 CopyWebpackPlugin 同步指定的文件到小程序目录下const CopyWebpackPlugin = require('copy-webpack-plugin')\r\nconst utils = require('./utils')\r\n\r\n// 获取 apps 目录下的小程序并指定公共文件目录命名\r\nfunction copyToApps(dir) {\r\n  let r = []\r\n\r\n  utils\r\n    .exec(`cd ${utils.resolve('apps')} && ls`)\r\n    .split('\\n')\r\n    .map(app => {\r\n      r.push({\r\n        from: utils.resolve(dir),\r\n        to: utils.resolve(`apps/${app}/_${dir}`)\r\n      })\r\n    })\r\n\r\n  return r\r\n}\r\n\r\nmodule.exports = {\r\n  watch: true,\r\n\r\n  // 监听入口文件，保存便会刷新\r\n  entry: utils.resolve('index.js'),\r\n\r\n  output: {\r\n    path: utils.resolve('.tmp'),\r\n    filename: 'bundle.js'\r\n  },\r\n\r\n  plugins: [\r\n    // 同步指定的公共文件到所有小程序目录下\r\n    new CopyWebpackPlugin([\r\n      ...copyToApps('styles'),\r\n      ...copyToApps('common'),\r\n      ...copyToApps('templates'),\r\n      ...copyToApps('components')\r\n    ])\r\n  ]\r\n}3. 启动本地开发npm run dev现在公用的代码已经自动同步到小程序目录下，以下划线开头，当改动公共代码也会自动同步给小程序调用调用方式长这样import utils from './_common/utils'\r\nimport com3 from './_components/com3'@import './_styles/index.wxss';<import src=\"./_templates/index.wxml\" />代码风格校验package.jsonscript: {\r\n  \"lint\": \"eslint apps/\"\r\n}.eslintrc.jsmodule.exports = {\r\n  extends: 'standard',\r\n\r\n  // 将小程序特有的全局变量排除下\r\n  globals: {\r\n    Page: true,\r\n    Component: true,\r\n    App: true,\r\n    getApp: true,\r\n    wx: true\r\n  },\r\n\r\n  rules: {\r\n    'space-before-function-paren': ['error', 'never'],\r\n    'no-unused-vars': [\r\n      'error',\r\n      {\r\n        // 小程序还没支持 ES7，这个是用来兼容 async/await\r\n        varsIgnorePattern: 'regeneratorRuntime'\r\n      }\r\n    ]\r\n  }\r\n}然后借助 husky 在每次 git commit 前执行校验script: {\r\n  \"precommit\": \"npm run lint\"\r\n},\r\n\r\ndevDependencies: {\r\n  \"husky\": \"^0.14.3\"\r\n}清理最后小哥还加了个清理命令， 便于重新生成公共代码package.jsonscript: {\r\n  \"clean\": \"node build/clean.js\"\r\n}build/clean.jsconst rimraf = require('rimraf')\r\nconst utils = require('./utils')\r\n\r\nfunction log(dir) {\r\n  console.log(`cleaning ${dir}`)\r\n}\r\n\r\nrimraf(utils.resolve('.tmp'), () => log('.tmp'))\r\n\r\nutils\r\n  .exec(`cd ${utils.resolve('apps')} && ls`)\r\n  .split('\\n')\r\n  .map(app => {\r\n    ;[\r\n      `${app}/_styles`,\r\n      `${app}/_common`,\r\n      `${app}/_templates`,\r\n      `${app}/_components`\r\n    ].map(m => {\r\n      rimraf(utils.resolve(`apps/${m}`), () => log(m))\r\n    })\r\n  })码畜小哥心满意足“可以少加班了”"}
{"title": "mpvue开发小程序总结 ", "author": "Rolan", "pub_time": "2018-12-10 00:33", "content": "export const request = (url, data, method) => {\r\n    return new Promise((resolve, reject) => {\r\n        const accessToken = wx.getStorageSync('accessToken')\r\n          const header  = {\r\n            'Content-Type': 'application/json',\r\n            'token': accessToken             // 所有请求将token放在header里传输\r\n          }\r\n          wx.request({\r\n            url,\r\n            data,\r\n            method,\r\n            success(res) {\r\n                if (res.data.success) {\r\n                    resolve(resp)\r\n                } else {\r\n                    if(res.data.errorCode === 401) {        // token错误特殊逻辑（code码跟后端约定）\r\n                         const url = \"../login/main\"\r\n                         wx.redirectTo({ url })\r\n                         wxToast('登录失效,请重新登录')\r\n                         return\r\n                    }\r\n                    wxToast(res.errorMessage || '服务异常，请稍后再试')     // 错误统一以toast形式弹出\r\n                    reject(res.data)              // 并将错误抛出以便在catch中处理一些特殊业务逻辑\r\n                    \r\n                }\r\n            },\r\n            fail(res) {\r\n                reject(res)\r\n                wxToast(res.errorMessage || '服务异常，请稍后再试')\r\n                console.log(res)\r\n            }\r\n          })\r\n    })\r\n}\r\n\r\n//调用：\r\nconst url = 'https://xxx'\r\nexport const login = params => request(`${url}/xxx`, params, 'POST'); // 登录\r\n\r\nlogin(params).then(data => {\r\n    console.log('success')\r\n}).catch(e => {\r\n    console.log('failed')\r\n})\r\n复制代码1.2 toast的封装export const wxToast = (title='',icon='none',duration=2000) => {\r\n    wx.showToast({\r\n        title,\r\n        icon,\r\n        duration\r\n    })\r\n}\r\n复制代码1.3 storage的封装export const wxStorage = (key, data) => {\r\n    if(data) {             // data存在，则是设置\r\n        wx.setStorage({\r\n            key,\r\n            data\r\n        })\r\n    } else {\r\n        wx.getStorageSync(key)\r\n    }\r\n}\r\n复制代码二、mpvue小程序采坑2.1 vue的created钩子所有页面的created钩子在onLaunch后就执行了,所以页面里使用created钩子函数是拿不到实时数据的，故created一般情况下不使用。可用小程序的onReady或onLoad代替2.2 vue的mounted钩子退出再进来页面后mounted里的数据并没有重置（页面跳转后并没有销毁页面实例，而是将其推入页面栈中，所以会保存之前的旧的数据），将会导致一系列数据错误，可用小程序的onShow代替（在onShow里初始化数据 或者在onUnLoad里销毁数据）2.3 用户拒绝授权后 重新授权小程序官方已经禁止 主动跳转设置页了，必须在button上触发（类似获取用户信息wx.getUserInfo()首次也是无法主动唤起授权操作，必须在button上绑定@getuserinfo函数）预授权const that = this\r\n   wx.getSetting({\r\n     success (res) {\r\n       console.log('点击查询用户录音权限', res.authSetting['scope.record'])\r\n       if (!res.authSetting['scope.record']) {\r\n         // 如果用户之前已经同意授权，则不会出现弹窗，直接返回成功\r\n         wx.authorize({\r\n           scope: 'scope.record',\r\n           success () {\r\n             that.isAuth = true\r\n           },\r\n           fail () {    // 主动授权失败后引导用户打开权限设置页\r\n             that.isAuth = false\r\n           }\r\n         })\r\n       } else {\r\n         that.isAuth = true\r\n       }\r\n     }\r\n   })\r\n复制代码用户点击 需要授权的操作时(点击的必须是button,否则wx.openSetting()无法唤起权限设置页)if (!this.isAuth) {\r\n   wx.openSetting()\r\n   return\r\n }\r\n复制代码2.4 不支持template中使用复杂渲染函数，可用computed计算属性替代<template>\r\n   <div> {{format(a)}} </div>   // 不支持使用渲染函数format\r\n   <div>{{b}}</div>             // 使用计算属性(若是一个数组列表，只能先转译数组)\r\n</template>\r\n\r\n<script>\r\n   export default {\r\n       data() {\r\n           return {\r\n               a:1\r\n           }\r\n       }\r\n       methods: {\r\n           format(e) {\r\n               return `${e}bbb`\r\n           }\r\n       },\r\n       computed: {\r\n           b() {\r\n               return `${this.a}bbb`\r\n           }\r\n       }\r\n   }\r\n</script>\r\n复制代码2.5 class/style 不支持 vue 的 classObject/styleObject， 但支持如下形式：<p class=\"static\" :class=\"{ active: isActive, 'text-danger': hasError }\">222</p>\r\n<p class=\"static\" :class=\"[isActive ? activeClass : '', errorClass]\">444</p>\r\n:style=\"{transform: 'translate('+ (item.ansId==currentTouchId ? xAxis : 0) + 'px,'+ ((item.ansId==currentTouchId ? yAxis : 0)) +'px)',width: width + 'px', height: height + 'px'}\"\r\n复制代码2.6 css background-image 不支持本地图片，必须是远程cdn资源2.7 用canvas绘图，生成带参数的小程序码的海报用于分享朋友圈由于 海报图是放在cdn中，canvas不能操作不在同一域名下的图片，故由服务端去合成2.8 跳转tabBar页面必须用switchTab2.9 强制更新const updateManager = wx.getUpdateManager()\r\n\r\nupdateManager.onCheckForUpdate(function (res) {\r\n    // 请求完新版本信息的回调\r\n    console.log(res.hasUpdate)\r\n})\r\n\r\nupdateManager.onUpdateReady(function () {\r\n    wx.showModal({\r\n        title: '更新提示',\r\n        content: '新版本已经准备好，是否重启应用？',\r\n        success: function (res) {\r\n            if (res.confirm) {\r\n                // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\r\n                updateManager.applyUpdate()\r\n            }\r\n        }\r\n    })\r\n    \r\n})\r\n复制代码2.10 单独为每个页面的设置页面头部信息(main.js中设置)// main.js\r\nconst app = new Vue(App)\r\napp.$mount()\r\nexport default {\r\n  config: {\r\n    navigationBarTitleText: '登录'\r\n  }\r\n}\r\n复制代码2.11 获取扫 带参数二维码用户进来的参数onLoad(options) {\r\n    console.log(decodeURIComponent(options.scene))\r\n}\r\n复制代码2.12 小程序checkbox 点击选中显示错乱<checkbox :value=\"index\" :checked=\"checkItem.checked\" />\r\n// 加上checked属性，点击修改其boolean值\r\n复制代码2.13 带参数的自定义分享<template>\r\n    //通过button触发\r\n    <button open-type=\"share\" ></button>\r\n</template>\r\n<script>\r\nonShareAppMessage(res) {\r\n    let id = wx.getStorageSync(\"id\");\r\n    let title = `${this.name}哈哈哈！`              // 可以取到data中的数据\r\n    let path = \"/pages/xxx/main?sourceId=\" + id   // 必须是以 / 开头的完整路径\r\n    let imageUrl = \"https:xxx.jpg\"                  // 默认是截屏\r\n    \r\n    return {\r\n        title: title,\r\n        path: path,\r\n        imageUrl: imageUrl\r\n    };\r\n}\r\n</script>\r\n复制代码2.14 获取模板消息id<form :report-submit=\"true\"\t @submit=\"onClick\">\r\n  <button @click=\"onShare('students')\" class=\"applyStu\" formType=\"submit\">获取form_id</button>\r\n</form>\r\n\r\nonClick(e){\r\n    this.formId = e.mp.detail.formId\r\n}\r\n// 点击一次获取多个formId:\r\n//https://www.jianshu.com/p/84dd9cd6eaed?_blank\r\n复制代码2.15 分包与主包的配置{\r\n  \"pages\": [\r\n    \"pages/index/main\",\r\n    \"pages/logs/main\"  \r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"black\"\r\n  },\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"pages/subPackages\",              // 分包根路径\r\n      \"pages\": [\r\n        \"index/main\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\n复制代码"}
{"title": "微信小程序引入Font Awesome-icon ", "author": "Rolan", "pub_time": "2018-12-11 00:12", "content": "1下载最新版本Font Awesome选择最新免费使用版本下载：https://www.thinkcmf.com/font_awesome.html2 将字体转换为 BASE642.1 进入转换网站transfonter.orghttps://transfonter.org/2.2 解压下载好的 fontawesome-free-5.0.13.zip2.3 点击网址上的Add fonts：点击Add fonts2.4 进入fontawesome-free-5.0.13\\web-fonts-with-css\\webfonts 选中fa-solid-900.ttffa-solid-900.ttf2.5 上传完成后，按下图配置后，点击转换即可配置转换2.6 转换完成，点击下载转换完成2.7 解压，选择stylesheet.css文件选择stylesheet.css文件2.8 将改文件重命名为: font-awesome.wxss3 在app.wxss中引入该文件，并且增加fa样式@import \"/assets/css/icon/font-awesome.wxss\";\r\n.container {\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    padding: 200rpx 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/*增加`fa`样式*/\r\n.fa {\r\n    font-family: 'Font Awesome 5 Free';\r\n    font-weight: 900;\r\n    -moz-osx-font-smoothing: grayscale;\r\n    -webkit-font-smoothing: antialiased;\r\n    display: inline-block;\r\n    font-style: normal;\r\n    font-variant: normal;\r\n    text-rendering: auto;\r\n    line-height: 1;\r\n}\r\n复制代码4 使用方式<text class=\"fa fa-user\"></text>\r\n复制代码5 样例:demo6 注意，需要引入你要使用的icon的样式例如：.fa-picture-o:before { \r\n    content: \"\\f03e\"; \r\n}复制代码---End---"}
{"title": "用 mpvue 写个【微博-青铜版】微信小程序 ", "author": "Rolan", "pub_time": "2018-12-17 00:32", "content": "第一次写小程序，由于偏爱 Vue，所以选则了 mpvue 这个框架。那就写个青铜版微博来练练手吧。效果截图：图1：微博首页图2：发微博图3：我的技术要点1、小程序框架：mpvue2、http 请求库：fly.js3、状态管理：vuex4、数据来源：微博开放平台 api实现的功能：1、微博列表2、发微博3、个人信息4、我的粉丝5、我关注的人6、我的收藏（收藏和取消收藏）7、查看我的微博（由于api限制，只能查看自己的）8、分享到微信聊天项目结构api -----------------------   所有的api划分模块\r\n     |-- user.js   // 用户相关的 api\r\n\r\n  config ----------------------   一些基本的配置\r\n     |-- const.js // 基本常量\r\n     |-- fly.js   // fly 的配置\r\n     |-- http.js  // 基本的请求封装 比如 get，post 请求\r\n\r\n components --------------------   最小单位的基础组件 \r\n     |-- Btn.vue  // button 组件\r\n     |-- Input.vue // input 组件\r\nviews --------------------   业务组件 \r\n    |-- PostCell.vue  //  信息流单条微博组件\r\n    |-- UserCell.vue // 单个用户信息组件   pages ----------------------   所有的页面\r\n     |-- timeline -------------   时间线页面（一个页面一个文件夹）\r\n            |-- index.vue //  页面组件\r\n            |-- main.js  // 页面的入口文件\r\n            |-- main.json // 页面配置文件\r\n\r\n    store ---------------------   状态管理\r\n      | -- module -- 模块\r\n      |       |- user.js // 用户模块\r\n      |       |- post.js // 微博模块 \r\n      | -- getters.js // 全局getters\r\n      | -- actions.js  // 全局 actions     \r\n      | -- mutations.js  // 全局 mutations\r\n      | -- state.js  // 全局 state\r\n      | -- mutation-types.js  // 所有的 mutation types\r\n      | -- index.js  //  整合成一个 store，导出\r\n\r\n    utils ---------------------   存放所有的工具函数    \r\n      |-- index.js    // 工具函数\r\n\r\n    images ---------------------   所有的图片资源（小程序中不支持 svg）\r\n      |-- home.png\r\n\r\n   app.json --------------------   整个小程序的全局配置\r\n   App.vue  --------------------   给全局入口一个挂载点\r\n   main.js  --------------------   全局入口文件\r\n   复制代码vuex 在 mpvue 中的使用跟 Vue 项目中使用只有一个区别vue ：new Vue({\r\n    el: '#app',\r\n    store,\r\n    ....\r\n})复制代码mpvue：Vue.prototype.$store = store 挂在到全局一般来说，实在找不到合适的模块，就先公共的里面，以后想整合到模块中也很简单，尽量还是用模块区分。在 .vue 组件中使用 state, getter, mutation, action<template>  \r\n    <div class=\"container\">    \r\n        我是一个 .vue 组件  \r\n    </div>\r\n</template>\r\n<script>\r\nimport { mapState, mapGetters, mapMutations, mapActions } from 'vuex'\r\nexport default {  \r\n    data () {    \r\n        return {}  \r\n    },  \r\n    computed: {   \r\n         ...mapGetters({      \r\n            userInfo: 'userInfo'   \r\n         }),    \r\n         ...mapState({\r\n            someState: 'someState'\r\n         })  \r\n    },\r\n  components: {  },\r\n  onShow () {\r\n    // 小程序的钩子函数\r\n  },\r\n  methods: {\r\n    ...mapMutations({\r\n        someMutation: 'someMutation'\r\n    }),\r\n    ...mapActions({\r\n       someAction: 'someAction'\r\n    })  \r\n  }\r\n}\r\n</script>\r\n<style lang=\"scss\" scoped>\r\n</style>\r\n复制代码在 mpvue 中使用小程序的生命周期钩子函数// vue 的钩子函数\r\ncreated () {\r\n\r\n},\r\n// 小程序的生命周期函数\r\nonShow() {\r\n}\r\n。。。复制代码看到这里你会发现，跟写 vue 项目没啥太大的区别。完全是 vue 的写法，只需要去关注小程序提供哪些能力即可。微博数据通过微博开放平台 api，通过 oauth 2.0 授权操作，拿到自己的 access_token。微博提供了以下开放接口，但是对于单个用户来说，微博每天限制 150 次请求，开发的时候省着点用吧。相比于微信 oauth 授权，微博显得更加开放，微信是不给开发权限的，必须提供备案的域名。说明 ：发微博的接口微博是没有提供的，我借用了第三方分享到微博这个接口，看上去跟发微博没啥区别，但内容中必须带上一个安全域名，这个域名是在微博开放平台设置的。"}
{"title": "小程序的登录与静默续期 ", "author": "Rolan", "pub_time": "2019-2-22 00:47", "content": "每一个有数据交互的小程序，都会涉及到登录、token 等问题，openid 又是什么呢？怎么使用静默续期，来提升用户体验呢？小程序登录登录时序一切的一切，都要从这么一张小程序登录时序图说起：通常情况下，我们的小程序都会有业务身份，如何将微信帐号和业务身份关联起来呢？这个时候我们需要上图的步骤：小程序调用wx.login()获取临时登录凭证code。小程序将code传到开发者服务器。开发者服务器以code换取用户唯一标识openid和会话密钥session_key。开发者服务器可绑定微信用户身份id和业务用户身份。开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。相关数据或参数上面的登录时序中，我们会涉及到一些数据和参数，先来了解下它们都是用来做啥的。临时登录凭证 code在小程序中调用wx.login()，能拿到一个code作为用户登录凭证（有效期五分钟）。在开发者服务器后台，开发者可使用code换取openid和session_key等信息（code只能使用一次）。code的设计，主要用于防止黑客使用穷举等方式把业务侧个人信息数据全拉走。AppId 与 AppSecret为了确保拿code过来换取身份信息的人就是对应的小程序开发者，到微信服务器的请求要同时带上AppId和AppSecret。session_key会话密钥session_key是对用户数据进行加密签名的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。设计session_key主要是为了节省流程消耗，如果每次都通过小程序前端wx.login()生成微信登录凭证code去微信服务器请求信息，步骤太多会造成整体耗时比较严重。使用接口wx.checkSession()可以校验session_key是否有效。用户越频繁使用小程序，session_key有效期越长。session_key失效时，可以通过重新执行登录流程获取有效的session_key。openidopenid是微信用户id，可以用这个id来区分不同的微信用户。微信针对不同的用户在不同的应用下都有唯一的一个openid, 但是要想确定用户是不是同一个用户，就需要靠unionid来区分。unionid如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性。同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。加锁的登录在某些情况下，我们或许多个地方会同时触发登录逻辑（如多个接口同时拉取，发现登录态过期的情况）。一般来说，我们会简单地给请求加个锁来解决：使用isLogining来标志是否请求中。方法返回 Promise，登录态过期时静默续期后重新发起。使用sessionId来记录业务侧的登录态。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// session 参数 key（后台吐回）export const SESSION_KEY = 'sessionId';let isLogining = false;export function doLogin() {  return new Promise((resolve, reject) => {    const session = wx.getStorageSync(SESSION_KEY);    if (session) {      // 缓存中有 session      resolve();    } else if (isLogining) {      // 正在登录中，请求轮询稍后，避免重复调用登录接口      setTimeout(() => {        doLogin()          .then(res => {            resolve(res);          })          .catch(err => {            reject(err);          });      }, 500);    } else {      isLogining = true;      wx.login({        success: (res) => {          if (res.code) {            const reqData: ILoginRequest = {                code: res.code            }            wx.request({              url: API.login,              data: reqData,              // method: \"POST\",              success: (resp) => {                const data = resp.data;                isLogining = false;                // 保存登录态                if (data.return_code === 0) {                  wx.setStorageSync(SESSION_KEY, data[SESSION_KEY]);                  resolve();                } else {                  reject(data.return_msg);                }              },              fail: err => {                // 登录失败，解除锁，防止死锁                isLogining = false;                reject(err);              }            });          } else {            // 登录失败，解除锁，防止死锁            isLogining = false;            reject();          }        },        fail: (err) => {          // 登录失败，解除锁，防止死锁          isLogining = false;          reject(err);        }      });    }  });}登录态静默续期的实现checkSession前面也提到，微信不会把session_key的有效期告知开发者，因此需要使用接口wx.checkSession()来校验session_key是否有效。这里我们：使用isCheckingSession来标志是否查询中。返回 Promise。使用isSessionFresh来标志session_key是否有效。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import { doLogin } from \"./doLogin\";import { SESSION_KEY } from \"./doLogin\";let isCheckingSession = false;let isSessionFresh = false;export function checkSession(): Promise<string> {  return new Promise((resolve, reject) => {    const session = wx.getStorageSync(SESSION_KEY);    if (isCheckingSession) {      setTimeout(() => {        checkSession()          .then(res => {            resolve(res);          })          .catch(err => {            reject(err);          });      }, 500);    } else if (!isSessionFresh && session) {      isCheckingSession = true;      wx.checkSession({        success: () => {          // session_key 未过期，并且在本生命周期一直有效          isSessionFresh = true;          resolve();        },        fail: () => {          // session_key 已经失效，需要重新执行登录流程          wx.removeStorage({            key: \"skey\",            complete: () => {              doLogin()                .then(() => {                  resolve();                })                .catch(err => {                  reject(err);                });            }          });        },        complete: () => {          isCheckingSession = false;        }      });    } else {      doLogin()        .then(res => {          resolve(res);        })        .catch(err => {          reject(err);        });    }  });}静默续期的接口请求至此，我们可以封装一个简单的接口，来在每次登录态过期的时候自动续期：在请求前，使用checkSession()检车本次周期内session_key是否有效，无效则doLogin()拉起登录获取sessionId。请求接口，若返回特定登录态失效错误码（此处假设为LOGIN_FAIL_CODE），则doLogin()拉起登录获取sessionId。使用tryLoginCount来标志重试次数，TRY_LOGIN_LIMIT来标志重试次数上限，避免进入死循环。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import { doLogin } from \"./doLogin\";import { SESSION_KEY } from \"./doLogin\";import { checkSession } from \"./checkSession\";// 会话过期错误码，需要重新登录export const LOGIN_FAIL_CODES = [10000];const TRY_LOGIN_LIMIT = 3;export function request(obj: any = {}): Promise<object> {  return new Promise((resolve, reject) => {    checkSession()      .then(() => {        let session = wx.getStorageSync(SESSION_KEY);        const { url, data, method, header, dataType } = obj;        let tryLoginCount = obj.tryLoginCount || 0;        // 如果需要通过 data 把登录态 sessionId 带上        const dataWithSession = { ...data, [SESSION_KEY]: session, appid: APPID };        wx.request({          url,          data: dataWithSession,          method,          header,          dataType,          success: (res: any) => {            if (res.statusCode === 200) {              const data: ICommonResponse = res.data;              // 登陆态失效特定错误码判断，且重试次数未达到上限              if (LOGIN_FAIL_CODES.indexOf(data.return_code) > -1 && tryLoginCount < TRY_LOGIN_LIMIT) {                doLogin().then(() => {                  obj.tryLoginCount = ++tryLoginCount;                  request(obj)                    .then(res => {                      resolve(res);                    })                    .catch(err => {                      reject(err);                    });                });              } else {                resolve(res);              }            } else {              reject(res);            }          },          fail: function(err) {            reject(err);          }        });      })      .catch(err => {        reject(err);      });  });}至此，我们大概包装了一个能自动登录或是进行静默续期的一个请求接口。参考小程序登录API《小程序开发指南》结束语小程序的登录和登录态管理，大概是大部分小程序都需要的能力。code和session_key的设计，做了哪些事情来保护用户的数据。如何在全局范围地保证登录态的有效性，微信侧的登录态也好，业务侧的登录态也好，静默续期的能力能给用户带来不少的体验提升。查看Github有更多内容噢：https://github.com/godbasin"}
{"title": "微信小程序获得openid免密登录 ", "author": "Rolan", "pub_time": "2018-12-28 00:38", "content": "{\r\n  wx.login({\r\n    success: res => {\r\n      let d = {\r\n        appid: 'wx111111111111', // 从微信公众平台开发设置中获取\r\n        secret: 'sec2222222222' // 从微信公众平台开发设置中获取\r\n      };\r\n      // 微信官方的获取openid的接口\r\n      var wxLoginUrl = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + d.appid +'&secret=' \r\n      + d.secret + '&js_code=' + res.code + '&grant_type=authorization_code';\r\n      wx.request({\r\n        url: wxLoginUrl,\r\n        data: {},\r\n        method: 'GET',\r\n        success: res => {\r\n           let openid = res.data.openid;\r\n          this.judgeIsWxlogin(openid); // 向后端发送openid判断是否可以直接用该微信号登陆\r\n        }\r\n      });\r\n    }\r\n  });\r\n}从微信公众平台开发设置中获取appid和secret:"}
{"title": "微信小程序电商实战-你所困扰的自定义顶部导航栏都在这里 ", "author": "Rolan", "pub_time": "2018-12-17 00:46", "content": "本文章是一个系列文章，以一个完整的可用于生产的实际项目探索微信小程序开发中我们经常会遇到的问题，希望能提供完美的解决方案，这次是本系列文章的第二篇了，一下列出该系列文章链接。微信小程序及h5，基于taro，zoro最佳实践探索 微信小程序电商实战-解决你的登陆难问题微信自6.6.0版本之后提供了自定义底部导航栏的功能，这使得我们的全屏页面设计成为了可能 首先演示下最终的实现效果我们实现了一个与微信之前的导航栏行为基本一致，样式可自定义的导航栏，接下来让我们一步一步实现它，这里主要需要考虑如下几点不同的手机，状态栏高度不同，需要进行相关适配 当开启小程序下拉刷新时，如何让顶部导航不会跟着下拉 自定义导航栏封装成独立组件，实现仅需引入到页面，无需对页面样式做相关适配工作该项目托管于github，有兴趣的可以直接查看源码，weapp-clover，如何运行项目源码请查看ztaro 要想实现自定义导航，首先我们需要配置navigationStyle为custom(src/app.js)config = {  window: {    navigationStyle: 'custom'  }}再实际情况中，我们往往需要对自定义导航进行各种各样的定制化，因此我们希望，封装一个最基本的导航栏，用于解决适配问题，其他样式的导航栏仅需对其进行二次封装，无需在关心适配问题，对于这个项目，我们封装组件如下： ComponentBaseNavigation 导航栏基本组件，用于解决适配问题 ComponentHomeNavigation 引入基本导航组件，定制化首页导航栏组件 ComponentCommonNavigation 引入基本导航组件，定制化其他页面导航组件ComponentBaseNavigation实现对于适配不通手机顶部的状态栏高度，我们需要利用微信wx.getSystemInfo获取状态栏的高度，因此在user model中新增如下代码(src/models/user.js)// 省略其他无关代码import Taro from '@tarojs/taro'export default {  namespace: 'user',  mixins: ['common'],  state: {    systemInfo: {},  },  async setup({ put }) {    // 新增初始化获取用户手机系统相关信息，存储到redux全局状态中    Taro.getSystemInfo().then(systemInfo =>      put({ type: 'update', payload: { systemInfo } }),    )  }}实现组件逻辑(src/components/base/navigation/navigation.js)import Taro, { Component } from '@tarojs/taro'import { View } from '@tarojs/components'import { connect } from '@tarojs/redux'import './navigation.scss'@connect(({ user }) => ({  // 链接redux中存储的状态栏高度到组件中  statusBarHeight: user.systemInfo.statusBarHeight,}))class ComponentBaseNavigation extends Component {  static defaultProps = {    color: 'white',    backgroundColor: '#2f3333',  }  render() {    const { statusBarHeight, backgroundColor, color } = this.props    const barStyle = {      paddingTop: `${statusBarHeight}px`,      backgroundColor,      color,    }    return (      <View className=\"navigation\">        <View className=\"bar\" style={barStyle}>          {this.props.children}        </View>        <View className=\"placeholder\" style={barStyle} />      </View>    )  }}export default ComponentBaseNavigation样式如下(src/components/base/navigation.scss)// 大写的PX单位是为了告诉Taro，不要转换成单位rpx// 通过测试和观察发现，微信顶部的胶囊宽高如下，并且各个屏幕下一致// 因此采用PX单位$capsule-padding: 6PX; // 胶囊的上下padding距离$capsule-height: 32PX; // 胶囊的高度$capsule-width: 88PX; // 胶囊的宽度$navigation-height: $capsule-padding * 2 + $capsule-height;$navigation-font-size: 15PX;$navigation-icon-font-size: 25PX;$navigation-box-shadow: 0 2PX 2PX #222;.navigation {  position: relative;  background: transparent;  .bar {    position: fixed;    top: 0;    left: 0;    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    width: 100%;    height: $navigation-height;    z-index: 1;    font-size: $navigation-font-size;  }  .placeholder {    display: block;    height: $navigation-height;    background: transparent;  }}要解决我们先前提到的问题当开启小程序下拉刷新时，如何让顶部导航不会跟着下拉，仅仅只需设置.bar样式为position: fixed，这样当我们下拉刷新时导航栏就不会跟着动了，那为什么我们还需要.placeholder标签呢 如果你尝试着去掉它，并且运行查看效果时，你会发现，页面的内容会被顶部导航栏遮挡了，我们需要对每个页面进行额外的设置以使它如预期一样显示，比如给每个页面设置顶部padding，这样的消耗太大，因此我们专门设置placeholder标签占据与导航栏相同的高度，使页面不被遮挡，且无需额外处理ComponentHomeNavigation实现有了这样一个基础组件，我们要实现首页导航栏效果就变得相当的简单了，直接上代码(src/components/home/navigation/navigation.js)import Taro, { Component } from '@tarojs/taro'import { View, Image, Text } from '@tarojs/components'import { noop } from '../../../utils/tools'import ComponentBaseNavigation from '../../base/navigation/navigation'import './navigation.scss'class ComponentHomeNavigation extends Component {  static defaultProps = {    onSearch: noop,  }  render() {    const { onSearch } = this.props    return (      <ComponentBaseNavigation>        <View className=\"navigation\">          <Image className=\"logo\" src=\"@oss/logo.png\" />          <View className=\"search\" onClick={onSearch}>            <View className=\"icon iconfont icon-search\" />            <Text className=\"text\">搜索</Text>          </View>        </View>      </ComponentBaseNavigation>    )  }}export default ComponentHomeNavigation引入导航组件到首页中, 省略样式代码(src/pages/home/home.js)import Taro, { Component } from '@tarojs/taro'import { View } from '@tarojs/components'import { dispatcher } from '@opcjs/zoro'import ComponentCommonLogin from '../../components/common/login/login'import ComponentCommonSlogan from '../../components/common/slogan/slogan'// 引入导航组件import ComponentHomeNavigation from '../../components/home/navigation/navigation'import ComponentHomeCarousel from '../../components/home/carousel/carousel'import ComponentHomeBrand from '../../components/home/brand/brand'import './home.scss'class PageHome extends Component {  config = {    enablePullDownRefresh: true,  }  state = {    // 请到README.md中查看此参数说明    __TAB_PAGE__: true, // eslint-disable-line  }  componentDidMount() {    dispatcher.banner.getBannerInfo()    dispatcher.brand.getHotBrandList()  }  onPullDownRefresh() {    Promise.all([      dispatcher.banner.getBannerInfo(),      dispatcher.brand.getHotBrandList(),    ])      .then(Taro.stopPullDownRefresh)      .catch(Taro.stopPullDownRefresh)  }  handleGoSearch = () => Taro.navigateTo({ url: '/pages/search/search' })  render() {    return (      <View className=\"home\">        <ComponentCommonLogin />        <ComponentHomeNavigation onSearch={this.handleGoSearch} />        <ComponentHomeCarousel />        <View class=\"content\">          <ComponentCommonSlogan />          <ComponentHomeBrand />        </View>      </View>    )  }}export default PageHomeComponentCommonNavigation实现该组件的实现方式与首页基本一致，需要提的一点就是返回键的实现，我们该如何统一的判断该页面是否需要返回键呢，这里需要利用微信接口wx.getCurrentPages()，实现代码如下(src/components/common/navigation/navigation.js)import Taro, { Component } from '@tarojs/taro'import { View } from '@tarojs/components'import classNames from 'classnames'import ComponentBaseNavigation from '../../base/navigation/navigation'import './navigation.scss'class ComponentCommonNavigation extends Component {  static defaultProps = {    title: '',  }  state = {    canBack: false,  }  componentDidMount() {    // 获取当前页面是否需要返回键    const canBack = Taro.getCurrentPages().length > 1    this.setState({ canBack })  }  handleGoHome = () => Taro.switchTab({ url: '/pages/home/home' })  handleGoBack = () => Taro.navigateBack()  render() {    const { title } = this.props    const { canBack } = this.state    return (      <ComponentBaseNavigation>        <View className={classNames('navigation', { padding: !canBack })}>          <View className=\"tools\">            {canBack && (              <View                className=\"iconfont icon-arrow-left back\"                onClick={this.handleGoBack}              />            )}            <View              className=\"iconfont icon-home home\"              onClick={this.handleGoHome}            />          </View>          <View className=\"title\">{title}</View>        </View>      </ComponentBaseNavigation>    )  }}export default ComponentCommonNavigation感谢观看，文笔不佳，不能完全表达出设计思路，代码是最好的表达，移步weapp-clover 本项目会持续完善，如有兴趣，请关注一波作者：FaureWu 链接：https://www.jianshu.com/p/5877a3dc0b1e 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"}
{"title": "微信小程序获得微信头像和昵称 ", "author": "Rolan", "pub_time": "2018-12-29 00:30", "content": "{\r\n  wx.getSetting({\r\n    success: res => {\r\n      if (res.authSetting && res.authSetting['scope.userInfo']) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n        wx.getUserInfo({\r\n          success: function (data) {\r\n            console.log(data.userInfo);\r\n            // {\r\n            //   avatarUrl: '微信头像img文件path'\r\n            //   nickname: '微信昵称'\r\n            // }\r\n          }\r\n        });\r\n      } else {\r\n        this.showShouquan = true; // 打开模态框进行授权\r\n      }\r\n    }\r\n  });\r\n}\r\n<template>\r\n    <div>\r\n        <!-- 这里采用vantui进行弹框，只不过把弹出框的button类型设置成了\"getUserInfo\"，原理就是下面这个button\r\n        <button wx:if=\"{{showShouquan}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfoFromWx\">授权登录</button> -->\r\n        <van-dialog use-slot async-close :show=\"showShouquan\" show-cancel-button confirm-button-open-type=\"getUserInfo\"\r\n            @close=\"cancelShouquan\" @getuserinfo=\"getUserInfoFromWx\">\r\n            <h4 class=\"wx-shouquan-title\">微信授权</h4>\r\n            <p class=\"wx-shouquan-content\">\r\n                xxxxxxx小程序将获得您的微信头像、昵称等公开消息\r\n            </p>\r\n        </van-dialog>\r\n        <div>\r\n</template>    getUserInfoFromWx (e) {\r\n      this.$store.state.user_userinfo = e.mp.detail.userInfo;\r\n      this.showShouquan = false;\r\n    },\r\n    cancelShouquan () {\r\n      this.showShouquan = false;\r\n    },"}
{"title": "使用uni-app快速Vue项目输出到小程序和H5 ", "author": "Rolan", "pub_time": "2018-12-28 00:32", "content": "跨端彻底，直接发行，无需二次开发；通过Tree-Shaking摇出最小化内置组件等优化策略，提升性能这应该是uni-app在H5平台的相对其他小程序框架更友好的地方背景随着微信小程序的火爆及百度、头条小程序的持续推进，跨端开发的需求愈发迫切，业界随之出现了一系列的跨端框架，但对于H5平台跨端支持的都不太彻底：Vue技术栈的小程序框架：对于H5平台支持普遍较弱部分React技术栈的小程序框架：虽支持生成可在H5端运行的代码，但仅仅是代码可运行，离项目直接发行上线的目标还存在一定差距。鉴于客观需求及现状，DCloud前端团队响应开发者彻底跨端的呼声，经过连续奋战，uni-app1.2版本支持发行到H5平台，完整模拟小程序生命周期、事件处理、组件规范等，真正实现“一套代码、多端发行”的目标。https://uniapp.dcloud.io/h5/ (二维码自动识别)本文主要分享，我们在实现uni-app发行到H5平台时，在引擎实现、差异抹平、性能优化方面都做了哪些工作。完整模拟小程序引擎uni-app设计的开发标准是：Vue.js的语法 + 小程序的API + 条件编译扩展平台个性化能力。其中：Vue.js 的语法在微信小程序端，uni-app是在mpvue的基础上增强实现的，在H5端则默认支持；而小程序的API，其实包括三个部分：框架 + 组件（UI）+ 接口（API），这三部分在微信小程序端是内置支持的，而uni-app若要发布到H5平台，则需完整模拟实现小程序运行时环境。如下是一个简易的小程序运行时框架，核心是一个响应的数据绑定系统。为实现小程序、H5两端的完整跨端，uni-app在H5平台完整模拟实现了小程序的逻辑层和视图层，相比业界其它跨端框架，uni-app在H5平台有如下几点实现更完善。页面配置小程序中的导航条、选项卡是通过配置文件生成的，配置后由原生组件进行渲染，uni-app在H5平台同样兼容这些配置，不过会降级通过div控件模拟实现，因此开发者无需单独为H5平台添加导航条或选项卡。生命周期uni-app在H5平台实现了完整的小程序生命周期，为此填了很多坑。举一个详情页互跳的栗子：详情A 打开 详情B，在通常的 web 端 SPA 方案中，会在详情A页面获取B详情的数据，仅会触发详情页A的updated生命周期，不会触发onHide；但在小程序中，则会打开一个新的webview并加载详情B，此时会触发详情A的onHide生命周期，也会触发详情B的onShow生命周期；uni-app完整模拟了小程序的生命周期，详情页之间互相切换时，会触发onHide、onShow等生命周期；这样的实现，即保证了两端兼容性，同时在详情B返回详情A时，详情A已被缓存，无需再次联网加载，也会有更高的性能。事件处理uni-app对于页面事件处理函数支持更为全面，下拉刷新、上拉触底等常用函数均可在H5平台正常复用，无需二次开发。组件规范uni-appH5平台的组件实现，有两个特点：兼容的组件数量更多：比如navigator等组件在H5平台可正常跳转组件属性、嵌套实现更接近小程序实现抹平引擎差异fixed元素遮挡微信小程序是一种 native + web 混合渲染的机制，比如小程序的导航条（navigationBar）、选项卡（tabBar）为原生组件，但H5平台为纯 web 渲染，导航条、选项卡均为 web 实现，这可能引发页面 fixed 元素 和导航条/选项卡位置发生互相遮挡的问题，如下一段 fixed 定位的代码：.fixed{\r\n    position: fixed;\r\n    z-index: 9999;\r\n    bottom: 0px;//底部距离为0\r\n    background-color:peru;\r\n}\r\n在不同平台上运行效果不同，如下图所示：uni-app通过引入css变量解决这类问题，在编译到不同平台时，给css变量设置对应的值。有了css变量，开发者若需处理 fixed 定位的元素，只需像如下方式编写即可：.fixed{\r\n    bottom:var(--window-bottom)\r\n}\r\ncss作用域uni-app在开发时遵循 Vue 单文件组件 (SFC) 规范，编译到微信小程序时会生成对应的 wxml 文件，最终运行时由 webview 渲染，iOS 平台由 WKWebView 渲染，Android 平台由 XWeb 引擎基于 Mobile Chrome 53 内核渲染；uni-app中的不同.vue页面文件( 编译后的.wxml 文件)，在小程序端会由不同的 webview 渲染，故 .vue页面文件中的 css 作用域是天然隔离的，开发者无需在<style> 标签上增加scoped 属性。但H5平台是一套SPA框架，无scoped就会变成全局样式，影响其他页面。uni-app在H5平台做了智能处理，自动增加了scoped。平台性能优化性能一直是 web app 首要关注的焦点，uni-app发行到H5平台时也做了很多性能优化。内置组件按需打包（Tree-Shaking）uni-app有8大类、几十个内置组件，但开发者实际开发时仅会使用其中的一部分组件，比如很多App不会用到map、canvas等组件，若打包时将uni-app整个组件类库都打包进去，则会造成极大的资源浪费，延迟首页渲染速度。uni-app发行到H5平台时采用了摇树优化（Tree-Shaking）策略，将开发者项目中没用到的组件从整个框架中“摇”掉，保证编译后的 JS 文件最小化。具体来说，uni-app编译到H5平台时分为预编译、再编译两个阶段，预编译阶段通过vue-template-compiler分析出来的AST，映射生成项目中使用到的组件清单，然后再基于Webpack插件将使用到的组件编译生成一个最小化的uni-app框架文件。我们以uni-app的两个开源项目模板登录模板、看图模板为例，测试 Tree-Shaking 前后组件框架的大小，效果喜人，数据如下：路由组件按需加载（Lazy-Loading）当打包构建 SPA 应用时，Javascript 包会变得非常大，影响页面加载。虽然开发者基于Vue 的异步组件和 Webpack 的code-splitting 功能，可以实现路由组件的懒加载，但开发者需调整.vue源码及Webpack配置，有一定的学习门槛，且比较繁琐。uni-app在H5平台实现了自动按需加载路由组件，开发者无需调整组件开发方式，仅需关心业务实现即可。其它方面uni-app为提升性能体验，在很多细节上都有特殊设计。比如常见的 SPA 框架一般采用div区域滚动，uni-app为改善用户体验，使用的是body滚动，由此填了很多坑，比如不同页面的background-color，若使用div滚动，则在编译阶段就可完成样式定义，但基于body滚动，就需要在页面前进、后退时动态设置body的背景色。githubuni-app在H5平台的相关代码均已全部开源，详见uni-app，欢迎大家 star 支持."}
{"title": "用微信小程序云开发做一个错误日志 ", "author": "Rolan", "pub_time": "2018-12-28 00:43", "content": "为什么要用云开发做错误日志：我司没有测试，所以产品上线的话比较多不确定性云开发业务并不稳定，且有限制，所以不建议直接用做整个小程序的后台开发。做错误日志并不会影响小程序的流程出bug后，难定位问题，尤其是线上错误如果叫后端小伙伴给接口记录错误，总是不方便，还是自己动手丰衣足食尝鲜基于以上的原因，在小程序云开发刚出来没多久，我就开始着手在我的小程序上尝试构建一个错误日志:一般用一门新技术的第一步，你需要先浏览一下小程序云开发的官方文档：https://developers.weixin.qq....初始化环境然后你需要一个小程序，一个小程序开发工具：新建一个空白的小程序后，点击左上角的云开发按钮，初始化一个云开发的环境我这里给它取名叫error-storage。当然我是因为之后我的小程序也不太可能会用到云开发做后台，所以可以浪费一个环境命名。如果你是要用云开发做后台业务的话。那么还是按照微信推荐，一个做测试一个做正式，命名也尽量规范一点。然后它的环境限制也是我们目前不拿它当主要后端脚本的主要原因之一。ok，点击确定就创建了一个云开发后台了。然后我们回到代码。我们需要写后端脚本记录错误信息，那么根据云开发的文档，我们需要修改project.config.json给他配置一下小程序代码放在哪里，后端代码放在哪里。以下是我的配置:我把小程序文件都放在了根目录下的client文件夹内，而云函数的文件则都放在了根目录的server文件夹的cloudFunctions里那么现在我们的目录结构是这样的。我们需要手动移动一下我们的小程序代码。注意这里project.config.json是在根目录现在先添加一个数据库集合，打开云开发控制台，点击数据库。添加一个叫errors的集合编写接收错误的云函数然后我们先开始写接收错误的云函数用微信开发工具打开代码，然后点击目录树上面的cloudFunctiions目录，新建一个云函数，我们将它取名叫做errorHandler然后写上我们的代码逻辑// 云函数入口文件\r\nconst cloud = require('wx-server-sdk');\r\n\r\ncloud.init();\r\n\r\nconst db = cloud.database();\r\nconst errorCllection = db.collection('errors');\r\n\r\nfunction addError(data) {\r\n  return errorCllection.add({\r\n    data: {\r\n      ...data,\r\n      createTime: Date.now()\r\n    }\r\n  });\r\n}\r\n\r\n// 云函数入口函数\r\nexports.main = async event => {\r\n  event.openid = event.userInfo.openId;\r\n  delete event.userInfo;\r\n  await addError(event);\r\n  return true;\r\n};\r\n这面这段代码很简单就是将小程序端传过来的错误写进数据库里面，错误信息是什么由小程序端决定，它仅仅只是将所有数据丢进数据库去而已保存字后再次右键cloudFunctions选择上传并部署。那么我们的服务端就基本搞定了。（好简单啊）写小程序端的错误处理函数首先，根据教程，我们要在app.js里面做云能力初始化在app.js的第一行添加代码try {\r\n  wx.cloud.init({ // 云开发初始化\r\n    env: '云环境id',\r\n    traceUser: true\r\n  });\r\n} catch(err) {}给它加上catch是因为防止出现一些错误导致app.js运行失败，那简直是灾难吧！这里的env是你的云环境id，那么在哪里拿呢，在这里然后我们在client/utils文件夹里面添加一个处理错误的模块吧名字就叫 error.jsconst { config } = require('./config.js');\r\n\r\nglobal.onError = function (message, showModal = true) {\r\n  return function (error) {\r\n    wx.hideLoading();\r\n    if (showModal) {\r\n      wx.showModal({\r\n        title: '错误',\r\n        content: error.msg || message,\r\n        // 这里的error.msg是因为与后端约定如果有什么错误，则带一个msg的描述\r\n        // 而message则是传入进来备用的错误信息\r\n        confirmText: '返回首页',\r\n        cancelText: '继续操作',\r\n        success: res => {\r\n          if (res.confirm) {\r\n            // 重新加载首页\r\n            wx.switchTab({\r\n              url: '/pages/index/index'\r\n            });\r\n          } else {\r\n            // 取消就不管了\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // 上传到小程序云数据库\r\n    try {\r\n      let userInfo = getApp().globalData.userInfo,\r\n        systemInfo = wx.getSystemInfoSync(),\r\n        page = getCurrentPages();\r\n      // 只有不在开发工具上触发的才上报\r\n      if (systemInfo.platform !== 'devtools') {\r\n        wx.getNetworkType({\r\n          success: res => {\r\n            wx.cloud.callFunction({\r\n              name: 'errorHandler',\r\n              data: {\r\n                username: userInfo.nickName,\r\n                uid: userInfo.id,\r\n                clientType: systemInfo.model,\r\n                systemInfo: JSON.stringify(systemInfo),\r\n                pageRoute: page[page.length - 1].route,\r\n                message: error.msg || message,\r\n                version: config.version,\r\n                networkType: res.networkType,\r\n                errorTime: new Date(),\r\n                error: typeof error === 'object' ? JSON.stringify(error) : String(error)\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n    } catch(err) {}\r\n    console.error('程序发生错误:\\n', '时间:\\n', new Date(), '\\n错误信息:\\n', message, '\\nvvvvvvvvvvvvvv\\n', error);\r\n  };\r\n};\r\n如上，除了错误信息之外，还储存了系统信息，网络类型，最顶部的页面路由，错误时间，用户信息，版本号等(这里我加了个config.js用以储存版本号，版本描述等信息)用try catch包起来也是为了防止触发错误导致死循环并且为了方便使用，我将其直接挂载到global。不喜欢全局变量的童鞋可以选择export出去再引用并且在触发错误的时候弹出一个提示框提示错误了。错误处理函数的使用那么接下来就是对这个方法的使用了，首先我们要监听app.js的onError方法，小程序页面逻辑出现错误都会到这个方法内request('./utils/error.js'); // 别忘了引入error.js\r\nApp({\r\n    onError: global.onError('程序发生错误') // 这里返回接受错误的函数的闭包，并且传入的'程序发生错误'则是未知错误发生时的提示语\r\n});\r\n而其他的应用基本是应用到在promise的错误监听上，由于promise中的错误不会被app.js的onError接收到，所以我们需要在每个promise的catch中使用global.onError这也是我为什么将onError挂载global的原因，因为基本每个页面都会用到，所以每个页面去引用的话很麻烦例子:demo.jsPage({\r\n    onLoad() {\r\n        wx.showLoading();\r\n        this.requestList()\r\n            .then(res => {\r\n                // 做一些事情\r\n            })\r\n            .catch(global.onError('获取列表数据失败!'));\r\n    },\r\n    requestList() {\r\n        return new Promise((resolve, reject) => {\r\n            wx.request({\r\n                url: 'https://mock.com/aaa',\r\n                success: resolve,\r\n                fail: reject\r\n            });\r\n        });\r\n    }\r\n});那么，到现在，基本上已经完成了，愉快的开发，再也不担心出现完全没有头绪的错误啦最后贴一张我收集到的错误吧。但是有些字段我做了调整最后还是要吐槽一下微信本身它自己的bug有点多。实在是很无奈的"}
{"title": "微信小程序踩坑指南 ", "author": "Rolan", "pub_time": "2018-12-29 00:25", "content": "最近因为公司业务一直在做微信小程序的项目，趁此机会将最近踩过的一些坑总结记录下。\r\n微信小程序登陆相关\r\n\r\n\r\n前端调用wx.login()，获取临时登录凭证 code\r\n通过wx.request()将code发给服务器（需要后端创建接口接收code）\r\n后端进行登录凭证校验，入参为(appid,secret,js_code,grant_type)\r\n\r\n\r\n\r\nappid\t\t  小程序唯一标识\r\nsecret\t\t 小程序的 app secret\r\njs_code\t\t 登录时获取的 code\r\ngrant_type\t填写为 authorization_code\r\n\r\n\r\n\r\n登陆凭证校验通过,从微信服务器换取openid和session_key\r\n\r\n\r\nopenid\t用户唯一标识\r\nsession_key\t会话密钥\r\n\r\nopenid 是用户唯一标识，但不建议直接用做后端服务器的各用户标示符。\r\nsession_key 是针对用户数据进行加密签名的密匙。session_key 在文件校验，获取用户具体信息时均需使用\r\n一般为了安全起见，这两个数据都不会发往客户端。\r\n\r\n\r\n\r\n后端将session_key处理之后，返回前端一个处理后的一个字符串作为用户的登陆标识，一般以token的形式。（自定义登陆态与openid session_key相关）\r\n前端接收到token,储存到localStorage中，每次向服务器请求数据的时候带上，作为服务器识别用户的凭证。\r\n后续用户进入小程序时，首先调用 wx.checkSession() 检测登陆态，如果失败，重新发起登陆流程。\r\n\r\n//app.js\r\nconst NOLOGINCODE = 1000003  //未登录\r\nconst SUCCESS = 1000001 //成功\r\nApp({\r\n  onLaunch: function () {\r\n    var loginFlag = wx.getStorageSync('sessionId');\r\n    var that = this;\r\n    if (loginFlag) {\r\n      // 检查 session_key 是否过期\r\n      wx.checkSession({\r\n        // session_key 有效(未过期)\r\n        success: function () {\r\n          var userInfo = wx.getStorageSync('wxUserInfo')\r\n          if (userInfo) {\r\n            that.globalData.hasUserInfo = true\r\n          }\r\n        },\r\n        // session_key 过期\r\n        fail: function () {\r\n          // session_key过期，重新登录\r\n          that.doLogin();\r\n        }\r\n      });\r\n    } else {\r\n      // 无skey，作为首次登录\r\n      this.doLogin();\r\n    }\r\n  },\r\n  doLogin() {\r\n    this.log().then(res => {\r\n      this.$post('/auth', { code: res.code, }, false).then(data => {\r\n        wx.setStorageSync('sessionId', data.sessionId);\r\n      })\r\n    })\r\n  },\r\n  /**\r\n   *微信登录 获取code值,并将code传递给服务器\r\n   * @returns\r\n   */\r\n  log() {\r\n    return new Promise(resolve => {\r\n      wx.login({\r\n        success(res) {\r\n          if (res.errMsg === \"login:ok\") {\r\n            resolve(res)\r\n          } else {\r\n            wx.showToast({\r\n              title: '微信登录失败',\r\n              icon: 'none',\r\n              duration: 1200\r\n            })\r\n          }\r\n        },\r\n        fail() {\r\n          wx.showToast({\r\n            title: '微信登录接口调用失败',\r\n            icon: 'none',\r\n            duration: 1200\r\n          })\r\n        }\r\n      })\r\n    })\r\n  },\r\n  globalData: {\r\n    baseurl: 'https://www.fake.shop'\r\n  }\r\n})\r\n复制代码网络请求封装\r\n\r\n微信小程序中网络请求的api是wx.request(),但是这个请求是个异步回调的形式，每次发请求都要写好长一串，而且如果是嵌套的发请求，就会发现代码写的及其臃肿，所以将其 Promisefy是及其有必要的。\r\n代码如下：\r\n $get(url, data = {}, needToken = true) {\r\n    let SUCCESS = 200\r\n    var that = this\r\n    needToken ? (data.token = wx.getStorageSync('ToKen')) : ''\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: that.globalData.baseurl + url,\r\n        method: \"GET\",\r\n        header: {\r\n          'content-type': 'application/json'\r\n        },\r\n        data: data,\r\n        success(e) {\r\n          if (e.data.code == SUCCESS) {\r\n            resolve(e.data)\r\n            return\r\n          }\r\n\r\n        },\r\n        fail(e) {\r\n          wx.showModal({\r\n            title: '提示',\r\n            content: '请求失败',\r\n            showCancel: false\r\n          })\r\n          reject(e)\r\n        }\r\n      })\r\n    })\r\n  },\r\n  $post(url, data = {}, needToken = true) {\r\n    let that = this\r\n    let SUCCESS = 200\r\n    let TimeOut = 1000\r\n    var that = this\r\n    needToken ? (data.token = wx.getStorageSync('ToKen')) : ''\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: that.globalData.baseurl + url,\r\n        method: \"POST\",\r\n        //此处可以根据接口文档设置header头\r\n        // header: { \r\n        //   'content-type': 'application/x-www-form-urlencoded'\r\n        // },\r\n        data: data,\r\n        success(e) {\r\n          if (e.statusCode == SUCCESS) {\r\n            if (e.data.code == SUCCESS) {\r\n              resolve(e.data)\r\n            }\r\n            else {\r\n              reject(e)\r\n              wx.showModal({\r\n                title: '提示',\r\n                content: e.data.msg,\r\n                showCancel: false,\r\n                success: function (res) {\r\n                  if (res.confirm) {\r\n                    if (e.data.code == TimeOut) { //根据实际业务返回的code码判断是否过期\r\n                      // 登录过期\r\n                      that.doLogin();\r\n                    }\r\n                  }\r\n                }\r\n              })\r\n            }\r\n          } else {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: e.data.error,\r\n              showCancel: false\r\n            })\r\n            reject(e)\r\n          }\r\n        },\r\n        fail(e) {\r\n          console.log(e)\r\n          wx.showModal({\r\n            title: '提示',\r\n            content: '请求失败',\r\n            showCancel: false\r\n          })\r\n          reject(e)\r\n        },\r\n        complete(e) {\r\n        }\r\n      })\r\n\r\n    })\r\n  },\r\n复制代码微信公共号支付（微信浏览器）\r\n\r\n虽然是写小程序踩坑指南，但是在微信内的H5页面支付和小程序内掉起支付还是有相似之处的，顺便记录一下。\r\n应用场景\r\n\r\n已有 H5 商城网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程。\r\n\r\n准备\r\n\r\n\r\nUnionID:为了识别用户，每个用户针对每个公众号会产生一个安全的 OpenID，如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的 OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个 UnionID\r\n网页授权: 一些复杂的业务场景下，需要以网页的形式提供服务，通过网页授权可以获取用户的openid（注：获取用户的 OpenID 是无需用户同意的，获取用户的基本信息则需用户同意）\r\n微信 JS-SDK：是开发者在网页上通过 JavaScript 代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。\r\n\r\n\r\n业务流程时序图\r\n\r\n主要流程\r\n\r\n网页内引入jssdk,主要有两种\r\n\r\n在需要调用 JS 接口的页面引入如下 JS 文件：res.wx.qq.com/open/js/jwe…      JSSDK 使用步骤\r\n模块引入： 直接引入npm包weixin-js-sdk\r\n\r\n\r\nnpm install weixin-js-sdk ;\r\n\r\n\r\n\r\n\r\nvar wx = require('weixin-js-sdk');\r\n\r\n\r\n\r\n\r\n网页授权\r\n\r\n我的理解就是网页授权主要是为了使在微信浏览器里面打开的第三方网页，可以跟微信公共号以及用户的微信相关联的操作，最终获取用户在该公共号下的openid.\r\n网站应用微信登录是基于 OAuth2.0 协议标准构建的微信 OAuth2.0 授权登录系统。获取 openid 分为两步\r\n\r\n前端通过跳转网址获取 code，然后将code发送给后端\r\n后端然后根据 code 获取 openid。\r\n\r\n\r\n\r\n\r\n\r\ncode的获取\r\n\r\n在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的 “开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息” 的配置选项中，修改授权回调域名。本例中回调域名为www.foo.com\r\n业务流程 举例： 支付页面地址： payUrl => \"www.foo.com/pay\"\r\n\r\n要跳转到支付页面时，如果是微信浏览器直接跳转href(办法有很多可以重定向也可以location.href)到 \"open.weixin.qq.com/connect/oau…\"+ appid +\"&redirect_uri=\"+ URLEncoder.encode(payUrl) +\"&response_type=code&scope=snsapi_base&state=123#wechat_redirect\"\r\n系统会自动跳转到 payUrl 并且返回一个参数 code 例如=> \"www.aa.com/pay?code=aa…\"\r\n然后读取下code发送后端就ok了，这个大家应该都会吧。\r\n注：\r\n\r\n\r\n\r\n\r\nURLEncoder.encode(payUrl)是非常有必要的\r\nstate参数：\t用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止 csrf 攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加 session 进行校验\r\n后端获取openid的原因： 因为我是前端，不想搞这个（开玩笑的"}
{"title": "你的年目标实现了吗，记一次开发微信小程序 ", "author": "Rolan", "pub_time": "2019-1-2 00:12", "content": "前言：这是笔者第一次开发小程序，此前一直有打算自己做一个，并且能够上线使用，但一直找不到灵感，加上还需要服务器端、数据库等技能，所有一直没能实现。后来偶然看到微信小程序云开发(有点惊艳了，确实挺简便)，再加上一点点想法，于是就开始了小程序云开发之旅。第一步，要做什么东西？鉴于自己的技术水平(捂脸)，还有看到年末很多人都在分享年目标，于是便决定好做一个年目标备忘录，简单方便，且有一些意义。第二步，思考小程序的结构实际开发中，往往需要产品相关的思维导图、原型图等来指导开发，即使做一个小项目，我认为也需要一个良好的构思，以下是小程序的思维导图：第三步，开发阶段以下列举主要页面首页首页实现的功能：通过云函数获取当前用户的openid，并查询用户的今年目标；查询链接附带的id，获取其他用户分享后的目标内容；部分代码如下：// 调用云函数\r\n wx.cloud.callFunction({\r\n  name: 'login',\r\n  data: {},\r\n  success: res => {\r\n    console.log('[云函数] [login] user openid: ', res.result.openid)\r\n    app.globalData.openid = res.result.openid;\r\n    if(!id){\r\n      this.getData();\r\n    }\r\n  },\r\n  fail: err => {\r\n    console.error('[云函数] [login] 调用失败', err)\r\n  }\r\n})\r\n //查询数据库\r\n const db = wx.cloud.database();\r\n db.collection(\"targets\").where({\r\n  _openid: app.globalData.openid,\r\n  date: new Date().getFullYear()\r\n}).get({\r\n  success: res => {\r\n    let data = res.data[0] || {};\r\n\r\n    this.setData({\r\n      id: data._id || '',\r\n      title: data.title || '',\r\n      content: data.content || '',\r\n      flag: false\r\n    })\r\n  }, fail: err => {\r\n    console.log(err)\r\n    this.setData({\r\n      flag: false\r\n    })\r\n  }\r\n})\r\n复制代码列表页列表实现的功能：展示所有该用户添加的目标；左滑可删除，并且增加目标详情、编辑、添加入口；部分代码如下：//获取所有目标\r\nconst db = wx.cloud.database();\r\ndb.collection(\"targets\").where({\r\n  _openid: app.globalData.openid\r\n}).get({\r\n  success: res => {\r\n    this.setData({\r\n      flag: true,\r\n      targetList: res.data, height: height\r\n    })\r\n    app.globalData.targetList = res.data;\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      icon: \"none\",\r\n      title: '查询记录失败',\r\n    })\r\n  }\r\n})\r\n//响应删除\r\nlet id = e.currentTarget.id;\r\nconst db = wx.cloud.database();\r\n\r\ndb.collection(\"targets\").doc(id).remove({\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '删除成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '删除失败',\r\n    })\r\n  }\r\n})\r\n复制代码添加目标添加目标实现的功能：通过picker组件让用户选取年份；可添加/编辑年目标标题、内容；部分代码如下：//新增数据\r\ndb.collection(\"targets\").add({\r\n  data: data,\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '新增成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '新增失败',\r\n      icon: 'none'\r\n    })\r\n  }\r\n})\r\n//编辑数据\r\ndb.collection(\"targets\").doc(data.id).update({\r\n  data: data,\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '修改成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '修改失败',\r\n    })\r\n  }\r\n})\r\n复制代码第四步，最终结果小程序从开发到发布成功，只花了一周时间，不得不赞扬云开发给开发者带来的便利，并且还是免费的，为了表达出开发的顺畅，我特意百度了一张图来体现希望没有想歪哈，这是一张纯粹的过山车图(>▽<)因时间、技术或者环境限制，一些还没有解决的问题：分享到朋友圈功能还没有实现，后续将实现保存当前页为图片，让用户手动分享;使用了textarea标签给用户添加数据，有些简陋，希望小程序尽快出富文本编辑器;虽然工作中经常接触设计图，但对ui设计还是有些无感，以后尽量弥补设计上的不足;小程序云开发数据响应有一些缓慢，据称云开发目前只部署在上海，期待后续优化;最后附上小程序码，微信扫码即可体验(或搜索我的年目标)。另外，祝愿大家都能开发出自己的小程序，并且在新的一年实现自己的人生目标^_^该小程序的github地址： 我的年目标参考文档/文章：微信小程序云开发文档微信小程序开发平台新功能「云开发」快速上手体验微信小程序实现左滑删除-一切没有那么简单微信小程序之云开发——模拟后台增删改查"}
{"title": "微信小程序商品筛选，侧方弹出动画选择页面 ", "author": "Rolan", "pub_time": "2018-12-29 00:32", "content": "微信小程序商品筛选，侧方弹出动画选择页面，在一点点的零碎的时间里面写出来的代码，和前两篇效果结合出来的。点击按钮的同时，要实现这两个功能的叠加。 小程序动画animation向左移动效果：https://www.jianshu.com/p/1cdf36070205 小程序点击按钮出现和隐藏遮罩层：https://www.jianshu.com/p/1193bf63a87d效果是这样的:demo是这样的：wxml<view class=\"\">  <view class=\"animation-button\" bindtap=\"translate\">筛选</view>  <view class=\"float {{isRuleTrue?'isRuleShow':'isRuleHide'}} \">    <view class=\"animation-element\" animation=\"{{animation}}\">      <view class='use'>        <view class='iconuse'>用途</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <!-- 价格 -->      <view class='use'>        <view class='iconprice'>价格</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <view class='buttom'>      <view class=\"animation-reset\" >重置</view>      <view class=\"animation-button\" bindtap=\"success\">完成</view>      </view>    </view>  </view></view>wxss.isRuleShow {  display: block;}.isRuleHide {  display: none;}.float {  height: 100%;  width: 100%;  position: fixed;  background-color: rgba(0, 0, 0, 0.5);  z-index: 2;  top: 0;  left: 0;  /* margin-top:80rpx; */}.iconuse {  margin-left: 11rpx;}.iconprice {  margin-left: 11rpx;}.animation-element {  width: 580rpx;  height: 1175rpx;   background-color: #ffffff;   border: 1px solid #f3f0f0;  position: absolute;  right: -572rpx;}.useage {  height: 40rpx;}.useage li {  width: 177rpx;  margin: 12rpx 7rpx;  height: 70rpx;  line-height: 70rpx;  display: inline-block;  text-align: center;  border: 1px solid #f3f0f0;  border-radius: 15rpx;  font-size: 30rpx;}.buttom{  position: fixed;  bottom: 0;}.animation-reset{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}.animation-button{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}jsPage({  onReady: function () {    this.animation = wx.createAnimation()  },  translate: function () {    this.setData({      isRuleTrue: true    })    this.animation.translate(-245, 0).step()    this.setData({ animation: this.animation.export() })  },  success: function () {    this.setData({      isRuleTrue: false    })    this.animation.translate(0, 0).step()    this.setData({ animation: this.animation.export() })  },  tryDriver: function () {    this.setData({      background: \"#89dcf8\"    })  }})ok完成了，今天再说一点，有人问我关于技术博客日更的事情，一来是参加了简书的日更活动，不想断开，二来是一路走来，能看见自己每天学习到的知识点和解决的问题，所以才会感到很充实，不会觉得自己每天在空空度日。如果你也想坚持一件事情，可以私聊我，我们相互监督，互相帮助，让自己变得更好。原文作者：祈澈姑娘 技术博客：https://www.jianshu.com/u/05f416aefbe1 90后前端妹子，爱编程，爱运营，爱折腾。 坚持总结工作中遇到的技术问题，坚持记录工作中所所思所见，对于博客上面有不会的问题，可以加入qq群聊来问我：473819131。"}
{"title": "个税计算器 / 微信小程序开发 ", "author": "Rolan", "pub_time": "2019-1-2 00:36", "content": "019年1月1日即将到来，码农们除了关心自己的技能之外，还有薪资是不是可以多拿点。 每次算的时候 都要百度一下个人所得税，但是很多都是老的税率计算，找一个新的出来还是比较麻烦，所以个人开发了一个最新税率的小程序。解决和我有着一样痛苦的码农们的问题。根据最新税改后计算个人所得税的计算器。目前支持南京，后续开放 杭州 上海 北京等城市。 如果有疑问的可以加最下方 开发者微信。首先在微信官网下载微信小程序开发工具 https://mp.weixin.qq.com在https://mp.weixin.qq.com 注册小程序账号，完成个人实名认证。在小程序后台拿到appid，下面就可以开发了。实例查看二维码：先使用weui 小程序ui框架就行页面布局<button block type=\"dark\" bindtap='calculationBindtap'>计算</button>其次写JS代码（计算按钮逻辑代码）import data from './data'\r\n\r\nconst app = getApp;\r\n\r\nPage({\r\n    data: {\r\n        options1: data,\r\n        value: '1',\r\n        checked: true,\r\n        standard: 1,\r\n        marking: 5000,\r\n        beforetaxCount: 0,\r\n        specialitemCount: 0\r\n    },\r\n    \r\n\r\n    calculationBindtap:function(){\r\n        // 开始计算  计算完成把计算结果放在result对象中\r\n        var beforetaxCount = this.data.beforetaxCount;\r\n        var specialitemCount = this.data.specialitemCount;\r\n        var marking = this.data.marking;\r\n        if (beforetaxCount == null || beforetaxCount == 0 || beforetaxCount == ''){\r\n            wx.showToast({\r\n                title: '输入正确薪资',\r\n                mask: true,\r\n                icon: 'loading'\r\n            })\r\n            return;\r\n        }\r\n        if (specialitemCount == null || specialitemCount == ''){\r\n            specialitemCount = 0;\r\n        }\r\n        // 开始计算\r\n\r\n        var oldNum = 0.08;\r\n        var medNum = 0.02;\r\n        var unemNum = 0.005;\r\n        var workNum = 0;\r\n        var giveNum = 0;\r\n\r\n        var providentfundNum = 0.08;\r\n\r\n        var insuranceBase = 19935;\r\n        var providentfundBase = 25300;\r\n\r\n        var oldcount = 0;\r\n        var medcount = 0;\r\n        var unemcount = 0;\r\n        var workcount = 0;\r\n        var givecount = 0;\r\n\r\n        var providentfundcount = 0;\r\n\r\n        var privateFee = 0;\r\n        var plusFee = 0;\r\n\r\n        if(this.data.checked){\r\n            if (parseFloat(beforetaxCount) > parseFloat(insuranceBase)) {\r\n                oldcount = parseFloat(insuranceBase) * parseFloat(oldNum);\r\n                medcount = parseFloat(insuranceBase) * parseFloat(medNum);\r\n                unemcount = parseFloat(insuranceBase) * parseFloat(unemNum);\r\n                workcount = parseFloat(insuranceBase) * parseFloat(workNum);\r\n                givecount = parseFloat(insuranceBase) * parseFloat(giveNum);\r\n            } else {\r\n                oldcount = parseFloat(beforetaxCount) * parseFloat(oldNum);\r\n                medcount = parseFloat(beforetaxCount) * parseFloat(medNum);\r\n                unemcount = parseFloat(beforetaxCount) * parseFloat(unemNum);\r\n                workcount = parseFloat(beforetaxCount) * parseFloat(workNum);\r\n                givecount = parseFloat(beforetaxCount) * parseFloat(giveNum);\r\n            }\r\n\r\n            if (parseFloat(beforetaxCount) > parseFloat(providentfundBase)) {\r\n                providentfundcount = parseFloat(providentfundBase) * parseFloat(providentfundNum);\r\n            } else {\r\n                providentfundcount = parseFloat(beforetaxCount) * parseFloat(providentfundNum);\r\n            }\r\n        }\r\n\r\n        // 保险总费用\r\n        var totalInsuranceFee = parseFloat(oldcount) + parseFloat(medcount) + parseFloat(unemcount) + parseFloat(workcount) + parseFloat(givecount);\r\n        // 公积金费用 \r\n        var totalProvidentfundFee = providentfundcount;\r\n\r\n        // 下面的钱 交税\r\n        console.log(this.data.marking);\r\n        var otherFee = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(this.data.marking) - parseFloat(specialitemCount);\r\n        \r\n        if (parseFloat(otherFee) <= 3000 && parseFloat(otherFee) > 0) {\r\n            privateFee = parseFloat(otherFee) * 0.03;\r\n            plusFee = 0;\r\n        }\r\n        if (parseFloat(otherFee) <= 12000 && parseFloat(otherFee) > 3000) {\r\n            privateFee = parseFloat(otherFee) * 0.1;\r\n            plusFee = 210;\r\n        }\r\n        if (parseFloat(otherFee) <= 25000 && parseFloat(otherFee) > 12000) {\r\n            privateFee = parseFloat(otherFee) * 0.2;\r\n            plusFee = 1410;\r\n        }\r\n        if (parseFloat(otherFee) <= 35000 && parseFloat(otherFee) > 25000) {\r\n            privateFee = parseFloat(otherFee) * 0.25;\r\n            plusFee = 2660;\r\n        }\r\n        if (parseFloat(otherFee) <= 55000 && parseFloat(otherFee) > 35000) {\r\n            privateFee = parseFloat(otherFee) * 0.3;\r\n            plusFee = 4410;\r\n        }\r\n        if (parseFloat(otherFee) <= 80000 && parseFloat(otherFee) > 55000) {\r\n            privateFee = parseFloat(otherFee) * 0.35;\r\n            plusFee = 7160;\r\n        }\r\n        if ( parseFloat(otherFee) > 80000) {\r\n            privateFee = parseFloat(otherFee) * 0.45;\r\n            plusFee = 15160;\r\n        }\r\n\r\n        var result = {};\r\n        \r\n        result.insuranceCount = totalInsuranceFee;\r\n        result.providentfundCount = totalProvidentfundFee;\r\n        result.providentfundNum = parseFloat(providentfundNum) * 100;\r\n        result.money = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(privateFee) + parseFloat(plusFee);\r\n        result.privateFee = privateFee - parseFloat(plusFee);\r\n        result.specialitemCount = specialitemCount;\r\n        result.oldNum = parseFloat(oldNum) * 100;\r\n        result.medNum = parseFloat(medNum) * 100;\r\n        result.unemNum = parseFloat(unemNum) * 100;\r\n        result.workNum = parseFloat(workNum) * 100;\r\n        result.giveNum = parseFloat(giveNum) * 100;\r\n\r\n        result.oldcount = parseFloat(oldcount);\r\n        result.medcount = parseFloat(medcount);\r\n        result.unemcount = parseFloat(unemcount);\r\n        result.workcount = parseFloat(workcount);\r\n        result.givecount = parseFloat(givecount);\r\n\r\n        wx.setStorage({\r\n            key: 'result',\r\n            data: result,\r\n            success:function(){\r\n                wx.navigateTo({\r\n                    url: '../calculation/calculationResult',\r\n                })\r\n            }\r\n        })\r\n        \r\n    },\r\n\r\n})把计算好的结果放在result对象中 通过wx.setStorage 放在缓存中，传到下一个页面。最后展示出来。"}
